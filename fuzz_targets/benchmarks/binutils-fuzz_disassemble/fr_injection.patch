diff --git a/bfd/.gitignore b/bfd/.gitignore
old mode 100644
new mode 100755
diff --git a/bfd/COPYING b/bfd/COPYING
old mode 100644
new mode 100755
diff --git a/bfd/ChangeLog b/bfd/ChangeLog
old mode 100644
new mode 100755
diff --git a/bfd/ChangeLog-0001 b/bfd/ChangeLog-0001
old mode 100644
new mode 100755
diff --git a/bfd/ChangeLog-0203 b/bfd/ChangeLog-0203
old mode 100644
new mode 100755
diff --git a/bfd/ChangeLog-2004 b/bfd/ChangeLog-2004
old mode 100644
new mode 100755
diff --git a/bfd/ChangeLog-2005 b/bfd/ChangeLog-2005
old mode 100644
new mode 100755
diff --git a/bfd/ChangeLog-2006 b/bfd/ChangeLog-2006
old mode 100644
new mode 100755
diff --git a/bfd/ChangeLog-2007 b/bfd/ChangeLog-2007
old mode 100644
new mode 100755
diff --git a/bfd/ChangeLog-2008 b/bfd/ChangeLog-2008
old mode 100644
new mode 100755
diff --git a/bfd/ChangeLog-2009 b/bfd/ChangeLog-2009
old mode 100644
new mode 100755
diff --git a/bfd/ChangeLog-2010 b/bfd/ChangeLog-2010
old mode 100644
new mode 100755
diff --git a/bfd/ChangeLog-2011 b/bfd/ChangeLog-2011
old mode 100644
new mode 100755
diff --git a/bfd/ChangeLog-2012 b/bfd/ChangeLog-2012
old mode 100644
new mode 100755
diff --git a/bfd/ChangeLog-2013 b/bfd/ChangeLog-2013
old mode 100644
new mode 100755
diff --git a/bfd/ChangeLog-2014 b/bfd/ChangeLog-2014
old mode 100644
new mode 100755
diff --git a/bfd/ChangeLog-2015 b/bfd/ChangeLog-2015
old mode 100644
new mode 100755
diff --git a/bfd/ChangeLog-2016 b/bfd/ChangeLog-2016
old mode 100644
new mode 100755
diff --git a/bfd/ChangeLog-2017 b/bfd/ChangeLog-2017
old mode 100644
new mode 100755
diff --git a/bfd/ChangeLog-2018 b/bfd/ChangeLog-2018
old mode 100644
new mode 100755
diff --git a/bfd/ChangeLog-2019 b/bfd/ChangeLog-2019
old mode 100644
new mode 100755
diff --git a/bfd/ChangeLog-2020 b/bfd/ChangeLog-2020
old mode 100644
new mode 100755
diff --git a/bfd/ChangeLog-9193 b/bfd/ChangeLog-9193
old mode 100644
new mode 100755
diff --git a/bfd/ChangeLog-9495 b/bfd/ChangeLog-9495
old mode 100644
new mode 100755
diff --git a/bfd/ChangeLog-9697 b/bfd/ChangeLog-9697
old mode 100644
new mode 100755
diff --git a/bfd/ChangeLog-9899 b/bfd/ChangeLog-9899
old mode 100644
new mode 100755
diff --git a/bfd/MAINTAINERS b/bfd/MAINTAINERS
old mode 100644
new mode 100755
diff --git a/bfd/Makefile.am b/bfd/Makefile.am
old mode 100644
new mode 100755
diff --git a/bfd/Makefile.in b/bfd/Makefile.in
old mode 100644
new mode 100755
diff --git a/bfd/PORTING b/bfd/PORTING
old mode 100644
new mode 100755
diff --git a/bfd/README b/bfd/README
old mode 100644
new mode 100755
diff --git a/bfd/TODO b/bfd/TODO
old mode 100644
new mode 100755
diff --git a/bfd/acinclude.m4 b/bfd/acinclude.m4
old mode 100644
new mode 100755
diff --git a/bfd/aclocal.m4 b/bfd/aclocal.m4
old mode 100644
new mode 100755
diff --git a/bfd/aix386-core.c b/bfd/aix386-core.c
old mode 100644
new mode 100755
diff --git a/bfd/aix5ppc-core.c b/bfd/aix5ppc-core.c
old mode 100644
new mode 100755
diff --git a/bfd/aout-cris.c b/bfd/aout-cris.c
old mode 100644
new mode 100755
diff --git a/bfd/aout-ns32k.c b/bfd/aout-ns32k.c
old mode 100644
new mode 100755
diff --git a/bfd/aout-target.h b/bfd/aout-target.h
old mode 100644
new mode 100755
diff --git a/bfd/aout32.c b/bfd/aout32.c
old mode 100644
new mode 100755
diff --git a/bfd/aout64.c b/bfd/aout64.c
old mode 100644
new mode 100755
diff --git a/bfd/aoutx.h b/bfd/aoutx.h
old mode 100644
new mode 100755
diff --git a/bfd/arc-got.h b/bfd/arc-got.h
old mode 100644
new mode 100755
diff --git a/bfd/arc-plt.def b/bfd/arc-plt.def
old mode 100644
new mode 100755
diff --git a/bfd/arc-plt.h b/bfd/arc-plt.h
old mode 100644
new mode 100755
diff --git a/bfd/archive.c b/bfd/archive.c
old mode 100644
new mode 100755
index 2f3a1d4..dc705a7
--- a/bfd/archive.c
+++ b/bfd/archive.c
@@ -1,3 +1,6 @@
+#ifdef FRCOV
+extern short FIXREVERTER[];
+#endif
 /* BFD back-end for archive files (libraries).
    Copyright (C) 1990-2021 Free Software Foundation, Inc.
    Written by Cygnus Support.  Mostly Gumby Henkel-Wallace's fault.
@@ -531,8 +534,23 @@ _bfd_generic_read_ar_hdr_mag (bfd *abfd, const char *mag)
       && bfd_ardata (abfd)->extended_names != NULL)
     {
       filename = get_extended_arelt_filename (abfd, hdr.ar_name, &origin);
-      if (filename == NULL)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[9019]) {
+        if ((filename == (void *) 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 9019\n");
+        else
+          fprintf(stderr, "reached bug index 9019\n");
+      }
+      if ((!FIXREVERTER[9019] && (filename == (void *) 0 ))
+      #else
+      if (0
+      #endif
+      )
 	return NULL;
+	#ifdef FRCOV
+	}
+	#endif
     }
   /* BSD4.4-style long filename.  */
   else if (is_bsd44_extended_name (hdr.ar_name))
@@ -552,8 +570,23 @@ _bfd_generic_read_ar_hdr_mag (bfd *abfd, const char *mag)
       extra_size = namelen;
 
       allocptr = (char *) bfd_malloc (allocsize);
-      if (allocptr == NULL)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[9020]) {
+        if ((allocptr == (void *) 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 9020\n");
+        else
+          fprintf(stderr, "reached bug index 9020\n");
+      }
+      if ((!FIXREVERTER[9020] && (allocptr == (void *) 0 ))
+      #else
+      if (0
+      #endif
+      )
 	return NULL;
+	#ifdef FRCOV
+	}
+	#endif
       filename = (allocptr
 		  + sizeof (struct areltdata)
 		  + sizeof (struct ar_hdr));
@@ -577,8 +610,23 @@ _bfd_generic_read_ar_hdr_mag (bfd *abfd, const char *mag)
       if (e == NULL)
 	{
 	  e = (char *) memchr (hdr.ar_name, '/', ar_maxnamelen (abfd));
-	  if (e == NULL)
+	  
+	  #ifdef FRCOV
+	  {if (FIXREVERTER[9021]) {
+	    if ((e == (void *) 0 ) && !(0))
+	      fprintf(stderr, "triggered bug index 9021\n");
+	    else
+	      fprintf(stderr, "reached bug index 9021\n");
+	  }
+	  if ((!FIXREVERTER[9021] && (e == (void *) 0 ))
+	  #else
+	  if (0
+	  #endif
+	  )
 	    e = (char *) memchr (hdr.ar_name, ' ', ar_maxnamelen (abfd));
+	    #ifdef FRCOV
+	    }
+	    #endif
 	}
 
       if (e != NULL)
@@ -596,8 +644,23 @@ _bfd_generic_read_ar_hdr_mag (bfd *abfd, const char *mag)
   if (!allocptr)
     {
       allocptr = (char *) bfd_malloc (allocsize);
-      if (allocptr == NULL)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[9022]) {
+        if ((allocptr == (void *) 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 9022\n");
+        else
+          fprintf(stderr, "reached bug index 9022\n");
+      }
+      if ((!FIXREVERTER[9022] && (allocptr == (void *) 0 ))
+      #else
+      if (0
+      #endif
+      )
 	return NULL;
+	#ifdef FRCOV
+	}
+	#endif
     }
 
   memset (allocptr, 0, sizeof (struct areltdata));
@@ -638,8 +701,23 @@ _bfd_append_relative_path (bfd *arch, char *elt_name)
 
   prefix_len = base_name - arch_name;
   filename = (char *) bfd_alloc (arch, prefix_len + strlen (elt_name) + 1);
-  if (filename == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[9024]) {
+    if ((filename == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 9024\n");
+    else
+      fprintf(stderr, "reached bug index 9024\n");
+  }
+  if ((!FIXREVERTER[9024] && (filename == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     return NULL;
+    #ifdef FRCOV
+    }
+    #endif
 
   strncpy (filename, arch_name, prefix_len);
   strcpy (filename + prefix_len, elt_name);
@@ -675,11 +753,26 @@ _bfd_get_elt_at_filepos (bfd *archive, file_ptr filepos)
       if (! IS_ABSOLUTE_PATH (filename))
 	{
 	  filename = _bfd_append_relative_path (archive, filename);
-	  if (filename == NULL)
+	  
+	  #ifdef FRCOV
+	  {if (FIXREVERTER[9025]) {
+	    if ((filename == (void *) 0 ) && !(0))
+	      fprintf(stderr, "triggered bug index 9025\n");
+	    else
+	      fprintf(stderr, "reached bug index 9025\n");
+	  }
+	  if ((!FIXREVERTER[9025] && (filename == (void *) 0 ))
+	  #else
+	  if (0
+	  #endif
+	  )
 	    {
 	      free (new_areldata);
 	      return NULL;
 	    }
+	    #ifdef FRCOV
+	    }
+	    #endif
 	}
 
       if (new_areldata->origin > 0)
@@ -695,11 +788,26 @@ _bfd_get_elt_at_filepos (bfd *archive, file_ptr filepos)
 	      return NULL;
 	    }
 	  n_bfd = _bfd_get_elt_at_filepos (ext_arch, new_areldata->origin);
-	  if (n_bfd == NULL)
+	  
+	  #ifdef FRCOV
+	  {if (FIXREVERTER[9026]) {
+	    if ((n_bfd == (void *) 0 ) && !(0))
+	      fprintf(stderr, "triggered bug index 9026\n");
+	    else
+	      fprintf(stderr, "reached bug index 9026\n");
+	  }
+	  if ((!FIXREVERTER[9026] && (n_bfd == (void *) 0 ))
+	  #else
+	  if (0
+	  #endif
+	  )
 	    {
 	      free (new_areldata);
 	      return NULL;
 	    }
+	    #ifdef FRCOV
+	    }
+	    #endif
 	  n_bfd->proxy_origin = bfd_tell (archive);
 
 	  /* Copy BFD_COMPRESS, BFD_DECOMPRESS and BFD_COMPRESS_GABI
@@ -722,11 +830,26 @@ _bfd_get_elt_at_filepos (bfd *archive, file_ptr filepos)
       n_bfd = _bfd_create_empty_archive_element_shell (archive);
     }
 
-  if (n_bfd == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[9027]) {
+    if ((n_bfd == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 9027\n");
+    else
+      fprintf(stderr, "reached bug index 9027\n");
+  }
+  if ((!FIXREVERTER[9027] && (n_bfd == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     {
       free (new_areldata);
       return NULL;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
   n_bfd->proxy_origin = bfd_tell (archive);
 
@@ -968,21 +1091,66 @@ do_slurp_bsd_armap (bfd *abfd)
   carsym *set;
 
   mapdata = (struct areltdata *) _bfd_read_ar_hdr (abfd);
-  if (mapdata == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[9030]) {
+    if ((mapdata == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 9030\n");
+    else
+      fprintf(stderr, "reached bug index 9030\n");
+  }
+  if ((!FIXREVERTER[9030] && (mapdata == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     return false;
+    #ifdef FRCOV
+    }
+    #endif
   parsed_size = mapdata->parsed_size;
   free (mapdata);
   /* PR 17512: file: 883ff754.  */
   /* PR 17512: file: 0458885f.  */
-  if (parsed_size < BSD_SYMDEF_COUNT_SIZE + BSD_STRING_COUNT_SIZE)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[9031]) {
+    if ((parsed_size < 4 + 4 ) && !(0))
+      fprintf(stderr, "triggered bug index 9031\n");
+    else
+      fprintf(stderr, "reached bug index 9031\n");
+  }
+  if ((!FIXREVERTER[9031] && (parsed_size < 4 + 4 ))
+  #else
+  if (0
+  #endif
+  )
     {
       bfd_set_error (bfd_error_malformed_archive);
       return false;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
   raw_armap = (bfd_byte *) _bfd_alloc_and_read (abfd, parsed_size, parsed_size);
-  if (raw_armap == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[9032]) {
+    if ((raw_armap == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 9032\n");
+    else
+      fprintf(stderr, "reached bug index 9032\n");
+  }
+  if ((!FIXREVERTER[9032] && (raw_armap == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     return false;
+    #ifdef FRCOV
+    }
+    #endif
 
   parsed_size -= BSD_SYMDEF_COUNT_SIZE + BSD_STRING_COUNT_SIZE;
   amt = H_GET_32 (abfd, raw_armap);
@@ -1013,11 +1181,26 @@ do_slurp_bsd_armap (bfd *abfd)
        counter++, set++, rbase += BSD_SYMDEF_SIZE)
     {
       unsigned nameoff = H_GET_32 (abfd, rbase);
-      if (nameoff >= string_size)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[9033]) {
+        if ((nameoff >= string_size ) && !(0))
+          fprintf(stderr, "triggered bug index 9033\n");
+        else
+          fprintf(stderr, "reached bug index 9033\n");
+      }
+      if ((!FIXREVERTER[9033] && (nameoff >= string_size ))
+      #else
+      if (0
+      #endif
+      )
 	{
 	  bfd_set_error (bfd_error_malformed_archive);
 	  goto release_armap;
 	}
+	#ifdef FRCOV
+	}
+	#endif
       set->name = stringbase + nameoff;
       set->file_offset = H_GET_32 (abfd, rbase + BSD_SYMDEF_OFFSET_SIZE);
     }
@@ -1059,8 +1242,23 @@ do_slurp_coff_armap (bfd *abfd)
   struct areltdata *tmp;
 
   mapdata = (struct areltdata *) _bfd_read_ar_hdr (abfd);
-  if (mapdata == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[9035]) {
+    if ((mapdata == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 9035\n");
+    else
+      fprintf(stderr, "reached bug index 9035\n");
+  }
+  if ((!FIXREVERTER[9035] && (mapdata == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     return false;
+    #ifdef FRCOV
+    }
+    #endif
   parsed_size = mapdata->parsed_size;
   free (mapdata);
 
@@ -1101,13 +1299,43 @@ do_slurp_coff_armap (bfd *abfd)
 
   /* Allocate and read in the raw offsets.  */
   raw_armap = (int *) _bfd_malloc_and_read (abfd, ptrsize, ptrsize);
-  if (raw_armap == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[9036]) {
+    if ((raw_armap == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 9036\n");
+    else
+      fprintf(stderr, "reached bug index 9036\n");
+  }
+  if ((!FIXREVERTER[9036] && (raw_armap == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     return false;
+    #ifdef FRCOV
+    }
+    #endif
 
   ardata->symdefs = (struct carsym *) bfd_alloc (abfd,
 						 carsym_size + stringsize + 1);
-  if (ardata->symdefs == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[9037]) {
+    if ((ardata -> symdefs == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 9037\n");
+    else
+      fprintf(stderr, "reached bug index 9037\n");
+  }
+  if ((!FIXREVERTER[9037] && (ardata -> symdefs == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     goto free_armap;
+    #ifdef FRCOV
+    }
+    #endif
   carsyms = ardata->symdefs;
   stringbase = ((char *) ardata->symdefs) + carsym_size;
 
@@ -1883,8 +2111,23 @@ bfd_ar_hdr_from_filesystem (bfd *abfd, const char *filename, bfd *member)
 
   amt = sizeof (struct ar_hdr) + sizeof (struct areltdata);
   ared = (struct areltdata *) bfd_zmalloc (amt);
-  if (ared == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[9039]) {
+    if ((ared == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 9039\n");
+    else
+      fprintf(stderr, "reached bug index 9039\n");
+  }
+  if ((!FIXREVERTER[9039] && (ared == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     return NULL;
+    #ifdef FRCOV
+    }
+    #endif
   hdr = (struct ar_hdr *) (((char *) ared) + sizeof (struct areltdata));
 
   /* ar headers are space padded, not null padded!  */
@@ -1938,16 +2181,46 @@ bfd_generic_stat_arch_elt (bfd *abfd, struct stat *buf)
   struct ar_hdr *hdr;
   char *aloser;
 
-  if (abfd->arelt_data == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[9040]) {
+    if ((abfd -> arelt_data == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 9040\n");
+    else
+      fprintf(stderr, "reached bug index 9040\n");
+  }
+  if ((!FIXREVERTER[9040] && (abfd -> arelt_data == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     {
       bfd_set_error (bfd_error_invalid_operation);
       return -1;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
   hdr = arch_hdr (abfd);
   /* PR 17512: file: 3d9e9fe9.  */
-  if (hdr == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[9041]) {
+    if ((hdr == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 9041\n");
+    else
+      fprintf(stderr, "reached bug index 9041\n");
+  }
+  if ((!FIXREVERTER[9041] && (hdr == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     return -1;
+    #ifdef FRCOV
+    }
+    #endif
 #define foo(arelt, stelt, size)				\
   buf->stelt = strtol (hdr->arelt, &aloser, size);	\
   if (aloser == hdr->arelt)				\
diff --git a/bfd/archive64.c b/bfd/archive64.c
old mode 100644
new mode 100755
diff --git a/bfd/archures.c b/bfd/archures.c
old mode 100644
new mode 100755
index 390691b..ea6b968
--- a/bfd/archures.c
+++ b/bfd/archures.c
@@ -1,3 +1,6 @@
+#ifdef FRCOV
+extern short FIXREVERTER[];
+#endif
 /* BFD library support routines for architectures.
    Copyright (C) 1990-2021 Free Software Foundation, Inc.
    Hacked by John Gilmore and Steve Chamberlain of Cygnus Support.
@@ -1092,11 +1095,41 @@ bfd_default_compatible (const bfd_arch_info_type *a,
   if (a->bits_per_word != b->bits_per_word)
     return NULL;
 
-  if (a->mach > b->mach)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[1289]) {
+    if ((a -> mach > b -> mach ) && !(0))
+      fprintf(stderr, "triggered bug index 1289\n");
+    else
+      fprintf(stderr, "reached bug index 1289\n");
+  }
+  if ((!FIXREVERTER[1289] && (a -> mach > b -> mach ))
+  #else
+  if (0
+  #endif
+  )
     return a;
-
-  if (b->mach > a->mach)
+    #ifdef FRCOV
+    }
+    #endif
+
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[1290]) {
+    if ((b -> mach > a -> mach ) && !(0))
+      fprintf(stderr, "triggered bug index 1290\n");
+    else
+      fprintf(stderr, "reached bug index 1290\n");
+  }
+  if ((!FIXREVERTER[1290] && (b -> mach > a -> mach ))
+  #else
+  if (0
+  #endif
+  )
     return b;
+    #ifdef FRCOV
+    }
+    #endif
 
   return a;
 }
diff --git a/bfd/bfd-in.h b/bfd/bfd-in.h
old mode 100644
new mode 100755
diff --git a/bfd/bfd-in2.h b/bfd/bfd-in2.h
old mode 100644
new mode 100755
diff --git a/bfd/bfd.c b/bfd/bfd.c
old mode 100644
new mode 100755
index 6e5d339..011f1f4
--- a/bfd/bfd.c
+++ b/bfd/bfd.c
@@ -1,3 +1,6 @@
+#ifdef FRCOV
+extern short FIXREVERTER[];
+#endif
 /* Generic BFD library interface and support routines.
    Copyright (C) 1990-2021 Free Software Foundation, Inc.
    Written by Cygnus Support.
@@ -2128,8 +2131,23 @@ bfd_get_relocated_section_contents (bfd *abfd,
   if (link_order->type == bfd_indirect_link_order)
     {
       abfd2 = link_order->u.indirect.section->owner;
-      if (abfd2 == NULL)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[7573]) {
+        if ((abfd2 == (void *) 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 7573\n");
+        else
+          fprintf(stderr, "reached bug index 7573\n");
+      }
+      if ((!FIXREVERTER[7573] && (abfd2 == (void *) 0 ))
+      #else
+      if (0
+      #endif
+      )
 	abfd2 = abfd;
+	#ifdef FRCOV
+	}
+	#endif
     }
   else
     abfd2 = abfd;
diff --git a/bfd/bfd.m4 b/bfd/bfd.m4
old mode 100644
new mode 100755
diff --git a/bfd/bfdio.c b/bfd/bfdio.c
old mode 100644
new mode 100755
index 463b387..f4a1eab
--- a/bfd/bfdio.c
+++ b/bfd/bfdio.c
@@ -1,3 +1,6 @@
+#ifdef FRCOV
+extern short FIXREVERTER[];
+#endif
 /* Low-level I/O routines for BFDs.
 
    Copyright (C) 1990-2021 Free Software Foundation, Inc.
@@ -237,20 +240,50 @@ bfd_bread (void *ptr, bfd_size_type size, bfd *abfd)
     {
       bfd_size_type maxbytes = arelt_size (element_bfd);
 
-      if (abfd->where < offset || abfd->where - offset >= maxbytes)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[10709]) {
+        if ((abfd -> where < offset || abfd -> where - offset >= maxbytes ) && !(0))
+          fprintf(stderr, "triggered bug index 10709\n");
+        else
+          fprintf(stderr, "reached bug index 10709\n");
+      }
+      if ((!FIXREVERTER[10709] && (abfd -> where < offset || abfd -> where - offset >= maxbytes ))
+      #else
+      if (0
+      #endif
+      )
 	{
 	  bfd_set_error (bfd_error_invalid_operation);
 	  return -1;
 	}
+	#ifdef FRCOV
+	}
+	#endif
       if (abfd->where - offset + size > maxbytes)
 	size = maxbytes - (abfd->where - offset);
     }
 
-  if (abfd->iovec == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[10710]) {
+    if ((abfd -> iovec == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 10710\n");
+    else
+      fprintf(stderr, "reached bug index 10710\n");
+  }
+  if ((!FIXREVERTER[10710] && (abfd -> iovec == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     {
       bfd_set_error (bfd_error_invalid_operation);
       return -1;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
   nread = abfd->iovec->bread (abfd, ptr, size);
   if (nread != -1)
@@ -268,11 +301,26 @@ bfd_bwrite (const void *ptr, bfd_size_type size, bfd *abfd)
 	 && !bfd_is_thin_archive (abfd->my_archive))
     abfd = abfd->my_archive;
 
-  if (abfd->iovec == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[10711]) {
+    if ((abfd -> iovec == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 10711\n");
+    else
+      fprintf(stderr, "reached bug index 10711\n");
+  }
+  if ((!FIXREVERTER[10711] && (abfd -> iovec == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     {
       bfd_set_error (bfd_error_invalid_operation);
       return -1;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
   nwrote = abfd->iovec->bwrite (abfd, ptr, size);
   if (nwrote != -1)
@@ -301,8 +349,23 @@ bfd_tell (bfd *abfd)
     }
   offset += abfd->origin;
 
-  if (abfd->iovec == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[10712]) {
+    if ((abfd -> iovec == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 10712\n");
+    else
+      fprintf(stderr, "reached bug index 10712\n");
+  }
+  if ((!FIXREVERTER[10712] && (abfd -> iovec == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     return 0;
+    #ifdef FRCOV
+    }
+    #endif
 
   ptr = abfd->iovec->btell (abfd);
   abfd->where = ptr;
@@ -316,8 +379,23 @@ bfd_flush (bfd *abfd)
 	 && !bfd_is_thin_archive (abfd->my_archive))
     abfd = abfd->my_archive;
 
-  if (abfd->iovec == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[10713]) {
+    if ((abfd -> iovec == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 10713\n");
+    else
+      fprintf(stderr, "reached bug index 10713\n");
+  }
+  if ((!FIXREVERTER[10713] && (abfd -> iovec == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     return 0;
+    #ifdef FRCOV
+    }
+    #endif
 
   return abfd->iovec->bflush (abfd);
 }
@@ -333,11 +411,26 @@ bfd_stat (bfd *abfd, struct stat *statbuf)
 	 && !bfd_is_thin_archive (abfd->my_archive))
     abfd = abfd->my_archive;
 
-  if (abfd->iovec == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[10714]) {
+    if ((abfd -> iovec == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 10714\n");
+    else
+      fprintf(stderr, "reached bug index 10714\n");
+  }
+  if ((!FIXREVERTER[10714] && (abfd -> iovec == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     {
       bfd_set_error (bfd_error_invalid_operation);
       return -1;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
   result = abfd->iovec->bstat (abfd, statbuf);
   if (result < 0)
@@ -362,11 +455,26 @@ bfd_seek (bfd *abfd, file_ptr position, int direction)
     }
   offset += abfd->origin;
 
-  if (abfd->iovec == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[10715]) {
+    if ((abfd -> iovec == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 10715\n");
+    else
+      fprintf(stderr, "reached bug index 10715\n");
+  }
+  if ((!FIXREVERTER[10715] && (abfd -> iovec == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     {
       bfd_set_error (bfd_error_invalid_operation);
       return -1;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
   /* For the time being, a BFD may not seek to it's end.  The problem
      is that we don't easily have a way to recognize the end of an
@@ -526,8 +634,23 @@ bfd_get_file_size (bfd *abfd)
     }
 
   file_size = bfd_get_size (abfd);
-  if (archive_size < file_size)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[10716]) {
+    if ((archive_size < file_size ) && !(0))
+      fprintf(stderr, "triggered bug index 10716\n");
+    else
+      fprintf(stderr, "reached bug index 10716\n");
+  }
+  if ((!FIXREVERTER[10716] && (archive_size < file_size ))
+  #else
+  if (0
+  #endif
+  )
     return archive_size;
+    #ifdef FRCOV
+    }
+    #endif
   return file_size;
 }
 
@@ -608,11 +731,26 @@ memory_bwrite (bfd *abfd, const void *ptr, file_ptr size)
       if (newsize > oldsize)
 	{
 	  bim->buffer = (bfd_byte *) bfd_realloc_or_free (bim->buffer, newsize);
-	  if (bim->buffer == NULL)
+	  
+	  #ifdef FRCOV
+	  {if (FIXREVERTER[10718]) {
+	    if ((bim -> buffer == (void *) 0 ) && !(0))
+	      fprintf(stderr, "triggered bug index 10718\n");
+	    else
+	      fprintf(stderr, "reached bug index 10718\n");
+	  }
+	  if ((!FIXREVERTER[10718] && (bim -> buffer == (void *) 0 ))
+	  #else
+	  if (0
+	  #endif
+	  )
 	    {
 	      bim->size = 0;
 	      return 0;
 	    }
+	    #ifdef FRCOV
+	    }
+	    #endif
 	  if (newsize > bim->size)
 	    memset (bim->buffer + bim->size, 0, newsize - bim->size);
 	}
@@ -640,12 +778,27 @@ memory_bseek (bfd *abfd, file_ptr position, int direction)
   else
     nwhere = abfd->where + position;
 
-  if (nwhere < 0)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[10719]) {
+    if ((nwhere < 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 10719\n");
+    else
+      fprintf(stderr, "reached bug index 10719\n");
+  }
+  if ((!FIXREVERTER[10719] && (nwhere < 0 ))
+  #else
+  if (0
+  #endif
+  )
     {
       abfd->where = 0;
       errno = EINVAL;
       return -1;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
   if ((bfd_size_type)nwhere > bim->size)
     {
@@ -661,12 +814,27 @@ memory_bseek (bfd *abfd, file_ptr position, int direction)
 	  if (newsize > oldsize)
 	    {
 	      bim->buffer = (bfd_byte *) bfd_realloc_or_free (bim->buffer, newsize);
-	      if (bim->buffer == NULL)
+	      
+	      #ifdef FRCOV
+	      {if (FIXREVERTER[10720]) {
+	        if ((bim -> buffer == (void *) 0 ) && !(0))
+	          fprintf(stderr, "triggered bug index 10720\n");
+	        else
+	          fprintf(stderr, "reached bug index 10720\n");
+	      }
+	      if ((!FIXREVERTER[10720] && (bim -> buffer == (void *) 0 ))
+	      #else
+	      if (0
+	      #endif
+	      )
 		{
 		  errno = EINVAL;
 		  bim->size = 0;
 		  return -1;
 		}
+		#ifdef FRCOV
+		}
+		#endif
 	      memset (bim->buffer + oldsize, 0, newsize - oldsize);
 	    }
 	}
diff --git a/bfd/bfdwin.c b/bfd/bfdwin.c
old mode 100644
new mode 100755
diff --git a/bfd/binary.c b/bfd/binary.c
old mode 100644
new mode 100755
index 0761a0b..3843bd5
--- a/bfd/binary.c
+++ b/bfd/binary.c
@@ -1,3 +1,6 @@
+#ifdef FRCOV
+extern short FIXREVERTER[];
+#endif
 /* BFD back-end for binary objects.
    Copyright (C) 1994-2021 Free Software Foundation, Inc.
    Written by Ian Lance Taylor, Cygnus Support, <ian@cygnus.com>
@@ -130,8 +133,23 @@ mangle_name (bfd *abfd, char *suffix)
 	  + sizeof "_binary__");
 
   buf = (char *) bfd_alloc (abfd, size);
-  if (buf == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[9951]) {
+    if ((buf == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 9951\n");
+    else
+      fprintf(stderr, "reached bug index 9951\n");
+  }
+  if ((!FIXREVERTER[9951] && (buf == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     return "";
+    #ifdef FRCOV
+    }
+    #endif
 
   sprintf (buf, "_binary_%s_%s", bfd_get_filename (abfd), suffix);
 
@@ -154,8 +172,23 @@ binary_canonicalize_symtab (bfd *abfd, asymbol **alocation)
   size_t amt = BIN_SYMS * sizeof (asymbol);
 
   syms = (asymbol *) bfd_alloc (abfd, amt);
-  if (syms == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[9952]) {
+    if ((syms == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 9952\n");
+    else
+      fprintf(stderr, "reached bug index 9952\n");
+  }
+  if ((!FIXREVERTER[9952] && (syms == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     return -1;
+    #ifdef FRCOV
+    }
+    #endif
 
   /* Start symbol.  */
   syms[0].the_bfd = abfd;
@@ -225,8 +258,23 @@ binary_set_section_contents (bfd *abfd,
 			     file_ptr offset,
 			     bfd_size_type size)
 {
-  if (size == 0)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[9953]) {
+    if ((size == 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 9953\n");
+    else
+      fprintf(stderr, "reached bug index 9953\n");
+  }
+  if ((!FIXREVERTER[9953] && (size == 0 ))
+  #else
+  if (0
+  #endif
+  )
     return true;
+    #ifdef FRCOV
+    }
+    #endif
 
   if (! abfd->output_has_begun)
     {
diff --git a/bfd/cache.c b/bfd/cache.c
old mode 100644
new mode 100755
index 1935359..fa25ce7
--- a/bfd/cache.c
+++ b/bfd/cache.c
@@ -1,3 +1,6 @@
+#ifdef FRCOV
+extern short FIXREVERTER[];
+#endif
 /* BFD library -- caching of file descriptors.
 
    Copyright (C) 1990-2021 Free Software Foundation, Inc.
@@ -205,11 +208,26 @@ close_one (void)
 	}
     }
 
-  if (to_kill == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[750]) {
+    if ((to_kill == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 750\n");
+    else
+      fprintf(stderr, "reached bug index 750\n");
+  }
+  if ((!FIXREVERTER[750] && (to_kill == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     {
       /* There are no open cacheable BFD's.  */
       return true;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
   to_kill->where = _bfd_real_ftell ((FILE *) to_kill->iostream);
 
@@ -277,8 +295,23 @@ static file_ptr
 cache_btell (struct bfd *abfd)
 {
   FILE *f = bfd_cache_lookup (abfd, CACHE_NO_OPEN);
-  if (f == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[751]) {
+    if ((f == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 751\n");
+    else
+      fprintf(stderr, "reached bug index 751\n");
+  }
+  if ((!FIXREVERTER[751] && (f == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     return abfd->where;
+    #ifdef FRCOV
+    }
+    #endif
   return _bfd_real_ftell (f);
 }
 
@@ -286,8 +319,23 @@ static int
 cache_bseek (struct bfd *abfd, file_ptr offset, int whence)
 {
   FILE *f = bfd_cache_lookup (abfd, whence != SEEK_CUR ? CACHE_NO_SEEK : CACHE_NORMAL);
-  if (f == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[752]) {
+    if ((f == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 752\n");
+    else
+      fprintf(stderr, "reached bug index 752\n");
+  }
+  if ((!FIXREVERTER[752] && (f == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     return -1;
+    #ifdef FRCOV
+    }
+    #endif
   return _bfd_real_fseek (f, offset, whence);
 }
 
@@ -340,8 +388,23 @@ cache_bread (struct bfd *abfd, void *buf, file_ptr nbytes)
   FILE *f;
 
   f = bfd_cache_lookup (abfd, CACHE_NORMAL);
-  if (f == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[753]) {
+    if ((f == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 753\n");
+    else
+      fprintf(stderr, "reached bug index 753\n");
+  }
+  if ((!FIXREVERTER[753] && (f == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     return -1;
+    #ifdef FRCOV
+    }
+    #endif
 
   /* Some filesystems are unable to handle reads that are too large
      (for instance, NetApp shares with oplocks turned off).  To avoid
@@ -368,8 +431,23 @@ cache_bread (struct bfd *abfd, void *buf, file_ptr nbytes)
       if (nread == 0 || chunk_nread > 0)
 	nread += chunk_nread;
 
-      if (chunk_nread < chunk_size)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[754]) {
+        if ((chunk_nread < chunk_size ) && !(0))
+          fprintf(stderr, "triggered bug index 754\n");
+        else
+          fprintf(stderr, "reached bug index 754\n");
+      }
+      if ((!FIXREVERTER[754] && (chunk_nread < chunk_size ))
+      #else
+      if (0
+      #endif
+      )
 	break;
+	#ifdef FRCOV
+	}
+	#endif
     }
 
   return nread;
@@ -381,8 +459,23 @@ cache_bwrite (struct bfd *abfd, const void *from, file_ptr nbytes)
   file_ptr nwrite;
   FILE *f = bfd_cache_lookup (abfd, CACHE_NORMAL);
 
-  if (f == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[755]) {
+    if ((f == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 755\n");
+    else
+      fprintf(stderr, "reached bug index 755\n");
+  }
+  if ((!FIXREVERTER[755] && (f == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     return 0;
+    #ifdef FRCOV
+    }
+    #endif
   nwrite = fwrite (from, 1, nbytes, f);
   if (nwrite < nbytes && ferror (f))
     {
@@ -404,8 +497,23 @@ cache_bflush (struct bfd *abfd)
   int sts;
   FILE *f = bfd_cache_lookup (abfd, CACHE_NO_OPEN);
 
-  if (f == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[756]) {
+    if ((f == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 756\n");
+    else
+      fprintf(stderr, "reached bug index 756\n");
+  }
+  if ((!FIXREVERTER[756] && (f == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     return 0;
+    #ifdef FRCOV
+    }
+    #endif
   sts = fflush (f);
   if (sts < 0)
     bfd_set_error (bfd_error_system_call);
@@ -418,8 +526,23 @@ cache_bstat (struct bfd *abfd, struct stat *sb)
   int sts;
   FILE *f = bfd_cache_lookup (abfd, CACHE_NO_SEEK_ERROR);
 
-  if (f == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[757]) {
+    if ((f == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 757\n");
+    else
+      fprintf(stderr, "reached bug index 757\n");
+  }
+  if ((!FIXREVERTER[757] && (f == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     return -1;
+    #ifdef FRCOV
+    }
+    #endif
   sts = fstat (fileno (f), sb);
   if (sts < 0)
     bfd_set_error (bfd_error_system_call);
@@ -600,9 +723,24 @@ bfd_open_file (bfd *abfd)
 	{
 	  abfd->iostream = _bfd_real_fopen (bfd_get_filename (abfd),
 					    FOPEN_RUB);
-	  if (abfd->iostream == NULL)
+	  
+	  #ifdef FRCOV
+	  {if (FIXREVERTER[760]) {
+	    if ((abfd -> iostream == (void *) 0  ) && !(0))
+	      fprintf(stderr, "triggered bug index 760\n");
+	    else
+	      fprintf(stderr, "reached bug index 760\n");
+	  }
+	  if ((!FIXREVERTER[760] && (abfd -> iostream == (void *) 0  ))
+	  #else
+	  if (0
+	  #endif
+	  )
 	    abfd->iostream = _bfd_real_fopen (bfd_get_filename (abfd),
 					      FOPEN_WUB);
+					      #ifdef FRCOV
+					      }
+					      #endif
 	}
       else
 	{
diff --git a/bfd/cf-i386lynx.c b/bfd/cf-i386lynx.c
old mode 100644
new mode 100755
diff --git a/bfd/cisco-core.c b/bfd/cisco-core.c
old mode 100644
new mode 100755
diff --git a/bfd/coff-alpha.c b/bfd/coff-alpha.c
old mode 100644
new mode 100755
diff --git a/bfd/coff-arm.c b/bfd/coff-arm.c
old mode 100644
new mode 100755
diff --git a/bfd/coff-arm.h b/bfd/coff-arm.h
old mode 100644
new mode 100755
diff --git a/bfd/coff-bfd.c b/bfd/coff-bfd.c
old mode 100644
new mode 100755
diff --git a/bfd/coff-bfd.h b/bfd/coff-bfd.h
old mode 100644
new mode 100755
diff --git a/bfd/coff-go32.c b/bfd/coff-go32.c
old mode 100644
new mode 100755
diff --git a/bfd/coff-i386.c b/bfd/coff-i386.c
old mode 100644
new mode 100755
diff --git a/bfd/coff-ia64.c b/bfd/coff-ia64.c
old mode 100644
new mode 100755
diff --git a/bfd/coff-mcore.c b/bfd/coff-mcore.c
old mode 100644
new mode 100755
diff --git a/bfd/coff-mips.c b/bfd/coff-mips.c
old mode 100644
new mode 100755
diff --git a/bfd/coff-rs6000.c b/bfd/coff-rs6000.c
old mode 100644
new mode 100755
index 45ba9b3..9fd8c2e
--- a/bfd/coff-rs6000.c
+++ b/bfd/coff-rs6000.c
@@ -1,3 +1,6 @@
+#ifdef FRCOV
+extern short FIXREVERTER[];
+#endif
 /* BFD back-end for IBM RS/6000 "XCOFF" files.
    Copyright (C) 1990-2021 Free Software Foundation, Inc.
    Written by Metin G. Ozisik, Mimi Phuong-Thao Vo, and John Gilmore.
@@ -1169,8 +1172,23 @@ xcoff_rtype2howto (arelent *relent, struct internal_reloc *internal)
 	relent->howto = &xcoff_howto_table[0x1c];
       else if (R_RBR == internal->r_type)
 	relent->howto = &xcoff_howto_table[0x1d];
-      else if (R_RBA == internal->r_type)
+      else 
+      #ifdef FRCOV
+      {if (FIXREVERTER[7257]) {
+        if ((24 == internal -> r_type  ) && !(0))
+          fprintf(stderr, "triggered bug index 7257\n");
+        else
+          fprintf(stderr, "reached bug index 7257\n");
+      }
+      if ((!FIXREVERTER[7257] && (24 == internal -> r_type  ))
+      #else
+      if (0
+      #endif
+      )
 	relent->howto = &xcoff_howto_table[0x1e];
+	#ifdef FRCOV
+	}
+	#endif
     }
 
   /* The r_size field of an XCOFF reloc encodes the bitsize of the
@@ -1619,12 +1637,42 @@ _bfd_xcoff_read_ar_hdr (bfd *abfd)
 	return NULL;
 
       GET_VALUE_IN_FIELD (namlen, hdr.namlen, 10);
-      if (namlen > bfd_get_file_size (abfd))
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[7265]) {
+        if ((namlen > bfd_get_file_size ( abfd ) ) && !(0))
+          fprintf(stderr, "triggered bug index 7265\n");
+        else
+          fprintf(stderr, "reached bug index 7265\n");
+      }
+      if ((!FIXREVERTER[7265] && (namlen > bfd_get_file_size ( abfd ) ))
+      #else
+      if (0
+      #endif
+      )
 	return NULL;
+	#ifdef FRCOV
+	}
+	#endif
       amt = sizeof (struct areltdata) + SIZEOF_AR_HDR + namlen + 1;
       ret = (struct areltdata *) bfd_malloc (amt);
-      if (ret == NULL)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[7266]) {
+        if ((ret == (void *) 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 7266\n");
+        else
+          fprintf(stderr, "reached bug index 7266\n");
+      }
+      if ((!FIXREVERTER[7266] && (ret == (void *) 0 ))
+      #else
+      if (0
+      #endif
+      )
 	return ret;
+	#ifdef FRCOV
+	}
+	#endif
 
       hdrp = (struct xcoff_ar_hdr *) (ret + 1);
       memcpy (hdrp, &hdr, SIZEOF_AR_HDR);
@@ -1648,12 +1696,42 @@ _bfd_xcoff_read_ar_hdr (bfd *abfd)
 	return NULL;
 
       GET_VALUE_IN_FIELD (namlen, hdr.namlen, 10);
-      if (namlen > bfd_get_file_size (abfd))
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[7267]) {
+        if ((namlen > bfd_get_file_size ( abfd ) ) && !(0))
+          fprintf(stderr, "triggered bug index 7267\n");
+        else
+          fprintf(stderr, "reached bug index 7267\n");
+      }
+      if ((!FIXREVERTER[7267] && (namlen > bfd_get_file_size ( abfd ) ))
+      #else
+      if (0
+      #endif
+      )
 	return NULL;
+	#ifdef FRCOV
+	}
+	#endif
       amt = sizeof (struct areltdata) + SIZEOF_AR_HDR_BIG + namlen + 1;
       ret = (struct areltdata *) bfd_malloc (amt);
-      if (ret == NULL)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[7268]) {
+        if ((ret == (void *) 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 7268\n");
+        else
+          fprintf(stderr, "reached bug index 7268\n");
+      }
+      if ((!FIXREVERTER[7268] && (ret == (void *) 0 ))
+      #else
+      if (0
+      #endif
+      )
 	return ret;
+	#ifdef FRCOV
+	}
+	#endif
 
       hdrp = (struct xcoff_ar_hdr_big *) (ret + 1);
       memcpy (hdrp, &hdr, SIZEOF_AR_HDR_BIG);
@@ -1728,11 +1806,26 @@ _bfd_xcoff_openr_next_archived_file (bfd *archive, bfd *last_file)
 int
 _bfd_xcoff_stat_arch_elt (bfd *abfd, struct stat *s)
 {
-  if (abfd->arelt_data == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[7269]) {
+    if ((abfd -> arelt_data == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 7269\n");
+    else
+      fprintf(stderr, "reached bug index 7269\n");
+  }
+  if ((!FIXREVERTER[7269] && (abfd -> arelt_data == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     {
       bfd_set_error (bfd_error_invalid_operation);
       return -1;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
   if (! xcoff_big_format_p (abfd->my_archive))
     {
@@ -2011,8 +2104,23 @@ xcoff_write_armap_big (bfd *abfd, unsigned int elength ATTRIBUTE_UNUSED,
 	+ str_32 + (str_32 & 1);
 
       symbol_table = bfd_zmalloc (symbol_table_size);
-      if (symbol_table == NULL)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[7276]) {
+        if ((symbol_table == (void *) 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 7276\n");
+        else
+          fprintf(stderr, "reached bug index 7276\n");
+      }
+      if ((!FIXREVERTER[7276] && (symbol_table == (void *) 0 ))
+      #else
+      if (0
+      #endif
+      )
 	return false;
+	#ifdef FRCOV
+	}
+	#endif
 
       hdr = (struct xcoff_ar_hdr_big *) symbol_table;
 
@@ -2096,8 +2204,23 @@ xcoff_write_armap_big (bfd *abfd, unsigned int elength ATTRIBUTE_UNUSED,
 	+ str_64 + (str_64 & 1);
 
       symbol_table = bfd_zmalloc (symbol_table_size);
-      if (symbol_table == NULL)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[7277]) {
+        if ((symbol_table == (void *) 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 7277\n");
+        else
+          fprintf(stderr, "reached bug index 7277\n");
+      }
+      if ((!FIXREVERTER[7277] && (symbol_table == (void *) 0 ))
+      #else
+      if (0
+      #endif
+      )
 	return false;
+	#ifdef FRCOV
+	}
+	#endif
 
       hdr = (struct xcoff_ar_hdr_big *) symbol_table;
 
@@ -2209,8 +2332,23 @@ xcoff_write_archive_contents_old (bfd *abfd)
       if (sub->arelt_data == NULL)
 	{
 	  sub->arelt_data = bfd_zmalloc (sizeof (struct areltdata));
-	  if (sub->arelt_data == NULL)
+	  
+	  #ifdef FRCOV
+	  {if (FIXREVERTER[7279]) {
+	    if ((sub -> arelt_data == (void *) 0 ) && !(0))
+	      fprintf(stderr, "triggered bug index 7279\n");
+	    else
+	      fprintf(stderr, "reached bug index 7279\n");
+	  }
+	  if ((!FIXREVERTER[7279] && (sub -> arelt_data == (void *) 0 ))
+	  #else
+	  if (0
+	  #endif
+	  )
 	    return false;
+	    #ifdef FRCOV
+	    }
+	    #endif
 	}
       if (arch_xhdr (sub) == NULL)
 	{
@@ -2243,8 +2381,23 @@ xcoff_write_archive_contents_old (bfd *abfd)
 	    }
 
 	  ahdrp = bfd_zalloc (sub, sizeof (*ahdrp));
-	  if (ahdrp == NULL)
+	  
+	  #ifdef FRCOV
+	  {if (FIXREVERTER[7280]) {
+	    if ((ahdrp == (void *) 0 ) && !(0))
+	      fprintf(stderr, "triggered bug index 7280\n");
+	    else
+	      fprintf(stderr, "reached bug index 7280\n");
+	  }
+	  if ((!FIXREVERTER[7280] && (ahdrp == (void *) 0 ))
+	  #else
+	  if (0
+	  #endif
+	  )
 	    return false;
+	    #ifdef FRCOV
+	    }
+	    #endif
 
 	  sprintf (ahdrp->size, "%ld", (long) s.st_size);
 	  sprintf (ahdrp->date, "%ld", (long) s.st_mtime);
@@ -2257,8 +2410,23 @@ xcoff_write_archive_contents_old (bfd *abfd)
 	}
     }
   offsets = (file_ptr *) bfd_alloc (abfd, count * sizeof (file_ptr));
-  if (offsets == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[7281]) {
+    if ((offsets == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 7281\n");
+    else
+      fprintf(stderr, "reached bug index 7281\n");
+  }
+  if ((!FIXREVERTER[7281] && (offsets == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     return false;
+    #ifdef FRCOV
+    }
+    #endif
 
   if (bfd_seek (abfd, (file_ptr) SIZEOF_AR_FILE_HDR, SEEK_SET) != 0)
     return false;
@@ -2444,8 +2612,23 @@ xcoff_write_archive_contents_big (bfd *abfd)
 	{
 	  size = sizeof (struct areltdata);
 	  current_bfd->arelt_data = bfd_zmalloc (size);
-	  if (current_bfd->arelt_data == NULL)
+	  
+	  #ifdef FRCOV
+	  {if (FIXREVERTER[7282]) {
+	    if ((current_bfd -> arelt_data == (void *) 0 ) && !(0))
+	      fprintf(stderr, "triggered bug index 7282\n");
+	    else
+	      fprintf(stderr, "reached bug index 7282\n");
+	  }
+	  if ((!FIXREVERTER[7282] && (current_bfd -> arelt_data == (void *) 0 ))
+	  #else
+	  if (0
+	  #endif
+	  )
 	    return false;
+	    #ifdef FRCOV
+	    }
+	    #endif
 	}
 
       if (arch_xhdr_big (current_bfd) == NULL)
@@ -2479,8 +2662,23 @@ xcoff_write_archive_contents_big (bfd *abfd)
 	    }
 
 	  ahdrp = bfd_zalloc (current_bfd, sizeof (*ahdrp));
-	  if (ahdrp == NULL)
+	  
+	  #ifdef FRCOV
+	  {if (FIXREVERTER[7283]) {
+	    if ((ahdrp == (void *) 0 ) && !(0))
+	      fprintf(stderr, "triggered bug index 7283\n");
+	    else
+	      fprintf(stderr, "reached bug index 7283\n");
+	  }
+	  if ((!FIXREVERTER[7283] && (ahdrp == (void *) 0 ))
+	  #else
+	  if (0
+	  #endif
+	  )
 	    return false;
+	    #ifdef FRCOV
+	    }
+	    #endif
 
 	  PRINT20 (ahdrp->size, s.st_size);
 	  PRINT12 (ahdrp->date, s.st_mtime);
@@ -2497,8 +2695,23 @@ xcoff_write_archive_contents_big (bfd *abfd)
   if (count)
     {
       offsets = (file_ptr *) bfd_malloc (count * sizeof (file_ptr));
-      if (offsets == NULL)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[7284]) {
+        if ((offsets == (void *) 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 7284\n");
+        else
+          fprintf(stderr, "reached bug index 7284\n");
+      }
+      if ((!FIXREVERTER[7284] && (offsets == (void *) 0 ))
+      #else
+      if (0
+      #endif
+      )
 	return false;
+	#ifdef FRCOV
+	}
+	#endif
     }
 
   prevoff = 0;
@@ -2575,11 +2788,26 @@ xcoff_write_archive_contents_big (bfd *abfd)
 
   member_table_size += member_table_size & 1;
   member_table = bfd_zmalloc (member_table_size);
-  if (member_table == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[7285]) {
+    if ((member_table == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 7285\n");
+    else
+      fprintf(stderr, "reached bug index 7285\n");
+  }
+  if ((!FIXREVERTER[7285] && (member_table == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     {
       free (offsets);
       return false;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
   hdr = (struct xcoff_ar_hdr_big *) member_table;
 
@@ -2716,8 +2944,23 @@ _bfd_xcoff_sizeof_headers (bfd *abfd,
 	 preallocated array as the number of sections is limited on XCOFF,
 	 but this creates a maintainance issue.  */
       n_rl = bfd_zmalloc ((max_index + 1) * sizeof (*n_rl));
-      if (n_rl == NULL)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[7287]) {
+        if ((n_rl == (void *) 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 7287\n");
+        else
+          fprintf(stderr, "reached bug index 7287\n");
+      }
+      if ((!FIXREVERTER[7287] && (n_rl == (void *) 0 ))
+      #else
+      if (0
+      #endif
+      )
 	return -1;
+	#ifdef FRCOV
+	}
+	#endif
 
       /* Sum.  */
       for (sub = info->input_bfds; sub != NULL; sub = sub->link.next)
diff --git a/bfd/coff-sh.c b/bfd/coff-sh.c
old mode 100644
new mode 100755
index 10d203f..2ac2744
--- a/bfd/coff-sh.c
+++ b/bfd/coff-sh.c
@@ -1,3 +1,6 @@
+#ifdef FRCOV
+extern short FIXREVERTER[];
+#endif
 /* BFD back-end for Renesas Super-H COFF binaries.
    Copyright (C) 1993-2021 Free Software Foundation, Inc.
    Contributed by Cygnus Support.
@@ -597,8 +600,23 @@ sh_reloc (bfd *      abfd,
       && bfd_is_und_section (symbol_in->section))
     return bfd_reloc_undefined;
 
-  if (addr > input_section->size)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[8413]) {
+    if ((addr > input_section -> size ) && !(0))
+      fprintf(stderr, "triggered bug index 8413\n");
+    else
+      fprintf(stderr, "reached bug index 8413\n");
+  }
+  if ((!FIXREVERTER[8413] && (addr > input_section -> size ))
+  #else
+  if (0
+  #endif
+  )
     return bfd_reloc_outofrange;
+    #ifdef FRCOV
+    }
+    #endif
 
   sym_value = get_symbol_value (symbol_in);
 
@@ -724,16 +742,46 @@ sh_relax_section (bfd *abfd,
     {
       size_t amt = sizeof (struct coff_section_tdata);
       sec->used_by_bfd = bfd_zalloc (abfd, amt);
-      if (sec->used_by_bfd == NULL)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[8414]) {
+        if ((sec -> used_by_bfd == (void *) 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 8414\n");
+        else
+          fprintf(stderr, "reached bug index 8414\n");
+      }
+      if ((!FIXREVERTER[8414] && (sec -> used_by_bfd == (void *) 0 ))
+      #else
+      if (0
+      #endif
+      )
 	return false;
+	#ifdef FRCOV
+	}
+	#endif
     }
 
   internal_relocs = (_bfd_coff_read_internal_relocs
 		     (abfd, sec, link_info->keep_memory,
 		      (bfd_byte *) NULL, false,
 		      (struct internal_reloc *) NULL));
-  if (internal_relocs == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[8415]) {
+    if ((internal_relocs == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 8415\n");
+    else
+      fprintf(stderr, "reached bug index 8415\n");
+  }
+  if ((!FIXREVERTER[8415] && (internal_relocs == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     goto error_return;
+    #ifdef FRCOV
+    }
+    #endif
 
   have_code = false;
 
@@ -749,8 +797,23 @@ sh_relax_section (bfd *abfd,
       if (irel->r_type == R_SH_CODE)
 	have_code = true;
 
-      if (irel->r_type != R_SH_USES)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[8416]) {
+        if ((irel -> r_type != 27 ) && !(0))
+          fprintf(stderr, "triggered bug index 8416\n");
+        else
+          fprintf(stderr, "reached bug index 8416\n");
+      }
+      if ((!FIXREVERTER[8416] && (irel -> r_type != 27 ))
+      #else
+      if (0
+      #endif
+      )
 	continue;
+	#ifdef FRCOV
+	}
+	#endif
 
       /* Get the section contents.  */
       if (contents == NULL)
@@ -771,7 +834,19 @@ sh_relax_section (bfd *abfd,
       laddr = irel->r_vaddr - sec->vma + 4;
       /* Careful to sign extend the 32-bit offset.  */
       laddr += ((irel->r_offset & 0xffffffff) ^ 0x80000000) - 0x80000000;
-      if (laddr >= sec->size)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[8417]) {
+        if ((laddr >= sec -> size ) && !(0))
+          fprintf(stderr, "triggered bug index 8417\n");
+        else
+          fprintf(stderr, "reached bug index 8417\n");
+      }
+      if ((!FIXREVERTER[8417] && (laddr >= sec -> size ))
+      #else
+      if (0
+      #endif
+      )
 	{
 	  /* xgettext: c-format */
 	  _bfd_error_handler
@@ -779,6 +854,9 @@ sh_relax_section (bfd *abfd,
 	     abfd, (uint64_t) irel->r_vaddr);
 	  continue;
 	}
+	#ifdef FRCOV
+	}
+	#endif
       insn = bfd_get_16 (abfd, contents + laddr);
 
       /* If the instruction is not mov.l NN,rN, we don't know what to do.  */
@@ -800,7 +878,19 @@ sh_relax_section (bfd *abfd,
       paddr = insn & 0xff;
       paddr *= 4;
       paddr += (laddr + 4) &~ (bfd_vma) 3;
-      if (paddr >= sec->size)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[8418]) {
+        if ((paddr >= sec -> size ) && !(0))
+          fprintf(stderr, "triggered bug index 8418\n");
+        else
+          fprintf(stderr, "reached bug index 8418\n");
+      }
+      if ((!FIXREVERTER[8418] && (paddr >= sec -> size ))
+      #else
+      if (0
+      #endif
+      )
 	{
 	  _bfd_error_handler
 	    /* xgettext: c-format */
@@ -808,6 +898,9 @@ sh_relax_section (bfd *abfd,
 	     abfd, (uint64_t) irel->r_vaddr);
 	  continue;
 	}
+	#ifdef FRCOV
+	}
+	#endif
 
       /* Get the reloc for the address from which the register is
 	 being loaded.  This reloc will tell us which function is
@@ -825,7 +918,19 @@ sh_relax_section (bfd *abfd,
 #endif
 	    )
 	  break;
-      if (irelfn >= irelend)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[8419]) {
+        if ((irelfn >= irelend ) && !(0))
+          fprintf(stderr, "triggered bug index 8419\n");
+        else
+          fprintf(stderr, "reached bug index 8419\n");
+      }
+      if ((!FIXREVERTER[8419] && (irelfn >= irelend ))
+      #else
+      if (0
+      #endif
+      )
 	{
 	  _bfd_error_handler
 	    /* xgettext: c-format */
@@ -833,6 +938,9 @@ sh_relax_section (bfd *abfd,
 	     abfd, (uint64_t) paddr);
 	  continue;
 	}
+	#ifdef FRCOV
+	}
+	#endif
 
       /* Get the value of the symbol referred to by the reloc.  */
       if (! _bfd_coff_get_external_symbols (abfd))
@@ -941,7 +1049,19 @@ sh_relax_section (bfd *abfd,
 	if (irelscan->r_type == R_SH_USES
 	    && laddr == irelscan->r_vaddr - sec->vma + 4 + irelscan->r_offset)
 	  break;
-      if (irelscan < irelend)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[8420]) {
+        if ((irelscan < irelend ) && !(0))
+          fprintf(stderr, "triggered bug index 8420\n");
+        else
+          fprintf(stderr, "reached bug index 8420\n");
+      }
+      if ((!FIXREVERTER[8420] && (irelscan < irelend ))
+      #else
+      if (0
+      #endif
+      )
 	{
 	  /* Some other function call depends upon this register load,
 	     and we have not yet converted that function call.
@@ -949,6 +1069,9 @@ sh_relax_section (bfd *abfd,
 	     nothing else we can do at this point.  */
 	  continue;
 	}
+	#ifdef FRCOV
+	}
+	#endif
 
       /* Look for a R_SH_COUNT reloc on the location where the
 	 function address is stored.  Do this before deleting any
@@ -968,7 +1091,19 @@ sh_relax_section (bfd *abfd,
       *again = true;
 
       /* Now check whether we got a COUNT reloc.  */
-      if (irelcount >= irelend)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[8421]) {
+        if ((irelcount >= irelend ) && !(0))
+          fprintf(stderr, "triggered bug index 8421\n");
+        else
+          fprintf(stderr, "reached bug index 8421\n");
+      }
+      if ((!FIXREVERTER[8421] && (irelcount >= irelend ))
+      #else
+      if (0
+      #endif
+      )
 	{
 	  _bfd_error_handler
 	    /* xgettext: c-format */
@@ -976,16 +1111,34 @@ sh_relax_section (bfd *abfd,
 	     abfd, (uint64_t) paddr);
 	  continue;
 	}
+	#ifdef FRCOV
+	}
+	#endif
 
       /* The number of uses is stored in the r_offset field.  We've
 	 just deleted one.  */
-      if (irelcount->r_offset == 0)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[8422]) {
+        if ((irelcount -> r_offset == 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 8422\n");
+        else
+          fprintf(stderr, "reached bug index 8422\n");
+      }
+      if ((!FIXREVERTER[8422] && (irelcount -> r_offset == 0 ))
+      #else
+      if (0
+      #endif
+      )
 	{
 	  /* xgettext: c-format */
 	  _bfd_error_handler (_("%pB: %#" PRIx64 ": warning: bad count"),
 			      abfd, (uint64_t) paddr);
 	  continue;
 	}
+	#ifdef FRCOV
+	}
+	#endif
 
       --irelcount->r_offset;
 
@@ -1140,13 +1293,25 @@ sh_relax_delete_bytes (bfd *abfd,
       /* See if this reloc was for the bytes we have deleted, in which
 	 case we no longer care about it.  Don't delete relocs which
 	 represent addresses, though.  */
-      if (irel->r_vaddr - sec->vma >= addr
-	  && irel->r_vaddr - sec->vma < addr + count
-	  && irel->r_type != R_SH_ALIGN
-	  && irel->r_type != R_SH_CODE
-	  && irel->r_type != R_SH_DATA
-	  && irel->r_type != R_SH_LABEL)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[8423]) {
+        fprintf(stderr, "reached bug index 8423\n");
+      }
+      if ((FIXREVERTER[8423] && (irel -> r_vaddr - sec -> vma >= addr && irel -> r_vaddr - sec -> vma < addr + count && irel -> r_type != 29 && irel -> r_type != 30 && irel -> r_type != 31 )) || (!FIXREVERTER[8423] && (irel -> r_vaddr - sec -> vma >= addr && irel -> r_vaddr - sec -> vma < addr + count && irel -> r_type != 29 && irel -> r_type != 30 && irel -> r_type != 31 && irel -> r_type != 32 ))
+      #else
+      if (irel -> r_vaddr - sec -> vma >= addr && irel -> r_vaddr - sec -> vma < addr + count && irel -> r_type != 29 && irel -> r_type != 30 && irel -> r_type != 31 
+      #endif
+      )
+	
+	#ifdef FRCOV
+	{if (!(irel -> r_type != 32 ))
+	  fprintf(stderr, "triggered bug index 8423\n");
+	#endif
 	irel->r_type = R_SH_UNUSED;
+	#ifdef FRCOV
+	}}
+	#endif
 
       /* If this is a PC relative reloc, see if the range it covers
 	 includes the bytes we have deleted.  */
@@ -1193,8 +1358,25 @@ sh_relax_delete_bytes (bfd *abfd,
 
 	      val = bfd_get_32 (abfd, contents + nraddr);
 	      val += sym.n_value;
-	      if (val > addr && val < toaddr)
+	      
+	      #ifdef FRCOV
+	      {if (FIXREVERTER[8424]) {
+	        fprintf(stderr, "reached bug index 8424\n");
+	      }
+	      if ((FIXREVERTER[8424] && (val > addr )) || (!FIXREVERTER[8424] && (val > addr && val < toaddr ))
+	      #else
+	      if (val > addr 
+	      #endif
+	      )
+		
+		#ifdef FRCOV
+		{if (!(val < toaddr ))
+		  fprintf(stderr, "triggered bug index 8424\n");
+		#endif
 		bfd_put_32 (abfd, val - count, contents + nraddr);
+		#ifdef FRCOV
+		}}
+		#endif
 	    }
 	  start = stop = addr;
 	  break;
@@ -1383,8 +1565,23 @@ sh_relax_delete_bytes (bfd *abfd,
       internal_relocs = (_bfd_coff_read_internal_relocs
 			 (abfd, o, true, (bfd_byte *) NULL, false,
 			  (struct internal_reloc *) NULL));
-      if (internal_relocs == NULL)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[8425]) {
+        if ((internal_relocs == (void *) 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 8425\n");
+        else
+          fprintf(stderr, "reached bug index 8425\n");
+      }
+      if ((!FIXREVERTER[8425] && (internal_relocs == (void *) 0 ))
+      #else
+      if (0
+      #endif
+      )
 	return false;
+	#ifdef FRCOV
+	}
+	#endif
 
       ocontents = NULL;
       irelscanend = internal_relocs + o->reloc_count;
@@ -1392,14 +1589,29 @@ sh_relax_delete_bytes (bfd *abfd,
 	{
 	  struct internal_syment sym;
 
-#ifdef COFF_WITH_PE
-	  if (irelscan->r_type != R_SH_IMM32
-	      && irelscan->r_type != R_SH_IMAGEBASE
-	      && irelscan->r_type != R_SH_IMM32CE)
-#else
-	  if (irelscan->r_type != R_SH_IMM32)
-#endif
+
+
+
+
+
+	  
+	  #ifdef FRCOV
+	  {if (FIXREVERTER[8426]) {
+	    if ((irelscan -> r_type != 14 ) && !(0))
+	      fprintf(stderr, "triggered bug index 8426\n");
+	    else
+	      fprintf(stderr, "reached bug index 8426\n");
+	  }
+	  if ((!FIXREVERTER[8426] && (irelscan -> r_type != 14 ))
+	  #else
+	  if (0
+	  #endif
+	  )
+
 	    continue;
+	    #ifdef FRCOV
+	    }
+	    #endif
 
 	  bfd_coff_swap_sym_in (abfd,
 				((bfd_byte *) obj_coff_external_syms (abfd)
@@ -1431,9 +1643,26 @@ sh_relax_delete_bytes (bfd *abfd,
 
 	      val = bfd_get_32 (abfd, ocontents + irelscan->r_vaddr - o->vma);
 	      val += sym.n_value;
-	      if (val > addr && val < toaddr)
+	      
+	      #ifdef FRCOV
+	      {if (FIXREVERTER[8427]) {
+	        fprintf(stderr, "reached bug index 8427\n");
+	      }
+	      if ((FIXREVERTER[8427] && (val > addr )) || (!FIXREVERTER[8427] && (val > addr && val < toaddr ))
+	      #else
+	      if (val > addr 
+	      #endif
+	      )
+		
+		#ifdef FRCOV
+		{if (!(val < toaddr ))
+		  fprintf(stderr, "triggered bug index 8427\n");
+		#endif
 		bfd_put_32 (abfd, val - count,
 			    ocontents + irelscan->r_vaddr - o->vma);
+			    #ifdef FRCOV
+			    }}
+			    #endif
 
 	      coff_section_data (abfd, o)->keep_contents = true;
 	    }
@@ -1495,12 +1724,27 @@ sh_relax_delete_bytes (bfd *abfd,
       alignto = BFD_ALIGN (toaddr, 1 << irelalign->r_offset);
       alignaddr = BFD_ALIGN (irelalign->r_vaddr - sec->vma,
 			     1 << irelalign->r_offset);
-      if (alignto != alignaddr)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[8428]) {
+        if ((alignto != alignaddr ) && !(0))
+          fprintf(stderr, "triggered bug index 8428\n");
+        else
+          fprintf(stderr, "reached bug index 8428\n");
+      }
+      if ((!FIXREVERTER[8428] && (alignto != alignaddr ))
+      #else
+      if (0
+      #endif
+      )
 	{
 	  /* Tail recursion.  */
 	  return sh_relax_delete_bytes (abfd, sec, alignaddr,
 					(int) (alignto - alignaddr));
 	}
+	#ifdef FRCOV
+	}
+	#endif
     }
 
   return true;
@@ -2676,8 +2920,23 @@ sh_align_loads (bfd *abfd,
   /* Get all the addresses with labels on them.  */
   amt = (bfd_size_type) sec->reloc_count * sizeof (bfd_vma);
   labels = (bfd_vma *) bfd_malloc (amt);
-  if (labels == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[8470]) {
+    if ((labels == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 8470\n");
+    else
+      fprintf(stderr, "reached bug index 8470\n");
+  }
+  if ((!FIXREVERTER[8470] && (labels == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     goto error_return;
+    #ifdef FRCOV
+    }
+    #endif
   label_end = labels;
   for (irel = internal_relocs; irel < irelend; irel++)
     {
@@ -2698,14 +2957,44 @@ sh_align_loads (bfd *abfd,
     {
       bfd_vma start, stop;
 
-      if (irel->r_type != R_SH_CODE)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[8471]) {
+        if ((irel -> r_type != 30 ) && !(0))
+          fprintf(stderr, "triggered bug index 8471\n");
+        else
+          fprintf(stderr, "reached bug index 8471\n");
+      }
+      if ((!FIXREVERTER[8471] && (irel -> r_type != 30 ))
+      #else
+      if (0
+      #endif
+      )
 	continue;
+	#ifdef FRCOV
+	}
+	#endif
 
       start = irel->r_vaddr - sec->vma;
 
       for (irel++; irel < irelend; irel++)
-	if (irel->r_type == R_SH_DATA)
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[8472]) {
+	  if ((irel -> r_type == 31 ) && !(0))
+	    fprintf(stderr, "triggered bug index 8472\n");
+	  else
+	    fprintf(stderr, "reached bug index 8472\n");
+	}
+	if ((!FIXREVERTER[8472] && (irel -> r_type == 31 ))
+	#else
+	if (0
+	#endif
+	)
 	  break;
+	  #ifdef FRCOV
+	  }
+	  #endif
       if (irel < irelend)
 	stop = irel->r_vaddr - sec->vma;
       else
@@ -2800,11 +3089,26 @@ sh_relocate_section (bfd *output_bfd ATTRIBUTE_UNUSED,
       else
 	howto = &sh_coff_howtos[rel->r_type];
 
-      if (howto == NULL)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[8473]) {
+        if ((howto == (void *) 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 8473\n");
+        else
+          fprintf(stderr, "reached bug index 8473\n");
+      }
+      if ((!FIXREVERTER[8473] && (howto == (void *) 0 ))
+      #else
+      if (0
+      #endif
+      )
 	{
 	  bfd_set_error (bfd_error_bad_value);
 	  return false;
 	}
+	#ifdef FRCOV
+	}
+	#endif
 
 #ifdef COFF_WITH_PE
       if (rel->r_type == R_SH_IMAGEBASE)
@@ -2818,8 +3122,23 @@ sh_relocate_section (bfd *output_bfd ATTRIBUTE_UNUSED,
 	  asection *sec;
 
 	  /* There is nothing to do for an internal PCDISP reloc.  */
-	  if (rel->r_type == R_SH_PCDISP)
+	  
+	  #ifdef FRCOV
+	  {if (FIXREVERTER[8474]) {
+	    if ((rel -> r_type == 12 ) && !(0))
+	      fprintf(stderr, "triggered bug index 8474\n");
+	    else
+	      fprintf(stderr, "reached bug index 8474\n");
+	  }
+	  if ((!FIXREVERTER[8474] && (rel -> r_type == 12 ))
+	  #else
+	  if (0
+	  #endif
+	  )
 	    continue;
+	    #ifdef FRCOV
+	    }
+	    #endif
 
 	  if (symndx == -1)
 	    {
@@ -2939,20 +3258,65 @@ sh_coff_get_relocated_section_contents (bfd *output_bfd,
       internal_relocs = (_bfd_coff_read_internal_relocs
 			 (input_bfd, input_section, false, (bfd_byte *) NULL,
 			  false, (struct internal_reloc *) NULL));
-      if (internal_relocs == NULL)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[8476]) {
+        if ((internal_relocs == (void *) 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 8476\n");
+        else
+          fprintf(stderr, "reached bug index 8476\n");
+      }
+      if ((!FIXREVERTER[8476] && (internal_relocs == (void *) 0 ))
+      #else
+      if (0
+      #endif
+      )
 	goto error_return;
+	#ifdef FRCOV
+	}
+	#endif
 
       amt = obj_raw_syment_count (input_bfd);
       amt *= sizeof (struct internal_syment);
       internal_syms = (struct internal_syment *) bfd_malloc (amt);
-      if (internal_syms == NULL)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[8477]) {
+        if ((internal_syms == (void *) 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 8477\n");
+        else
+          fprintf(stderr, "reached bug index 8477\n");
+      }
+      if ((!FIXREVERTER[8477] && (internal_syms == (void *) 0 ))
+      #else
+      if (0
+      #endif
+      )
 	goto error_return;
+	#ifdef FRCOV
+	}
+	#endif
 
       amt = obj_raw_syment_count (input_bfd);
       amt *= sizeof (asection *);
       sections = (asection **) bfd_malloc (amt);
-      if (sections == NULL)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[8478]) {
+        if ((sections == (void *) 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 8478\n");
+        else
+          fprintf(stderr, "reached bug index 8478\n");
+      }
+      if ((!FIXREVERTER[8478] && (sections == (void *) 0 ))
+      #else
+      if (0
+      #endif
+      )
 	goto error_return;
+	#ifdef FRCOV
+	}
+	#endif
 
       isymp = internal_syms;
       secpp = sections;
@@ -3060,8 +3424,23 @@ coff_small_new_section_hook (bfd *abfd, asection *section)
 
   /* We must align to at least a four byte boundary, because longword
      accesses must be on a four byte boundary.  */
-  if (section->alignment_power == COFF_DEFAULT_SECTION_ALIGNMENT_POWER)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[8479]) {
+    if ((section -> alignment_power == 4  ) && !(0))
+      fprintf(stderr, "triggered bug index 8479\n");
+    else
+      fprintf(stderr, "reached bug index 8479\n");
+  }
+  if ((!FIXREVERTER[8479] && (section -> alignment_power == 4  ))
+  #else
+  if (0
+  #endif
+  )
     section->alignment_power = 2;
+    #ifdef FRCOV
+    }
+    #endif
 
   return true;
 }
diff --git a/bfd/coff-stgo32.c b/bfd/coff-stgo32.c
old mode 100644
new mode 100755
diff --git a/bfd/coff-tic30.c b/bfd/coff-tic30.c
old mode 100644
new mode 100755
diff --git a/bfd/coff-tic4x.c b/bfd/coff-tic4x.c
old mode 100644
new mode 100755
diff --git a/bfd/coff-tic54x.c b/bfd/coff-tic54x.c
old mode 100644
new mode 100755
diff --git a/bfd/coff-x86_64.c b/bfd/coff-x86_64.c
old mode 100644
new mode 100755
diff --git a/bfd/coff-z80.c b/bfd/coff-z80.c
old mode 100644
new mode 100755
diff --git a/bfd/coff-z8k.c b/bfd/coff-z8k.c
old mode 100644
new mode 100755
diff --git a/bfd/coff64-rs6000.c b/bfd/coff64-rs6000.c
old mode 100644
new mode 100755
index 9e9f9c2..ebc7fa3
--- a/bfd/coff64-rs6000.c
+++ b/bfd/coff64-rs6000.c
@@ -1,3 +1,6 @@
+#ifdef FRCOV
+extern short FIXREVERTER[];
+#endif
 /* BFD back-end for IBM RS/6000 "XCOFF64" files.
    Copyright (C) 2000-2021 Free Software Foundation, Inc.
    Written Clinton Popetz.
@@ -1429,17 +1432,62 @@ xcoff64_rtype2howto (arelent *relent, struct internal_reloc *internal)
 	relent->howto = &xcoff64_howto_table[0x1d];
       else if (R_RBR == internal->r_type)
 	relent->howto = &xcoff64_howto_table[0x1e];
-      else if (R_RBA == internal->r_type)
+      else 
+      #ifdef FRCOV
+      {if (FIXREVERTER[7459]) {
+        if ((24 == internal -> r_type  ) && !(0))
+          fprintf(stderr, "triggered bug index 7459\n");
+        else
+          fprintf(stderr, "reached bug index 7459\n");
+      }
+      if ((!FIXREVERTER[7459] && (24 == internal -> r_type  ))
+      #else
+      if (0
+      #endif
+      )
 	relent->howto = &xcoff64_howto_table[0x1f];
+	#ifdef FRCOV
+	}
+	#endif
     }
   /* Special case 32 bit */
   else if (31 == (internal->r_size & 0x3f))
     {
-      if (R_POS == internal->r_type)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[7460]) {
+        if ((0 == internal -> r_type  ) && !(0))
+          fprintf(stderr, "triggered bug index 7460\n");
+        else
+          fprintf(stderr, "reached bug index 7460\n");
+      }
+      if ((!FIXREVERTER[7460] && (0 == internal -> r_type  ))
+      #else
+      if (0
+      #endif
+      )
 	relent->howto = &xcoff64_howto_table[0x1c];
-
-      if (R_NEG == internal->r_type)
+	#ifdef FRCOV
+	}
+	#endif
+
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[7461]) {
+        if ((1 == internal -> r_type  ) && !(0))
+          fprintf(stderr, "triggered bug index 7461\n");
+        else
+          fprintf(stderr, "reached bug index 7461\n");
+      }
+      if ((!FIXREVERTER[7461] && (1 == internal -> r_type  ))
+      #else
+      if (0
+      #endif
+      )
 	relent->howto = &xcoff64_howto_table[0x26];
+	#ifdef FRCOV
+	}
+	#endif
     }
 
   /* The r_size field of an XCOFF reloc encodes the bitsize of the
@@ -1783,11 +1831,26 @@ xcoff64_slurp_armap (bfd *abfd)
 
   off = bfd_scan_vma (xcoff_ardata_big (abfd)->symoff64,
 		      (const char **) NULL, 10);
-  if (off == 0)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[7466]) {
+    if ((off == 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 7466\n");
+    else
+      fprintf(stderr, "reached bug index 7466\n");
+  }
+  if ((!FIXREVERTER[7466] && (off == 0 ))
+  #else
+  if (0
+  #endif
+  )
     {
       abfd->has_armap = false;
       return true;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
   if (bfd_seek (abfd, off, SEEK_SET) != 0)
     return false;
@@ -1804,16 +1867,46 @@ xcoff64_slurp_armap (bfd *abfd)
     return false;
 
   sz = bfd_scan_vma (hdr.size, (const char **) NULL, 10);
-  if (sz + 1 < 9)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[7467]) {
+    if ((sz + 1 < 9 ) && !(0))
+      fprintf(stderr, "triggered bug index 7467\n");
+    else
+      fprintf(stderr, "reached bug index 7467\n");
+  }
+  if ((!FIXREVERTER[7467] && (sz + 1 < 9 ))
+  #else
+  if (0
+  #endif
+  )
     {
       bfd_set_error (bfd_error_bad_value);
       return false;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
   /* Read in the entire symbol table.  */
   contents = (bfd_byte *) _bfd_alloc_and_read (abfd, sz + 1, sz);
-  if (contents == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[7468]) {
+    if ((contents == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 7468\n");
+    else
+      fprintf(stderr, "reached bug index 7468\n");
+  }
+  if ((!FIXREVERTER[7468] && (contents == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     return false;
+    #ifdef FRCOV
+    }
+    #endif
 
   /* Ensure strings are NULL terminated so we don't wander off the end
      of the buffer.  */
@@ -1822,11 +1915,26 @@ xcoff64_slurp_armap (bfd *abfd)
   /* The symbol table starts with an eight byte count.  */
   c = H_GET_64 (abfd, contents);
 
-  if (c >= sz / 8)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[7469]) {
+    if ((c >= sz / 8 ) && !(0))
+      fprintf(stderr, "triggered bug index 7469\n");
+    else
+      fprintf(stderr, "reached bug index 7469\n");
+  }
+  if ((!FIXREVERTER[7469] && (c >= sz / 8 ))
+  #else
+  if (0
+  #endif
+  )
     {
       bfd_set_error (bfd_error_bad_value);
       return false;
     }
+    #ifdef FRCOV
+    }
+    #endif
   amt = c;
   amt *= sizeof (carsym);
   bfd_ardata (abfd)->symdefs = (carsym *) bfd_alloc (abfd, amt);
@@ -1845,11 +1953,26 @@ xcoff64_slurp_armap (bfd *abfd)
        i < c;
        ++i, ++arsym, p += strlen ((char *) p) + 1)
     {
-      if (p >= cend)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[7470]) {
+        if ((p >= cend ) && !(0))
+          fprintf(stderr, "triggered bug index 7470\n");
+        else
+          fprintf(stderr, "reached bug index 7470\n");
+      }
+      if ((!FIXREVERTER[7470] && (p >= cend ))
+      #else
+      if (0
+      #endif
+      )
 	{
 	  bfd_set_error (bfd_error_bad_value);
 	  return false;
 	}
+	#ifdef FRCOV
+	}
+	#endif
       arsym->name = (char *) p;
     }
 
diff --git a/bfd/coffcode.h b/bfd/coffcode.h
old mode 100644
new mode 100755
diff --git a/bfd/coffgen.c b/bfd/coffgen.c
old mode 100644
new mode 100755
index b13e773..d044fe0
--- a/bfd/coffgen.c
+++ b/bfd/coffgen.c
@@ -1,3 +1,6 @@
+#ifdef FRCOV
+extern short FIXREVERTER[];
+#endif
 /* Support for the generic parts of COFF, for BFD.
    Copyright (C) 1990-2021 Free Software Foundation, Inc.
    Written by Cygnus Support.
@@ -330,12 +333,27 @@ coff_object_p (bfd *abfd)
   aoutsz = bfd_coff_aoutsz (abfd);
 
   filehdr = _bfd_alloc_and_read (abfd, filhsz, filhsz);
-  if (filehdr == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[2760]) {
+    if ((filehdr == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 2760\n");
+    else
+      fprintf(stderr, "reached bug index 2760\n");
+  }
+  if ((!FIXREVERTER[2760] && (filehdr == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     {
       if (bfd_get_error () != bfd_error_system_call)
 	bfd_set_error (bfd_error_wrong_format);
       return NULL;
     }
+    #ifdef FRCOV
+    }
+    #endif
   bfd_coff_swap_filehdr_in (abfd, filehdr, &internal_f);
   bfd_release (abfd, filehdr);
 
@@ -360,8 +378,23 @@ coff_object_p (bfd *abfd)
       void * opthdr;
 
       opthdr = _bfd_alloc_and_read (abfd, aoutsz, internal_f.f_opthdr);
-      if (opthdr == NULL)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[2761]) {
+        if ((opthdr == (void *) 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 2761\n");
+        else
+          fprintf(stderr, "reached bug index 2761\n");
+      }
+      if ((!FIXREVERTER[2761] && (opthdr == (void *) 0 ))
+      #else
+      if (0
+      #endif
+      )
 	return NULL;
+	#ifdef FRCOV
+	}
+	#endif
       /* PR 17512: file: 11056-1136-0.004.  */
       if (internal_f.f_opthdr < aoutsz)
 	memset (((char *) opthdr) + internal_f.f_opthdr, 0,
@@ -462,8 +495,23 @@ _bfd_coff_internal_syment_name (bfd *abfd,
       if (strings == NULL)
 	{
 	  strings = _bfd_coff_read_string_table (abfd);
-	  if (strings == NULL)
+	  
+	  #ifdef FRCOV
+	  {if (FIXREVERTER[2763]) {
+	    if ((strings == (void *) 0 ) && !(0))
+	      fprintf(stderr, "triggered bug index 2763\n");
+	    else
+	      fprintf(stderr, "reached bug index 2763\n");
+	  }
+	  if ((!FIXREVERTER[2763] && (strings == (void *) 0 ))
+	  #else
+	  if (0
+	  #endif
+	  )
 	    return NULL;
+	    #ifdef FRCOV
+	    }
+	    #endif
 	}
       /* PR 17910: Only check for string overflow if the length has been set.
 	 Some DLLs, eg those produced by Visual Studio, may not set the length field.  */
@@ -499,8 +547,23 @@ _bfd_coff_read_internal_relocs (bfd *abfd,
   struct internal_reloc *irel;
   bfd_size_type amt;
 
-  if (sec->reloc_count == 0)
-    return internal_relocs;	/* Nothing to do.  */
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[2764]) {
+    if ((sec -> reloc_count == 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 2764\n");
+    else
+      fprintf(stderr, "reached bug index 2764\n");
+  }
+  if ((!FIXREVERTER[2764] && (sec -> reloc_count == 0 ))
+  #else
+  if (0
+  #endif
+  )
+    return internal_relocs;
+    #ifdef FRCOV
+    }
+    #endif	/* Nothing to do.  */
 
   if (coff_section_data (abfd, sec) != NULL
       && coff_section_data (abfd, sec)->relocs != NULL)
@@ -518,8 +581,23 @@ _bfd_coff_read_internal_relocs (bfd *abfd,
   if (external_relocs == NULL)
     {
       free_external = (bfd_byte *) bfd_malloc (amt);
-      if (free_external == NULL)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[2765]) {
+        if ((free_external == (void *) 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 2765\n");
+        else
+          fprintf(stderr, "reached bug index 2765\n");
+      }
+      if ((!FIXREVERTER[2765] && (free_external == (void *) 0 ))
+      #else
+      if (0
+      #endif
+      )
 	goto error_return;
+	#ifdef FRCOV
+	}
+	#endif
       external_relocs = free_external;
     }
 
@@ -532,8 +610,23 @@ _bfd_coff_read_internal_relocs (bfd *abfd,
       amt = sec->reloc_count;
       amt *= sizeof (struct internal_reloc);
       free_internal = (struct internal_reloc *) bfd_malloc (amt);
-      if (free_internal == NULL)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[2766]) {
+        if ((free_internal == (void *) 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 2766\n");
+        else
+          fprintf(stderr, "reached bug index 2766\n");
+      }
+      if ((!FIXREVERTER[2766] && (free_internal == (void *) 0 ))
+      #else
+      if (0
+      #endif
+      )
 	goto error_return;
+	#ifdef FRCOV
+	}
+	#endif
       internal_relocs = free_internal;
     }
 
@@ -553,8 +646,23 @@ _bfd_coff_read_internal_relocs (bfd *abfd,
 	{
 	  amt = sizeof (struct coff_section_tdata);
 	  sec->used_by_bfd = bfd_zalloc (abfd, amt);
-	  if (sec->used_by_bfd == NULL)
+	  
+	  #ifdef FRCOV
+	  {if (FIXREVERTER[2767]) {
+	    if ((sec -> used_by_bfd == (void *) 0 ) && !(0))
+	      fprintf(stderr, "triggered bug index 2767\n");
+	    else
+	      fprintf(stderr, "reached bug index 2767\n");
+	  }
+	  if ((!FIXREVERTER[2767] && (sec -> used_by_bfd == (void *) 0 ))
+	  #else
+	  if (0
+	  #endif
+	  )
 	    goto error_return;
+	    #ifdef FRCOV
+	    }
+	    #endif
 	  coff_section_data (abfd, sec)->contents = NULL;
 	}
       coff_section_data (abfd, sec)->relocs = free_internal;
@@ -1589,8 +1697,23 @@ build_debug_section (bfd *abfd, asection ** sect_return)
 
   sec_size = sect->size;
   debug_section = (char *) _bfd_alloc_and_read (abfd, sec_size, sec_size);
-  if (debug_section == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[2772]) {
+    if ((debug_section == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 2772\n");
+    else
+      fprintf(stderr, "reached bug index 2772\n");
+  }
+  if ((!FIXREVERTER[2772] && (debug_section == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     return NULL;
+    #ifdef FRCOV
+    }
+    #endif
 
   if (bfd_seek (abfd, position, SEEK_SET) != 0)
     return NULL;
@@ -1709,8 +1832,23 @@ _bfd_coff_read_string_table (bfd *abfd)
     }
 
   strings = (char *) bfd_malloc (strsize + 1);
-  if (strings == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[2774]) {
+    if ((strings == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 2774\n");
+    else
+      fprintf(stderr, "reached bug index 2774\n");
+  }
+  if ((!FIXREVERTER[2774] && (strings == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     return NULL;
+    #ifdef FRCOV
+    }
+    #endif
 
   /* PR 17521 file: 079-54929-0.004.
      A corrupt file could contain an index that points into the first
@@ -1869,8 +2007,23 @@ coff_get_normalized_symtab (bfd *abfd)
 	      if (string_table == NULL)
 		{
 		  string_table = _bfd_coff_read_string_table (abfd);
-		  if (string_table == NULL)
+		  
+		  #ifdef FRCOV
+		  {if (FIXREVERTER[2775]) {
+		    if ((string_table == (void *) 0 ) && !(0))
+		      fprintf(stderr, "triggered bug index 2775\n");
+		    else
+		      fprintf(stderr, "reached bug index 2775\n");
+		  }
+		  if ((!FIXREVERTER[2775] && (string_table == (void *) 0 ))
+		  #else
+		  if (0
+		  #endif
+		  )
 		    return NULL;
+		    #ifdef FRCOV
+		    }
+		    #endif
 		}
 
 	      if ((bfd_size_type)(aux->u.auxent.x_file.x_n.x_offset)
@@ -1915,8 +2068,23 @@ coff_get_normalized_symtab (bfd *abfd)
 		  break;
 
 	      newstring = (char *) bfd_zalloc (abfd, (bfd_size_type) (i + 1));
-	      if (newstring == NULL)
+	      
+	      #ifdef FRCOV
+	      {if (FIXREVERTER[2776]) {
+	        if ((newstring == (void *) 0 ) && !(0))
+	          fprintf(stderr, "triggered bug index 2776\n");
+	        else
+	          fprintf(stderr, "reached bug index 2776\n");
+	      }
+	      if ((!FIXREVERTER[2776] && (newstring == (void *) 0 ))
+	      #else
+	      if (0
+	      #endif
+	      )
 		return NULL;
+		#ifdef FRCOV
+		}
+		#endif
 	      strncpy (newstring, internal_ptr->u.syment._n._n_name, i);
 	      internal_ptr->u.syment._n._n_n._n_offset = (bfd_hostptr_t) newstring;
 	      internal_ptr->u.syment._n._n_n._n_zeroes = 0;
@@ -1930,8 +2098,23 @@ coff_get_normalized_symtab (bfd *abfd)
 	      if (string_table == NULL)
 		{
 		  string_table = _bfd_coff_read_string_table (abfd);
-		  if (string_table == NULL)
+		  
+		  #ifdef FRCOV
+		  {if (FIXREVERTER[2777]) {
+		    if ((string_table == (void *) 0 ) && !(0))
+		      fprintf(stderr, "triggered bug index 2777\n");
+		    else
+		      fprintf(stderr, "reached bug index 2777\n");
+		  }
+		  if ((!FIXREVERTER[2777] && (string_table == (void *) 0 ))
+		  #else
+		  if (0
+		  #endif
+		  )
 		    return NULL;
+		    #ifdef FRCOV
+		    }
+		    #endif
 		}
 	      if (internal_ptr->u.syment._n._n_n._n_offset >= obj_coff_strings_len (abfd)
 		  || string_table + internal_ptr->u.syment._n._n_n._n_offset < string_table)
@@ -1945,8 +2128,23 @@ coff_get_normalized_symtab (bfd *abfd)
 	  else
 	    {
 	      /* Long name in debug section.  Very similar.  */
-	      if (debug_sec_data == NULL)
+	      
+	      #ifdef FRCOV
+	      {if (FIXREVERTER[2778]) {
+	        if ((debug_sec_data == (void *) 0 ) && !(0))
+	          fprintf(stderr, "triggered bug index 2778\n");
+	        else
+	          fprintf(stderr, "reached bug index 2778\n");
+	      }
+	      if ((!FIXREVERTER[2778] && (debug_sec_data == (void *) 0 ))
+	      #else
+	      if (0
+	      #endif
+	      )
 		debug_sec_data = build_debug_section (abfd, & debug_sec);
+		#ifdef FRCOV
+		}
+		#endif
 	      if (debug_sec_data != NULL)
 		{
 		  BFD_ASSERT (debug_sec != NULL);
@@ -1996,8 +2194,23 @@ coff_make_empty_symbol (bfd *abfd)
   size_t amt = sizeof (coff_symbol_type);
   coff_symbol_type *new_symbol = (coff_symbol_type *) bfd_zalloc (abfd, amt);
 
-  if (new_symbol == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[2780]) {
+    if ((new_symbol == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 2780\n");
+    else
+      fprintf(stderr, "reached bug index 2780\n");
+  }
+  if ((!FIXREVERTER[2780] && (new_symbol == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     return NULL;
+    #ifdef FRCOV
+    }
+    #endif
   new_symbol->symbol.section = 0;
   new_symbol->native = NULL;
   new_symbol->lineno = NULL;
diff --git a/bfd/cofflink.c b/bfd/cofflink.c
old mode 100644
new mode 100755
index dd3e8dd..4991881
--- a/bfd/cofflink.c
+++ b/bfd/cofflink.c
@@ -1,3 +1,6 @@
+#ifdef FRCOV
+extern short FIXREVERTER[];
+#endif
 /* COFF specific linker code.
    Copyright (C) 1994-2021 Free Software Foundation, Inc.
    Written by Ian Lance Taylor, Cygnus Support.
@@ -250,8 +253,23 @@ coff_link_add_symbols (bfd *abfd,
 
   symcount = obj_raw_syment_count (abfd);
 
-  if (symcount == 0)
-    return true;		/* Nothing to do.  */
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[8675]) {
+    if ((symcount == 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 8675\n");
+    else
+      fprintf(stderr, "reached bug index 8675\n");
+  }
+  if ((!FIXREVERTER[8675] && (symcount == 0 ))
+  #else
+  if (0
+  #endif
+  )
+    return true;
+    #ifdef FRCOV
+    }
+    #endif		/* Nothing to do.  */
 
   /* Keep the symbols during this function, in case the linker needs
      to read the generic symbols in order to report an error message.  */
@@ -267,8 +285,23 @@ coff_link_add_symbols (bfd *abfd,
      to particular symbols.  */
   amt = symcount * sizeof (struct coff_link_hash_entry *);
   sym_hash = (struct coff_link_hash_entry **) bfd_zalloc (abfd, amt);
-  if (sym_hash == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[8676]) {
+    if ((sym_hash == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 8676\n");
+    else
+      fprintf(stderr, "reached bug index 8676\n");
+  }
+  if ((!FIXREVERTER[8676] && (sym_hash == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     goto error_return;
+    #ifdef FRCOV
+    }
+    #endif
   obj_coff_sym_hashes (abfd) = sym_hash;
 
   symesz = bfd_coff_symesz (abfd);
@@ -297,8 +330,23 @@ coff_link_add_symbols (bfd *abfd,
 	  /* This symbol is externally visible.  */
 
 	  name = _bfd_coff_internal_syment_name (abfd, &sym, buf);
-	  if (name == NULL)
+	  
+	  #ifdef FRCOV
+	  {if (FIXREVERTER[8678]) {
+	    if ((name == (void *) 0 ) && !(0))
+	      fprintf(stderr, "triggered bug index 8678\n");
+	    else
+	      fprintf(stderr, "reached bug index 8678\n");
+	  }
+	  if ((!FIXREVERTER[8678] && (name == (void *) 0 ))
+	  #else
+	  if (0
+	  #endif
+	  )
 	    goto error_return;
+	    #ifdef FRCOV
+	    }
+	    #endif
 
 	  /* We must copy the name into memory if we got it from the
 	     syment itself, rather than the string table.  */
@@ -492,8 +540,23 @@ coff_link_add_symbols (bfd *abfd,
 			       bfd_hash_allocate (&info->hash->table,
 						  (sym.n_numaux
 						   * sizeof (*alloc))));
-		      if (alloc == NULL)
+		      
+		      #ifdef FRCOV
+		      {if (FIXREVERTER[8679]) {
+		        if ((alloc == (void *) 0 ) && !(0))
+		          fprintf(stderr, "triggered bug index 8679\n");
+		        else
+		          fprintf(stderr, "reached bug index 8679\n");
+		      }
+		      if ((!FIXREVERTER[8679] && (alloc == (void *) 0 ))
+		      #else
+		      if (0
+		      #endif
+		      )
 			goto error_return;
+			#ifdef FRCOV
+			}
+			#endif
 		      for (i = 0, eaux = esym + symesz, iaux = alloc;
 			   i < sym.n_numaux;
 			   i++, eaux += symesz, iaux++)
@@ -558,8 +621,23 @@ coff_link_add_symbols (bfd *abfd,
 		{
 		  amt = sizeof (struct coff_section_tdata);
 		  stab->used_by_bfd = bfd_zalloc (abfd, amt);
-		  if (stab->used_by_bfd == NULL)
+		  
+		  #ifdef FRCOV
+		  {if (FIXREVERTER[8681]) {
+		    if ((stab -> used_by_bfd == (void *) 0 ) && !(0))
+		      fprintf(stderr, "triggered bug index 8681\n");
+		    else
+		      fprintf(stderr, "reached bug index 8681\n");
+		  }
+		  if ((!FIXREVERTER[8681] && (stab -> used_by_bfd == (void *) 0 ))
+		  #else
+		  if (0
+		  #endif
+		  )
 		    goto error_return;
+		    #ifdef FRCOV
+		    }
+		    #endif
 		  secdata = coff_section_data (abfd, stab);
 		}
 
@@ -1372,8 +1450,23 @@ mark_relocs (struct coff_final_link_info *flaginfo, bfd *input_bfd)
 	  : flaginfo->internal_relocs)
 	);
 
-      if (internal_relocs == NULL)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[8682]) {
+        if ((internal_relocs == (void *) 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 8682\n");
+        else
+          fprintf(stderr, "reached bug index 8682\n");
+      }
+      if ((!FIXREVERTER[8682] && (internal_relocs == (void *) 0 ))
+      #else
+      if (0
+      #endif
+      )
 	continue;
+	#ifdef FRCOV
+	}
+	#endif
 
       irel     = internal_relocs;
       irelend  = irel + a->reloc_count;
diff --git a/bfd/coffswap.h b/bfd/coffswap.h
old mode 100644
new mode 100755
diff --git a/bfd/compress.c b/bfd/compress.c
old mode 100644
new mode 100755
index 6d98aec..4d1b393
--- a/bfd/compress.c
+++ b/bfd/compress.c
@@ -1,3 +1,6 @@
+#ifdef FRCOV
+extern short FIXREVERTER[];
+#endif
 /* Compressed section support (intended for debug sections).
    Copyright (C) 2008-2021 Free Software Foundation, Inc.
 
@@ -137,8 +140,23 @@ bfd_compress_section_contents (bfd *abfd, sec_ptr sec,
       buffer_size = compressed_size;
     }
   buffer = (bfd_byte *) bfd_alloc (abfd, buffer_size);
-  if (buffer == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[12356]) {
+    if ((buffer == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 12356\n");
+    else
+      fprintf(stderr, "reached bug index 12356\n");
+  }
+  if ((!FIXREVERTER[12356] && (buffer == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     return 0;
+    #ifdef FRCOV
+    }
+    #endif
 
   if (compressed)
     {
diff --git a/bfd/config.bfd b/bfd/config.bfd
old mode 100644
new mode 100755
diff --git a/bfd/config.in b/bfd/config.in
old mode 100644
new mode 100755
diff --git a/bfd/configure.ac b/bfd/configure.ac
old mode 100644
new mode 100755
diff --git a/bfd/configure.com b/bfd/configure.com
old mode 100644
new mode 100755
diff --git a/bfd/configure.host b/bfd/configure.host
old mode 100644
new mode 100755
diff --git a/bfd/corefile.c b/bfd/corefile.c
old mode 100644
new mode 100755
diff --git a/bfd/cpu-aarch64.c b/bfd/cpu-aarch64.c
old mode 100644
new mode 100755
diff --git a/bfd/cpu-aarch64.h b/bfd/cpu-aarch64.h
old mode 100644
new mode 100755
diff --git a/bfd/cpu-alpha.c b/bfd/cpu-alpha.c
old mode 100644
new mode 100755
diff --git a/bfd/cpu-arc.c b/bfd/cpu-arc.c
old mode 100644
new mode 100755
diff --git a/bfd/cpu-arm.c b/bfd/cpu-arm.c
old mode 100644
new mode 100755
diff --git a/bfd/cpu-arm.h b/bfd/cpu-arm.h
old mode 100644
new mode 100755
diff --git a/bfd/cpu-avr.c b/bfd/cpu-avr.c
old mode 100644
new mode 100755
diff --git a/bfd/cpu-bfin.c b/bfd/cpu-bfin.c
old mode 100644
new mode 100755
diff --git a/bfd/cpu-bpf.c b/bfd/cpu-bpf.c
old mode 100644
new mode 100755
diff --git a/bfd/cpu-cr16.c b/bfd/cpu-cr16.c
old mode 100644
new mode 100755
diff --git a/bfd/cpu-cris.c b/bfd/cpu-cris.c
old mode 100644
new mode 100755
diff --git a/bfd/cpu-crx.c b/bfd/cpu-crx.c
old mode 100644
new mode 100755
diff --git a/bfd/cpu-csky.c b/bfd/cpu-csky.c
old mode 100644
new mode 100755
diff --git a/bfd/cpu-d10v.c b/bfd/cpu-d10v.c
old mode 100644
new mode 100755
diff --git a/bfd/cpu-d30v.c b/bfd/cpu-d30v.c
old mode 100644
new mode 100755
diff --git a/bfd/cpu-dlx.c b/bfd/cpu-dlx.c
old mode 100644
new mode 100755
diff --git a/bfd/cpu-epiphany.c b/bfd/cpu-epiphany.c
old mode 100644
new mode 100755
diff --git a/bfd/cpu-fr30.c b/bfd/cpu-fr30.c
old mode 100644
new mode 100755
diff --git a/bfd/cpu-frv.c b/bfd/cpu-frv.c
old mode 100644
new mode 100755
diff --git a/bfd/cpu-ft32.c b/bfd/cpu-ft32.c
old mode 100644
new mode 100755
diff --git a/bfd/cpu-h8300.c b/bfd/cpu-h8300.c
old mode 100644
new mode 100755
diff --git a/bfd/cpu-h8300.h b/bfd/cpu-h8300.h
old mode 100644
new mode 100755
diff --git a/bfd/cpu-hppa.c b/bfd/cpu-hppa.c
old mode 100644
new mode 100755
diff --git a/bfd/cpu-i386.c b/bfd/cpu-i386.c
old mode 100644
new mode 100755
diff --git a/bfd/cpu-ia64-opc.c b/bfd/cpu-ia64-opc.c
old mode 100644
new mode 100755
diff --git a/bfd/cpu-ia64.c b/bfd/cpu-ia64.c
old mode 100644
new mode 100755
diff --git a/bfd/cpu-iamcu.c b/bfd/cpu-iamcu.c
old mode 100644
new mode 100755
diff --git a/bfd/cpu-ip2k.c b/bfd/cpu-ip2k.c
old mode 100644
new mode 100755
diff --git a/bfd/cpu-iq2000.c b/bfd/cpu-iq2000.c
old mode 100644
new mode 100755
diff --git a/bfd/cpu-k1om.c b/bfd/cpu-k1om.c
old mode 100644
new mode 100755
diff --git a/bfd/cpu-l1om.c b/bfd/cpu-l1om.c
old mode 100644
new mode 100755
diff --git a/bfd/cpu-lm32.c b/bfd/cpu-lm32.c
old mode 100644
new mode 100755
diff --git a/bfd/cpu-m10200.c b/bfd/cpu-m10200.c
old mode 100644
new mode 100755
diff --git a/bfd/cpu-m10300.c b/bfd/cpu-m10300.c
old mode 100644
new mode 100755
diff --git a/bfd/cpu-m32c.c b/bfd/cpu-m32c.c
old mode 100644
new mode 100755
diff --git a/bfd/cpu-m32r.c b/bfd/cpu-m32r.c
old mode 100644
new mode 100755
diff --git a/bfd/cpu-m68hc11.c b/bfd/cpu-m68hc11.c
old mode 100644
new mode 100755
diff --git a/bfd/cpu-m68hc12.c b/bfd/cpu-m68hc12.c
old mode 100644
new mode 100755
diff --git a/bfd/cpu-m68k.c b/bfd/cpu-m68k.c
old mode 100644
new mode 100755
diff --git a/bfd/cpu-m68k.h b/bfd/cpu-m68k.h
old mode 100644
new mode 100755
diff --git a/bfd/cpu-m9s12x.c b/bfd/cpu-m9s12x.c
old mode 100644
new mode 100755
diff --git a/bfd/cpu-m9s12xg.c b/bfd/cpu-m9s12xg.c
old mode 100644
new mode 100755
diff --git a/bfd/cpu-mcore.c b/bfd/cpu-mcore.c
old mode 100644
new mode 100755
diff --git a/bfd/cpu-mep.c b/bfd/cpu-mep.c
old mode 100644
new mode 100755
diff --git a/bfd/cpu-metag.c b/bfd/cpu-metag.c
old mode 100644
new mode 100755
diff --git a/bfd/cpu-microblaze.c b/bfd/cpu-microblaze.c
old mode 100644
new mode 100755
diff --git a/bfd/cpu-mips.c b/bfd/cpu-mips.c
old mode 100644
new mode 100755
diff --git a/bfd/cpu-mmix.c b/bfd/cpu-mmix.c
old mode 100644
new mode 100755
diff --git a/bfd/cpu-moxie.c b/bfd/cpu-moxie.c
old mode 100644
new mode 100755
diff --git a/bfd/cpu-msp430.c b/bfd/cpu-msp430.c
old mode 100644
new mode 100755
diff --git a/bfd/cpu-mt.c b/bfd/cpu-mt.c
old mode 100644
new mode 100755
diff --git a/bfd/cpu-nds32.c b/bfd/cpu-nds32.c
old mode 100644
new mode 100755
diff --git a/bfd/cpu-nfp.c b/bfd/cpu-nfp.c
old mode 100644
new mode 100755
diff --git a/bfd/cpu-nios2.c b/bfd/cpu-nios2.c
old mode 100644
new mode 100755
diff --git a/bfd/cpu-ns32k.c b/bfd/cpu-ns32k.c
old mode 100644
new mode 100755
diff --git a/bfd/cpu-or1k.c b/bfd/cpu-or1k.c
old mode 100644
new mode 100755
diff --git a/bfd/cpu-pdp11.c b/bfd/cpu-pdp11.c
old mode 100644
new mode 100755
diff --git a/bfd/cpu-pj.c b/bfd/cpu-pj.c
old mode 100644
new mode 100755
diff --git a/bfd/cpu-powerpc.c b/bfd/cpu-powerpc.c
old mode 100644
new mode 100755
diff --git a/bfd/cpu-pru.c b/bfd/cpu-pru.c
old mode 100644
new mode 100755
diff --git a/bfd/cpu-riscv.c b/bfd/cpu-riscv.c
old mode 100644
new mode 100755
diff --git a/bfd/cpu-riscv.h b/bfd/cpu-riscv.h
old mode 100644
new mode 100755
diff --git a/bfd/cpu-rl78.c b/bfd/cpu-rl78.c
old mode 100644
new mode 100755
diff --git a/bfd/cpu-rs6000.c b/bfd/cpu-rs6000.c
old mode 100644
new mode 100755
diff --git a/bfd/cpu-rx.c b/bfd/cpu-rx.c
old mode 100644
new mode 100755
diff --git a/bfd/cpu-s12z.c b/bfd/cpu-s12z.c
old mode 100644
new mode 100755
diff --git a/bfd/cpu-s390.c b/bfd/cpu-s390.c
old mode 100644
new mode 100755
diff --git a/bfd/cpu-score.c b/bfd/cpu-score.c
old mode 100644
new mode 100755
diff --git a/bfd/cpu-sh.c b/bfd/cpu-sh.c
old mode 100644
new mode 100755
diff --git a/bfd/cpu-sparc.c b/bfd/cpu-sparc.c
old mode 100644
new mode 100755
diff --git a/bfd/cpu-spu.c b/bfd/cpu-spu.c
old mode 100644
new mode 100755
diff --git a/bfd/cpu-tic30.c b/bfd/cpu-tic30.c
old mode 100644
new mode 100755
diff --git a/bfd/cpu-tic4x.c b/bfd/cpu-tic4x.c
old mode 100644
new mode 100755
diff --git a/bfd/cpu-tic54x.c b/bfd/cpu-tic54x.c
old mode 100644
new mode 100755
diff --git a/bfd/cpu-tic6x.c b/bfd/cpu-tic6x.c
old mode 100644
new mode 100755
diff --git a/bfd/cpu-tilegx.c b/bfd/cpu-tilegx.c
old mode 100644
new mode 100755
diff --git a/bfd/cpu-tilepro.c b/bfd/cpu-tilepro.c
old mode 100644
new mode 100755
diff --git a/bfd/cpu-v850.c b/bfd/cpu-v850.c
old mode 100644
new mode 100755
diff --git a/bfd/cpu-v850_rh850.c b/bfd/cpu-v850_rh850.c
old mode 100644
new mode 100755
diff --git a/bfd/cpu-vax.c b/bfd/cpu-vax.c
old mode 100644
new mode 100755
diff --git a/bfd/cpu-visium.c b/bfd/cpu-visium.c
old mode 100644
new mode 100755
diff --git a/bfd/cpu-wasm32.c b/bfd/cpu-wasm32.c
old mode 100644
new mode 100755
diff --git a/bfd/cpu-xc16x.c b/bfd/cpu-xc16x.c
old mode 100644
new mode 100755
diff --git a/bfd/cpu-xgate.c b/bfd/cpu-xgate.c
old mode 100644
new mode 100755
diff --git a/bfd/cpu-xstormy16.c b/bfd/cpu-xstormy16.c
old mode 100644
new mode 100755
diff --git a/bfd/cpu-xtensa.c b/bfd/cpu-xtensa.c
old mode 100644
new mode 100755
diff --git a/bfd/cpu-z80.c b/bfd/cpu-z80.c
old mode 100644
new mode 100755
diff --git a/bfd/cpu-z8k.c b/bfd/cpu-z8k.c
old mode 100644
new mode 100755
diff --git a/bfd/dep-in.sed b/bfd/dep-in.sed
old mode 100644
new mode 100755
diff --git a/bfd/development.sh b/bfd/development.sh
old mode 100644
new mode 100755
diff --git a/bfd/doc/ChangeLog-0415 b/bfd/doc/ChangeLog-0415
old mode 100644
new mode 100755
diff --git a/bfd/doc/ChangeLog-9103 b/bfd/doc/ChangeLog-9103
old mode 100644
new mode 100755
diff --git a/bfd/doc/Makefile.am b/bfd/doc/Makefile.am
old mode 100644
new mode 100755
diff --git a/bfd/doc/Makefile.in b/bfd/doc/Makefile.in
old mode 100644
new mode 100755
diff --git a/bfd/doc/bfd.texi b/bfd/doc/bfd.texi
old mode 100644
new mode 100755
diff --git a/bfd/doc/bfdint.texi b/bfd/doc/bfdint.texi
old mode 100644
new mode 100755
diff --git a/bfd/doc/bfdsumm.texi b/bfd/doc/bfdsumm.texi
old mode 100644
new mode 100755
diff --git a/bfd/doc/chew.c b/bfd/doc/chew.c
old mode 100644
new mode 100755
index b3be7fa..ff1ada0
--- a/bfd/doc/chew.c
+++ b/bfd/doc/chew.c
@@ -1,3 +1,6 @@
+#ifdef FRCOV
+short FIXREVERTER[12386];
+#endif
 /* chew
    Copyright (C) 1990-2021 Free Software Foundation, Inc.
    Contributed by steve chamberlain @cygnus
diff --git a/bfd/doc/doc.str b/bfd/doc/doc.str
old mode 100644
new mode 100755
diff --git a/bfd/doc/fdl.texi b/bfd/doc/fdl.texi
old mode 100644
new mode 100755
diff --git a/bfd/doc/header.sed b/bfd/doc/header.sed
old mode 100644
new mode 100755
diff --git a/bfd/doc/makefile.vms b/bfd/doc/makefile.vms
old mode 100644
new mode 100755
diff --git a/bfd/doc/proto.str b/bfd/doc/proto.str
old mode 100644
new mode 100755
diff --git a/bfd/doc/webassembly.texi b/bfd/doc/webassembly.texi
old mode 100644
new mode 100755
diff --git a/bfd/dwarf1.c b/bfd/dwarf1.c
old mode 100644
new mode 100755
diff --git a/bfd/dwarf2.c b/bfd/dwarf2.c
old mode 100644
new mode 100755
index 0a8a557..fcde268
--- a/bfd/dwarf2.c
+++ b/bfd/dwarf2.c
@@ -1,3 +1,6 @@
+#ifdef FRCOV
+extern short FIXREVERTER[];
+#endif
 /* DWARF 2 support.
    Copyright (C) 1994-2021 Free Software Foundation, Inc.
 
@@ -1819,10 +1822,40 @@ compare_sequences (const void* a, const void* b)
   const struct line_sequence* seq2 = b;
 
   /* Sort by low_pc as the primary key.  */
-  if (seq1->low_pc < seq2->low_pc)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[6738]) {
+    if ((seq1 -> low_pc < seq2 -> low_pc ) && !(0))
+      fprintf(stderr, "triggered bug index 6738\n");
+    else
+      fprintf(stderr, "reached bug index 6738\n");
+  }
+  if ((!FIXREVERTER[6738] && (seq1 -> low_pc < seq2 -> low_pc ))
+  #else
+  if (0
+  #endif
+  )
     return -1;
-  if (seq1->low_pc > seq2->low_pc)
+    #ifdef FRCOV
+    }
+    #endif
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[6739]) {
+    if ((seq1 -> low_pc > seq2 -> low_pc ) && !(0))
+      fprintf(stderr, "triggered bug index 6739\n");
+    else
+      fprintf(stderr, "reached bug index 6739\n");
+  }
+  if ((!FIXREVERTER[6739] && (seq1 -> low_pc > seq2 -> low_pc ))
+  #else
+  if (0
+  #endif
+  )
     return 1;
+    #ifdef FRCOV
+    }
+    #endif
 
   /* If low_pc values are equal, sort in reverse order of
      high_pc, so that the largest region comes first.  */
@@ -1837,10 +1870,40 @@ compare_sequences (const void* a, const void* b)
     return -1;
 
   /* num_lines is initially an index, to make the sort stable.  */
-  if (seq1->num_lines < seq2->num_lines)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[6740]) {
+    if ((seq1 -> num_lines < seq2 -> num_lines ) && !(0))
+      fprintf(stderr, "triggered bug index 6740\n");
+    else
+      fprintf(stderr, "reached bug index 6740\n");
+  }
+  if ((!FIXREVERTER[6740] && (seq1 -> num_lines < seq2 -> num_lines ))
+  #else
+  if (0
+  #endif
+  )
     return -1;
-  if (seq1->num_lines > seq2->num_lines)
+    #ifdef FRCOV
+    }
+    #endif
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[6741]) {
+    if ((seq1 -> num_lines > seq2 -> num_lines ) && !(0))
+      fprintf(stderr, "triggered bug index 6741\n");
+    else
+      fprintf(stderr, "reached bug index 6741\n");
+  }
+  if ((!FIXREVERTER[6741] && (seq1 -> num_lines > seq2 -> num_lines ))
+  #else
+  if (0
+  #endif
+  )
     return 1;
+    #ifdef FRCOV
+    }
+    #endif
   return 0;
 }
 
@@ -5381,8 +5444,23 @@ _bfd_dwarf2_cleanup_debug_info (bfd *abfd, void **pinfo)
   struct comp_unit *each;
   struct dwarf2_debug_file *file;
 
-  if (abfd == NULL || stash == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[6807]) {
+    if ((abfd == (void *) 0 || stash == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 6807\n");
+    else
+      fprintf(stderr, "reached bug index 6807\n");
+  }
+  if ((!FIXREVERTER[6807] && (abfd == (void *) 0 || stash == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     return;
+    #ifdef FRCOV
+    }
+    #endif
 
   if (stash->varinfo_hash_table)
     bfd_hash_table_free (&stash->varinfo_hash_table->base);
diff --git a/bfd/ecoff-bfd.h b/bfd/ecoff-bfd.h
old mode 100644
new mode 100755
diff --git a/bfd/ecoff.c b/bfd/ecoff.c
old mode 100644
new mode 100755
diff --git a/bfd/ecofflink.c b/bfd/ecofflink.c
old mode 100644
new mode 100755
index 9f72409..46d4b2a
--- a/bfd/ecofflink.c
+++ b/bfd/ecofflink.c
@@ -1,3 +1,6 @@
+#ifdef FRCOV
+extern short FIXREVERTER[];
+#endif
 /* Routines to link ECOFF debugging information.
    Copyright (C) 1993-2021 Free Software Foundation, Inc.
    Written by Ian Lance Taylor, Cygnus Support, <ian@cygnus.com>.
@@ -253,12 +256,42 @@ ecoff_add_bytes (char **buf, char **bufend, size_t need)
   else
     {
       want = need - have;
-      if (want < ALLOC_SIZE)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[4073]) {
+        if ((want < 4064 ) && !(0))
+          fprintf(stderr, "triggered bug index 4073\n");
+        else
+          fprintf(stderr, "reached bug index 4073\n");
+      }
+      if ((!FIXREVERTER[4073] && (want < 4064 ))
+      #else
+      if (0
+      #endif
+      )
 	want = ALLOC_SIZE;
+	#ifdef FRCOV
+	}
+	#endif
     }
   newbuf = (char *) bfd_realloc (*buf, (bfd_size_type) have + want);
-  if (newbuf == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[4074]) {
+    if ((newbuf == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 4074\n");
+    else
+      fprintf(stderr, "reached bug index 4074\n");
+  }
+  if ((!FIXREVERTER[4074] && (newbuf == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     return false;
+    #ifdef FRCOV
+    }
+    #endif
   *buf = newbuf;
   *bufend = *buf + have + want;
   return true;
diff --git a/bfd/ecoffswap.h b/bfd/ecoffswap.h
old mode 100644
new mode 100755
diff --git a/bfd/elf-attrs.c b/bfd/elf-attrs.c
old mode 100644
new mode 100755
index a7a76a2..ea840d9
--- a/bfd/elf-attrs.c
+++ b/bfd/elf-attrs.c
@@ -1,3 +1,6 @@
+#ifdef FRCOV
+extern short FIXREVERTER[];
+#endif
 /* ELF attributes support (based on ARM EABI attributes).
    Copyright (C) 2005-2021 Free Software Foundation, Inc.
 
@@ -253,8 +256,23 @@ elf_new_obj_attr (bfd *abfd, int vendor, unsigned int tag)
       lastp = &elf_other_obj_attributes (abfd)[vendor];
       for (p = *lastp; p; p = p->next)
 	{
-	  if (tag < p->tag)
+	  
+	  #ifdef FRCOV
+	  {if (FIXREVERTER[115]) {
+	    if ((tag < p -> tag ) && !(0))
+	      fprintf(stderr, "triggered bug index 115\n");
+	    else
+	      fprintf(stderr, "reached bug index 115\n");
+	  }
+	  if ((!FIXREVERTER[115] && (tag < p -> tag ))
+	  #else
+	  if (0
+	  #endif
+	  )
 	    break;
+	    #ifdef FRCOV
+	    }
+	    #endif
 	  lastp = &p->next;
 	}
       list->next = *lastp;
@@ -282,10 +300,40 @@ bfd_elf_get_obj_attr_int (bfd *abfd, int vendor, unsigned int tag)
 	   p;
 	   p = p->next)
 	{
-	  if (tag == p->tag)
+	  
+	  #ifdef FRCOV
+	  {if (FIXREVERTER[116]) {
+	    if ((tag == p -> tag ) && !(0))
+	      fprintf(stderr, "triggered bug index 116\n");
+	    else
+	      fprintf(stderr, "reached bug index 116\n");
+	  }
+	  if ((!FIXREVERTER[116] && (tag == p -> tag ))
+	  #else
+	  if (0
+	  #endif
+	  )
 	    return p->attr.i;
-	  if (tag < p->tag)
+	    #ifdef FRCOV
+	    }
+	    #endif
+	  
+	  #ifdef FRCOV
+	  {if (FIXREVERTER[117]) {
+	    if ((tag < p -> tag ) && !(0))
+	      fprintf(stderr, "triggered bug index 117\n");
+	    else
+	      fprintf(stderr, "reached bug index 117\n");
+	  }
+	  if ((!FIXREVERTER[117] && (tag < p -> tag ))
+	  #else
+	  if (0
+	  #endif
+	  )
 	    break;
+	    #ifdef FRCOV
+	    }
+	    #endif
 	}
       return 0;
     }
@@ -439,8 +487,23 @@ _bfd_elf_parse_attributes (bfd *abfd, Elf_Internal_Shdr * hdr)
   ufile_ptr filesize;
 
   /* PR 17512: file: 2844a11d.  */
-  if (hdr->sh_size == 0)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[120]) {
+    if ((hdr -> sh_size == 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 120\n");
+    else
+      fprintf(stderr, "reached bug index 120\n");
+  }
+  if ((!FIXREVERTER[120] && (hdr -> sh_size == 0 ))
+  #else
+  if (0
+  #endif
+  )
     return;
+    #ifdef FRCOV
+    }
+    #endif
 
   filesize = bfd_get_file_size (abfd);
   if (filesize != 0 && hdr->sh_size > filesize)
@@ -471,30 +534,104 @@ _bfd_elf_parse_attributes (bfd *abfd, Elf_Internal_Shdr * hdr)
     {
       len = hdr->sh_size - 1;
 
-      while (len > 0 && p < p_end - 4)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[129])
+        fprintf(stderr, "reached bug index 129\n");
+      while ((FIXREVERTER[129] && (len > 0 )) || (!FIXREVERTER[129] && (len > 0 && p < p_end - 4 ))
+      #else
+      while (len > 0 
+      #endif
+      )
 	{
+	  
+	#ifdef FRCOV
+	  if (!(p < p_end - 4 ))
+	    fprintf(stderr, "triggered bug index 129\n");
+	  #endif
+	
 	  unsigned namelen;
 	  bfd_vma section_len;
 	  int vendor;
 
 	  section_len = bfd_get_32 (abfd, p);
 	  p += 4;
-	  if (section_len == 0)
+	  
+	  #ifdef FRCOV
+	  {if (FIXREVERTER[121]) {
+	    if ((section_len == 0 ) && !(0))
+	      fprintf(stderr, "triggered bug index 121\n");
+	    else
+	      fprintf(stderr, "reached bug index 121\n");
+	  }
+	  if ((!FIXREVERTER[121] && (section_len == 0 ))
+	  #else
+	  if (0
+	  #endif
+	  )
 	    break;
-	  if (section_len > len)
+	    #ifdef FRCOV
+	    }
+	    #endif
+	  
+	  #ifdef FRCOV
+	  {if (FIXREVERTER[122]) {
+	    if ((section_len > len ) && !(0))
+	      fprintf(stderr, "triggered bug index 122\n");
+	    else
+	      fprintf(stderr, "reached bug index 122\n");
+	  }
+	  if ((!FIXREVERTER[122] && (section_len > len ))
+	  #else
+	  if (0
+	  #endif
+	  )
 	    section_len = len;
+	    #ifdef FRCOV
+	    }
+	    #endif
 	  len -= section_len;
-	  if (section_len <= 4)
+	  
+	  #ifdef FRCOV
+	  {if (FIXREVERTER[123]) {
+	    if ((section_len <= 4 ) && !(0))
+	      fprintf(stderr, "triggered bug index 123\n");
+	    else
+	      fprintf(stderr, "reached bug index 123\n");
+	  }
+	  if ((!FIXREVERTER[123] && (section_len <= 4 ))
+	  #else
+	  if (0
+	  #endif
+	  )
 	    {
 	      _bfd_error_handler
 		(_("%pB: error: attribute section length too small: %" PRId64),
 		 abfd, (int64_t) section_len);
 	      break;
 	    }
+	    #ifdef FRCOV
+	    }
+	    #endif
 	  section_len -= 4;
 	  namelen = strnlen ((char *) p, section_len) + 1;
-	  if (namelen == 0 || namelen >= section_len)
+	  
+	  #ifdef FRCOV
+	  {if (FIXREVERTER[124]) {
+	    if ((namelen == 0 || namelen >= section_len ) && !(0))
+	      fprintf(stderr, "triggered bug index 124\n");
+	    else
+	      fprintf(stderr, "reached bug index 124\n");
+	  }
+	  if ((!FIXREVERTER[124] && (namelen == 0 || namelen >= section_len ))
+	  #else
+	  if (0
+	  #endif
+	  )
 	    break;
+	    #ifdef FRCOV
+	    }
+	    #endif
 	  section_len -= namelen;
 	  if (std_sec && strcmp ((char *) p, std_sec) == 0)
 	    vendor = OBJ_ATTR_PROC;
@@ -508,8 +645,22 @@ _bfd_elf_parse_attributes (bfd *abfd, Elf_Internal_Shdr * hdr)
 	    }
 
 	  p += namelen;
-	  while (section_len > 0 && p < p_end)
+	  
+	  #ifdef FRCOV
+	  {if (FIXREVERTER[128])
+	    fprintf(stderr, "reached bug index 128\n");
+	  while ((FIXREVERTER[128] && (section_len > 0 )) || (!FIXREVERTER[128] && (section_len > 0 && p < p_end ))
+	  #else
+	  while (section_len > 0 
+	  #endif
+	  )
 	    {
+	      
+	    #ifdef FRCOV
+	      if (!(p < p_end ))
+	        fprintf(stderr, "triggered bug index 128\n");
+	      #endif
+	    
 	      unsigned int tag;
 	      unsigned int n;
 	      unsigned int val;
@@ -523,16 +674,61 @@ _bfd_elf_parse_attributes (bfd *abfd, Elf_Internal_Shdr * hdr)
 	      else
 		subsection_len = 0;
 	      p += 4;
-	      if (subsection_len == 0)
+	      
+	      #ifdef FRCOV
+	      {if (FIXREVERTER[125]) {
+	        if ((subsection_len == 0 ) && !(0))
+	          fprintf(stderr, "triggered bug index 125\n");
+	        else
+	          fprintf(stderr, "reached bug index 125\n");
+	      }
+	      if ((!FIXREVERTER[125] && (subsection_len == 0 ))
+	      #else
+	      if (0
+	      #endif
+	      )
 		break;
-	      if (subsection_len > section_len)
+		#ifdef FRCOV
+		}
+		#endif
+	      
+	      #ifdef FRCOV
+	      {if (FIXREVERTER[126]) {
+	        if ((subsection_len > section_len ) && !(0))
+	          fprintf(stderr, "triggered bug index 126\n");
+	        else
+	          fprintf(stderr, "reached bug index 126\n");
+	      }
+	      if ((!FIXREVERTER[126] && (subsection_len > section_len ))
+	      #else
+	      if (0
+	      #endif
+	      )
 		subsection_len = section_len;
+		#ifdef FRCOV
+		}
+		#endif
 	      section_len -= subsection_len;
 	      subsection_len -= n + 4;
 	      end = p + subsection_len;
 	      /* PR 17512: file: 0e8c0c90.  */
-	      if (end > p_end)
+	      
+	      #ifdef FRCOV
+	      {if (FIXREVERTER[127]) {
+	        if ((end > p_end ) && !(0))
+	          fprintf(stderr, "triggered bug index 127\n");
+	        else
+	          fprintf(stderr, "reached bug index 127\n");
+	      }
+	      if ((!FIXREVERTER[127] && (end > p_end ))
+	      #else
+	      if (0
+	      #endif
+	      )
 		end = p_end;
+		#ifdef FRCOV
+		}
+		#endif
 	      switch (tag)
 		{
 		case Tag_File:
@@ -578,7 +774,13 @@ _bfd_elf_parse_attributes (bfd *abfd, Elf_Internal_Shdr * hdr)
 		  break;
 		}
 	    }
+	    #ifdef FRCOV
+	    }
+	    #endif
+	}
+	#ifdef FRCOV
 	}
+	#endif
     }
   free (contents);
 }
diff --git a/bfd/elf-bfd.h b/bfd/elf-bfd.h
old mode 100644
new mode 100755
diff --git a/bfd/elf-eh-frame.c b/bfd/elf-eh-frame.c
old mode 100644
new mode 100755
index 6ce6d22..bfb6fc3
--- a/bfd/elf-eh-frame.c
+++ b/bfd/elf-eh-frame.c
@@ -1,3 +1,6 @@
+#ifdef FRCOV
+extern short FIXREVERTER[];
+#endif
 /* .eh_frame section optimization.
    Copyright (C) 2001-2021 Free Software Foundation, Inc.
    Written by Jakub Jelinek <jakub@redhat.com>.
@@ -601,12 +604,26 @@ _bfd_elf_parse_eh_frame (bfd *abfd, struct bfd_link_info *info,
   htab = elf_hash_table (info);
   hdr_info = &htab->eh_info;
 
-  if (sec->size == 0
-      || sec->sec_info_type != SEC_INFO_TYPE_NONE)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[6178]) {
+    if ((sec -> size == 0 || sec -> sec_info_type != 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 6178\n");
+    else
+      fprintf(stderr, "reached bug index 6178\n");
+  }
+  if ((!FIXREVERTER[6178] && (sec -> size == 0 || sec -> sec_info_type != 0 ))
+  #else
+  if (0
+  #endif
+  )
     {
       /* This file does not contain .eh_frame information.  */
       return;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
   if (bfd_is_abs_section (sec->output_section))
     {
@@ -643,8 +660,23 @@ _bfd_elf_parse_eh_frame (bfd *abfd, struct bfd_link_info *info,
 
       /* 64-bit .eh_frame is not supported.  */
       REQUIRE (hdr_length != 0xffffffff);
-      if (hdr_length == 0)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[6179]) {
+        if ((hdr_length == 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 6179\n");
+        else
+          fprintf(stderr, "reached bug index 6179\n");
+      }
+      if ((!FIXREVERTER[6179] && (hdr_length == 0 ))
+      #else
+      if (0
+      #endif
+      )
 	break;
+	#ifdef FRCOV
+	}
+	#endif
 
       REQUIRE (skip_bytes (&buf, end, 4));
       hdr_id = bfd_get_32 (abfd, buf - 4);
@@ -2264,14 +2296,74 @@ vma_compare (const void *a, const void *b)
 {
   const struct eh_frame_array_ent *p = (const struct eh_frame_array_ent *) a;
   const struct eh_frame_array_ent *q = (const struct eh_frame_array_ent *) b;
-  if (p->initial_loc > q->initial_loc)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[6192]) {
+    if ((p -> initial_loc > q -> initial_loc ) && !(0))
+      fprintf(stderr, "triggered bug index 6192\n");
+    else
+      fprintf(stderr, "reached bug index 6192\n");
+  }
+  if ((!FIXREVERTER[6192] && (p -> initial_loc > q -> initial_loc ))
+  #else
+  if (0
+  #endif
+  )
     return 1;
-  if (p->initial_loc < q->initial_loc)
+    #ifdef FRCOV
+    }
+    #endif
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[6193]) {
+    if ((p -> initial_loc < q -> initial_loc ) && !(0))
+      fprintf(stderr, "triggered bug index 6193\n");
+    else
+      fprintf(stderr, "reached bug index 6193\n");
+  }
+  if ((!FIXREVERTER[6193] && (p -> initial_loc < q -> initial_loc ))
+  #else
+  if (0
+  #endif
+  )
     return -1;
-  if (p->range > q->range)
+    #ifdef FRCOV
+    }
+    #endif
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[6194]) {
+    if ((p -> range > q -> range ) && !(0))
+      fprintf(stderr, "triggered bug index 6194\n");
+    else
+      fprintf(stderr, "reached bug index 6194\n");
+  }
+  if ((!FIXREVERTER[6194] && (p -> range > q -> range ))
+  #else
+  if (0
+  #endif
+  )
     return 1;
-  if (p->range < q->range)
+    #ifdef FRCOV
+    }
+    #endif
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[6195]) {
+    if ((p -> range < q -> range ) && !(0))
+      fprintf(stderr, "triggered bug index 6195\n");
+    else
+      fprintf(stderr, "reached bug index 6195\n");
+  }
+  if ((!FIXREVERTER[6195] && (p -> range < q -> range ))
+  #else
+  if (0
+  #endif
+  )
     return -1;
+    #ifdef FRCOV
+    }
+    #endif
   return 0;
 }
 
@@ -2419,15 +2511,45 @@ write_dwarf_eh_frame_hdr (bfd *abfd, struct bfd_link_info *info)
       && hdr_info->array_count == hdr_info->u.dwarf.fde_count)
     size += 4 + hdr_info->u.dwarf.fde_count * 8;
   contents = (bfd_byte *) bfd_malloc (size);
-  if (contents == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[6197]) {
+    if ((contents == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 6197\n");
+    else
+      fprintf(stderr, "reached bug index 6197\n");
+  }
+  if ((!FIXREVERTER[6197] && (contents == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     return false;
+    #ifdef FRCOV
+    }
+    #endif
 
   eh_frame_sec = bfd_get_section_by_name (abfd, ".eh_frame");
-  if (eh_frame_sec == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[6198]) {
+    if ((eh_frame_sec == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 6198\n");
+    else
+      fprintf(stderr, "reached bug index 6198\n");
+  }
+  if ((!FIXREVERTER[6198] && (eh_frame_sec == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     {
       free (contents);
       return false;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
   memset (contents, 0, EH_FRAME_HDR_SIZE);
   /* Version.  */
diff --git a/bfd/elf-hppa.h b/bfd/elf-hppa.h
old mode 100644
new mode 100755
diff --git a/bfd/elf-ifunc.c b/bfd/elf-ifunc.c
old mode 100644
new mode 100755
diff --git a/bfd/elf-linker-x86.h b/bfd/elf-linker-x86.h
old mode 100644
new mode 100755
diff --git a/bfd/elf-linux-core.h b/bfd/elf-linux-core.h
old mode 100644
new mode 100755
diff --git a/bfd/elf-m10200.c b/bfd/elf-m10200.c
old mode 100644
new mode 100755
diff --git a/bfd/elf-m10300.c b/bfd/elf-m10300.c
old mode 100644
new mode 100755
diff --git a/bfd/elf-nacl.c b/bfd/elf-nacl.c
old mode 100644
new mode 100755
diff --git a/bfd/elf-nacl.h b/bfd/elf-nacl.h
old mode 100644
new mode 100755
diff --git a/bfd/elf-properties.c b/bfd/elf-properties.c
old mode 100644
new mode 100755
diff --git a/bfd/elf-s390-common.c b/bfd/elf-s390-common.c
old mode 100644
new mode 100755
diff --git a/bfd/elf-s390.h b/bfd/elf-s390.h
old mode 100644
new mode 100755
diff --git a/bfd/elf-strtab.c b/bfd/elf-strtab.c
old mode 100644
new mode 100755
index 39eab6b..cd110f0
--- a/bfd/elf-strtab.c
+++ b/bfd/elf-strtab.c
@@ -1,3 +1,6 @@
+#ifdef FRCOV
+extern short FIXREVERTER[];
+#endif
 /* ELF strtab with GC and suffix merging support.
    Copyright (C) 2001-2021 Free Software Foundation, Inc.
    Written by Jakub Jelinek <jakub@redhat.com>.
@@ -66,11 +69,41 @@ elf_strtab_hash_newfunc (struct bfd_hash_entry *entry,
 {
   /* Allocate the structure if it has not already been allocated by a
      subclass.  */
-  if (entry == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[2437]) {
+    if ((entry == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 2437\n");
+    else
+      fprintf(stderr, "reached bug index 2437\n");
+  }
+  if ((!FIXREVERTER[2437] && (entry == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     entry = (struct bfd_hash_entry *)
 	bfd_hash_allocate (table, sizeof (struct elf_strtab_hash_entry));
-  if (entry == NULL)
+	#ifdef FRCOV
+	}
+	#endif
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[2438]) {
+    if ((entry == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 2438\n");
+    else
+      fprintf(stderr, "reached bug index 2438\n");
+  }
+  if ((!FIXREVERTER[2438] && (entry == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     return NULL;
+    #ifdef FRCOV
+    }
+    #endif
 
   /* Call the allocation method of the superclass.  */
   entry = bfd_hash_newfunc (entry, table, string);
@@ -98,8 +131,23 @@ _bfd_elf_strtab_init (void)
   size_t amt = sizeof (struct elf_strtab_hash);
 
   table = (struct elf_strtab_hash *) bfd_malloc (amt);
-  if (table == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[2439]) {
+    if ((table == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 2439\n");
+    else
+      fprintf(stderr, "reached bug index 2439\n");
+  }
+  if ((!FIXREVERTER[2439] && (table == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     return NULL;
+    #ifdef FRCOV
+    }
+    #endif
 
   if (!bfd_hash_table_init (&table->table, elf_strtab_hash_newfunc,
 			    sizeof (struct elf_strtab_hash_entry)))
@@ -114,11 +162,26 @@ _bfd_elf_strtab_init (void)
   amt = sizeof (struct elf_strtab_hasn_entry *);
   table->array = ((struct elf_strtab_hash_entry **)
 		  bfd_malloc (table->alloced * amt));
-  if (table->array == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[2440]) {
+    if ((table -> array == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 2440\n");
+    else
+      fprintf(stderr, "reached bug index 2440\n");
+  }
+  if ((!FIXREVERTER[2440] && (table -> array == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     {
       free (table);
       return NULL;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
   table->array[0] = NULL;
 
@@ -154,8 +217,23 @@ _bfd_elf_strtab_add (struct elf_strtab_hash *tab,
   entry = (struct elf_strtab_hash_entry *)
 	  bfd_hash_lookup (&tab->table, str, true, copy);
 
-  if (entry == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[2441]) {
+    if ((entry == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 2441\n");
+    else
+      fprintf(stderr, "reached bug index 2441\n");
+  }
+  if ((!FIXREVERTER[2441] && (entry == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     return (size_t) -1;
+    #ifdef FRCOV
+    }
+    #endif
 
   entry->refcount++;
   if (entry->len == 0)
@@ -169,8 +247,23 @@ _bfd_elf_strtab_add (struct elf_strtab_hash *tab,
 	  tab->alloced *= 2;
 	  tab->array = (struct elf_strtab_hash_entry **)
 	      bfd_realloc_or_free (tab->array, tab->alloced * amt);
-	  if (tab->array == NULL)
+	  
+	  #ifdef FRCOV
+	  {if (FIXREVERTER[2442]) {
+	    if ((tab -> array == (void *) 0 ) && !(0))
+	      fprintf(stderr, "triggered bug index 2442\n");
+	    else
+	      fprintf(stderr, "reached bug index 2442\n");
+	  }
+	  if ((!FIXREVERTER[2442] && (tab -> array == (void *) 0 ))
+	  #else
+	  if (0
+	  #endif
+	  )
 	    return (size_t) -1;
+	    #ifdef FRCOV
+	    }
+	    #endif
 	}
 
       entry->u.index = tab->size++;
@@ -250,8 +343,23 @@ _bfd_elf_strtab_restore (struct elf_strtab_hash *tab, void *buf)
 
   BFD_ASSERT (tab->sec_size == 0);
   save_size = 1;
-  if (save != NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[2444]) {
+    if ((save != (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 2444\n");
+    else
+      fprintf(stderr, "reached bug index 2444\n");
+  }
+  if ((!FIXREVERTER[2444] && (save != (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     save_size = save->size;
+    #ifdef FRCOV
+    }
+    #endif
   BFD_ASSERT (save_size <= curr_size);
   tab->size = save_size;
   for (idx = 1; idx < save_size; ++idx)
@@ -284,8 +392,23 @@ _bfd_elf_strtab_offset (struct elf_strtab_hash *tab, size_t idx)
 {
   struct elf_strtab_hash_entry *entry;
 
-  if (idx == 0)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[2445]) {
+    if ((idx == 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 2445\n");
+    else
+      fprintf(stderr, "reached bug index 2445\n");
+  }
+  if ((!FIXREVERTER[2445] && (idx == 0 ))
+  #else
+  if (0
+  #endif
+  )
     return 0;
+    #ifdef FRCOV
+    }
+    #endif
   BFD_ASSERT (idx < tab->size);
   BFD_ASSERT (tab->sec_size);
   entry = tab->array[idx];
@@ -369,10 +492,25 @@ static inline int
 is_suffix (const struct elf_strtab_hash_entry *A,
 	   const struct elf_strtab_hash_entry *B)
 {
-  if (A->len <= B->len)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[2447]) {
+    if ((A -> len <= B -> len ) && !(0))
+      fprintf(stderr, "triggered bug index 2447\n");
+    else
+      fprintf(stderr, "reached bug index 2447\n");
+  }
+  if ((!FIXREVERTER[2447] && (A -> len <= B -> len ))
+  #else
+  if (0
+  #endif
+  )
     /* B cannot be a suffix of A unless A is equal to B, which is guaranteed
        not to be equal by the hash table.  */
     return 0;
+    #ifdef FRCOV
+    }
+    #endif
 
   return memcmp (A->root.string + (A->len - B->len),
 		 B->root.string, B->len - 1) == 0;
@@ -392,8 +530,23 @@ _bfd_elf_strtab_finalize (struct elf_strtab_hash *tab)
   amt = tab->size;
   amt *= sizeof (struct elf_strtab_hash_entry *);
   array = (struct elf_strtab_hash_entry **) bfd_malloc (amt);
-  if (array == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[2448]) {
+    if ((array == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 2448\n");
+    else
+      fprintf(stderr, "reached bug index 2448\n");
+  }
+  if ((!FIXREVERTER[2448] && (array == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     goto alloc_failure;
+    #ifdef FRCOV
+    }
+    #endif
 
   for (i = 1, a = array; i < tab->size; ++i)
     {
diff --git a/bfd/elf-vxworks.c b/bfd/elf-vxworks.c
old mode 100644
new mode 100755
diff --git a/bfd/elf-vxworks.h b/bfd/elf-vxworks.h
old mode 100644
new mode 100755
diff --git a/bfd/elf.c b/bfd/elf.c
old mode 100644
new mode 100755
index 8ed1623..93ec884
--- a/bfd/elf.c
+++ b/bfd/elf.c
@@ -1,3 +1,6 @@
+#ifdef FRCOV
+extern short FIXREVERTER[];
+#endif
 /* ELF executable support for BFD.
 
    Copyright (C) 1993-2021 Free Software Foundation, Inc.
@@ -320,8 +323,23 @@ bfd_elf_string_from_elf_section (bfd *abfd,
 {
   Elf_Internal_Shdr *hdr;
 
-  if (strindex == 0)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[5448]) {
+    if ((strindex == 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 5448\n");
+    else
+      fprintf(stderr, "reached bug index 5448\n");
+  }
+  if ((!FIXREVERTER[5448] && (strindex == 0 ))
+  #else
+  if (0
+  #endif
+  )
     return "";
+    #ifdef FRCOV
+    }
+    #endif
 
   if (elf_elfsections (abfd) == NULL || shindex >= elf_numsections (abfd))
     return NULL;
@@ -354,7 +372,19 @@ bfd_elf_string_from_elf_section (bfd *abfd,
 	return NULL;
     }
 
-  if (strindex >= hdr->sh_size)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[5449]) {
+    if ((strindex >= hdr -> sh_size ) && !(0))
+      fprintf(stderr, "triggered bug index 5449\n");
+    else
+      fprintf(stderr, "reached bug index 5449\n");
+  }
+  if ((!FIXREVERTER[5449] && (strindex >= hdr -> sh_size ))
+  #else
+  if (0
+  #endif
+  )
     {
       unsigned int shstrndx = elf_elfheader(abfd)->e_shstrndx;
       _bfd_error_handler
@@ -366,6 +396,9 @@ bfd_elf_string_from_elf_section (bfd *abfd,
 	  : bfd_elf_string_from_elf_section (abfd, shstrndx, hdr->sh_name)));
       return NULL;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
   return ((char *) hdr->contents) + strindex;
 }
@@ -403,8 +436,23 @@ bfd_elf_get_elf_syms (bfd *ibfd,
   if (bfd_get_flavour (ibfd) != bfd_target_elf_flavour)
     abort ();
 
-  if (symcount == 0)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[5450]) {
+    if ((symcount == 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 5450\n");
+    else
+      fprintf(stderr, "reached bug index 5450\n");
+  }
+  if ((!FIXREVERTER[5450] && (symcount == 0 ))
+  #else
+  if (0
+  #endif
+  )
     return intsym_buf;
+    #ifdef FRCOV
+    }
+    #endif
 
   /* Normal syms might have section extension entries.  */
   shndx_hdr = NULL;
@@ -497,8 +545,23 @@ bfd_elf_get_elf_syms (bfd *ibfd,
 	}
       alloc_intsym = (Elf_Internal_Sym *) bfd_malloc (amt);
       intsym_buf = alloc_intsym;
-      if (intsym_buf == NULL)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[5451]) {
+        if ((intsym_buf == (void *) 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 5451\n");
+        else
+          fprintf(stderr, "reached bug index 5451\n");
+      }
+      if ((!FIXREVERTER[5451] && (intsym_buf == (void *) 0 ))
+      #else
+      if (0
+      #endif
+      )
 	goto out;
+	#ifdef FRCOV
+	}
+	#endif
     }
 
   /* Convert the symbols to internal form.  */
@@ -758,8 +821,23 @@ setup_group (bfd *abfd, Elf_Internal_Shdr *hdr, asection *newsect)
 	  Elf_Internal_Group *idx;
 	  bfd_size_type n_elt;
 
-	  if (shdr == NULL)
+	  
+	  #ifdef FRCOV
+	  {if (FIXREVERTER[5453]) {
+	    if ((shdr == (void *) 0 ) && !(0))
+	      fprintf(stderr, "triggered bug index 5453\n");
+	    else
+	      fprintf(stderr, "reached bug index 5453\n");
+	  }
+	  if ((!FIXREVERTER[5453] && (shdr == (void *) 0 ))
+	  #else
+	  if (0
+	  #endif
+	  )
 	    continue;
+	    #ifdef FRCOV
+	    }
+	    #endif
 
 	  idx = (Elf_Internal_Group *) shdr->contents;
 	  if (idx == NULL || shdr->sh_size < 4)
@@ -804,8 +882,23 @@ setup_group (bfd *abfd, Elf_Internal_Shdr *hdr, asection *newsect)
 		    const char *gname;
 
 		    gname = group_signature (abfd, shdr);
-		    if (gname == NULL)
+		    
+		    #ifdef FRCOV
+		    {if (FIXREVERTER[5454]) {
+		      if ((gname == (void *) 0 ) && !(0))
+		        fprintf(stderr, "triggered bug index 5454\n");
+		      else
+		        fprintf(stderr, "reached bug index 5454\n");
+		    }
+		    if ((!FIXREVERTER[5454] && (gname == (void *) 0 ))
+		    #else
+		    if (0
+		    #endif
+		    )
 		      return false;
+		      #ifdef FRCOV
+		      }
+		      #endif
 		    elf_group_name (newsect) = gname;
 
 		    /* Start a circular list with one element.  */
@@ -967,8 +1060,23 @@ convert_debug_to_zdebug (bfd *abfd, const char *name)
 {
   unsigned int len = strlen (name);
   char *new_name = bfd_alloc (abfd, len + 2);
-  if (new_name == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[5455]) {
+    if ((new_name == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 5455\n");
+    else
+      fprintf(stderr, "reached bug index 5455\n");
+  }
+  if ((!FIXREVERTER[5455] && (new_name == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     return NULL;
+    #ifdef FRCOV
+    }
+    #endif
   new_name[0] = '.';
   new_name[1] = 'z';
   memcpy (new_name + 2, name + 1, len);
@@ -980,8 +1088,23 @@ convert_zdebug_to_debug (bfd *abfd, const char *name)
 {
   unsigned int len = strlen (name);
   char *new_name = bfd_alloc (abfd, len);
-  if (new_name == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[5457]) {
+    if ((new_name == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 5457\n");
+    else
+      fprintf(stderr, "reached bug index 5457\n");
+  }
+  if ((!FIXREVERTER[5457] && (new_name == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     return NULL;
+    #ifdef FRCOV
+    }
+    #endif
   new_name[0] = '.';
   memcpy (new_name + 1, name + 2, len - 1);
   return new_name;
@@ -1352,9 +1475,23 @@ section_match (const Elf_Internal_Shdr * a,
       || a->sh_addralign != b->sh_addralign
       || a->sh_entsize != b->sh_entsize)
     return false;
-  if (a->sh_type == SHT_SYMTAB
-      || a->sh_type == SHT_STRTAB)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[5459]) {
+    if ((a -> sh_type == 2 || a -> sh_type == 3 ) && !(0))
+      fprintf(stderr, "triggered bug index 5459\n");
+    else
+      fprintf(stderr, "reached bug index 5459\n");
+  }
+  if ((!FIXREVERTER[5459] && (a -> sh_type == 2 || a -> sh_type == 3 ))
+  #else
+  if (0
+  #endif
+  )
     return true;
+    #ifdef FRCOV
+    }
+    #endif
   return a->sh_size == b->sh_size;
 }
 
@@ -1382,8 +1519,23 @@ find_link (const bfd *obfd, const Elf_Internal_Shdr *iheader,
     {
       Elf_Internal_Shdr * oheader = oheaders[i];
 
-      if (oheader == NULL)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[5460]) {
+        if ((oheader == (void *) 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 5460\n");
+        else
+          fprintf(stderr, "reached bug index 5460\n");
+      }
+      if ((!FIXREVERTER[5460] && (oheader == (void *) 0 ))
+      #else
+      if (0
+      #endif
+      )
 	continue;
+	#ifdef FRCOV
+	}
+	#endif
       if (section_match (oheader, iheader))
 	/* FIXME: Do we care if there is a potential for
 	   multiple matches ?  */
@@ -1409,7 +1561,19 @@ copy_special_section_fields (const bfd *ibfd,
   bool changed = false;
   unsigned int sh_link;
 
-  if (oheader->sh_type == SHT_NOBITS)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[5463]) {
+    if ((oheader -> sh_type == 8 ) && !(0))
+      fprintf(stderr, "triggered bug index 5463\n");
+    else
+      fprintf(stderr, "reached bug index 5463\n");
+  }
+  if ((!FIXREVERTER[5463] && (oheader -> sh_type == 8 ))
+  #else
+  if (0
+  #endif
+  )
     {
       /* This is a feature for objcopy --only-keep-debug:
 	 When a section's type is changed to NOBITS, we preserve
@@ -1427,12 +1591,45 @@ copy_special_section_fields (const bfd *ibfd,
 	 creating an invalid ELF file, but it is only for a file
 	 that just contains debug info and only for sections
 	 without any contents.  */
-      if (oheader->sh_link == 0)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[5461]) {
+        if ((oheader -> sh_link == 0  ) && !(0))
+          fprintf(stderr, "triggered bug index 5461\n");
+        else
+          fprintf(stderr, "reached bug index 5461\n");
+      }
+      if ((!FIXREVERTER[5461] && (oheader -> sh_link == 0  ))
+      #else
+      if (0
+      #endif
+      )
 	oheader->sh_link = iheader->sh_link;
-      if (oheader->sh_info == 0)
+	#ifdef FRCOV
+	}
+	#endif
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[5462]) {
+        if ((oheader -> sh_info == 0  ) && !(0))
+          fprintf(stderr, "triggered bug index 5462\n");
+        else
+          fprintf(stderr, "reached bug index 5462\n");
+      }
+      if ((!FIXREVERTER[5462] && (oheader -> sh_info == 0  ))
+      #else
+      if (0
+      #endif
+      )
 	oheader->sh_info = iheader->sh_info;
+	#ifdef FRCOV
+	}
+	#endif
       return true;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
   /* Allow the target a chance to decide how these fields should be set.  */
   if (bed->elf_backend_copy_special_section_fields (ibfd, obfd,
@@ -3110,8 +3307,23 @@ _bfd_elf_set_reloc_sh_name (bfd *abfd,
 {
   char *name = (char *) bfd_alloc (abfd,
 				   sizeof ".rela" + strlen (sec_name));
-  if (name == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[5485]) {
+    if ((name == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 5485\n");
+    else
+      fprintf(stderr, "reached bug index 5485\n");
+  }
+  if ((!FIXREVERTER[5485] && (name == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     return false;
+    #ifdef FRCOV
+    }
+    #endif
 
   sprintf (name, "%s%s", use_rela_p ? ".rela" : ".rel", sec_name);
   rel_hdr->sh_name =
@@ -3228,11 +3440,26 @@ elf_fake_sections (bfd *abfd, asection *asect, void *fsarg)
 	  if (name[1] == 'z')
 	    {
 	      char *new_name = convert_zdebug_to_debug (abfd, name);
-	      if (new_name == NULL)
+	      
+	      #ifdef FRCOV
+	      {if (FIXREVERTER[5486]) {
+	        if ((new_name == (void *) 0 ) && !(0))
+	          fprintf(stderr, "triggered bug index 5486\n");
+	        else
+	          fprintf(stderr, "reached bug index 5486\n");
+	      }
+	      if ((!FIXREVERTER[5486] && (new_name == (void *) 0 ))
+	      #else
+	      if (0
+	      #endif
+	      )
 		{
 		  arg->failed = true;
 		  return;
 		}
+		#ifdef FRCOV
+		}
+		#endif
 	      name = new_name;
 	    }
 	}
@@ -3243,11 +3470,26 @@ elf_fake_sections (bfd *abfd, asection *asect, void *fsarg)
 	     compression has actually taken place.  If input section
 	     name is .zdebug_*, we should never compress it again.  */
 	  char *new_name = convert_debug_to_zdebug (abfd, name);
-	  if (new_name == NULL)
+	  
+	  #ifdef FRCOV
+	  {if (FIXREVERTER[5487]) {
+	    if ((new_name == (void *) 0 ) && !(0))
+	      fprintf(stderr, "triggered bug index 5487\n");
+	    else
+	      fprintf(stderr, "reached bug index 5487\n");
+	  }
+	  if ((!FIXREVERTER[5487] && (new_name == (void *) 0 ))
+	  #else
+	  if (0
+	  #endif
+	  )
 	    {
 	      arg->failed = true;
 	      return;
 	    }
+	    #ifdef FRCOV
+	    }
+	    #endif
 	  BFD_ASSERT (name[1] != 'z');
 	  name = new_name;
 	}
@@ -3423,8 +3665,23 @@ elf_fake_sections (bfd *abfd, asection *asect, void *fsarg)
 	  if (o != NULL)
 	    {
 	      this_hdr->sh_size = o->offset + o->size;
-	      if (this_hdr->sh_size != 0)
+	      
+	      #ifdef FRCOV
+	      {if (FIXREVERTER[5488]) {
+	        if ((this_hdr -> sh_size != 0  ) && !(0))
+	          fprintf(stderr, "triggered bug index 5488\n");
+	        else
+	          fprintf(stderr, "reached bug index 5488\n");
+	      }
+	      if ((!FIXREVERTER[5488] && (this_hdr -> sh_size != 0  ))
+	      #else
+	      if (0
+	      #endif
+	      )
 		this_hdr->sh_type = SHT_NOBITS;
+		#ifdef FRCOV
+		}
+		#endif
 	    }
 	}
     }
@@ -3481,12 +3738,30 @@ elf_fake_sections (bfd *abfd, asection *asect, void *fsarg)
       return;
     }
 
-  if (sh_type == SHT_NOBITS && asect->size != 0)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[5489]) {
+    fprintf(stderr, "reached bug index 5489\n");
+  }
+  if ((FIXREVERTER[5489] && (sh_type == 8 )) || (!FIXREVERTER[5489] && (sh_type == 8 && asect -> size != 0 ))
+  #else
+  if (sh_type == 8 
+  #endif
+  )
     {
+      
+    #ifdef FRCOV
+      if (!(asect -> size != 0 ))
+        fprintf(stderr, "triggered bug index 5489\n");
+      #endif
+    
       /* Don't change the header type from NOBITS if we are being
 	 called for objcopy --only-keep-debug.  */
       this_hdr->sh_type = sh_type;
     }
+    #ifdef FRCOV
+    }
+    #endif
 }
 
 /* Fill in the contents of a SHT_GROUP section.  Called from
@@ -3574,11 +3849,26 @@ bfd_elf_set_group_contents (bfd *abfd, asection *sec, void *failedptrarg)
 
       /* Arrange for the section to be written out.  */
       elf_section_data (sec)->this_hdr.contents = sec->contents;
-      if (sec->contents == NULL)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[5490]) {
+        if ((sec -> contents == (void *) 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 5490\n");
+        else
+          fprintf(stderr, "reached bug index 5490\n");
+      }
+      if ((!FIXREVERTER[5490] && (sec -> contents == (void *) 0 ))
+      #else
+      if (0
+      #endif
+      )
 	{
 	  *failedptr = true;
 	  return;
 	}
+	#ifdef FRCOV
+	}
+	#endif
     }
 
   loc = sec->contents + sec->size;
@@ -3812,8 +4102,23 @@ assign_section_numbers (bfd *abfd, struct bfd_link_info *link_info)
      indices.  */
   amt = section_number * sizeof (Elf_Internal_Shdr *);
   i_shdrp = (Elf_Internal_Shdr **) bfd_zalloc (abfd, amt);
-  if (i_shdrp == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[5491]) {
+    if ((i_shdrp == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 5491\n");
+    else
+      fprintf(stderr, "reached bug index 5491\n");
+  }
+  if ((!FIXREVERTER[5491] && (i_shdrp == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     return false;
+    #ifdef FRCOV
+    }
+    #endif
 
   i_shdrp[0] = (Elf_Internal_Shdr *) bfd_zalloc (abfd,
 						 sizeof (Elf_Internal_Shdr));
@@ -3892,15 +4197,42 @@ assign_section_numbers (bfd *abfd, struct bfd_link_info *link_info)
 		  /* Point to the kept section if it has the same
 		     size as the discarded one.  */
 		  kept = _bfd_elf_check_kept_section (s, link_info);
-		  if (kept == NULL)
+		  
+		  #ifdef FRCOV
+		  {if (FIXREVERTER[5492]) {
+		    if ((kept == (void *) 0 ) && !(0))
+		      fprintf(stderr, "triggered bug index 5492\n");
+		    else
+		      fprintf(stderr, "reached bug index 5492\n");
+		  }
+		  if ((!FIXREVERTER[5492] && (kept == (void *) 0 ))
+		  #else
+		  if (0
+		  #endif
+		  )
 		    {
 		      bfd_set_error (bfd_error_bad_value);
 		      return false;
 		    }
+		    #ifdef FRCOV
+		    }
+		    #endif
 		  s = kept;
 		}
 	      /* Handle objcopy. */
-	      else if (s->output_section == NULL)
+	      else 
+	      #ifdef FRCOV
+	      {if (FIXREVERTER[5493]) {
+	        if ((s -> output_section == (void *) 0 ) && !(0))
+	          fprintf(stderr, "triggered bug index 5493\n");
+	        else
+	          fprintf(stderr, "reached bug index 5493\n");
+	      }
+	      if ((!FIXREVERTER[5493] && (s -> output_section == (void *) 0 ))
+	      #else
+	      if (0
+	      #endif
+	      )
 		{
 		  _bfd_error_handler
 		    /* xgettext:c-format */
@@ -3910,6 +4242,9 @@ assign_section_numbers (bfd *abfd, struct bfd_link_info *link_info)
 		  bfd_set_error (bfd_error_bad_value);
 		  return false;
 		}
+		#ifdef FRCOV
+		}
+		#endif
 	      s = s->output_section;
 	      d->this_hdr.sh_link = elf_section_data (s)->this_idx;
 	    }
@@ -3950,8 +4285,23 @@ assign_section_numbers (bfd *abfd, struct bfd_link_info *link_info)
 
 	      len = strlen (sec->name);
 	      alc = (char *) bfd_malloc (len - 2);
-	      if (alc == NULL)
+	      
+	      #ifdef FRCOV
+	      {if (FIXREVERTER[5494]) {
+	        if ((alc == (void *) 0 ) && !(0))
+	          fprintf(stderr, "triggered bug index 5494\n");
+	        else
+	          fprintf(stderr, "reached bug index 5494\n");
+	      }
+	      if ((!FIXREVERTER[5494] && (alc == (void *) 0 ))
+	      #else
+	      if (0
+	      #endif
+	      )
 		return false;
+		#ifdef FRCOV
+		}
+		#endif
 	      memcpy (alc, sec->name, len - 3);
 	      alc[len - 3] = '\0';
 	      s = bfd_get_section_by_name (abfd, alc);
@@ -4046,8 +4396,23 @@ _bfd_elf_filter_global_symbols (bfd *abfd, struct bfd_link_info *info,
 	continue;
 
       h = bfd_link_hash_lookup (info->hash, name, false, false, false);
-      if (h == NULL)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[5496]) {
+        if ((h == (void *) 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 5496\n");
+        else
+          fprintf(stderr, "reached bug index 5496\n");
+      }
+      if ((!FIXREVERTER[5496] && (h == (void *) 0 ))
+      #else
+      if (0
+      #endif
+      )
 	continue;
+	#ifdef FRCOV
+	}
+	#endif
       if (h->type != bfd_link_hash_defined && h->type != bfd_link_hash_defweak)
 	continue;
       if (h->linker_def || h->ldscript_def)
@@ -4069,8 +4434,23 @@ ignore_section_sym (bfd *abfd, asymbol *sym)
 {
   elf_symbol_type *type_ptr;
 
-  if (sym == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[5497]) {
+    if ((sym == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 5497\n");
+    else
+      fprintf(stderr, "reached bug index 5497\n");
+  }
+  if ((!FIXREVERTER[5497] && (sym == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     return false;
+    #ifdef FRCOV
+    }
+    #endif
 
   if ((sym->flags & BSF_SECTION_SYM) == 0)
     return false;
@@ -4079,8 +4459,23 @@ ignore_section_sym (bfd *abfd, asymbol *sym)
   if ((sym->flags & BSF_SECTION_SYM_USED) == 0)
     return true;
 
-  if (sym->section == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[5498]) {
+    if ((sym -> section == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 5498\n");
+    else
+      fprintf(stderr, "reached bug index 5498\n");
+  }
+  if ((!FIXREVERTER[5498] && (sym -> section == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     return true;
+    #ifdef FRCOV
+    }
+    #endif
 
   type_ptr = elf_symbol_from (sym);
   return ((type_ptr != NULL
@@ -4119,15 +4514,45 @@ elf_map_symbols (bfd *abfd, unsigned int *pnum_locals)
 
   for (asect = abfd->sections; asect; asect = asect->next)
     {
-      if (max_index < asect->index)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[5499]) {
+        if ((max_index < asect -> index ) && !(0))
+          fprintf(stderr, "triggered bug index 5499\n");
+        else
+          fprintf(stderr, "reached bug index 5499\n");
+      }
+      if ((!FIXREVERTER[5499] && (max_index < asect -> index ))
+      #else
+      if (0
+      #endif
+      )
 	max_index = asect->index;
+	#ifdef FRCOV
+	}
+	#endif
     }
 
   max_index++;
   amt = max_index * sizeof (asymbol *);
   sect_syms = (asymbol **) bfd_zalloc (abfd, amt);
-  if (sect_syms == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[5500]) {
+    if ((sect_syms == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 5500\n");
+    else
+      fprintf(stderr, "reached bug index 5500\n");
+  }
+  if ((!FIXREVERTER[5500] && (sect_syms == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     return false;
+    #ifdef FRCOV
+    }
+    #endif
   elf_section_syms (abfd) = sect_syms;
   elf_num_section_syms (abfd) = max_index;
 
@@ -4144,8 +4569,23 @@ elf_map_symbols (bfd *abfd, unsigned int *pnum_locals)
 	{
 	  asection *sec = sym->section;
 
-	  if (sec->owner != abfd)
+	  
+	  #ifdef FRCOV
+	  {if (FIXREVERTER[5501]) {
+	    if ((sec -> owner != abfd ) && !(0))
+	      fprintf(stderr, "triggered bug index 5501\n");
+	    else
+	      fprintf(stderr, "reached bug index 5501\n");
+	  }
+	  if ((!FIXREVERTER[5501] && (sec -> owner != abfd ))
+	  #else
+	  if (0
+	  #endif
+	  )
 	    sec = sec->output_section;
+	    #ifdef FRCOV
+	    }
+	    #endif
 
 	  sect_syms[sec->index] = syms[idx];
 	}
@@ -4181,8 +4621,23 @@ elf_map_symbols (bfd *abfd, unsigned int *pnum_locals)
   /* Now sort the symbols so the local symbols are first.  */
   amt = (num_locals + num_globals) * sizeof (asymbol *);
   new_syms = (asymbol **) bfd_alloc (abfd, amt);
-  if (new_syms == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[5502]) {
+    if ((new_syms == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 5502\n");
+    else
+      fprintf(stderr, "reached bug index 5502\n");
+  }
+  if ((!FIXREVERTER[5502] && (new_syms == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     return false;
+    #ifdef FRCOV
+    }
+    #endif
 
   for (idx = 0; idx < symcount; idx++)
     {
@@ -4472,8 +4927,23 @@ get_program_header_size (bfd *abfd, struct bfd_link_info *info)
 		continue;
 	      }
 	    /* Align mbind section to page size.  */
-	    if (s->alignment_power < page_align_power)
+	    
+	    #ifdef FRCOV
+	    {if (FIXREVERTER[5503]) {
+	      if ((s -> alignment_power < page_align_power  ) && !(0))
+	        fprintf(stderr, "triggered bug index 5503\n");
+	      else
+	        fprintf(stderr, "reached bug index 5503\n");
+	    }
+	    if ((!FIXREVERTER[5503] && (s -> alignment_power < page_align_power  ))
+	    #else
+	    if (0
+	    #endif
+	    )
 	      s->alignment_power = page_align_power;
+	      #ifdef FRCOV
+	      }
+	      #endif
 	    segs ++;
 	  }
     }
@@ -4531,8 +5001,23 @@ make_mapping (bfd *abfd,
   amt = sizeof (struct elf_segment_map) - sizeof (asection *);
   amt += (to - from) * sizeof (asection *);
   m = (struct elf_segment_map *) bfd_zalloc (abfd, amt);
-  if (m == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[5504]) {
+    if ((m == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 5504\n");
+    else
+      fprintf(stderr, "reached bug index 5504\n");
+  }
+  if ((!FIXREVERTER[5504] && (m == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     return NULL;
+    #ifdef FRCOV
+    }
+    #endif
   m->next = NULL;
   m->p_type = PT_LOAD;
   for (i = from, hdrpp = sections + from; i < to; i++, hdrpp++)
@@ -4559,8 +5044,23 @@ _bfd_elf_make_dynamic_segment (bfd *abfd, asection *dynsec)
 
   m = (struct elf_segment_map *) bfd_zalloc (abfd,
 					     sizeof (struct elf_segment_map));
-  if (m == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[5505]) {
+    if ((m == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 5505\n");
+    else
+      fprintf(stderr, "reached bug index 5505\n");
+  }
+  if ((!FIXREVERTER[5505] && (m == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     return NULL;
+    #ifdef FRCOV
+    }
+    #endif
   m->next = NULL;
   m->p_type = PT_DYNAMIC;
   m->count = 1;
@@ -5242,15 +5742,45 @@ elf_sort_sections (const void *arg1, const void *arg2)
      place the section into a segment.  */
   if (sec1->lma < sec2->lma)
     return -1;
-  else if (sec1->lma > sec2->lma)
+  else 
+  #ifdef FRCOV
+  {if (FIXREVERTER[5506]) {
+    if ((sec1 -> lma > sec2 -> lma ) && !(0))
+      fprintf(stderr, "triggered bug index 5506\n");
+    else
+      fprintf(stderr, "reached bug index 5506\n");
+  }
+  if ((!FIXREVERTER[5506] && (sec1 -> lma > sec2 -> lma ))
+  #else
+  if (0
+  #endif
+  )
     return 1;
+    #ifdef FRCOV
+    }
+    #endif
 
   /* Then sort by VMA.  Normally the LMA and the VMA will be
      the same, and this will do nothing.  */
   if (sec1->vma < sec2->vma)
     return -1;
-  else if (sec1->vma > sec2->vma)
+  else 
+  #ifdef FRCOV
+  {if (FIXREVERTER[5507]) {
+    if ((sec1 -> vma > sec2 -> vma ) && !(0))
+      fprintf(stderr, "triggered bug index 5507\n");
+    else
+      fprintf(stderr, "reached bug index 5507\n");
+  }
+  if ((!FIXREVERTER[5507] && (sec1 -> vma > sec2 -> vma ))
+  #else
+  if (0
+  #endif
+  )
     return 1;
+    #ifdef FRCOV
+    }
+    #endif
 
   /* Put !SEC_LOAD sections after SEC_LOAD ones.  */
 
@@ -5290,18 +5820,93 @@ elf_sort_segments (const void *arg1, const void *arg2)
   const struct elf_segment_map *m1 = *(const struct elf_segment_map **) arg1;
   const struct elf_segment_map *m2 = *(const struct elf_segment_map **) arg2;
 
-  if (m1->p_type != m2->p_type)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[5512]) {
+    if ((m1 -> p_type != m2 -> p_type ) && !(0))
+      fprintf(stderr, "triggered bug index 5512\n");
+    else
+      fprintf(stderr, "reached bug index 5512\n");
+  }
+  if ((!FIXREVERTER[5512] && (m1 -> p_type != m2 -> p_type ))
+  #else
+  if (0
+  #endif
+  )
     {
-      if (m1->p_type == PT_NULL)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[5510]) {
+        if ((m1 -> p_type == 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 5510\n");
+        else
+          fprintf(stderr, "reached bug index 5510\n");
+      }
+      if ((!FIXREVERTER[5510] && (m1 -> p_type == 0 ))
+      #else
+      if (0
+      #endif
+      )
 	return 1;
-      if (m2->p_type == PT_NULL)
+	#ifdef FRCOV
+	}
+	#endif
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[5511]) {
+        if ((m2 -> p_type == 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 5511\n");
+        else
+          fprintf(stderr, "reached bug index 5511\n");
+      }
+      if ((!FIXREVERTER[5511] && (m2 -> p_type == 0 ))
+      #else
+      if (0
+      #endif
+      )
 	return -1;
+	#ifdef FRCOV
+	}
+	#endif
       return m1->p_type < m2->p_type ? -1 : 1;
     }
-  if (m1->includes_filehdr != m2->includes_filehdr)
+    #ifdef FRCOV
+    }
+    #endif
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[5513]) {
+    if ((m1 -> includes_filehdr != m2 -> includes_filehdr ) && !(0))
+      fprintf(stderr, "triggered bug index 5513\n");
+    else
+      fprintf(stderr, "reached bug index 5513\n");
+  }
+  if ((!FIXREVERTER[5513] && (m1 -> includes_filehdr != m2 -> includes_filehdr ))
+  #else
+  if (0
+  #endif
+  )
     return m1->includes_filehdr ? -1 : 1;
-  if (m1->no_sort_lma != m2->no_sort_lma)
+    #ifdef FRCOV
+    }
+    #endif
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[5514]) {
+    if ((m1 -> no_sort_lma != m2 -> no_sort_lma ) && !(0))
+      fprintf(stderr, "triggered bug index 5514\n");
+    else
+      fprintf(stderr, "reached bug index 5514\n");
+  }
+  if ((!FIXREVERTER[5514] && (m1 -> no_sort_lma != m2 -> no_sort_lma ))
+  #else
+  if (0
+  #endif
+  )
     return m1->no_sort_lma ? -1 : 1;
+    #ifdef FRCOV
+    }
+    #endif
   if (m1->p_type == PT_LOAD && !m1->no_sort_lma)
     {
       bfd_vma lma1, lma2;  /* Octets.  */
@@ -5326,8 +5931,23 @@ elf_sort_segments (const void *arg1, const void *arg2)
       if (lma1 != lma2)
 	return lma1 < lma2 ? -1 : 1;
     }
-  if (m1->idx != m2->idx)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[5516]) {
+    if ((m1 -> idx != m2 -> idx ) && !(0))
+      fprintf(stderr, "triggered bug index 5516\n");
+    else
+      fprintf(stderr, "reached bug index 5516\n");
+  }
+  if ((!FIXREVERTER[5516] && (m1 -> idx != m2 -> idx ))
+  #else
+  if (0
+  #endif
+  )
     return m1->idx < m2->idx ? -1 : 1;
+    #ifdef FRCOV
+    }
+    #endif
   return 0;
 }
 
@@ -5358,8 +5978,23 @@ static file_ptr
 vma_page_aligned_bias (bfd_vma vma, ufile_ptr off, bfd_vma maxpagesize)
 {
   /* PR binutils/16199: Handle an alignment of zero.  */
-  if (maxpagesize == 0)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[5517]) {
+    if ((maxpagesize == 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 5517\n");
+    else
+      fprintf(stderr, "reached bug index 5517\n");
+  }
+  if ((!FIXREVERTER[5517] && (maxpagesize == 0 ))
+  #else
+  if (0
+  #endif
+  )
     maxpagesize = 1;
+    #ifdef FRCOV
+    }
+    #endif
   return ((vma - off) % maxpagesize);
 }
 
@@ -5400,8 +6035,23 @@ write_zeros (bfd *abfd, file_ptr pos, bfd_size_type len)
   if (bfd_seek (abfd, pos, SEEK_SET) != 0)
     return false;
   buf = bfd_zmalloc (len);
-  if (buf == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[5519]) {
+    if ((buf == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 5519\n");
+    else
+      fprintf(stderr, "reached bug index 5519\n");
+  }
+  if ((!FIXREVERTER[5519] && (buf == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     return false;
+    #ifdef FRCOV
+    }
+    #endif
   ret = bfd_bwrite (buf, len, abfd) == len;
   free (buf);
   return ret;
@@ -5462,11 +6112,26 @@ assign_file_positions_for_load_sections (bfd *abfd,
       BFD_ASSERT (actual >= alloc);
     }
 
-  if (alloc == 0)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[5520]) {
+    if ((alloc == 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 5520\n");
+    else
+      fprintf(stderr, "reached bug index 5520\n");
+  }
+  if ((!FIXREVERTER[5520] && (alloc == 0 ))
+  #else
+  if (0
+  #endif
+  )
     {
       elf_next_file_pos (abfd) = bed->s->sizeof_ehdr;
       return true;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
   /* We're writing the size in elf_program_header_size (abfd),
      see assign_file_positions_except_relocs, so make sure we have
@@ -5481,8 +6146,23 @@ assign_file_positions_for_load_sections (bfd *abfd,
 			     + alloc * sizeof (*sorted_seg_map)));
   sorted_seg_map = (struct elf_segment_map **) (phdrs + actual);
   elf_tdata (abfd)->phdr = phdrs;
-  if (phdrs == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[5521]) {
+    if ((phdrs == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 5521\n");
+    else
+      fprintf(stderr, "reached bug index 5521\n");
+  }
+  if ((!FIXREVERTER[5521] && (phdrs == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     return false;
+    #ifdef FRCOV
+    }
+    #endif
 
   for (m = elf_seg_map (abfd), j = 0; m != NULL; m = m->next, j++)
     {
@@ -5524,8 +6204,23 @@ assign_file_positions_for_load_sections (bfd *abfd,
   for (j = 0; j < alloc; j++)
     {
       m = sorted_seg_map[j];
-      if (m->p_type != PT_LOAD)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[5522]) {
+        if ((m -> p_type != 1 ) && !(0))
+          fprintf(stderr, "triggered bug index 5522\n");
+        else
+          fprintf(stderr, "reached bug index 5522\n");
+      }
+      if ((!FIXREVERTER[5522] && (m -> p_type != 1 ))
+      #else
+      if (0
+      #endif
+      )
 	break;
+	#ifdef FRCOV
+	}
+	#endif
       if (m->includes_phdrs)
 	{
 	  phdr_load_seg = m;
@@ -5581,8 +6276,23 @@ assign_file_positions_for_load_sections (bfd *abfd,
 	}
       else if (m->p_align_valid)
 	p->p_align = m->p_align;
-      else if (m->count == 0)
+      else 
+      #ifdef FRCOV
+      {if (FIXREVERTER[5523]) {
+        if ((m -> count == 0  ) && !(0))
+          fprintf(stderr, "triggered bug index 5523\n");
+        else
+          fprintf(stderr, "reached bug index 5523\n");
+      }
+      if ((!FIXREVERTER[5523] && (m -> count == 0  ))
+      #else
+      if (0
+      #endif
+      )
 	p->p_align = 1 << bed->s->log_file_align;
+	#ifdef FRCOV
+	}
+	#endif
 
       if (m == phdr_load_seg)
 	{
@@ -5608,12 +6318,42 @@ assign_file_positions_for_load_sections (bfd *abfd,
 		  unsigned int secalign;
 
 		  secalign = bfd_section_alignment (*secpp);
-		  if (secalign > align_power)
+		  
+		  #ifdef FRCOV
+		  {if (FIXREVERTER[5524]) {
+		    if ((secalign > align_power ) && !(0))
+		      fprintf(stderr, "triggered bug index 5524\n");
+		    else
+		      fprintf(stderr, "reached bug index 5524\n");
+		  }
+		  if ((!FIXREVERTER[5524] && (secalign > align_power ))
+		  #else
+		  if (0
+		  #endif
+		  )
 		    align_power = secalign;
+		    #ifdef FRCOV
+		    }
+		    #endif
 		}
 	      align = (bfd_size_type) 1 << align_power;
-	      if (align < maxpagesize)
+	      
+	      #ifdef FRCOV
+	      {if (FIXREVERTER[5525]) {
+	        if ((align < maxpagesize ) && !(0))
+	          fprintf(stderr, "triggered bug index 5525\n");
+	        else
+	          fprintf(stderr, "reached bug index 5525\n");
+	      }
+	      if ((!FIXREVERTER[5525] && (align < maxpagesize ))
+	      #else
+	      if (0
+	      #endif
+	      )
 		align = maxpagesize;
+		#ifdef FRCOV
+		}
+		#endif
 	    }
 
 	  for (i = 0; i < m->count; i++)
@@ -5759,10 +6499,40 @@ assign_file_positions_for_load_sections (bfd *abfd,
 		     without file contents somewhere within the first
 		     page, in an attempt to not point past EOF.  */
 		  bfd_size_type align = maxpagesize;
-		  if (align < p->p_align)
+		  
+		  #ifdef FRCOV
+		  {if (FIXREVERTER[5526]) {
+		    if ((align < p -> p_align ) && !(0))
+		      fprintf(stderr, "triggered bug index 5526\n");
+		    else
+		      fprintf(stderr, "reached bug index 5526\n");
+		  }
+		  if ((!FIXREVERTER[5526] && (align < p -> p_align ))
+		  #else
+		  if (0
+		  #endif
+		  )
 		    align = p->p_align;
-		  if (align < 1)
+		    #ifdef FRCOV
+		    }
+		    #endif
+		  
+		  #ifdef FRCOV
+		  {if (FIXREVERTER[5527]) {
+		    if ((align < 1 ) && !(0))
+		      fprintf(stderr, "triggered bug index 5527\n");
+		    else
+		      fprintf(stderr, "reached bug index 5527\n");
+		  }
+		  if ((!FIXREVERTER[5527] && (align < 1 ))
+		  #else
+		  if (0
+		  #endif
+		  )
 		    align = 1;
+		    #ifdef FRCOV
+		    }
+		    #endif
 		  p->p_offset = off % align;
 		}
 	    }
@@ -5853,8 +6623,23 @@ assign_file_positions_for_load_sections (bfd *abfd,
 		p->p_filesz += adjust;
 	    }
 
-	  if (p->p_type == PT_NOTE && bfd_get_format (abfd) == bfd_core)
+	  
+	  #ifdef FRCOV
+	  {if (FIXREVERTER[5528]) {
+	    fprintf(stderr, "reached bug index 5528\n");
+	  }
+	  if ((FIXREVERTER[5528] && (bfd_get_format ( abfd ) == bfd_core )) || (!FIXREVERTER[5528] && (p -> p_type == 4 && bfd_get_format ( abfd ) == bfd_core ))
+	  #else
+	  if (bfd_get_format ( abfd ) == bfd_core 
+	  #endif
+	  )
 	    {
+	      
+	    #ifdef FRCOV
+	      if (!(p -> p_type == 4 ))
+	        fprintf(stderr, "triggered bug index 5528\n");
+	      #endif
+	    
 	      /* The section at i == 0 is the one that actually contains
 		 everything.  */
 	      if (i == 0)
@@ -5924,6 +6709,9 @@ assign_file_positions_for_load_sections (bfd *abfd,
 		      || (abfd->flags & D_PAGED) == 0))
 		p->p_align = align;
 	    }
+	    #ifdef FRCOV
+	    }
+	    #endif
 
 	  if (!m->p_flags_valid)
 	    {
@@ -5950,8 +6738,23 @@ assign_file_positions_for_load_sections (bfd *abfd,
 	  _bfd_error_handler (_("%pB: error: PHDR segment not covered"
 				" by LOAD segment"),
 			      abfd);
-	  if (link_info == NULL)
+	  
+	  #ifdef FRCOV
+	  {if (FIXREVERTER[5529]) {
+	    if ((link_info == (void *) 0 ) && !(0))
+	      fprintf(stderr, "triggered bug index 5529\n");
+	    else
+	      fprintf(stderr, "reached bug index 5529\n");
+	  }
+	  if ((!FIXREVERTER[5529] && (link_info == (void *) 0 ))
+	  #else
+	  if (0
+	  #endif
+	  )
 	    return false;
+	    #ifdef FRCOV
+	    }
+	    #endif
 	  /* Arrange for the linker to exit with an error, deleting
 	     the output file unless --noinhibit-exec is given.  */
 	  link_info->callbacks->info ("%X");
@@ -5959,8 +6762,23 @@ assign_file_positions_for_load_sections (bfd *abfd,
 
       /* Check that all sections are in a PT_LOAD segment.
 	 Don't check funky gdb generated core files.  */
-      if (p->p_type == PT_LOAD && bfd_get_format (abfd) != bfd_core)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[5530]) {
+        fprintf(stderr, "reached bug index 5530\n");
+      }
+      if ((FIXREVERTER[5530] && (bfd_get_format ( abfd ) != bfd_core )) || (!FIXREVERTER[5530] && (p -> p_type == 1 && bfd_get_format ( abfd ) != bfd_core ))
+      #else
+      if (bfd_get_format ( abfd ) != bfd_core 
+      #endif
+      )
 	{
+	  
+	#ifdef FRCOV
+	  if (!(p -> p_type == 1 ))
+	    fprintf(stderr, "triggered bug index 5530\n");
+	  #endif
+	
 	  bool check_vma = true;
 
 	  for (i = 1; i < m->count; i++)
@@ -5993,6 +6811,9 @@ assign_file_positions_for_load_sections (bfd *abfd,
 		}
 	    }
 	}
+	#ifdef FRCOV
+	}
+	#endif
     }
 
   elf_next_file_pos (abfd) = off;
@@ -6275,11 +7096,26 @@ assign_file_positions_for_non_load_sections (bfd *abfd,
 	    {
 	      /* A user specified segment layout may include a PHDR
 		 segment that overlaps with a LOAD segment...  */
-	      if (p->p_type == PT_PHDR)
+	      
+	      #ifdef FRCOV
+	      {if (FIXREVERTER[5531]) {
+	        if ((p -> p_type == 6 ) && !(0))
+	          fprintf(stderr, "triggered bug index 5531\n");
+	        else
+	          fprintf(stderr, "reached bug index 5531\n");
+	      }
+	      if ((!FIXREVERTER[5531] && (p -> p_type == 6 ))
+	      #else
+	      if (0
+	      #endif
+	      )
 		{
 		  m->count = 0;
 		  continue;
 		}
+		#ifdef FRCOV
+		}
+		#endif
 
 	      if (m->includes_filehdr || m->includes_phdrs)
 		{
@@ -6297,7 +7133,19 @@ assign_file_positions_for_non_load_sections (bfd *abfd,
 		{
 		  asection *sect = m->sections[i];
 		  Elf_Internal_Shdr *hdr = &elf_section_data (sect)->this_hdr;
-		  if (hdr->sh_type != SHT_NOBITS)
+		  
+		  #ifdef FRCOV
+		  {if (FIXREVERTER[5532]) {
+		    if ((hdr -> sh_type != 8 ) && !(0))
+		      fprintf(stderr, "triggered bug index 5532\n");
+		    else
+		      fprintf(stderr, "reached bug index 5532\n");
+		  }
+		  if ((!FIXREVERTER[5532] && (hdr -> sh_type != 8 ))
+		  #else
+		  if (0
+		  #endif
+		  )
 		    {
 		      p->p_filesz = (sect->filepos - m->sections[0]->filepos
 				     + hdr->sh_size);
@@ -6308,6 +7156,9 @@ assign_file_positions_for_non_load_sections (bfd *abfd,
 			p->p_memsz = p->p_filesz;
 		      break;
 		    }
+		    #ifdef FRCOV
+		    }
+		    #endif
 		}
 	    }
 	}
@@ -6320,8 +7171,23 @@ static elf_section_list *
 find_section_in_list (unsigned int i, elf_section_list * list)
 {
   for (;list != NULL; list = list->next)
-    if (list->ndx == i)
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[5533]) {
+      if ((list -> ndx == i ) && !(0))
+        fprintf(stderr, "triggered bug index 5533\n");
+      else
+        fprintf(stderr, "reached bug index 5533\n");
+    }
+    if ((!FIXREVERTER[5533] && (list -> ndx == i ))
+    #else
+    if (0
+    #endif
+    )
       break;
+      #ifdef FRCOV
+      }
+      #endif
   return list;
 }
 
@@ -6576,8 +7442,23 @@ _bfd_elf_assign_file_positions_for_non_load (bfd *abfd)
 			 section name from .debug_* to .zdebug_*.  */
 		      char *new_name
 			= convert_debug_to_zdebug (abfd, name);
-		      if (new_name == NULL)
+		      
+		      #ifdef FRCOV
+		      {if (FIXREVERTER[5534]) {
+		        if ((new_name == (void *) 0 ) && !(0))
+		          fprintf(stderr, "triggered bug index 5534\n");
+		        else
+		          fprintf(stderr, "reached bug index 5534\n");
+		      }
+		      if ((!FIXREVERTER[5534] && (new_name == (void *) 0 ))
+		      #else
+		      if (0
+		      #endif
+		      )
 			return false;
+			#ifdef FRCOV
+			}
+			#endif
 		      name = new_name;
 		    }
 		  /* Add section name to section name section.  */
@@ -6962,11 +7843,26 @@ rewrite_elf_program_header (bfd *ibfd, bfd *obfd, bfd_vma maxpagesize)
   for (i = 0, segment = elf_tdata (ibfd)->phdr;
        i < num_segments;
        i++, segment++)
-    if (segment->p_paddr != 0)
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[5536]) {
+      if ((segment -> p_paddr != 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 5536\n");
+      else
+        fprintf(stderr, "reached bug index 5536\n");
+    }
+    if ((!FIXREVERTER[5536] && (segment -> p_paddr != 0 ))
+    #else
+    if (0
+    #endif
+    )
       {
 	p_paddr_valid = true;
 	break;
       }
+      #ifdef FRCOV
+      }
+      #endif
 
   /* Scan through the segments specified in the program header
      of the input BFD.  For this first scan we look for overlaps
@@ -6989,13 +7885,43 @@ rewrite_elf_program_header (bfd *ibfd, bfd *obfd, bfd_vma maxpagesize)
 	      break;
 	    }
 
-      if (segment->p_type != PT_LOAD)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[5538]) {
+        if ((segment -> p_type != 1 ) && !(0))
+          fprintf(stderr, "triggered bug index 5538\n");
+        else
+          fprintf(stderr, "reached bug index 5538\n");
+      }
+      if ((!FIXREVERTER[5538] && (segment -> p_type != 1 ))
+      #else
+      if (0
+      #endif
+      )
 	{
 	  /* Remove PT_GNU_RELRO segment.  */
-	  if (segment->p_type == PT_GNU_RELRO)
+	  
+	  #ifdef FRCOV
+	  {if (FIXREVERTER[5537]) {
+	    if ((segment -> p_type == 1610612736 + 74769746  ) && !(0))
+	      fprintf(stderr, "triggered bug index 5537\n");
+	    else
+	      fprintf(stderr, "reached bug index 5537\n");
+	  }
+	  if ((!FIXREVERTER[5537] && (segment -> p_type == 1610612736 + 74769746  ))
+	  #else
+	  if (0
+	  #endif
+	  )
 	    segment->p_type = PT_NULL;
+	    #ifdef FRCOV
+	    }
+	    #endif
 	  continue;
 	}
+	#ifdef FRCOV
+	}
+	#endif
 
       /* Determine if this segment overlaps any previous segments.  */
       for (j = 0, segment2 = elf_tdata (ibfd)->phdr; j < i; j++, segment2++)
@@ -7060,8 +7986,23 @@ rewrite_elf_program_header (bfd *ibfd, bfd *obfd, bfd_vma maxpagesize)
       size_t amt;
       asection *first_section;
 
-      if (segment->p_type == PT_NULL)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[5539]) {
+        if ((segment -> p_type == 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 5539\n");
+        else
+          fprintf(stderr, "reached bug index 5539\n");
+      }
+      if ((!FIXREVERTER[5539] && (segment -> p_type == 0 ))
+      #else
+      if (0
+      #endif
+      )
 	continue;
+	#ifdef FRCOV
+	}
+	#endif
 
       first_section = NULL;
       /* Compute how many sections might be placed into this segment.  */
@@ -7073,8 +8014,23 @@ rewrite_elf_program_header (bfd *ibfd, bfd *obfd, bfd_vma maxpagesize)
 	     removed from the corresponding output segment.   */
 	  if (IS_SECTION_IN_INPUT_SEGMENT (section, segment, bed, opb))
 	    {
-	      if (first_section == NULL)
+	      
+	      #ifdef FRCOV
+	      {if (FIXREVERTER[5540]) {
+	        if ((first_section == (void *) 0 ) && !(0))
+	          fprintf(stderr, "triggered bug index 5540\n");
+	        else
+	          fprintf(stderr, "reached bug index 5540\n");
+	      }
+	      if ((!FIXREVERTER[5540] && (first_section == (void *) 0 ))
+	      #else
+	      if (0
+	      #endif
+	      )
 		first_section = section;
+		#ifdef FRCOV
+		}
+		#endif
 	      if (section->output_section != NULL)
 		++section_count;
 	    }
@@ -7085,8 +8041,23 @@ rewrite_elf_program_header (bfd *ibfd, bfd *obfd, bfd_vma maxpagesize)
       amt = sizeof (struct elf_segment_map) - sizeof (asection *);
       amt += section_count * sizeof (asection *);
       map = (struct elf_segment_map *) bfd_zalloc (obfd, amt);
-      if (map == NULL)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[5541]) {
+        if ((map == (void *) 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 5541\n");
+        else
+          fprintf(stderr, "reached bug index 5541\n");
+      }
+      if ((!FIXREVERTER[5541] && (map == (void *) 0 ))
+      #else
+      if (0
+      #endif
+      )
 	return false;
+	#ifdef FRCOV
+	}
+	#endif
 
       /* Initialise the fields of the segment map.  Default to
 	 using the physical address of the segment in the input BFD.  */
@@ -7101,8 +8072,23 @@ rewrite_elf_program_header (bfd *ibfd, bfd *obfd, bfd_vma maxpagesize)
 	  && segment->p_align > 1)
 	{
 	  map->p_align = segment->p_align;
-	  if (segment->p_align > maxpagesize)
+	  
+	  #ifdef FRCOV
+	  {if (FIXREVERTER[5542]) {
+	    if ((segment -> p_align > maxpagesize  ) && !(0))
+	      fprintf(stderr, "triggered bug index 5542\n");
+	    else
+	      fprintf(stderr, "reached bug index 5542\n");
+	  }
+	  if ((!FIXREVERTER[5542] && (segment -> p_align > maxpagesize  ))
+	  #else
+	  if (0
+	  #endif
+	  )
 	    map->p_align = maxpagesize;
+	    #ifdef FRCOV
+	    }
+	    #endif
 	  map->p_align_valid = 1;
 	}
 
@@ -7188,8 +8174,23 @@ rewrite_elf_program_header (bfd *ibfd, bfd *obfd, bfd_vma maxpagesize)
 
       amt = section_count * sizeof (asection *);
       sections = (asection **) bfd_malloc (amt);
-      if (sections == NULL)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[5543]) {
+        if ((sections == (void *) 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 5543\n");
+        else
+          fprintf(stderr, "reached bug index 5543\n");
+      }
+      if ((!FIXREVERTER[5543] && (sections == (void *) 0 ))
+      #else
+      if (0
+      #endif
+      )
 	return false;
+	#ifdef FRCOV
+	}
+	#endif
 
       /* Step One: Scan for segment vs section LMA conflicts.
 	 Also add the sections to the section array allocated above.
@@ -7247,11 +8248,41 @@ rewrite_elf_program_header (bfd *ibfd, bfd *obfd, bfd_vma maxpagesize)
 		     segment.  */
 		  map->sections[isec++] = output_section;
 		}
-	      else if (suggested_lma == NULL)
+	      else 
+	      #ifdef FRCOV
+	      {if (FIXREVERTER[5544]) {
+	        if ((suggested_lma == (void *) 0 ) && !(0))
+	          fprintf(stderr, "triggered bug index 5544\n");
+	        else
+	          fprintf(stderr, "reached bug index 5544\n");
+	      }
+	      if ((!FIXREVERTER[5544] && (suggested_lma == (void *) 0 ))
+	      #else
+	      if (0
+	      #endif
+	      )
 		suggested_lma = output_section;
-
-	      if (j == section_count)
+		#ifdef FRCOV
+		}
+		#endif
+
+	      
+	      #ifdef FRCOV
+	      {if (FIXREVERTER[5545]) {
+	        if ((j == section_count ) && !(0))
+	          fprintf(stderr, "triggered bug index 5545\n");
+	        else
+	          fprintf(stderr, "reached bug index 5545\n");
+	      }
+	      if ((!FIXREVERTER[5545] && (j == section_count ))
+	      #else
+	      if (0
+	      #endif
+	      )
 		break;
+		#ifdef FRCOV
+		}
+		#endif
 	    }
 	}
 
@@ -7292,8 +8323,23 @@ rewrite_elf_program_header (bfd *ibfd, bfd *obfd, bfd_vma maxpagesize)
 	  /* Change the current segment's physical address to match
 	     the LMA of the first section that fitted, or if no
 	     section fitted, the first section.  */
-	  if (matching_lma == NULL)
+	  
+	  #ifdef FRCOV
+	  {if (FIXREVERTER[5546]) {
+	    if ((matching_lma == (void *) 0 ) && !(0))
+	      fprintf(stderr, "triggered bug index 5546\n");
+	    else
+	      fprintf(stderr, "reached bug index 5546\n");
+	  }
+	  if ((!FIXREVERTER[5546] && (matching_lma == (void *) 0 ))
+	  #else
+	  if (0
+	  #endif
+	  )
 	    matching_lma = suggested_lma;
+	    #ifdef FRCOV
+	    }
+	    #endif
 
 	  map->p_paddr = matching_lma->lma * opb;
 
@@ -7321,8 +8367,25 @@ rewrite_elf_program_header (bfd *ibfd, bfd *obfd, bfd_vma maxpagesize)
 		 alignment padding before that section too.  Try to
 		 account for that by adjusting the segment lma down to
 		 the same alignment.  */
-	      if (segment->p_align != 0 && segment->p_align < align)
+	      
+	      #ifdef FRCOV
+	      {if (FIXREVERTER[5547]) {
+	        fprintf(stderr, "reached bug index 5547\n");
+	      }
+	      if ((FIXREVERTER[5547] && (segment -> p_align != 0 )) || (!FIXREVERTER[5547] && (segment -> p_align != 0 && segment -> p_align < align ))
+	      #else
+	      if (segment -> p_align != 0 
+	      #endif
+	      )
+		
+		#ifdef FRCOV
+		{if (!(segment -> p_align < align ))
+		  fprintf(stderr, "triggered bug index 5547\n");
+		#endif
 		align = segment->p_align;
+		#ifdef FRCOV
+		}}
+		#endif
 	      map->p_paddr &= -(align * opb);
 	    }
 	}
@@ -7345,8 +8408,23 @@ rewrite_elf_program_header (bfd *ibfd, bfd *obfd, bfd_vma maxpagesize)
 	    {
 	      section = sections[j];
 
-	      if (section == NULL)
+	      
+	      #ifdef FRCOV
+	      {if (FIXREVERTER[5548]) {
+	        if ((section == (void *) 0 ) && !(0))
+	          fprintf(stderr, "triggered bug index 5548\n");
+	        else
+	          fprintf(stderr, "reached bug index 5548\n");
+	      }
+	      if ((!FIXREVERTER[5548] && (section == (void *) 0 ))
+	      #else
+	      if (0
+	      #endif
+	      )
 		continue;
+		#ifdef FRCOV
+		}
+		#endif
 
 	      output_section = section->output_section;
 
@@ -7386,8 +8464,23 @@ rewrite_elf_program_header (bfd *ibfd, bfd *obfd, bfd_vma maxpagesize)
 			  || (prev_sec->lma + prev_sec->size
 			      > output_section->lma))
 			{
-			  if (suggested_lma == NULL)
+			  
+			  #ifdef FRCOV
+			  {if (FIXREVERTER[5549]) {
+			    if ((suggested_lma == (void *) 0 ) && !(0))
+			      fprintf(stderr, "triggered bug index 5549\n");
+			    else
+			      fprintf(stderr, "reached bug index 5549\n");
+			  }
+			  if ((!FIXREVERTER[5549] && (suggested_lma == (void *) 0 ))
+			  #else
+			  if (0
+			  #endif
+			  )
 			    suggested_lma = output_section;
+			    #ifdef FRCOV
+			    }
+			    #endif
 
 			  continue;
 			}
@@ -7396,11 +8489,41 @@ rewrite_elf_program_header (bfd *ibfd, bfd *obfd, bfd_vma maxpagesize)
 		  map->sections[map->count++] = output_section;
 		  ++isec;
 		  sections[j] = NULL;
-		  if (segment->p_type == PT_LOAD)
+		  
+		  #ifdef FRCOV
+		  {if (FIXREVERTER[5550]) {
+		    if ((segment -> p_type == 1  ) && !(0))
+		      fprintf(stderr, "triggered bug index 5550\n");
+		    else
+		      fprintf(stderr, "reached bug index 5550\n");
+		  }
+		  if ((!FIXREVERTER[5550] && (segment -> p_type == 1  ))
+		  #else
+		  if (0
+		  #endif
+		  )
 		    section->segment_mark = true;
+		    #ifdef FRCOV
+		    }
+		    #endif
 		}
-	      else if (suggested_lma == NULL)
+	      else 
+	      #ifdef FRCOV
+	      {if (FIXREVERTER[5551]) {
+	        if ((suggested_lma == (void *) 0 ) && !(0))
+	          fprintf(stderr, "triggered bug index 5551\n");
+	        else
+	          fprintf(stderr, "reached bug index 5551\n");
+	      }
+	      if ((!FIXREVERTER[5551] && (suggested_lma == (void *) 0 ))
+	      #else
+	      if (0
+	      #endif
+	      )
 		suggested_lma = output_section;
+		#ifdef FRCOV
+		}
+		#endif
 	    }
 
 	  /* PR 23932.  A corrupt input file may contain sections that cannot
@@ -7421,11 +8544,26 @@ rewrite_elf_program_header (bfd *ibfd, bfd *obfd, bfd_vma maxpagesize)
 	      amt = sizeof (struct elf_segment_map) - sizeof (asection *);
 	      amt += section_count * sizeof (asection *);
 	      map = (struct elf_segment_map *) bfd_zalloc (obfd, amt);
-	      if (map == NULL)
+	      
+	      #ifdef FRCOV
+	      {if (FIXREVERTER[5552]) {
+	        if ((map == (void *) 0 ) && !(0))
+	          fprintf(stderr, "triggered bug index 5552\n");
+	        else
+	          fprintf(stderr, "reached bug index 5552\n");
+	      }
+	      if ((!FIXREVERTER[5552] && (map == (void *) 0 ))
+	      #else
+	      if (0
+	      #endif
+	      )
 		{
 		  free (sections);
 		  return false;
 		}
+		#ifdef FRCOV
+		}
+		#endif
 
 	      /* Initialise the fields of the segment map.  Set the physical
 		 physical address to the LMA of the first section that has
@@ -7468,13 +8606,28 @@ rewrite_elf_program_header (bfd *ibfd, bfd *obfd, bfd_vma maxpagesize)
 	  -= (count - phdr_adjust_num) * iehdr->e_phentsize;
 
       for (map = map_first; map != NULL; map = map->next)
-	if (map->p_type == PT_PHDR)
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[5553]) {
+	  if ((map -> p_type == 6 ) && !(0))
+	    fprintf(stderr, "triggered bug index 5553\n");
+	  else
+	    fprintf(stderr, "reached bug index 5553\n");
+	}
+	if ((!FIXREVERTER[5553] && (map -> p_type == 6 ))
+	#else
+	if (0
+	#endif
+	)
 	  {
 	    bfd_vma adjust
 	      = phdr_adjust_seg->includes_filehdr ? iehdr->e_ehsize : 0;
 	    map->p_paddr = phdr_adjust_seg->p_paddr + adjust;
 	    break;
 	  }
+	  #ifdef FRCOV
+	  }
+	  #endif
     }
 
 #undef SEGMENT_END
@@ -7519,11 +8672,26 @@ copy_elf_program_header (bfd *ibfd, bfd *obfd)
   for (i = 0, segment = elf_tdata (ibfd)->phdr;
        i < num_segments;
        i++, segment++)
-    if (segment->p_paddr != 0)
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[5554]) {
+      if ((segment -> p_paddr != 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 5554\n");
+      else
+        fprintf(stderr, "reached bug index 5554\n");
+    }
+    if ((!FIXREVERTER[5554] && (segment -> p_paddr != 0 ))
+    #else
+    if (0
+    #endif
+    )
       {
 	p_paddr_valid = true;
 	break;
       }
+      #ifdef FRCOV
+      }
+      #endif
 
   for (i = 0, segment = elf_tdata (ibfd)->phdr;
        i < num_segments;
@@ -7544,8 +8712,23 @@ copy_elf_program_header (bfd *ibfd, bfd *obfd)
 	  this_hdr = &(elf_section_data(section)->this_hdr);
 	  if (ELF_SECTION_IN_SEGMENT (this_hdr, segment))
 	    {
-	      if (first_section == NULL)
+	      
+	      #ifdef FRCOV
+	      {if (FIXREVERTER[5555]) {
+	        if ((first_section == (void *) 0 ) && !(0))
+	          fprintf(stderr, "triggered bug index 5555\n");
+	        else
+	          fprintf(stderr, "reached bug index 5555\n");
+	      }
+	      if ((!FIXREVERTER[5555] && (first_section == (void *) 0 ))
+	      #else
+	      if (0
+	      #endif
+	      )
 		first_section = section;
+		#ifdef FRCOV
+		}
+		#endif
 	      section_count++;
 	    }
 	}
@@ -7555,8 +8738,23 @@ copy_elf_program_header (bfd *ibfd, bfd *obfd)
       amt = sizeof (struct elf_segment_map) - sizeof (asection *);
       amt += section_count * sizeof (asection *);
       map = (struct elf_segment_map *) bfd_zalloc (obfd, amt);
-      if (map == NULL)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[5556]) {
+        if ((map == (void *) 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 5556\n");
+        else
+          fprintf(stderr, "reached bug index 5556\n");
+      }
+      if ((!FIXREVERTER[5556] && (map == (void *) 0 ))
+      #else
+      if (0
+      #endif
+      )
 	return false;
+	#ifdef FRCOV
+	}
+	#endif
 
       /* Initialize the fields of the output segment map with the
 	 input segment.  */
@@ -7634,8 +8832,23 @@ copy_elf_program_header (bfd *ibfd, bfd *obfd)
 		      if (section->lma * opb - segment->p_paddr != seg_off)
 			map->p_paddr_valid = false;
 		    }
-		  if (isec == section_count)
+		  
+		  #ifdef FRCOV
+		  {if (FIXREVERTER[5557]) {
+		    if ((isec == section_count ) && !(0))
+		      fprintf(stderr, "triggered bug index 5557\n");
+		    else
+		      fprintf(stderr, "reached bug index 5557\n");
+		  }
+		  if ((!FIXREVERTER[5557] && (isec == section_count ))
+		  #else
+		  if (0
+		  #endif
+		  )
 		    break;
+		    #ifdef FRCOV
+		    }
+		    #endif
 		}
 	    }
 	}
@@ -7729,14 +8942,23 @@ copy_private_bfd_data (bfd *ibfd, bfd *obfd)
 		{
 		  /* FIXME: Check if its output section is changed or
 		     removed.  What else do we need to check?  */
-		  if (osec == NULL
-		      || section->flags != osec->flags
-		      || section->lma != osec->lma
-		      || section->vma != osec->vma
-		      || section->size != osec->size
-		      || section->rawsize != osec->rawsize
-		      || section->alignment_power != osec->alignment_power)
+		  
+		  #ifdef FRCOV
+		  {if (FIXREVERTER[5559]) {
+		    if ((osec == (void *) 0 || section -> flags != osec -> flags || section -> lma != osec -> lma || section -> vma != osec -> vma || section -> size != osec -> size || section -> rawsize != osec -> rawsize || section -> alignment_power != osec -> alignment_power ) && !(0))
+		      fprintf(stderr, "triggered bug index 5559\n");
+		    else
+		      fprintf(stderr, "reached bug index 5559\n");
+		  }
+		  if ((!FIXREVERTER[5559] && (osec == (void *) 0 || section -> flags != osec -> flags || section -> lma != osec -> lma || section -> vma != osec -> vma || section -> size != osec -> size || section -> rawsize != osec -> rawsize || section -> alignment_power != osec -> alignment_power ))
+		  #else
+		  if (0
+		  #endif
+		  )
 		    goto rewrite;
+		    #ifdef FRCOV
+		    }
+		    #endif
 		}
 	    }
 	}
@@ -7768,9 +8990,23 @@ copy_private_bfd_data (bfd *ibfd, bfd *obfd)
       for (i = 0, segment = elf_tdata (ibfd)->phdr;
 	   i < num_segments;
 	   i++, segment++)
-	if (segment->p_type == PT_LOAD
-	    && maxpagesize < segment->p_align)
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[5560]) {
+	  fprintf(stderr, "reached bug index 5560\n");
+	}
+	if ((FIXREVERTER[5560] && (segment -> p_type == 1 )) || (!FIXREVERTER[5560] && (segment -> p_type == 1 && maxpagesize < segment -> p_align ))
+	#else
+	if (segment -> p_type == 1 
+	#endif
+	)
 	  {
+	    
+	  #ifdef FRCOV
+	    if (!(maxpagesize < segment -> p_align ))
+	      fprintf(stderr, "triggered bug index 5560\n");
+	    #endif
+	  
 	    /* PR 17512: file: f17299af.  */
 	    if (segment->p_align > (bfd_vma) 1 << ((sizeof (bfd_vma) * 8) - 2))
 	      /* xgettext:c-format */
@@ -7780,9 +9016,27 @@ copy_private_bfd_data (bfd *ibfd, bfd *obfd)
 	    else
 	      maxpagesize = segment->p_align;
 	  }
+	  #ifdef FRCOV
+	  }
+	  #endif
     }
-  if (maxpagesize == 0)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[5561]) {
+    if ((maxpagesize == 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 5561\n");
+    else
+      fprintf(stderr, "reached bug index 5561\n");
+  }
+  if ((!FIXREVERTER[5561] && (maxpagesize == 0 ))
+  #else
+  if (0
+  #endif
+  )
     maxpagesize = get_elf_backend_data (obfd)->maxpagesize;
+    #ifdef FRCOV
+    }
+    #endif
 
   return rewrite_elf_program_header (ibfd, obfd, maxpagesize);
 }
@@ -8103,8 +9357,23 @@ swap_out_syms (bfd *abfd,
 
   /* Dump out the symtabs.  */
   stt = _bfd_elf_strtab_init ();
-  if (stt == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[5562]) {
+    if ((stt == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 5562\n");
+    else
+      fprintf(stderr, "reached bug index 5562\n");
+  }
+  if ((!FIXREVERTER[5562] && (stt == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     return false;
+    #ifdef FRCOV
+    }
+    #endif
 
   bed = get_elf_backend_data (abfd);
   symcount = bfd_get_symcount (abfd);
@@ -8152,8 +9421,23 @@ swap_out_syms (bfd *abfd,
 				 sizeof (Elf_External_Sym_Shndx), &amt))
 	    goto error_no_mem;
 	  outbound_shndx =  (bfd_byte *) bfd_zalloc (abfd, amt);
-	  if (outbound_shndx == NULL)
+	  
+	  #ifdef FRCOV
+	  {if (FIXREVERTER[5563]) {
+	    if ((outbound_shndx == (void *) 0 ) && !(0))
+	      fprintf(stderr, "triggered bug index 5563\n");
+	    else
+	      fprintf(stderr, "reached bug index 5563\n");
+	  }
+	  if ((!FIXREVERTER[5563] && (outbound_shndx == (void *) 0 ))
+	  #else
+	  if (0
+	  #endif
+	  )
 	    goto error_return;
+	    #ifdef FRCOV
+	    }
+	    #endif
 
 	  symtab_shndx_hdr->contents = outbound_shndx;
 	  symtab_shndx_hdr->sh_type = SHT_SYMTAB_SHNDX;
@@ -8311,8 +9595,23 @@ Unable to handle section index %x in ELF symbol.  Using ABS instead."),
 		     section of a symbol to be a section that is
 		     actually in the output file.  */
 		  sec2 = bfd_get_section_by_name (abfd, sec->name);
-		  if (sec2 != NULL)
+		  
+		  #ifdef FRCOV
+		  {if (FIXREVERTER[5564]) {
+		    if ((sec2 != (void *) 0 ) && !(0))
+		      fprintf(stderr, "triggered bug index 5564\n");
+		    else
+		      fprintf(stderr, "reached bug index 5564\n");
+		  }
+		  if ((!FIXREVERTER[5564] && (sec2 != (void *) 0 ))
+		  #else
+		  if (0
+		  #endif
+		  )
 		    shndx = _bfd_elf_section_from_bfd_section (abfd, sec2);
+		    #ifdef FRCOV
+		    }
+		    #endif
 		  if (shndx == SHN_BAD)
 		    {
 		      /* xgettext:c-format */
@@ -8590,8 +9889,23 @@ _bfd_elf_canonicalize_symtab (bfd *abfd, asymbol **allocation)
   const struct elf_backend_data *bed = get_elf_backend_data (abfd);
   long symcount = bed->s->slurp_symbol_table (abfd, allocation, false);
 
-  if (symcount >= 0)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[5565]) {
+    if ((symcount >= 0  ) && !(0))
+      fprintf(stderr, "triggered bug index 5565\n");
+    else
+      fprintf(stderr, "reached bug index 5565\n");
+  }
+  if ((!FIXREVERTER[5565] && (symcount >= 0  ))
+  #else
+  if (0
+  #endif
+  )
     abfd->symcount = symcount;
+    #ifdef FRCOV
+    }
+    #endif
   return symcount;
 }
 
@@ -8602,8 +9916,23 @@ _bfd_elf_canonicalize_dynamic_symtab (bfd *abfd,
   const struct elf_backend_data *bed = get_elf_backend_data (abfd);
   long symcount = bed->s->slurp_symbol_table (abfd, allocation, true);
 
-  if (symcount >= 0)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[5566]) {
+    if ((symcount >= 0  ) && !(0))
+      fprintf(stderr, "triggered bug index 5566\n");
+    else
+      fprintf(stderr, "reached bug index 5566\n");
+  }
+  if ((!FIXREVERTER[5566] && (symcount >= 0  ))
+  #else
+  if (0
+  #endif
+  )
     abfd->dynsymcount = symcount;
+    #ifdef FRCOV
+    }
+    #endif
   return symcount;
 }
 
@@ -9279,8 +10608,23 @@ _bfd_elf_sizeof_headers (bfd *abfd, struct bfd_link_info *info)
 	  for (m = elf_seg_map (abfd); m != NULL; m = m->next)
 	    phdr_size += bed->s->sizeof_phdr;
 
-	  if (phdr_size == 0)
+	  
+	  #ifdef FRCOV
+	  {if (FIXREVERTER[5568]) {
+	    if ((phdr_size == 0 ) && !(0))
+	      fprintf(stderr, "triggered bug index 5568\n");
+	    else
+	      fprintf(stderr, "reached bug index 5568\n");
+	  }
+	  if ((!FIXREVERTER[5568] && (phdr_size == 0 ))
+	  #else
+	  if (0
+	  #endif
+	  )
 	    phdr_size = get_program_header_size (abfd, info);
+	    #ifdef FRCOV
+	    }
+	    #endif
 	}
 
       elf_program_header_size (abfd) = phdr_size;
@@ -9533,8 +10877,23 @@ elfcore_maybe_make_sect (bfd *abfd, char *name, asection *sect)
     return true;
 
   sect2 = bfd_make_section_with_flags (abfd, name, sect->flags);
-  if (sect2 == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[5570]) {
+    if ((sect2 == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 5570\n");
+    else
+      fprintf(stderr, "reached bug index 5570\n");
+  }
+  if ((!FIXREVERTER[5570] && (sect2 == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     return false;
+    #ifdef FRCOV
+    }
+    #endif
 
   sect2->size = sect->size;
   sect2->filepos = sect->filepos;
@@ -9587,8 +10946,23 @@ elfcore_make_auxv_note_section (bfd *abfd, Elf_Internal_Note *note,
   asection *sect = bfd_make_section_anyway_with_flags (abfd, ".auxv",
 						       SEC_HAS_CONTENTS);
 
-  if (sect == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[5571]) {
+    if ((sect == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 5571\n");
+    else
+      fprintf(stderr, "reached bug index 5571\n");
+  }
+  if ((!FIXREVERTER[5571] && (sect == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     return false;
+    #ifdef FRCOV
+    }
+    #endif
 
   sect->size = note->descsz - offs;
   sect->filepos = note->descpos + offs;
@@ -9987,8 +11361,23 @@ _bfd_elfcore_strndup (bfd *abfd, char *start, size_t max)
     len = end - start;
 
   dups = (char *) bfd_alloc (abfd, len + 1);
-  if (dups == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[5572]) {
+    if ((dups == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 5572\n");
+    else
+      fprintf(stderr, "reached bug index 5572\n");
+  }
+  if ((!FIXREVERTER[5572] && (dups == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     return NULL;
+    #ifdef FRCOV
+    }
+    #endif
 
   memcpy (dups, start, len);
   dups[len] = '\0';
@@ -10199,8 +11588,23 @@ elfcore_grok_win32pstatus (bfd *abfd, Elf_Internal_Note *note)
   int is_active_thread;
   bfd_vma base_addr;
 
-  if (note->descsz < 4)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[5575]) {
+    if ((note -> descsz < 4 ) && !(0))
+      fprintf(stderr, "triggered bug index 5575\n");
+    else
+      fprintf(stderr, "reached bug index 5575\n");
+  }
+  if ((!FIXREVERTER[5575] && (note -> descsz < 4 ))
+  #else
+  if (0
+  #endif
+  )
     return true;
+    #ifdef FRCOV
+    }
+    #endif
 
   if (! startswith (note->namedata, "win32"))
     return true;
@@ -10219,8 +11623,23 @@ elfcore_grok_win32pstatus (bfd *abfd, Elf_Internal_Note *note)
        { "NOTE_INFO_MODULE64", 16 },
       };
 
-  if (type == 0 || type > (sizeof(size_check)/sizeof(size_check[0])))
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[5577]) {
+    if ((type == 0 || type > sizeof ( size_check ) / sizeof ( size_check [ 0 ] ) ) && !(0))
+      fprintf(stderr, "triggered bug index 5577\n");
+    else
+      fprintf(stderr, "reached bug index 5577\n");
+  }
+  if ((!FIXREVERTER[5577] && (type == 0 || type > sizeof ( size_check ) / sizeof ( size_check [ 0 ] ) ))
+  #else
+  if (0
+  #endif
+  )
       return true;
+      #ifdef FRCOV
+      }
+      #endif
 
   if (note->descsz < size_check[type - 1].min_size)
     {
@@ -10245,14 +11664,44 @@ elfcore_grok_win32pstatus (bfd *abfd, Elf_Internal_Note *note)
 
       len = strlen (buf) + 1;
       name = (char *) bfd_alloc (abfd, len);
-      if (name == NULL)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[5578]) {
+        if ((name == (void *) 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 5578\n");
+        else
+          fprintf(stderr, "reached bug index 5578\n");
+      }
+      if ((!FIXREVERTER[5578] && (name == (void *) 0 ))
+      #else
+      if (0
+      #endif
+      )
 	return false;
+	#ifdef FRCOV
+	}
+	#endif
 
       memcpy (name, buf, len);
 
       sect = bfd_make_section_anyway_with_flags (abfd, name, SEC_HAS_CONTENTS);
-      if (sect == NULL)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[5580]) {
+        if ((sect == (void *) 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 5580\n");
+        else
+          fprintf(stderr, "reached bug index 5580\n");
+      }
+      if ((!FIXREVERTER[5580] && (sect == (void *) 0 ))
+      #else
+      if (0
+      #endif
+      )
 	return false;
+	#ifdef FRCOV
+	}
+	#endif
 
       /* sizeof (thread_info.thread_context) */
       sect->size = note->descsz - 12;
@@ -10290,22 +11739,67 @@ elfcore_grok_win32pstatus (bfd *abfd, Elf_Internal_Note *note)
 
       len = strlen (buf) + 1;
       name = (char *) bfd_alloc (abfd, len);
-      if (name == NULL)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[5581]) {
+        if ((name == (void *) 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 5581\n");
+        else
+          fprintf(stderr, "reached bug index 5581\n");
+      }
+      if ((!FIXREVERTER[5581] && (name == (void *) 0 ))
+      #else
+      if (0
+      #endif
+      )
 	return false;
+	#ifdef FRCOV
+	}
+	#endif
 
       memcpy (name, buf, len);
 
       sect = bfd_make_section_anyway_with_flags (abfd, name, SEC_HAS_CONTENTS);
 
-      if (sect == NULL)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[5583]) {
+        if ((sect == (void *) 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 5583\n");
+        else
+          fprintf(stderr, "reached bug index 5583\n");
+      }
+      if ((!FIXREVERTER[5583] && (sect == (void *) 0 ))
+      #else
+      if (0
+      #endif
+      )
 	return false;
+	#ifdef FRCOV
+	}
+	#endif
 
-      if (note->descsz < 12 + name_size)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[5584]) {
+        if ((note -> descsz < 12 + name_size ) && !(0))
+          fprintf(stderr, "triggered bug index 5584\n");
+        else
+          fprintf(stderr, "reached bug index 5584\n");
+      }
+      if ((!FIXREVERTER[5584] && (note -> descsz < 12 + name_size ))
+      #else
+      if (0
+      #endif
+      )
         {
           _bfd_error_handler (_("%pB: win32pstatus NOTE_INFO_MODULE of size %lu is too small to contain a name of size %u"),
                               abfd, note->descsz, name_size);
           return true;
         }
+        #ifdef FRCOV
+        }
+        #endif
 
       sect->size = note->descsz;
       sect->filepos = note->descpos;
@@ -10665,12 +12159,42 @@ elfobj_grok_gnu_build_id (bfd *abfd, Elf_Internal_Note *note)
 {
   struct bfd_build_id* build_id;
 
-  if (note->descsz == 0)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[5585]) {
+    if ((note -> descsz == 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 5585\n");
+    else
+      fprintf(stderr, "reached bug index 5585\n");
+  }
+  if ((!FIXREVERTER[5585] && (note -> descsz == 0 ))
+  #else
+  if (0
+  #endif
+  )
     return false;
+    #ifdef FRCOV
+    }
+    #endif
 
   build_id = bfd_alloc (abfd, sizeof (struct bfd_build_id) - 1 + note->descsz);
-  if (build_id == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[5586]) {
+    if ((build_id == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 5586\n");
+    else
+      fprintf(stderr, "reached bug index 5586\n");
+  }
+  if ((!FIXREVERTER[5586] && (build_id == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     return false;
+    #ifdef FRCOV
+    }
+    #endif
 
   build_id->size = note->descsz;
   memcpy (build_id->data, note->descdata, note->descsz);
@@ -10732,13 +12256,43 @@ elfcore_grok_freebsd_psinfo (bfd *abfd, Elf_Internal_Note *note)
   switch (elf_elfheader (abfd)->e_ident[EI_CLASS])
     {
     case ELFCLASS32:
-      if (note->descsz < 108)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[5589]) {
+        if ((note -> descsz < 108 ) && !(0))
+          fprintf(stderr, "triggered bug index 5589\n");
+        else
+          fprintf(stderr, "reached bug index 5589\n");
+      }
+      if ((!FIXREVERTER[5589] && (note -> descsz < 108 ))
+      #else
+      if (0
+      #endif
+      )
 	return false;
+	#ifdef FRCOV
+	}
+	#endif
       break;
 
     case ELFCLASS64:
-      if (note->descsz < 120)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[5590]) {
+        if ((note -> descsz < 120 ) && !(0))
+          fprintf(stderr, "triggered bug index 5590\n");
+        else
+          fprintf(stderr, "reached bug index 5590\n");
+      }
+      if ((!FIXREVERTER[5590] && (note -> descsz < 120 ))
+      #else
+      if (0
+      #endif
+      )
 	return false;
+	#ifdef FRCOV
+	}
+	#endif
       break;
 
     default:
@@ -10774,8 +12328,23 @@ elfcore_grok_freebsd_psinfo (bfd *abfd, Elf_Internal_Note *note)
   offset += 2;
 
   /* The pr_pid field was added in version "1a".  */
-  if (note->descsz < offset + 4)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[5591]) {
+    if ((note -> descsz < offset + 4 ) && !(0))
+      fprintf(stderr, "triggered bug index 5591\n");
+    else
+      fprintf(stderr, "reached bug index 5591\n");
+  }
+  if ((!FIXREVERTER[5591] && (note -> descsz < offset + 4 ))
+  #else
+  if (0
+  #endif
+  )
     return true;
+    #ifdef FRCOV
+    }
+    #endif
 
   elf_tdata (abfd)->core->pid
     = bfd_h_get_32 (abfd, (bfd_byte *) note->descdata + offset);
@@ -10808,8 +12377,23 @@ elfcore_grok_freebsd_prstatus (bfd *abfd, Elf_Internal_Note *note)
       return false;
     }
 
-  if (note->descsz < min_size)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[5592]) {
+    if ((note -> descsz < min_size ) && !(0))
+      fprintf(stderr, "triggered bug index 5592\n");
+    else
+      fprintf(stderr, "reached bug index 5592\n");
+  }
+  if ((!FIXREVERTER[5592] && (note -> descsz < min_size ))
+  #else
+  if (0
+  #endif
+  )
     return false;
+    #ifdef FRCOV
+    }
+    #endif
 
   /* Check for version 1 in pr_version.  */
   if (bfd_h_get_32 (abfd, (bfd_byte *) note->descdata) != 1)
@@ -10847,8 +12431,23 @@ elfcore_grok_freebsd_prstatus (bfd *abfd, Elf_Internal_Note *note)
     offset += 4;
 
   /* Make sure that there is enough data remaining in the note.  */
-  if ((note->descsz - offset) < size)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[5593]) {
+    if ((note -> descsz - offset < size ) && !(0))
+      fprintf(stderr, "triggered bug index 5593\n");
+    else
+      fprintf(stderr, "reached bug index 5593\n");
+  }
+  if ((!FIXREVERTER[5593] && (note -> descsz - offset < size ))
+  #else
+  if (0
+  #endif
+  )
     return false;
+    #ifdef FRCOV
+    }
+    #endif
 
   /* Make a ".reg/999" section and a ".reg" section.  */
   return _bfd_elfcore_make_pseudosection (abfd, ".reg",
@@ -10930,8 +12529,23 @@ elfcore_netbsd_get_lwpid (Elf_Internal_Note *note, int *lwpidp)
 static bool
 elfcore_grok_netbsd_procinfo (bfd *abfd, Elf_Internal_Note *note)
 {
-  if (note->descsz <= 0x7c + 31)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[5594]) {
+    if ((note -> descsz <= 124 + 31 ) && !(0))
+      fprintf(stderr, "triggered bug index 5594\n");
+    else
+      fprintf(stderr, "reached bug index 5594\n");
+  }
+  if ((!FIXREVERTER[5594] && (note -> descsz <= 124 + 31 ))
+  #else
+  if (0
+  #endif
+  )
     return false;
+    #ifdef FRCOV
+    }
+    #endif
 
   /* Signal number at offset 0x08. */
   elf_tdata (abfd)->core->signal
@@ -10981,8 +12595,23 @@ elfcore_grok_netbsd_note (bfd *abfd, Elf_Internal_Note *note)
      than the start of the machine-dependent note types, we don't
      understand it.  */
 
-  if (note->type < NT_NETBSDCORE_FIRSTMACH)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[5595]) {
+    if ((note -> type < 32 ) && !(0))
+      fprintf(stderr, "triggered bug index 5595\n");
+    else
+      fprintf(stderr, "reached bug index 5595\n");
+  }
+  if ((!FIXREVERTER[5595] && (note -> type < 32 ))
+  #else
+  if (0
+  #endif
+  )
     return true;
+    #ifdef FRCOV
+    }
+    #endif
 
 
   switch (bfd_get_arch (abfd))
@@ -11044,8 +12673,23 @@ elfcore_grok_netbsd_note (bfd *abfd, Elf_Internal_Note *note)
 static bool
 elfcore_grok_openbsd_procinfo (bfd *abfd, Elf_Internal_Note *note)
 {
-  if (note->descsz <= 0x48 + 31)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[5596]) {
+    if ((note -> descsz <= 72 + 31 ) && !(0))
+      fprintf(stderr, "triggered bug index 5596\n");
+    else
+      fprintf(stderr, "reached bug index 5596\n");
+  }
+  if ((!FIXREVERTER[5596] && (note -> descsz <= 72 + 31 ))
+  #else
+  if (0
+  #endif
+  )
     return false;
+    #ifdef FRCOV
+    }
+    #endif
 
   /* Signal number at offset 0x08. */
   elf_tdata (abfd)->core->signal
@@ -11065,28 +12709,118 @@ elfcore_grok_openbsd_procinfo (bfd *abfd, Elf_Internal_Note *note)
 static bool
 elfcore_grok_openbsd_note (bfd *abfd, Elf_Internal_Note *note)
 {
-  if (note->type == NT_OPENBSD_PROCINFO)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[5597]) {
+    if ((note -> type == 10 ) && !(0))
+      fprintf(stderr, "triggered bug index 5597\n");
+    else
+      fprintf(stderr, "reached bug index 5597\n");
+  }
+  if ((!FIXREVERTER[5597] && (note -> type == 10 ))
+  #else
+  if (0
+  #endif
+  )
     return elfcore_grok_openbsd_procinfo (abfd, note);
+    #ifdef FRCOV
+    }
+    #endif
 
-  if (note->type == NT_OPENBSD_REGS)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[5598]) {
+    if ((note -> type == 20 ) && !(0))
+      fprintf(stderr, "triggered bug index 5598\n");
+    else
+      fprintf(stderr, "reached bug index 5598\n");
+  }
+  if ((!FIXREVERTER[5598] && (note -> type == 20 ))
+  #else
+  if (0
+  #endif
+  )
     return elfcore_make_note_pseudosection (abfd, ".reg", note);
+    #ifdef FRCOV
+    }
+    #endif
 
-  if (note->type == NT_OPENBSD_FPREGS)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[5599]) {
+    if ((note -> type == 21 ) && !(0))
+      fprintf(stderr, "triggered bug index 5599\n");
+    else
+      fprintf(stderr, "reached bug index 5599\n");
+  }
+  if ((!FIXREVERTER[5599] && (note -> type == 21 ))
+  #else
+  if (0
+  #endif
+  )
     return elfcore_make_note_pseudosection (abfd, ".reg2", note);
+    #ifdef FRCOV
+    }
+    #endif
 
-  if (note->type == NT_OPENBSD_XFPREGS)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[5600]) {
+    if ((note -> type == 22 ) && !(0))
+      fprintf(stderr, "triggered bug index 5600\n");
+    else
+      fprintf(stderr, "reached bug index 5600\n");
+  }
+  if ((!FIXREVERTER[5600] && (note -> type == 22 ))
+  #else
+  if (0
+  #endif
+  )
     return elfcore_make_note_pseudosection (abfd, ".reg-xfp", note);
+    #ifdef FRCOV
+    }
+    #endif
 
-  if (note->type == NT_OPENBSD_AUXV)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[5601]) {
+    if ((note -> type == 11 ) && !(0))
+      fprintf(stderr, "triggered bug index 5601\n");
+    else
+      fprintf(stderr, "reached bug index 5601\n");
+  }
+  if ((!FIXREVERTER[5601] && (note -> type == 11 ))
+  #else
+  if (0
+  #endif
+  )
     return elfcore_make_auxv_note_section (abfd, note, 0);
+    #ifdef FRCOV
+    }
+    #endif
 
   if (note->type == NT_OPENBSD_WCOOKIE)
     {
       asection *sect = bfd_make_section_anyway_with_flags (abfd, ".wcookie",
 							   SEC_HAS_CONTENTS);
 
-      if (sect == NULL)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[5602]) {
+        if ((sect == (void *) 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 5602\n");
+        else
+          fprintf(stderr, "reached bug index 5602\n");
+      }
+      if ((!FIXREVERTER[5602] && (sect == (void *) 0 ))
+      #else
+      if (0
+      #endif
+      )
 	return false;
+	#ifdef FRCOV
+	}
+	#endif
       sect->size = note->descsz;
       sect->filepos = note->descpos;
       sect->alignment_power = 1 + bfd_get_arch_size (abfd) / 32;
@@ -11107,8 +12841,23 @@ elfcore_grok_nto_status (bfd *abfd, Elf_Internal_Note *note, long *tid)
   short sig;
   unsigned flags;
 
-  if (note->descsz < 16)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[5604]) {
+    if ((note -> descsz < 16 ) && !(0))
+      fprintf(stderr, "triggered bug index 5604\n");
+    else
+      fprintf(stderr, "reached bug index 5604\n");
+  }
+  if ((!FIXREVERTER[5604] && (note -> descsz < 16 ))
+  #else
+  if (0
+  #endif
+  )
     return false;
+    #ifdef FRCOV
+    }
+    #endif
 
   /* nto_procfs_status 'pid' field is at offset 0.  */
   elf_tdata (abfd)->core->pid = bfd_get_32 (abfd, (bfd_byte *) ddata);
@@ -11136,13 +12885,43 @@ elfcore_grok_nto_status (bfd *abfd, Elf_Internal_Note *note, long *tid)
   sprintf (buf, ".qnx_core_status/%ld", *tid);
 
   name = (char *) bfd_alloc (abfd, strlen (buf) + 1);
-  if (name == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[5605]) {
+    if ((name == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 5605\n");
+    else
+      fprintf(stderr, "reached bug index 5605\n");
+  }
+  if ((!FIXREVERTER[5605] && (name == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     return false;
+    #ifdef FRCOV
+    }
+    #endif
   strcpy (name, buf);
 
   sect = bfd_make_section_anyway_with_flags (abfd, name, SEC_HAS_CONTENTS);
-  if (sect == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[5606]) {
+    if ((sect == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 5606\n");
+    else
+      fprintf(stderr, "reached bug index 5606\n");
+  }
+  if ((!FIXREVERTER[5606] && (sect == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     return false;
+    #ifdef FRCOV
+    }
+    #endif
 
   sect->size		= note->descsz;
   sect->filepos		= note->descpos;
@@ -11165,13 +12944,43 @@ elfcore_grok_nto_regs (bfd *abfd,
   sprintf (buf, "%s/%ld", base, tid);
 
   name = (char *) bfd_alloc (abfd, strlen (buf) + 1);
-  if (name == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[5608]) {
+    if ((name == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 5608\n");
+    else
+      fprintf(stderr, "reached bug index 5608\n");
+  }
+  if ((!FIXREVERTER[5608] && (name == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     return false;
+    #ifdef FRCOV
+    }
+    #endif
   strcpy (name, buf);
 
   sect = bfd_make_section_anyway_with_flags (abfd, name, SEC_HAS_CONTENTS);
-  if (sect == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[5609]) {
+    if ((sect == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 5609\n");
+    else
+      fprintf(stderr, "reached bug index 5609\n");
+  }
+  if ((!FIXREVERTER[5609] && (sect == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     return false;
+    #ifdef FRCOV
+    }
+    #endif
 
   sect->size		= note->descsz;
   sect->filepos		= note->descpos;
@@ -11222,14 +13031,44 @@ elfcore_grok_spu_note (bfd *abfd, Elf_Internal_Note *note)
   /* Use note name as section name.  */
   len = note->namesz;
   name = (char *) bfd_alloc (abfd, len);
-  if (name == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[5610]) {
+    if ((name == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 5610\n");
+    else
+      fprintf(stderr, "reached bug index 5610\n");
+  }
+  if ((!FIXREVERTER[5610] && (name == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     return false;
+    #ifdef FRCOV
+    }
+    #endif
   memcpy (name, note->namedata, len);
   name[len - 1] = '\0';
 
   sect = bfd_make_section_anyway_with_flags (abfd, name, SEC_HAS_CONTENTS);
-  if (sect == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[5612]) {
+    if ((sect == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 5612\n");
+    else
+      fprintf(stderr, "reached bug index 5612\n");
+  }
+  if ((!FIXREVERTER[5612] && (sect == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     return false;
+    #ifdef FRCOV
+    }
+    #endif
 
   sect->size		= note->descsz;
   sect->filepos		= note->descpos;
@@ -12171,8 +14010,23 @@ elf_parse_notes (bfd *abfd, char *buf, size_t size, file_ptr offset,
      gABI specifies that PT_NOTE alignment should be aligned to 4
      bytes for 32-bit objects and to 8 bytes for 64-bit objects.  If
      align is less than 4, we use 4 byte alignment.   */
-  if (align < 4)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[5617]) {
+    if ((align < 4 ) && !(0))
+      fprintf(stderr, "triggered bug index 5617\n");
+    else
+      fprintf(stderr, "reached bug index 5617\n");
+  }
+  if ((!FIXREVERTER[5617] && (align < 4 ))
+  #else
+  if (0
+  #endif
+  )
     align = 4;
+    #ifdef FRCOV
+    }
+    #endif
   if (align != 4 && align != 8)
     return false;
 
diff --git a/bfd/elf32-am33lin.c b/bfd/elf32-am33lin.c
old mode 100644
new mode 100755
diff --git a/bfd/elf32-arc.c b/bfd/elf32-arc.c
old mode 100644
new mode 100755
index 11a1388..cec2015
--- a/bfd/elf32-arc.c
+++ b/bfd/elf32-arc.c
@@ -1,3 +1,6 @@
+#ifdef FRCOV
+extern short FIXREVERTER[];
+#endif
 /* ARC-specific support for 32-bit ELF
    Copyright (C) 1994-2021 Free Software Foundation, Inc.
    Contributed by Cupertino Miranda (cmiranda@synopsys.com).
@@ -2982,8 +2985,23 @@ arc_elf_relax_section (bfd *abfd, asection *sec,
   /* Get a copy of the native relocations.  */
   internal_relocs = _bfd_elf_link_read_relocs (abfd, sec, NULL, NULL,
                                                link_info->keep_memory);
-  if (internal_relocs == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[4112]) {
+    if ((internal_relocs == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 4112\n");
+    else
+      fprintf(stderr, "reached bug index 4112\n");
+  }
+  if ((!FIXREVERTER[4112] && (internal_relocs == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     goto error_return;
+    #ifdef FRCOV
+    }
+    #endif
 
   /* Walk through them looking for relaxing opportunities.  */
   irelend = internal_relocs + sec->reloc_count;
@@ -3006,16 +3024,64 @@ arc_elf_relax_section (bfd *abfd, asection *sec,
         }
 
       /* Read this BFD's local symbols if we haven't done so already.  */
-      if (isymbuf == NULL && symtab_hdr->sh_info != 0)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[4115]) {
+        fprintf(stderr, "reached bug index 4115\n");
+      }
+      if ((FIXREVERTER[4115] && (isymbuf == (void *) 0 )) || (!FIXREVERTER[4115] && (isymbuf == (void *) 0 && symtab_hdr -> sh_info != 0 ))
+      #else
+      if (isymbuf == (void *) 0 
+      #endif
+      )
         {
+          
+        #ifdef FRCOV
+          if (!(symtab_hdr -> sh_info != 0 ))
+            fprintf(stderr, "triggered bug index 4115\n");
+          #endif
+        
           isymbuf = (Elf_Internal_Sym *) symtab_hdr->contents;
-          if (isymbuf == NULL)
+          
+          #ifdef FRCOV
+          {if (FIXREVERTER[4113]) {
+            if ((isymbuf == (void *) 0 ) && !(0))
+              fprintf(stderr, "triggered bug index 4113\n");
+            else
+              fprintf(stderr, "reached bug index 4113\n");
+          }
+          if ((!FIXREVERTER[4113] && (isymbuf == (void *) 0 ))
+          #else
+          if (0
+          #endif
+          )
             isymbuf = bfd_elf_get_elf_syms (abfd, symtab_hdr,
                                             symtab_hdr->sh_info, 0,
                                             NULL, NULL, NULL);
-          if (isymbuf == NULL)
+                                            #ifdef FRCOV
+                                            }
+                                            #endif
+          
+          #ifdef FRCOV
+          {if (FIXREVERTER[4114]) {
+            if ((isymbuf == (void *) 0 ) && !(0))
+              fprintf(stderr, "triggered bug index 4114\n");
+            else
+              fprintf(stderr, "reached bug index 4114\n");
+          }
+          if ((!FIXREVERTER[4114] && (isymbuf == (void *) 0 ))
+          #else
+          if (0
+          #endif
+          )
             goto error_return;
+            #ifdef FRCOV
+            }
+            #endif
+        }
+        #ifdef FRCOV
         }
+        #endif
 
       struct elf_link_hash_entry *htop = NULL;
 
diff --git a/bfd/elf32-arm.c b/bfd/elf32-arm.c
old mode 100644
new mode 100755
index cb567fe..3f91757
--- a/bfd/elf32-arm.c
+++ b/bfd/elf32-arm.c
@@ -1,3 +1,6 @@
+#ifdef FRCOV
+extern short FIXREVERTER[];
+#endif
 /* 32-bit ELF support for ARM
    Copyright (C) 1998-2021 Free Software Foundation, Inc.
 
@@ -3538,11 +3541,41 @@ elf32_arm_link_hash_newfunc (struct bfd_hash_entry * entry,
 
   /* Allocate the structure if it has not already been allocated by a
      subclass.  */
-  if (ret == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[9326]) {
+    if ((ret == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 9326\n");
+    else
+      fprintf(stderr, "reached bug index 9326\n");
+  }
+  if ((!FIXREVERTER[9326] && (ret == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     ret = (struct elf32_arm_link_hash_entry *)
 	bfd_hash_allocate (table, sizeof (struct elf32_arm_link_hash_entry));
-  if (ret == NULL)
+	#ifdef FRCOV
+	}
+	#endif
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[9327]) {
+    if ((ret == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 9327\n");
+    else
+      fprintf(stderr, "reached bug index 9327\n");
+  }
+  if ((!FIXREVERTER[9327] && (ret == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     return (struct bfd_hash_entry *) ret;
+    #ifdef FRCOV
+    }
+    #endif
 
   /* Call the allocation method of the superclass.  */
   ret = ((struct elf32_arm_link_hash_entry *)
@@ -3744,8 +3777,23 @@ stub_hash_newfunc (struct bfd_hash_entry *entry,
     {
       entry = (struct bfd_hash_entry *)
 	  bfd_hash_allocate (table, sizeof (struct elf32_arm_stub_hash_entry));
-      if (entry == NULL)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[9331]) {
+        if ((entry == (void *) 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 9331\n");
+        else
+          fprintf(stderr, "reached bug index 9331\n");
+      }
+      if ((!FIXREVERTER[9331] && (entry == (void *) 0 ))
+      #else
+      if (0
+      #endif
+      )
 	return entry;
+	#ifdef FRCOV
+	}
+	#endif
     }
 
   /* Call the allocation method of the superclass.  */
diff --git a/bfd/elf32-arm.h b/bfd/elf32-arm.h
old mode 100644
new mode 100755
diff --git a/bfd/elf32-avr.c b/bfd/elf32-avr.c
old mode 100644
new mode 100755
index 4d1ab54..196bc71
--- a/bfd/elf32-avr.c
+++ b/bfd/elf32-avr.c
@@ -1,3 +1,6 @@
+#ifdef FRCOV
+extern short FIXREVERTER[];
+#endif
 /* AVR-specific support for 32-bit ELF
    Copyright (C) 1999-2021 Free Software Foundation, Inc.
    Contributed by Denis Chertykov <denisc@overta.ru>
@@ -770,8 +773,23 @@ elf_avr_new_section_hook (bfd *abfd, asection *sec)
       size_t amt = sizeof (*sdata);
 
       sdata = bfd_zalloc (abfd, amt);
-      if (sdata == NULL)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[8107]) {
+        if ((sdata == (void *) 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 8107\n");
+        else
+          fprintf(stderr, "reached bug index 8107\n");
+      }
+      if ((!FIXREVERTER[8107] && (sdata == (void *) 0 ))
+      #else
+      if (0
+      #endif
+      )
 	return false;
+	#ifdef FRCOV
+	}
+	#endif
       sec->used_by_bfd = sdata;
     }
 
@@ -1429,8 +1447,23 @@ elf32_avr_relocate_section (bfd *output_bfd ATTRIBUTE_UNUSED,
   Elf_Internal_Rela *		relend;
   struct elf32_avr_link_hash_table * htab = avr_link_hash_table (info);
 
-  if (htab == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[8110]) {
+    if ((htab == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 8110\n");
+    else
+      fprintf(stderr, "reached bug index 8110\n");
+  }
+  if ((!FIXREVERTER[8110] && (htab == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     return false;
+    #ifdef FRCOV
+    }
+    #endif
 
   symtab_hdr = & elf_tdata (input_bfd)->symtab_hdr;
   sym_hashes = elf_sym_hashes (input_bfd);
@@ -1944,12 +1977,27 @@ elf32_avr_relax_delete_bytes (bfd *abfd,
 	  bfd_vma offset = relax_info->records.items [i].offset;
 
 	  BFD_ASSERT (offset <= addr || offset >= (addr + count));
-	  if (offset >= (addr + count))
+	  
+	  #ifdef FRCOV
+	  {if (FIXREVERTER[8112]) {
+	    if ((offset >= addr + count ) && !(0))
+	      fprintf(stderr, "triggered bug index 8112\n");
+	    else
+	      fprintf(stderr, "reached bug index 8112\n");
+	  }
+	  if ((!FIXREVERTER[8112] && (offset >= addr + count ))
+	  #else
+	  if (0
+	  #endif
+	  )
 	    {
 	      prop_record = &relax_info->records.items [i];
 	      toaddr = offset;
 	      break;
 	    }
+	    #ifdef FRCOV
+	    }
+	    #endif
 	}
     }
 
@@ -2007,9 +2055,23 @@ elf32_avr_relax_delete_bytes (bfd *abfd,
 			   + sec->output_offset + irel->r_offset);
 
       /* Get the new reloc address.  */
-      if ((irel->r_offset > addr
-	   && irel->r_offset < toaddr))
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[8113]) {
+        fprintf(stderr, "reached bug index 8113\n");
+      }
+      if ((FIXREVERTER[8113] && (irel -> r_offset > addr )) || (!FIXREVERTER[8113] && (irel -> r_offset > addr && irel -> r_offset < toaddr ))
+      #else
+      if (irel -> r_offset > addr 
+      #endif
+      )
 	{
+	  
+	#ifdef FRCOV
+	  if (!(irel -> r_offset < toaddr ))
+	    fprintf(stderr, "triggered bug index 8113\n");
+	  #endif
+	
 	  if (debug_relax)
 	    printf ("Relocation at address 0x%x needs to be moved.\n"
 		    "Old section offset: 0x%x, New section offset: 0x%x \n",
@@ -2019,6 +2081,9 @@ elf32_avr_relax_delete_bytes (bfd *abfd,
 
 	  irel->r_offset -= count;
 	}
+	#ifdef FRCOV
+	}
+	#endif
 
     }
 
@@ -2041,8 +2106,23 @@ elf32_avr_relax_delete_bytes (bfd *abfd,
        bfd_vma symval;
        bfd_vma shrinked_insn_address;
 
-       if (isec->reloc_count == 0)
+       
+       #ifdef FRCOV
+       {if (FIXREVERTER[8114]) {
+         if ((isec -> reloc_count == 0 ) && !(0))
+           fprintf(stderr, "triggered bug index 8114\n");
+         else
+           fprintf(stderr, "reached bug index 8114\n");
+       }
+       if ((!FIXREVERTER[8114] && (isec -> reloc_count == 0 ))
+       #else
+       if (0
+       #endif
+       )
 	 continue;
+	 #ifdef FRCOV
+	 }
+	 #endif
 
        shrinked_insn_address = (sec->output_section->vma
 				+ sec->output_offset + addr);
@@ -2051,8 +2131,23 @@ elf32_avr_relax_delete_bytes (bfd *abfd,
 
        irel = elf_section_data (isec)->relocs;
        /* PR 12161: Read in the relocs for this section if necessary.  */
-       if (irel == NULL)
+       
+       #ifdef FRCOV
+       {if (FIXREVERTER[8115]) {
+         if ((irel == (void *) 0 ) && !(0))
+           fprintf(stderr, "triggered bug index 8115\n");
+         else
+           fprintf(stderr, "reached bug index 8115\n");
+       }
+       if ((!FIXREVERTER[8115] && (irel == (void *) 0 ))
+       #else
+       if (0
+       #endif
+       )
 	 irel = _bfd_elf_link_read_relocs (abfd, isec, NULL, NULL, true);
+	 #ifdef FRCOV
+	 }
+	 #endif
 
        for (irelend = irel + isec->reloc_count;
 	    irel < irelend;
@@ -2060,16 +2155,64 @@ elf32_avr_relax_delete_bytes (bfd *abfd,
 	 {
 	   /* Read this BFD's local symbols if we haven't done
 	      so already.  */
-	   if (isymbuf == NULL && symtab_hdr->sh_info != 0)
+	   
+	   #ifdef FRCOV
+	   {if (FIXREVERTER[8118]) {
+	     fprintf(stderr, "reached bug index 8118\n");
+	   }
+	   if ((FIXREVERTER[8118] && (isymbuf == (void *) 0 )) || (!FIXREVERTER[8118] && (isymbuf == (void *) 0 && symtab_hdr -> sh_info != 0 ))
+	   #else
+	   if (isymbuf == (void *) 0 
+	   #endif
+	   )
 	     {
+	       
+	     #ifdef FRCOV
+	       if (!(symtab_hdr -> sh_info != 0 ))
+	         fprintf(stderr, "triggered bug index 8118\n");
+	       #endif
+	     
 	       isymbuf = (Elf_Internal_Sym *) symtab_hdr->contents;
-	       if (isymbuf == NULL)
+	       
+	       #ifdef FRCOV
+	       {if (FIXREVERTER[8116]) {
+	         if ((isymbuf == (void *) 0 ) && !(0))
+	           fprintf(stderr, "triggered bug index 8116\n");
+	         else
+	           fprintf(stderr, "reached bug index 8116\n");
+	       }
+	       if ((!FIXREVERTER[8116] && (isymbuf == (void *) 0 ))
+	       #else
+	       if (0
+	       #endif
+	       )
 		 isymbuf = bfd_elf_get_elf_syms (abfd, symtab_hdr,
 						 symtab_hdr->sh_info, 0,
 						 NULL, NULL, NULL);
-	       if (isymbuf == NULL)
+						 #ifdef FRCOV
+						 }
+						 #endif
+	       
+	       #ifdef FRCOV
+	       {if (FIXREVERTER[8117]) {
+	         if ((isymbuf == (void *) 0 ) && !(0))
+	           fprintf(stderr, "triggered bug index 8117\n");
+	         else
+	           fprintf(stderr, "reached bug index 8117\n");
+	       }
+	       if ((!FIXREVERTER[8117] && (isymbuf == (void *) 0 ))
+	       #else
+	       if (0
+	       #endif
+	       )
 		 return false;
+		 #ifdef FRCOV
+		 }
+		 #endif
 	     }
+	     #ifdef FRCOV
+	     }
+	     #endif
 
 	   /* Get the value of the symbol referred to by the reloc.  */
 	   if (ELF32_R_SYM (irel->r_info) < symtab_hdr->sh_info)
@@ -2197,9 +2340,26 @@ retrieve_local_syms (bfd *input_bfd)
   locsymcount = symtab_hdr->sh_info;
 
   isymbuf = (Elf_Internal_Sym *) symtab_hdr->contents;
-  if (isymbuf == NULL && locsymcount != 0)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[8119]) {
+    fprintf(stderr, "reached bug index 8119\n");
+  }
+  if ((FIXREVERTER[8119] && (isymbuf == (void *) 0 )) || (!FIXREVERTER[8119] && (isymbuf == (void *) 0 && locsymcount != 0 ))
+  #else
+  if (isymbuf == (void *) 0 
+  #endif
+  )
+    
+    #ifdef FRCOV
+    {if (!(locsymcount != 0 ))
+      fprintf(stderr, "triggered bug index 8119\n");
+    #endif
     isymbuf = bfd_elf_get_elf_syms (input_bfd, symtab_hdr, locsymcount, 0,
 				    NULL, NULL, NULL);
+				    #ifdef FRCOV
+				    }}
+				    #endif
 
   /* Save the symbols for this input file so they won't be read again.  */
   if (isymbuf && isymbuf != (Elf_Internal_Sym *) symtab_hdr->contents)
@@ -2345,8 +2505,23 @@ avr_property_record_compare (const void *ap, const void *bp)
   const struct avr_property_record *b
     = (struct avr_property_record *) bp;
 
-  if (a->offset != b->offset)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[8120]) {
+    if ((a -> offset != b -> offset ) && !(0))
+      fprintf(stderr, "triggered bug index 8120\n");
+    else
+      fprintf(stderr, "reached bug index 8120\n");
+  }
+  if ((!FIXREVERTER[8120] && (a -> offset != b -> offset ))
+  #else
+  if (0
+  #endif
+  )
     return (a->offset - b->offset);
+    #ifdef FRCOV
+    }
+    #endif
 
   if (a->section != b->section)
     return bfd_section_vma (a->section) - bfd_section_vma (b->section);
@@ -2486,8 +2661,23 @@ elf32_avr_relax_section (bfd *abfd,
       (_("%P%F: --relax and -r may not be used together\n"));
 
   htab = avr_link_hash_table (link_info);
-  if (htab == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[8121]) {
+    if ((htab == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 8121\n");
+    else
+      fprintf(stderr, "reached bug index 8121\n");
+  }
+  if ((!FIXREVERTER[8121] && (htab == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     return false;
+    #ifdef FRCOV
+    }
+    #endif
 
   /* Assume nothing changes.  */
   *again = false;
@@ -2535,8 +2725,23 @@ elf32_avr_relax_section (bfd *abfd,
   /* Get a copy of the native relocations.  */
   internal_relocs = (_bfd_elf_link_read_relocs
 		     (abfd, sec, NULL, NULL, link_info->keep_memory));
-  if (internal_relocs == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[8122]) {
+    if ((internal_relocs == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 8122\n");
+    else
+      fprintf(stderr, "reached bug index 8122\n");
+  }
+  if ((!FIXREVERTER[8122] && (internal_relocs == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     goto error_return;
+    #ifdef FRCOV
+    }
+    #endif
 
   /* Walk through the relocs looking for relaxing opportunities.  */
   irelend = internal_relocs + sec->reloc_count;
@@ -2564,16 +2769,64 @@ elf32_avr_relax_section (bfd *abfd,
 	}
 
       /* Read this BFD's local symbols if we haven't done so already.  */
-      if (isymbuf == NULL && symtab_hdr->sh_info != 0)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[8125]) {
+        fprintf(stderr, "reached bug index 8125\n");
+      }
+      if ((FIXREVERTER[8125] && (isymbuf == (void *) 0 )) || (!FIXREVERTER[8125] && (isymbuf == (void *) 0 && symtab_hdr -> sh_info != 0 ))
+      #else
+      if (isymbuf == (void *) 0 
+      #endif
+      )
 	{
+	  
+	#ifdef FRCOV
+	  if (!(symtab_hdr -> sh_info != 0 ))
+	    fprintf(stderr, "triggered bug index 8125\n");
+	  #endif
+	
 	  isymbuf = (Elf_Internal_Sym *) symtab_hdr->contents;
-	  if (isymbuf == NULL)
+	  
+	  #ifdef FRCOV
+	  {if (FIXREVERTER[8123]) {
+	    if ((isymbuf == (void *) 0 ) && !(0))
+	      fprintf(stderr, "triggered bug index 8123\n");
+	    else
+	      fprintf(stderr, "reached bug index 8123\n");
+	  }
+	  if ((!FIXREVERTER[8123] && (isymbuf == (void *) 0 ))
+	  #else
+	  if (0
+	  #endif
+	  )
 	    isymbuf = bfd_elf_get_elf_syms (abfd, symtab_hdr,
 					    symtab_hdr->sh_info, 0,
 					    NULL, NULL, NULL);
-	  if (isymbuf == NULL)
+					    #ifdef FRCOV
+					    }
+					    #endif
+	  
+	  #ifdef FRCOV
+	  {if (FIXREVERTER[8124]) {
+	    if ((isymbuf == (void *) 0 ) && !(0))
+	      fprintf(stderr, "triggered bug index 8124\n");
+	    else
+	      fprintf(stderr, "reached bug index 8124\n");
+	  }
+	  if ((!FIXREVERTER[8124] && (isymbuf == (void *) 0 ))
+	  #else
+	  if (0
+	  #endif
+	  )
 	    goto error_return;
+	    #ifdef FRCOV
+	    }
+	    #endif
+	}
+	#ifdef FRCOV
 	}
+	#endif
 
 
       /* Get the value of the symbol referred to by the reloc.  */
@@ -2989,8 +3242,23 @@ elf32_avr_relax_section (bfd *abfd,
 			    Elf_Internal_Rela *relend;
 
 			    rel = elf_section_data (isec)->relocs;
-			    if (rel == NULL)
+			    
+			    #ifdef FRCOV
+			    {if (FIXREVERTER[8128]) {
+			      if ((rel == (void *) 0 ) && !(0))
+			        fprintf(stderr, "triggered bug index 8128\n");
+			      else
+			        fprintf(stderr, "reached bug index 8128\n");
+			    }
+			    if ((!FIXREVERTER[8128] && (rel == (void *) 0 ))
+			    #else
+			    if (0
+			    #endif
+			    )
 			      rel = _bfd_elf_link_read_relocs (abfd, isec, NULL, NULL, true);
+			      #ifdef FRCOV
+			      }
+			      #endif
 
 			    relend = rel + isec->reloc_count;
 
@@ -3000,19 +3268,67 @@ elf32_avr_relax_section (bfd *abfd,
 
 				/* Read this BFD's local symbols if we haven't
 				   done so already.  */
-				if (isymbuf == NULL && symtab_hdr->sh_info != 0)
+				
+				#ifdef FRCOV
+				{if (FIXREVERTER[8131]) {
+				  fprintf(stderr, "reached bug index 8131\n");
+				}
+				if ((FIXREVERTER[8131] && (isymbuf == (void *) 0 )) || (!FIXREVERTER[8131] && (isymbuf == (void *) 0 && symtab_hdr -> sh_info != 0 ))
+				#else
+				if (isymbuf == (void *) 0 
+				#endif
+				)
 				  {
+				    
+				  #ifdef FRCOV
+				    if (!(symtab_hdr -> sh_info != 0 ))
+				      fprintf(stderr, "triggered bug index 8131\n");
+				    #endif
+				  
 				    isymbuf = (Elf_Internal_Sym *)
 				      symtab_hdr->contents;
-				    if (isymbuf == NULL)
+				    
+				    #ifdef FRCOV
+				    {if (FIXREVERTER[8129]) {
+				      if ((isymbuf == (void *) 0 ) && !(0))
+				        fprintf(stderr, "triggered bug index 8129\n");
+				      else
+				        fprintf(stderr, "reached bug index 8129\n");
+				    }
+				    if ((!FIXREVERTER[8129] && (isymbuf == (void *) 0 ))
+				    #else
+				    if (0
+				    #endif
+				    )
 				      isymbuf = bfd_elf_get_elf_syms
 					(abfd,
 					 symtab_hdr,
 					 symtab_hdr->sh_info, 0,
 					 NULL, NULL, NULL);
-				    if (isymbuf == NULL)
+					 #ifdef FRCOV
+					 }
+					 #endif
+				    
+				    #ifdef FRCOV
+				    {if (FIXREVERTER[8130]) {
+				      if ((isymbuf == (void *) 0 ) && !(0))
+				        fprintf(stderr, "triggered bug index 8130\n");
+				      else
+				        fprintf(stderr, "reached bug index 8130\n");
+				    }
+				    if ((!FIXREVERTER[8130] && (isymbuf == (void *) 0 ))
+				    #else
+				    if (0
+				    #endif
+				    )
 				      break;
+				      #ifdef FRCOV
+				      }
+				      #endif
+				  }
+				  #ifdef FRCOV
 				  }
+				  #endif
 
 				/* Get the value of the symbol referred to
 				   by the reloc.  */
@@ -3222,18 +3538,63 @@ elf32_avr_get_relocated_section_contents (bfd *output_bfd,
 
       internal_relocs = (_bfd_elf_link_read_relocs
 			 (input_bfd, input_section, NULL, NULL, false));
-      if (internal_relocs == NULL)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[8133]) {
+        if ((internal_relocs == (void *) 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 8133\n");
+        else
+          fprintf(stderr, "reached bug index 8133\n");
+      }
+      if ((!FIXREVERTER[8133] && (internal_relocs == (void *) 0 ))
+      #else
+      if (0
+      #endif
+      )
 	goto error_return;
+	#ifdef FRCOV
+	}
+	#endif
 
       if (symtab_hdr->sh_info != 0)
 	{
 	  isymbuf = (Elf_Internal_Sym *) symtab_hdr->contents;
-	  if (isymbuf == NULL)
+	  
+	  #ifdef FRCOV
+	  {if (FIXREVERTER[8134]) {
+	    if ((isymbuf == (void *) 0 ) && !(0))
+	      fprintf(stderr, "triggered bug index 8134\n");
+	    else
+	      fprintf(stderr, "reached bug index 8134\n");
+	  }
+	  if ((!FIXREVERTER[8134] && (isymbuf == (void *) 0 ))
+	  #else
+	  if (0
+	  #endif
+	  )
 	    isymbuf = bfd_elf_get_elf_syms (input_bfd, symtab_hdr,
 					    symtab_hdr->sh_info, 0,
 					    NULL, NULL, NULL);
-	  if (isymbuf == NULL)
+					    #ifdef FRCOV
+					    }
+					    #endif
+	  
+	  #ifdef FRCOV
+	  {if (FIXREVERTER[8135]) {
+	    if ((isymbuf == (void *) 0 ) && !(0))
+	      fprintf(stderr, "triggered bug index 8135\n");
+	    else
+	      fprintf(stderr, "reached bug index 8135\n");
+	  }
+	  if ((!FIXREVERTER[8135] && (isymbuf == (void *) 0 ))
+	  #else
+	  if (0
+	  #endif
+	  )
 	    goto error_return;
+	    #ifdef FRCOV
+	    }
+	    #endif
 	}
 
       amt = symtab_hdr->sh_info;
@@ -3318,12 +3679,27 @@ avr_add_stub (const char *stub_name,
   /* Enter this entry into the linker stub hash table.  */
   hsh = avr_stub_hash_lookup (&htab->bstab, stub_name, true, false);
 
-  if (hsh == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[8136]) {
+    if ((hsh == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 8136\n");
+    else
+      fprintf(stderr, "reached bug index 8136\n");
+  }
+  if ((!FIXREVERTER[8136] && (hsh == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     {
       /* xgettext:c-format */
       _bfd_error_handler (_("cannot create stub entry %s"), stub_name);
       return NULL;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
   hsh->stub_offset = 0;
   return hsh;
@@ -3360,8 +3736,23 @@ avr_build_one_stub (struct bfd_hash_entry *bh, void *in_arg)
   info = (struct bfd_link_info *) in_arg;
 
   htab = avr_link_hash_table (info);
-  if (htab == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[8137]) {
+    if ((htab == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 8137\n");
+    else
+      fprintf(stderr, "reached bug index 8137\n");
+  }
+  if ((!FIXREVERTER[8137] && (htab == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     return false;
+    #ifdef FRCOV
+    }
+    #endif
 
   target = hsh->target_value;
 
@@ -3546,8 +3937,23 @@ get_local_syms (bfd *input_bfd, struct bfd_link_info *info)
   struct elf32_avr_link_hash_table *htab = avr_link_hash_table (info);
   size_t amt;
 
-  if (htab == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[8142]) {
+    if ((htab == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 8142\n");
+    else
+      fprintf(stderr, "reached bug index 8142\n");
+  }
+  if ((!FIXREVERTER[8142] && (htab == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     return -1;
+    #ifdef FRCOV
+    }
+    #endif
 
   /* We want to read in symbol extension records only once.  To do this
      we need to read in the local symbols in parallel and save them for
@@ -3555,8 +3961,23 @@ get_local_syms (bfd *input_bfd, struct bfd_link_info *info)
   amt = sizeof (Elf_Internal_Sym *) * htab->bfd_count;
   all_local_syms = bfd_zmalloc (amt);
   htab->all_local_syms = all_local_syms;
-  if (all_local_syms == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[8143]) {
+    if ((all_local_syms == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 8143\n");
+    else
+      fprintf(stderr, "reached bug index 8143\n");
+  }
+  if ((!FIXREVERTER[8143] && (all_local_syms == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     return -1;
+    #ifdef FRCOV
+    }
+    #endif
 
   /* Walk over all the input BFDs, swapping in local symbols.
      If we are creating a shared library, create hash entries for the
@@ -3569,8 +3990,23 @@ get_local_syms (bfd *input_bfd, struct bfd_link_info *info)
 
       /* We'll need the symbol table in a second.  */
       symtab_hdr = &elf_tdata (input_bfd)->symtab_hdr;
-      if (symtab_hdr->sh_info == 0)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[8144]) {
+        if ((symtab_hdr -> sh_info == 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 8144\n");
+        else
+          fprintf(stderr, "reached bug index 8144\n");
+      }
+      if ((!FIXREVERTER[8144] && (symtab_hdr -> sh_info == 0 ))
+      #else
+      if (0
+      #endif
+      )
 	continue;
+	#ifdef FRCOV
+	}
+	#endif
 
       /* We need an array of the local symbols attached to the input bfd.  */
       local_syms = (Elf_Internal_Sym *) symtab_hdr->contents;
@@ -3582,8 +4018,23 @@ get_local_syms (bfd *input_bfd, struct bfd_link_info *info)
 	  /* Cache them for elf_link_input_bfd.  */
 	  symtab_hdr->contents = (unsigned char *) local_syms;
 	}
-      if (local_syms == NULL)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[8145]) {
+        if ((local_syms == (void *) 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 8145\n");
+        else
+          fprintf(stderr, "reached bug index 8145\n");
+      }
+      if ((!FIXREVERTER[8145] && (local_syms == (void *) 0 ))
+      #else
+      if (0
+      #endif
+      )
 	return -1;
+	#ifdef FRCOV
+	}
+	#endif
 
       all_local_syms[bfd_indx] = local_syms;
     }
@@ -3914,8 +4365,23 @@ internal_reloc_compare (const void *ap, const void *bp)
   const Elf_Internal_Rela *a = (const Elf_Internal_Rela *) ap;
   const Elf_Internal_Rela *b = (const Elf_Internal_Rela *) bp;
 
-  if (a->r_offset != b->r_offset)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[8146]) {
+    if ((a -> r_offset != b -> r_offset ) && !(0))
+      fprintf(stderr, "triggered bug index 8146\n");
+    else
+      fprintf(stderr, "reached bug index 8146\n");
+  }
+  if ((!FIXREVERTER[8146] && (a -> r_offset != b -> r_offset ))
+  #else
+  if (0
+  #endif
+  )
     return (a->r_offset - b->r_offset);
+    #ifdef FRCOV
+    }
+    #endif
 
   /* We don't need to sort on these criteria for correctness,
      but enforcing a more strict ordering prevents unstable qsort
@@ -3924,8 +4390,23 @@ internal_reloc_compare (const void *ap, const void *bp)
      on Solaris 2.7 and 2.8.  We would like to always produce the
      same results no matter the host.  */
 
-  if (a->r_info != b->r_info)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[8147]) {
+    if ((a -> r_info != b -> r_info ) && !(0))
+      fprintf(stderr, "triggered bug index 8147\n");
+    else
+      fprintf(stderr, "reached bug index 8147\n");
+  }
+  if ((!FIXREVERTER[8147] && (a -> r_info != b -> r_info ))
+  #else
+  if (0
+  #endif
+  )
     return (a->r_info - b->r_info);
+    #ifdef FRCOV
+    }
+    #endif
 
   return (a->r_addend - b->r_addend);
 }
@@ -4045,8 +4526,23 @@ avr_elf32_load_records_from_section (bfd *abfd, asection *sec)
   mem_size = sizeof (struct avr_property_record_list)
     + sizeof (struct avr_property_record) * record_count;
   r_list = bfd_malloc (mem_size);
-  if (r_list == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[8151]) {
+    if ((r_list == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 8151\n");
+    else
+      fprintf(stderr, "reached bug index 8151\n");
+  }
+  if ((!FIXREVERTER[8151] && (r_list == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     goto load_failed;
+    #ifdef FRCOV
+    }
+    #endif
 
   r_list->version = version;
   r_list->flags = flags;
@@ -4121,11 +4617,26 @@ avr_elf32_load_records_from_section (bfd *abfd, asection *sec)
 				     &fs_data);
 	    }
 
-	  if (fs_data.section == NULL)
+	  
+	  #ifdef FRCOV
+	  {if (FIXREVERTER[8153]) {
+	    if ((fs_data . section == (void *) 0 ) && !(0))
+	      fprintf(stderr, "triggered bug index 8153\n");
+	    else
+	      fprintf(stderr, "reached bug index 8153\n");
+	  }
+	  if ((!FIXREVERTER[8153] && (fs_data . section == (void *) 0 ))
+	  #else
+	  if (0
+	  #endif
+	  )
 	    {
 	      fprintf (stderr, "Failed to find matching section.\n");
 	      goto load_failed;
 	    }
+	    #ifdef FRCOV
+	    }
+	    #endif
 
 	  r_list->records [i].section = fs_data.section;
 	  r_list->records [i].offset
@@ -4201,8 +4712,23 @@ avr_elf32_load_property_records (bfd *abfd)
 
   /* Find the '.avr.prop' section and load the contents into memory.  */
   sec = bfd_get_section_by_name (abfd, AVR_PROPERTY_RECORD_SECTION_NAME);
-  if (sec == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[8157]) {
+    if ((sec == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 8157\n");
+    else
+      fprintf(stderr, "reached bug index 8157\n");
+  }
+  if ((!FIXREVERTER[8157] && (sec == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     return NULL;
+    #ifdef FRCOV
+    }
+    #endif
   return avr_elf32_load_records_from_section (abfd, sec);
 }
 
diff --git a/bfd/elf32-avr.h b/bfd/elf32-avr.h
old mode 100644
new mode 100755
diff --git a/bfd/elf32-bfin.c b/bfd/elf32-bfin.c
old mode 100644
new mode 100755
diff --git a/bfd/elf32-bfin.h b/bfd/elf32-bfin.h
old mode 100644
new mode 100755
diff --git a/bfd/elf32-cr16.c b/bfd/elf32-cr16.c
old mode 100644
new mode 100755
index 2a1c8be..889e840
--- a/bfd/elf32-cr16.c
+++ b/bfd/elf32-cr16.c
@@ -1,3 +1,6 @@
+#ifdef FRCOV
+extern short FIXREVERTER[];
+#endif
 /* BFD back-end for National Semiconductor's CR16 ELF
    Copyright (C) 2007-2021 Free Software Foundation, Inc.
    Written by M R Swami Reddy.
@@ -998,8 +1001,23 @@ cr16_elf_final_link_relocate (reloc_howto_type *howto,
 	  Rvalue += Rvalue1;
 
 	  /* Check for range.  */
-	  if (Rvalue > 0xffff)
+	  
+	  #ifdef FRCOV
+	  {if (FIXREVERTER[10666]) {
+	    if ((Rvalue > 65535 ) && !(0))
+	      fprintf(stderr, "triggered bug index 10666\n");
+	    else
+	      fprintf(stderr, "reached bug index 10666\n");
+	  }
+	  if ((!FIXREVERTER[10666] && (Rvalue > 65535 ))
+	  #else
+	  if (0
+	  #endif
+	  )
 	    return bfd_reloc_overflow;
+	    #ifdef FRCOV
+	    }
+	    #endif
 	}
 
       bfd_put_16 (input_bfd, Rvalue, hit_data);
@@ -1015,8 +1033,23 @@ cr16_elf_final_link_relocate (reloc_howto_type *howto,
 	  Rvalue += Rvalue1;
 
 	  /* Check for range.  */
-	  if (Rvalue > 0xfffff)
+	  
+	  #ifdef FRCOV
+	  {if (FIXREVERTER[10667]) {
+	    if ((Rvalue > 1048575 ) && !(0))
+	      fprintf(stderr, "triggered bug index 10667\n");
+	    else
+	      fprintf(stderr, "reached bug index 10667\n");
+	  }
+	  if ((!FIXREVERTER[10667] && (Rvalue > 1048575 ))
+	  #else
+	  if (0
+	  #endif
+	  )
 	    return bfd_reloc_overflow;
+	    #ifdef FRCOV
+	    }
+	    #endif
 
 	  bfd_put_16 (input_bfd, ((bfd_get_16 (input_bfd, hit_data) & 0xfff0)
 				  | ((Rvalue >> 16) & 0xf)), hit_data);
@@ -1055,8 +1088,23 @@ cr16_elf_final_link_relocate (reloc_howto_type *howto,
 
 	  /* REVISIT: if ((long) Rvalue > 0xffffff ||
 	     (long) Rvalue < -0x800000).  */
-	  if (Rvalue > 0xffffff)
+	  
+	  #ifdef FRCOV
+	  {if (FIXREVERTER[10668]) {
+	    if ((Rvalue > 16777215 ) && !(0))
+	      fprintf(stderr, "triggered bug index 10668\n");
+	    else
+	      fprintf(stderr, "reached bug index 10668\n");
+	  }
+	  if ((!FIXREVERTER[10668] && (Rvalue > 16777215 ))
+	  #else
+	  if (0
+	  #endif
+	  )
 	    return bfd_reloc_overflow;
+	    #ifdef FRCOV
+	    }
+	    #endif
 
 
 	  bfd_put_16 (input_bfd, (bfd_get_16 (input_bfd, hit_data))
@@ -1108,8 +1156,23 @@ cr16_elf_final_link_relocate (reloc_howto_type *howto,
 	  /* Check for range.  */
 	  /* REVISIT: if ((long) Rvalue > 0xffffff
 	     || (long) Rvalue < -0x800000).  */
-	  if (Rvalue > 0xffffff)
+	  
+	  #ifdef FRCOV
+	  {if (FIXREVERTER[10669]) {
+	    if ((Rvalue > 16777215 ) && !(0))
+	      fprintf(stderr, "triggered bug index 10669\n");
+	    else
+	      fprintf(stderr, "reached bug index 10669\n");
+	  }
+	  if ((!FIXREVERTER[10669] && (Rvalue > 16777215 ))
+	  #else
+	  if (0
+	  #endif
+	  )
 	    return bfd_reloc_overflow;
+	    #ifdef FRCOV
+	    }
+	    #endif
 
 	  bfd_put_16 (input_bfd, (bfd_get_16 (input_bfd, hit_data))
 		      | (((Rvalue >> 16) & 0xf) << 8), hit_data);
@@ -1128,8 +1191,23 @@ cr16_elf_final_link_relocate (reloc_howto_type *howto,
 	      Rvalue += Rvalue1;
 
 	      /* Check for Range.  */
-	      if (Rvalue > 0xffffff)
+	      
+	      #ifdef FRCOV
+	      {if (FIXREVERTER[10670]) {
+	        if ((Rvalue > 16777215 ) && !(0))
+	          fprintf(stderr, "triggered bug index 10670\n");
+	        else
+	          fprintf(stderr, "reached bug index 10670\n");
+	      }
+	      if ((!FIXREVERTER[10670] && (Rvalue > 16777215 ))
+	      #else
+	      if (0
+	      #endif
+	      )
 		return bfd_reloc_overflow;
+		#ifdef FRCOV
+		}
+		#endif
 
 	      Rvalue = ((((Rvalue >> 20) & 0xf) | (((Rvalue >> 16) & 0xf)<<8)
 			 | (bfd_get_32 (input_bfd, hit_data) & 0xf0f0))
@@ -1151,8 +1229,23 @@ cr16_elf_final_link_relocate (reloc_howto_type *howto,
 	      Rvalue += Rvalue1;
 
 	      /* Check for range.  */
-	      if (Rvalue > 0xffffffff)
+	      
+	      #ifdef FRCOV
+	      {if (FIXREVERTER[10671]) {
+	        if ((Rvalue > -1 ) && !(0))
+	          fprintf(stderr, "triggered bug index 10671\n");
+	        else
+	          fprintf(stderr, "reached bug index 10671\n");
+	      }
+	      if ((!FIXREVERTER[10671] && (Rvalue > -1 ))
+	      #else
+	      if (0
+	      #endif
+	      )
 		return bfd_reloc_overflow;
+		#ifdef FRCOV
+		}
+		#endif
 
 	      Rvalue = (((Rvalue >> 16) & 0xffff) | (Rvalue & 0xffff) << 16);
 	    }
@@ -1173,8 +1266,23 @@ cr16_elf_final_link_relocate (reloc_howto_type *howto,
 	      Rvalue += Rvalue1;
 
 	      /* Check for range.  */
-	      if (Rvalue > 0xfffff)
+	      
+	      #ifdef FRCOV
+	      {if (FIXREVERTER[10672]) {
+	        if ((Rvalue > 1048575 ) && !(0))
+	          fprintf(stderr, "triggered bug index 10672\n");
+	        else
+	          fprintf(stderr, "reached bug index 10672\n");
+	      }
+	      if ((!FIXREVERTER[10672] && (Rvalue > 1048575 ))
+	      #else
+	      if (0
+	      #endif
+	      )
 		return bfd_reloc_overflow;
+		#ifdef FRCOV
+		}
+		#endif
 
 	      Rvalue = (((((Rvalue >> 20) & 0xf) | (((Rvalue >> 16) & 0xf) << 8)
 			  | ((Rvalue & 0xffff) << 16)))
@@ -1189,8 +1297,23 @@ cr16_elf_final_link_relocate (reloc_howto_type *howto,
 	      Rvalue += Rvalue1;
 
 	      /* Check for Range.  */
-	      if (Rvalue > 0xffffffff)
+	      
+	      #ifdef FRCOV
+	      {if (FIXREVERTER[10673]) {
+	        if ((Rvalue > -1 ) && !(0))
+	          fprintf(stderr, "triggered bug index 10673\n");
+	        else
+	          fprintf(stderr, "reached bug index 10673\n");
+	      }
+	      if ((!FIXREVERTER[10673] && (Rvalue > -1 ))
+	      #else
+	      if (0
+	      #endif
+	      )
 		return bfd_reloc_overflow;
+		#ifdef FRCOV
+		}
+		#endif
 	    }
 
 	  bfd_put_32 (input_bfd, Rvalue, hit_data);
@@ -1239,18 +1362,48 @@ elf32_cr16_relax_delete_bytes (struct bfd_link_info *link_info, bfd *abfd,
   /* Adjust all the relocs.  */
   for (irel = elf_section_data (sec)->relocs; irel < irelend; irel++)
     /* Get the new reloc address.  */
-    if ((irel->r_offset > addr && irel->r_offset < toaddr))
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[10674]) {
+      fprintf(stderr, "reached bug index 10674\n");
+    }
+    if ((FIXREVERTER[10674] && (irel -> r_offset > addr )) || (!FIXREVERTER[10674] && (irel -> r_offset > addr && irel -> r_offset < toaddr ))
+    #else
+    if (irel -> r_offset > addr 
+    #endif
+    )
+      
+      #ifdef FRCOV
+      {if (!(irel -> r_offset < toaddr ))
+        fprintf(stderr, "triggered bug index 10674\n");
+      #endif
       irel->r_offset -= count;
+      #ifdef FRCOV
+      }}
+      #endif
 
   /* Adjust the local symbols defined in this section.  */
   symtab_hdr = &elf_tdata (abfd)->symtab_hdr;
   isym = (Elf_Internal_Sym *) symtab_hdr->contents;
   for (isymend = isym + symtab_hdr->sh_info; isym < isymend; isym++)
     {
-      if (isym->st_shndx == sec_shndx
-	  && isym->st_value > addr
-	  && isym->st_value < toaddr)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[10675]) {
+        fprintf(stderr, "reached bug index 10675\n");
+      }
+      if ((FIXREVERTER[10675] && (isym -> st_shndx == sec_shndx && isym -> st_value > addr )) || (!FIXREVERTER[10675] && (isym -> st_shndx == sec_shndx && isym -> st_value > addr && isym -> st_value < toaddr ))
+      #else
+      if (isym -> st_shndx == sec_shndx && isym -> st_value > addr 
+      #endif
+      )
 	{
+	  
+	#ifdef FRCOV
+	  if (!(isym -> st_value < toaddr ))
+	    fprintf(stderr, "triggered bug index 10675\n");
+	  #endif
+	
 	  /* Adjust the addend of SWITCH relocations in this section,
 	     which reference this local symbol.  */
 #if 0
@@ -1286,6 +1439,9 @@ elf32_cr16_relax_delete_bytes (struct bfd_link_info *link_info, bfd *abfd,
 
 	  isym->st_value -= count;
 	}
+	#ifdef FRCOV
+	}
+	#endif
     }
 
   /* Now adjust the global symbols defined in this section.  */
@@ -1318,8 +1474,23 @@ elf32_cr16_relax_delete_bytes (struct bfd_link_info *link_info, bfd *abfd,
 	      break;
 
 	  /* Don't adjust the symbol again.  */
-	  if (cur_sym_hashes < sym_hashes)
+	  
+	  #ifdef FRCOV
+	  {if (FIXREVERTER[10676]) {
+	    if ((cur_sym_hashes < sym_hashes ) && !(0))
+	      fprintf(stderr, "triggered bug index 10676\n");
+	    else
+	      fprintf(stderr, "reached bug index 10676\n");
+	  }
+	  if ((!FIXREVERTER[10676] && (cur_sym_hashes < sym_hashes ))
+	  #else
+	  if (0
+	  #endif
+	  )
 	    continue;
+	    #ifdef FRCOV
+	    }
+	    #endif
 	}
 
       if ((sym_hash->root.type == bfd_link_hash_defined
@@ -1497,18 +1668,63 @@ elf32_cr16_get_relocated_section_contents (bfd *output_bfd,
 
       internal_relocs = _bfd_elf_link_read_relocs (input_bfd, input_section,
 						   NULL, NULL, false);
-      if (internal_relocs == NULL)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[10677]) {
+        if ((internal_relocs == (void *) 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 10677\n");
+        else
+          fprintf(stderr, "reached bug index 10677\n");
+      }
+      if ((!FIXREVERTER[10677] && (internal_relocs == (void *) 0 ))
+      #else
+      if (0
+      #endif
+      )
 	goto error_return;
+	#ifdef FRCOV
+	}
+	#endif
 
       if (symtab_hdr->sh_info != 0)
 	{
 	  isymbuf = (Elf_Internal_Sym *) symtab_hdr->contents;
-	  if (isymbuf == NULL)
+	  
+	  #ifdef FRCOV
+	  {if (FIXREVERTER[10678]) {
+	    if ((isymbuf == (void *) 0 ) && !(0))
+	      fprintf(stderr, "triggered bug index 10678\n");
+	    else
+	      fprintf(stderr, "reached bug index 10678\n");
+	  }
+	  if ((!FIXREVERTER[10678] && (isymbuf == (void *) 0 ))
+	  #else
+	  if (0
+	  #endif
+	  )
 	    isymbuf = bfd_elf_get_elf_syms (input_bfd, symtab_hdr,
 					    symtab_hdr->sh_info, 0,
 					    NULL, NULL, NULL);
-	  if (isymbuf == NULL)
+					    #ifdef FRCOV
+					    }
+					    #endif
+	  
+	  #ifdef FRCOV
+	  {if (FIXREVERTER[10679]) {
+	    if ((isymbuf == (void *) 0 ) && !(0))
+	      fprintf(stderr, "triggered bug index 10679\n");
+	    else
+	      fprintf(stderr, "reached bug index 10679\n");
+	  }
+	  if ((!FIXREVERTER[10679] && (isymbuf == (void *) 0 ))
+	  #else
+	  if (0
+	  #endif
+	  )
 	    goto error_return;
+	    #ifdef FRCOV
+	    }
+	    #endif
 	}
 
       amt = symtab_hdr->sh_info;
@@ -1722,8 +1938,23 @@ elf32_cr16_relax_section (bfd *abfd, asection *sec,
   /* Get a copy of the native relocations.  */
   internal_relocs = _bfd_elf_link_read_relocs (abfd, sec, NULL, NULL,
 					       link_info->keep_memory);
-  if (internal_relocs == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[10681]) {
+    if ((internal_relocs == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 10681\n");
+    else
+      fprintf(stderr, "reached bug index 10681\n");
+  }
+  if ((!FIXREVERTER[10681] && (internal_relocs == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     goto error_return;
+    #ifdef FRCOV
+    }
+    #endif
 
   /* Walk through them looking for relaxing opportunities.  */
   irelend = internal_relocs + sec->reloc_count;
@@ -1752,16 +1983,64 @@ elf32_cr16_relax_section (bfd *abfd, asection *sec,
 	}
 
       /* Read this BFD's local symbols if we haven't done so already.  */
-      if (isymbuf == NULL && symtab_hdr->sh_info != 0)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[10684]) {
+        fprintf(stderr, "reached bug index 10684\n");
+      }
+      if ((FIXREVERTER[10684] && (isymbuf == (void *) 0 )) || (!FIXREVERTER[10684] && (isymbuf == (void *) 0 && symtab_hdr -> sh_info != 0 ))
+      #else
+      if (isymbuf == (void *) 0 
+      #endif
+      )
 	{
+	  
+	#ifdef FRCOV
+	  if (!(symtab_hdr -> sh_info != 0 ))
+	    fprintf(stderr, "triggered bug index 10684\n");
+	  #endif
+	
 	  isymbuf = (Elf_Internal_Sym *) symtab_hdr->contents;
-	  if (isymbuf == NULL)
+	  
+	  #ifdef FRCOV
+	  {if (FIXREVERTER[10682]) {
+	    if ((isymbuf == (void *) 0 ) && !(0))
+	      fprintf(stderr, "triggered bug index 10682\n");
+	    else
+	      fprintf(stderr, "reached bug index 10682\n");
+	  }
+	  if ((!FIXREVERTER[10682] && (isymbuf == (void *) 0 ))
+	  #else
+	  if (0
+	  #endif
+	  )
 	    isymbuf = bfd_elf_get_elf_syms (abfd, symtab_hdr,
 					    symtab_hdr->sh_info, 0,
 					    NULL, NULL, NULL);
-	  if (isymbuf == NULL)
+					    #ifdef FRCOV
+					    }
+					    #endif
+	  
+	  #ifdef FRCOV
+	  {if (FIXREVERTER[10683]) {
+	    if ((isymbuf == (void *) 0 ) && !(0))
+	      fprintf(stderr, "triggered bug index 10683\n");
+	    else
+	      fprintf(stderr, "reached bug index 10683\n");
+	  }
+	  if ((!FIXREVERTER[10683] && (isymbuf == (void *) 0 ))
+	  #else
+	  if (0
+	  #endif
+	  )
 	    goto error_return;
+	    #ifdef FRCOV
+	    }
+	    #endif
+	}
+	#ifdef FRCOV
 	}
+	#endif
 
       /* Get the value of the symbol referred to by the reloc.  */
       if (ELF32_R_SYM (irel->r_info) < symtab_hdr->sh_info)
diff --git a/bfd/elf32-cr16.h b/bfd/elf32-cr16.h
old mode 100644
new mode 100755
diff --git a/bfd/elf32-cris.c b/bfd/elf32-cris.c
old mode 100644
new mode 100755
diff --git a/bfd/elf32-crx.c b/bfd/elf32-crx.c
old mode 100644
new mode 100755
diff --git a/bfd/elf32-csky.c b/bfd/elf32-csky.c
old mode 100644
new mode 100755
index 927fb90..bcfe3cf
--- a/bfd/elf32-csky.c
+++ b/bfd/elf32-csky.c
@@ -1,3 +1,6 @@
+#ifdef FRCOV
+extern short FIXREVERTER[];
+#endif
 /* 32-bit ELF support for C-SKY.
    Copyright (C) 1998-2021 Free Software Foundation, Inc.
    Contributed by C-SKY Microsystems and Mentor Graphics.
@@ -1676,8 +1679,23 @@ csky_allocate_dynrelocs (struct elf_link_hash_entry *h, PTR inf)
 
   info = (struct bfd_link_info *) inf;
   htab = csky_elf_hash_table (info);
-  if (htab == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[6224]) {
+    if ((htab == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 6224\n");
+    else
+      fprintf(stderr, "reached bug index 6224\n");
+  }
+  if ((!FIXREVERTER[6224] && (htab == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     return false;
+    #ifdef FRCOV
+    }
+    #endif
   /*TODO: how to deal with weak symbol relocs.  */
   if ((htab->elf.dynamic_sections_created || h->type == STT_GNU_IFUNC)
       && h->plt.refcount > 0)
@@ -1798,8 +1816,23 @@ csky_allocate_dynrelocs (struct elf_link_hash_entry *h, PTR inf)
     h->got.offset = (bfd_vma) -1;
 
   eh = (struct csky_elf_link_hash_entry *) h;
-  if (h->dyn_relocs == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[6225]) {
+    if ((h -> dyn_relocs == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 6225\n");
+    else
+      fprintf(stderr, "reached bug index 6225\n");
+  }
+  if ((!FIXREVERTER[6225] && (h -> dyn_relocs == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     return true;
+    #ifdef FRCOV
+    }
+    #endif
 
   /* In the shared -Bsymbolic case, discard space allocated for
      dynamic pc-relative relocs against symbols which turn out to be
@@ -2841,8 +2874,23 @@ csky_find_arch_with_name (const char *name)
   csky_arch_for_merge *csky_arch = NULL;
   const char *msg;
 
-  if (name == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[6244]) {
+    if ((name == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 6244\n");
+    else
+      fprintf(stderr, "reached bug index 6244\n");
+  }
+  if ((!FIXREVERTER[6244] && (name == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     return NULL;
+    #ifdef FRCOV
+    }
+    #endif
 
   for (csky_arch = csky_archs; csky_arch->name != NULL; csky_arch++)
     {
diff --git a/bfd/elf32-csky.h b/bfd/elf32-csky.h
old mode 100644
new mode 100755
diff --git a/bfd/elf32-d10v.c b/bfd/elf32-d10v.c
old mode 100644
new mode 100755
diff --git a/bfd/elf32-d30v.c b/bfd/elf32-d30v.c
old mode 100644
new mode 100755
diff --git a/bfd/elf32-dlx.c b/bfd/elf32-dlx.c
old mode 100644
new mode 100755
diff --git a/bfd/elf32-dlx.h b/bfd/elf32-dlx.h
old mode 100644
new mode 100755
diff --git a/bfd/elf32-epiphany.c b/bfd/elf32-epiphany.c
old mode 100644
new mode 100755
diff --git a/bfd/elf32-fr30.c b/bfd/elf32-fr30.c
old mode 100644
new mode 100755
diff --git a/bfd/elf32-frv.c b/bfd/elf32-frv.c
old mode 100644
new mode 100755
diff --git a/bfd/elf32-ft32.c b/bfd/elf32-ft32.c
old mode 100644
new mode 100755
diff --git a/bfd/elf32-gen.c b/bfd/elf32-gen.c
old mode 100644
new mode 100755
diff --git a/bfd/elf32-h8300.c b/bfd/elf32-h8300.c
old mode 100644
new mode 100755
diff --git a/bfd/elf32-hppa.c b/bfd/elf32-hppa.c
old mode 100644
new mode 100755
diff --git a/bfd/elf32-hppa.h b/bfd/elf32-hppa.h
old mode 100644
new mode 100755
diff --git a/bfd/elf32-i386.c b/bfd/elf32-i386.c
old mode 100644
new mode 100755
diff --git a/bfd/elf32-ip2k.c b/bfd/elf32-ip2k.c
old mode 100644
new mode 100755
diff --git a/bfd/elf32-iq2000.c b/bfd/elf32-iq2000.c
old mode 100644
new mode 100755
diff --git a/bfd/elf32-lm32.c b/bfd/elf32-lm32.c
old mode 100644
new mode 100755
index be8d416..66910dc
--- a/bfd/elf32-lm32.c
+++ b/bfd/elf32-lm32.c
@@ -1,3 +1,6 @@
+#ifdef FRCOV
+extern short FIXREVERTER[];
+#endif
 /* Lattice Mico32-specific support for 32-bit ELF
    Copyright (C) 2008-2021 Free Software Foundation, Inc.
    Contributed by Jon Beniston <jon@beniston.com>
@@ -1732,8 +1735,23 @@ allocate_dynrelocs (struct elf_link_hash_entry *h, void * inf)
 
   info = (struct bfd_link_info *) inf;
   htab = lm32_elf_hash_table (info);
-  if (htab == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[11441]) {
+    if ((htab == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 11441\n");
+    else
+      fprintf(stderr, "reached bug index 11441\n");
+  }
+  if ((!FIXREVERTER[11441] && (htab == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     return false;
+    #ifdef FRCOV
+    }
+    #endif
 
   if (htab->root.dynamic_sections_created
       && h->plt.refcount > 0)
@@ -1817,8 +1835,23 @@ allocate_dynrelocs (struct elf_link_hash_entry *h, void * inf)
   else
     h->got.offset = (bfd_vma) -1;
 
-  if (h->dyn_relocs == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[11442]) {
+    if ((h -> dyn_relocs == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 11442\n");
+    else
+      fprintf(stderr, "reached bug index 11442\n");
+  }
+  if ((!FIXREVERTER[11442] && (h -> dyn_relocs == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     return true;
+    #ifdef FRCOV
+    }
+    #endif
 
   /* In the shared -Bsymbolic case, discard space allocated for
      dynamic pc-relative relocs against symbols which turn out to be
diff --git a/bfd/elf32-m32c.c b/bfd/elf32-m32c.c
old mode 100644
new mode 100755
diff --git a/bfd/elf32-m32r.c b/bfd/elf32-m32r.c
old mode 100644
new mode 100755
diff --git a/bfd/elf32-m68hc11.c b/bfd/elf32-m68hc11.c
old mode 100644
new mode 100755
diff --git a/bfd/elf32-m68hc12.c b/bfd/elf32-m68hc12.c
old mode 100644
new mode 100755
diff --git a/bfd/elf32-m68hc1x.c b/bfd/elf32-m68hc1x.c
old mode 100644
new mode 100755
diff --git a/bfd/elf32-m68hc1x.h b/bfd/elf32-m68hc1x.h
old mode 100644
new mode 100755
diff --git a/bfd/elf32-m68k.c b/bfd/elf32-m68k.c
old mode 100644
new mode 100755
index 3b4565c..123e22e
--- a/bfd/elf32-m68k.c
+++ b/bfd/elf32-m68k.c
@@ -1,3 +1,6 @@
+#ifdef FRCOV
+extern short FIXREVERTER[];
+#endif
 /* Motorola 68k series support for 32-bit ELF
    Copyright (C) 1993-2021 Free Software Foundation, Inc.
 
@@ -1446,8 +1449,23 @@ elf_m68k_create_empty_got (struct bfd_link_info *info)
   struct elf_m68k_got *got;
 
   got = bfd_alloc (elf_hash_table (info)->dynobj, sizeof (*got));
-  if (got == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[11623]) {
+    if ((got == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 11623\n");
+    else
+      fprintf(stderr, "reached bug index 11623\n");
+  }
+  if ((!FIXREVERTER[11623] && (got == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     return NULL;
+    #ifdef FRCOV
+    }
+    #endif
 
   elf_m68k_init_got (got);
 
@@ -1573,11 +1591,26 @@ elf_m68k_get_got_entry (struct elf_m68k_got *got,
 				      (info),
 				      elf_m68k_got_entry_hash,
 				      elf_m68k_got_entry_eq, NULL);
-      if (got->entries == NULL)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[11624]) {
+        if ((got -> entries == (void *) 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 11624\n");
+        else
+          fprintf(stderr, "reached bug index 11624\n");
+      }
+      if ((!FIXREVERTER[11624] && (got -> entries == (void *) 0 ))
+      #else
+      if (0
+      #endif
+      )
 	{
 	  bfd_set_error (bfd_error_no_memory);
 	  return NULL;
 	}
+	#ifdef FRCOV
+	}
+	#endif
     }
 
   entry_.key_ = *key;
@@ -1607,8 +1640,23 @@ elf_m68k_get_got_entry (struct elf_m68k_got *got,
       BFD_ASSERT (howto != SEARCH);
 
       entry = bfd_alloc (elf_hash_table (info)->dynobj, sizeof (*entry));
-      if (entry == NULL)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[11625]) {
+        if ((entry == (void *) 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 11625\n");
+        else
+          fprintf(stderr, "reached bug index 11625\n");
+      }
+      if ((!FIXREVERTER[11625] && (entry == (void *) 0 ))
+      #else
+      if (0
+      #endif
+      )
 	return NULL;
+	#ifdef FRCOV
+	}
+	#endif
 
       /* Initialize new entry.  */
       entry->key_ = *key;
@@ -1932,11 +1980,26 @@ elf_m68k_can_merge_gots_1 (void **_entry_ptr, void *_arg)
 
       entry = elf_m68k_get_got_entry (arg->diff, &entry1->key_, MUST_CREATE,
 				      arg->info);
-      if (entry == NULL)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[11630]) {
+        if ((entry == (void *) 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 11630\n");
+        else
+          fprintf(stderr, "reached bug index 11630\n");
+      }
+      if ((!FIXREVERTER[11630] && (entry == (void *) 0 ))
+      #else
+      if (0
+      #endif
+      )
 	{
 	  arg->error_p = true;
 	  return 0;
 	}
+	#ifdef FRCOV
+	}
+	#endif
 
       entry->key_.type = type;
     }
@@ -2007,11 +2070,26 @@ elf_m68k_merge_gots_1 (void **entry_ptr, void *_arg)
 
   to = elf_m68k_get_got_entry (arg->big, &from->key_, FIND_OR_CREATE,
 			       arg->info);
-  if (to == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[11631]) {
+    if ((to == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 11631\n");
+    else
+      fprintf(stderr, "reached bug index 11631\n");
+  }
+  if ((!FIXREVERTER[11631] && (to == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     {
       arg->error_p = true;
       return 0;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
   BFD_ASSERT (to->u.s1.refcount == 0);
   /* All we need to merge is TYPE.  */
diff --git a/bfd/elf32-m68k.h b/bfd/elf32-m68k.h
old mode 100644
new mode 100755
diff --git a/bfd/elf32-mcore.c b/bfd/elf32-mcore.c
old mode 100644
new mode 100755
diff --git a/bfd/elf32-mep.c b/bfd/elf32-mep.c
old mode 100644
new mode 100755
diff --git a/bfd/elf32-metag.c b/bfd/elf32-metag.c
old mode 100644
new mode 100755
index 9847418..790eb95
--- a/bfd/elf32-metag.c
+++ b/bfd/elf32-metag.c
@@ -1,3 +1,6 @@
+#ifdef FRCOV
+extern short FIXREVERTER[];
+#endif
 /* Meta support for 32-bit ELF
    Copyright (C) 2013-2021 Free Software Foundation, Inc.
    Contributed by Imagination Technologies Ltd.
@@ -938,8 +941,23 @@ stub_hash_newfunc (struct bfd_hash_entry *entry,
     {
       entry = bfd_hash_allocate (table,
 				 sizeof (struct elf_metag_stub_hash_entry));
-      if (entry == NULL)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[9547]) {
+        if ((entry == (void *) 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 9547\n");
+        else
+          fprintf(stderr, "reached bug index 9547\n");
+      }
+      if ((!FIXREVERTER[9547] && (entry == (void *) 0 ))
+      #else
+      if (0
+      #endif
+      )
 	return entry;
+	#ifdef FRCOV
+	}
+	#endif
     }
 
   /* Call the allocation method of the superclass.  */
@@ -975,8 +993,23 @@ metag_link_hash_newfunc (struct bfd_hash_entry *entry,
     {
       entry = bfd_hash_allocate (table,
 				 sizeof (struct elf_metag_link_hash_entry));
-      if (entry == NULL)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[9548]) {
+        if ((entry == (void *) 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 9548\n");
+        else
+          fprintf(stderr, "reached bug index 9548\n");
+      }
+      if ((!FIXREVERTER[9548] && (entry == (void *) 0 ))
+      #else
+      if (0
+      #endif
+      )
 	return entry;
+	#ifdef FRCOV
+	}
+	#endif
     }
 
   /* Call the allocation method of the superclass.  */
diff --git a/bfd/elf32-metag.h b/bfd/elf32-metag.h
old mode 100644
new mode 100755
diff --git a/bfd/elf32-microblaze.c b/bfd/elf32-microblaze.c
old mode 100644
new mode 100755
diff --git a/bfd/elf32-mips.c b/bfd/elf32-mips.c
old mode 100644
new mode 100755
diff --git a/bfd/elf32-moxie.c b/bfd/elf32-moxie.c
old mode 100644
new mode 100755
diff --git a/bfd/elf32-msp430.c b/bfd/elf32-msp430.c
old mode 100644
new mode 100755
diff --git a/bfd/elf32-mt.c b/bfd/elf32-mt.c
old mode 100644
new mode 100755
diff --git a/bfd/elf32-nds32.c b/bfd/elf32-nds32.c
old mode 100644
new mode 100755
index 5eb0295..5f7e23d
--- a/bfd/elf32-nds32.c
+++ b/bfd/elf32-nds32.c
@@ -1,3 +1,6 @@
+#ifdef FRCOV
+extern short FIXREVERTER[];
+#endif
 /* NDS32-specific support for 32-bit ELF.
    Copyright (C) 2012-2021 Free Software Foundation, Inc.
    Contributed by Andes Technology Corporation.
@@ -2545,8 +2548,23 @@ nds32_insertion_sort (void *base, size_t nmemb, size_t size,
 
       j++;
 
-      if (i == j)
-	continue; /* i is in order.  */
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[6513]) {
+        if ((i == j ) && !(0))
+          fprintf(stderr, "triggered bug index 6513\n");
+        else
+          fprintf(stderr, "reached bug index 6513\n");
+      }
+      if ((!FIXREVERTER[6513] && (i == j ))
+      #else
+      if (0
+      #endif
+      )
+	continue;
+	#ifdef FRCOV
+	}
+	#endif /* i is in order.  */
 
       memcpy (tmp, ptr + i * size, size);
       memmove (ptr + (j + 1) * size, ptr + j * size, (i - j) * size);
@@ -2737,8 +2755,23 @@ nds32_elf_hi20_reloc (bfd *abfd ATTRIBUTE_UNUSED,
 
   /* Save the information, and let LO12 do the actual relocation.  */
   n = (struct nds32_hi20 *) bfd_malloc ((bfd_size_type) sizeof *n);
-  if (n == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[6514]) {
+    if ((n == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 6514\n");
+    else
+      fprintf(stderr, "reached bug index 6514\n");
+  }
+  if ((!FIXREVERTER[6514] && (n == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     return bfd_reloc_outofrange;
+    #ifdef FRCOV
+    }
+    #endif
 
   n->addr = (bfd_byte *) data + reloc_entry->address;
   n->addend = relocation;
@@ -3470,11 +3503,26 @@ nds32_elf_final_sda_base (bfd *output_bfd,
 	};
       size_t i = 0;
 
-      if (output_bfd->sections == NULL)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[6517]) {
+        if ((output_bfd -> sections == (void *) 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 6517\n");
+        else
+          fprintf(stderr, "reached bug index 6517\n");
+      }
+      if ((!FIXREVERTER[6517] && (output_bfd -> sections == (void *) 0 ))
+      #else
+      if (0
+      #endif
+      )
 	{
 	  *psb = elf_gp (output_bfd);
 	  return bfd_reloc_ok;
 	}
+	#ifdef FRCOV
+	}
+	#endif
 
       /* Get the first and final section.  */
       while (i < ARRAY_SIZE (sec_name))
@@ -4050,8 +4098,23 @@ allocate_dynrelocs (struct elf_link_hash_entry *h, void *inf)
   info = (struct bfd_link_info *) inf;
   ehtab = elf_hash_table (info);
   htab = nds32_elf_hash_table (info);
-  if (htab == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[6522]) {
+    if ((htab == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 6522\n");
+    else
+      fprintf(stderr, "reached bug index 6522\n");
+  }
+  if ((!FIXREVERTER[6522] && (htab == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     return false;
+    #ifdef FRCOV
+    }
+    #endif
 
   if ((htab->root.dynamic_sections_created || h->type == STT_GNU_IFUNC)
       && h->plt.refcount > 0
@@ -4164,8 +4227,23 @@ allocate_dynrelocs (struct elf_link_hash_entry *h, void *inf)
   else
     h->got.offset = (bfd_vma)-1;
 
-  if (h->dyn_relocs == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[6523]) {
+    if ((h -> dyn_relocs == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 6523\n");
+    else
+      fprintf(stderr, "reached bug index 6523\n");
+  }
+  if ((!FIXREVERTER[6523] && (h -> dyn_relocs == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     return true;
+    #ifdef FRCOV
+    }
+    #endif
 
   /* In the shared -Bsymbolic case, discard space allocated for
      dynamic pc-relative relocs against symbols which turn out to be
@@ -6950,8 +7028,23 @@ elf32_nds32_allocate_local_sym_info (bfd *abfd)
 			 + sizeof (bfd_vma) + sizeof (int)
 			 + sizeof (bool) + sizeof (bfd_vma));
       data = bfd_zalloc (abfd, size);
-      if (data == NULL)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[6539]) {
+        if ((data == (void *) 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 6539\n");
+        else
+          fprintf(stderr, "reached bug index 6539\n");
+      }
+      if ((!FIXREVERTER[6539] && (data == (void *) 0 ))
+      #else
+      if (0
+      #endif
+      )
 	return false;
+	#ifdef FRCOV
+	}
+	#endif
 
       elf_local_got_refcounts (abfd) = (bfd_signed_vma *) data;
       data += num_syms * sizeof (bfd_signed_vma);
@@ -8715,8 +8808,23 @@ is_convert_32_to_16 (bfd *abfd, asection *sec,
   int convert_type;
   bfd_vma offset;
 
-  if (reloc->r_offset + 4 > sec->size)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[6546]) {
+    if ((reloc -> r_offset + 4 > sec -> size ) && !(0))
+      fprintf(stderr, "triggered bug index 6546\n");
+    else
+      fprintf(stderr, "reached bug index 6546\n");
+  }
+  if ((!FIXREVERTER[6546] && (reloc -> r_offset + 4 > sec -> size ))
+  #else
+  if (0
+  #endif
+  )
     return false;
+    #ifdef FRCOV
+    }
+    #endif
 
   offset = reloc->r_offset;
 
@@ -8741,8 +8849,22 @@ is_convert_32_to_16 (bfd *abfd, asection *sec,
   while ((pc_rel - 1) >= internal_relocs && pc_rel[-1].r_offset == offset)
     pc_rel--;
 
-  for (; pc_rel < irelend && pc_rel->r_offset == offset; pc_rel++)
-    {
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[6548])
+    fprintf(stderr, "reached bug index 6548\n");
+  for (; (FIXREVERTER[6548] && (pc_rel < irelend )) || (!FIXREVERTER[6548] && (pc_rel < irelend && pc_rel -> r_offset == offset ))
+  #else
+  for (; pc_rel < irelend 
+  #endif
+  ; pc_rel++)
+    {
+      
+    #ifdef FRCOV
+      if (!(pc_rel -> r_offset == offset ))
+        fprintf(stderr, "triggered bug index 6548\n");
+      #endif
+    
       if (ELF32_R_TYPE (pc_rel->r_info) == R_NDS32_15_PCREL_RELA
 	  || ELF32_R_TYPE (pc_rel->r_info) == R_NDS32_17_PCREL_RELA
 	  || ELF32_R_TYPE (pc_rel->r_info) == R_NDS32_25_PCREL_RELA
@@ -8801,6 +8923,9 @@ is_convert_32_to_16 (bfd *abfd, asection *sec,
 	  break;
 	}
     }
+    #ifdef FRCOV
+    }
+    #endif
 
   return true;
 }
@@ -8823,8 +8948,22 @@ nds32_elf_write_16 (bfd *abfd ATTRIBUTE_UNUSED, bfd_byte *contents,
   while ((pc_rel - 1) > internal_relocs && pc_rel[-1].r_offset == offset)
     pc_rel--;
 
-  for (; pc_rel < irelend && pc_rel->r_offset == offset; pc_rel++)
-    {
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[6549])
+    fprintf(stderr, "reached bug index 6549\n");
+  for (; (FIXREVERTER[6549] && (pc_rel < irelend )) || (!FIXREVERTER[6549] && (pc_rel < irelend && pc_rel -> r_offset == offset ))
+  #else
+  for (; pc_rel < irelend 
+  #endif
+  ; pc_rel++)
+    {
+      
+    #ifdef FRCOV
+      if (!(pc_rel -> r_offset == offset ))
+        fprintf(stderr, "triggered bug index 6549\n");
+      #endif
+    
       if (ELF32_R_TYPE (pc_rel->r_info) == R_NDS32_15_PCREL_RELA
 	  || ELF32_R_TYPE (pc_rel->r_info) == R_NDS32_17_PCREL_RELA
 	  || ELF32_R_TYPE (pc_rel->r_info) == R_NDS32_25_PCREL_RELA)
@@ -8846,6 +8985,9 @@ nds32_elf_write_16 (bfd *abfd ATTRIBUTE_UNUSED, bfd_byte *contents,
 	pc_rel->r_info =
 	  ELF32_R_INFO (ELF32_R_SYM (pc_rel->r_info), R_NDS32_10IFCU_PCREL_RELA);
     }
+    #ifdef FRCOV
+    }
+    #endif
 }
 
 /* Find a relocation of type specified by `reloc_type'
@@ -8865,18 +9007,48 @@ find_relocs_at_address (Elf_Internal_Rela *reloc,
   Elf_Internal_Rela *rel_t;
 
   /* Find backward.  */
-  for (rel_t = reloc;
-       rel_t >= relocs && rel_t->r_offset == reloc->r_offset;
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[6550])
+    fprintf(stderr, "reached bug index 6550\n");
+  for (rel_t = reloc; (FIXREVERTER[6550] && (rel_t >= relocs )) || (!FIXREVERTER[6550] && (rel_t >= relocs && rel_t -> r_offset == reloc -> r_offset ))
+  #else
+  for (rel_t = reloc; rel_t >= relocs 
+  #endif
+  ;
        rel_t--)
+    
+    #ifdef FRCOV
+    {if (!(rel_t -> r_offset == reloc -> r_offset ))
+      fprintf(stderr, "triggered bug index 6550\n");
+    #endif
     if (ELF32_R_TYPE (rel_t->r_info) == reloc_type)
       return rel_t;
+      #ifdef FRCOV
+      }}
+      #endif
 
   /* We didn't find it backward.  Try find it forward.  */
-  for (rel_t = reloc;
-       rel_t < irelend && rel_t->r_offset == reloc->r_offset;
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[6551])
+    fprintf(stderr, "reached bug index 6551\n");
+  for (rel_t = reloc; (FIXREVERTER[6551] && (rel_t < irelend )) || (!FIXREVERTER[6551] && (rel_t < irelend && rel_t -> r_offset == reloc -> r_offset ))
+  #else
+  for (rel_t = reloc; rel_t < irelend 
+  #endif
+  ;
        rel_t++)
+    
+    #ifdef FRCOV
+    {if (!(rel_t -> r_offset == reloc -> r_offset ))
+      fprintf(stderr, "triggered bug index 6551\n");
+    #endif
     if (ELF32_R_TYPE (rel_t->r_info) == reloc_type)
       return rel_t;
+      #ifdef FRCOV
+      }}
+      #endif
 
   return irelend;
 }
@@ -8953,8 +9125,23 @@ create_nds32_elf_blank (bfd_vma offset_p, bfd_vma size_p)
   else
     blank_t = bfd_malloc (sizeof (nds32_elf_blank_t));
 
-  if (blank_t == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[6554]) {
+    if ((blank_t == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 6554\n");
+    else
+      fprintf(stderr, "reached bug index 6554\n");
+  }
+  if ((!FIXREVERTER[6554] && (blank_t == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     return NULL;
+    #ifdef FRCOV
+    }
+    #endif
 
   blank_t->offset = offset_p;
   blank_t->size = size_p;
@@ -9058,8 +9245,23 @@ insert_nds32_elf_blank (nds32_elf_blank_t **blank_p, bfd_vma addr, bfd_vma len)
   if (addr < blank_t->offset + blank_t->size)
     {
       /* Extend the origin blank.  */
-      if (addr + len > blank_t->offset + blank_t->size)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[6555]) {
+        if ((addr + len > blank_t -> offset + blank_t -> size  ) && !(0))
+          fprintf(stderr, "triggered bug index 6555\n");
+        else
+          fprintf(stderr, "reached bug index 6555\n");
+      }
+      if ((!FIXREVERTER[6555] && (addr + len > blank_t -> offset + blank_t -> size  ))
+      #else
+      if (0
+      #endif
+      )
 	blank_t->size = addr + len - blank_t->offset;
+	#ifdef FRCOV
+	}
+	#endif
     }
   else
     {
@@ -9179,8 +9381,23 @@ nds32_elf_relax_delete_blanks (bfd *abfd, asection *sec,
       symtab_hdr->contents = (bfd_byte *) isym;
     }
 
-  if (isym == NULL || symtab_hdr->sh_info == 0)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[6556]) {
+    if ((isym == (void *) 0 || symtab_hdr -> sh_info == 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 6556\n");
+    else
+      fprintf(stderr, "reached bug index 6556\n");
+  }
+  if ((!FIXREVERTER[6556] && (isym == (void *) 0 || symtab_hdr -> sh_info == 0 ))
+  #else
+  if (0
+  #endif
+  )
     return false;
+    #ifdef FRCOV
+    }
+    #endif
 
   blank_t = blank_head;
   calc_nds32_blank_total (blank_head);
@@ -9252,8 +9469,23 @@ nds32_elf_relax_delete_blanks (bfd *abfd, asection *sec,
 	      before = get_nds32_elf_blank_total (&blank_t, irel->r_addend, 0);
 	      between = get_nds32_elf_blank_total (&blank_t,
 						   irel->r_addend + offset, 0);
-	      if (between == before)
+	      
+	      #ifdef FRCOV
+	      {if (FIXREVERTER[6557]) {
+	        if ((between == before ) && !(0))
+	          fprintf(stderr, "triggered bug index 6557\n");
+	        else
+	          fprintf(stderr, "reached bug index 6557\n");
+	      }
+	      if ((!FIXREVERTER[6557] && (between == before ))
+	      #else
+	      if (0
+	      #endif
+	      )
 		goto done_adjust_diff;
+		#ifdef FRCOV
+		}
+		#endif
 
 	      switch (ELF32_R_TYPE (irel->r_info))
 		{
@@ -9285,8 +9517,23 @@ nds32_elf_relax_delete_blanks (bfd *abfd, asection *sec,
 	      before = get_nds32_elf_blank_total (&blank_t, irel->r_addend, 0);
 	      between = get_nds32_elf_blank_total (&blank_t,
 						   irel->r_addend + val, 0);
-	      if (between == before)
+	      
+	      #ifdef FRCOV
+	      {if (FIXREVERTER[6558]) {
+	        if ((between == before ) && !(0))
+	          fprintf(stderr, "triggered bug index 6558\n");
+	        else
+	          fprintf(stderr, "reached bug index 6558\n");
+	      }
+	      if ((!FIXREVERTER[6558] && (between == before ))
+	      #else
+	      if (0
+	      #endif
+	      )
 		goto done_adjust_diff;
+		#ifdef FRCOV
+		}
+		#endif
 
 	      p = contents + irel->r_offset;
 	      endp = p + len -1;
@@ -9740,9 +9987,24 @@ nds32_elf_relax_longcall2 (bfd *abfd, asection *sec, Elf_Internal_Rela *irel,
   cond_irelfn =
     find_relocs_at_address_addr (irel, internal_relocs, irelend,
 				 R_NDS32_17_PCREL_RELA, laddr);
-  if (cond_irelfn != irelend)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[6562]) {
+    if ((cond_irelfn != irelend  ) && !(0))
+      fprintf(stderr, "triggered bug index 6562\n");
+    else
+      fprintf(stderr, "reached bug index 6562\n");
+  }
+  if ((!FIXREVERTER[6562] && (cond_irelfn != irelend  ))
+  #else
+  if (0
+  #endif
+  )
     cond_irelfn->r_info =
       ELF32_R_INFO (ELF32_R_SYM (cond_irelfn->r_info), R_NDS32_NONE);
+      #ifdef FRCOV
+      }
+      #endif
 
   /* Replace the long call with a bgezal.  */
   irel->r_info = ELF32_R_INFO (ELF32_R_SYM (i1_irelfn->r_info),
@@ -10587,9 +10849,24 @@ nds32_elf_relax_longcall4 (bfd *abfd, asection *sec, Elf_Internal_Rela *irel,
 
   insn_irel = find_relocs_at_address_addr (irel, internal_relocs, irelend,
 					  R_NDS32_INSN16, irel->r_addend);
-  if (insn_irel != irelend)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[6565]) {
+    if ((insn_irel != irelend  ) && !(0))
+      fprintf(stderr, "triggered bug index 6565\n");
+    else
+      fprintf(stderr, "reached bug index 6565\n");
+  }
+  if ((!FIXREVERTER[6565] && (insn_irel != irelend  ))
+  #else
+  if (0
+  #endif
+  )
     insn_irel->r_info =
       ELF32_R_INFO (ELF32_R_SYM (irel->r_info), R_NDS32_NONE);
+      #ifdef FRCOV
+      }
+      #endif
 
   return true;
 }
@@ -10753,16 +11030,46 @@ nds32_elf_relax_longcall6 (bfd *abfd, asection *sec, Elf_Internal_Rela *irel,
       cond_irel =
 	find_relocs_at_address_addr (irel, internal_relocs, irelend,
 				     R_NDS32_17_PCREL_RELA, laddr);
-      if (cond_irel != irelend)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[6566]) {
+        if ((cond_irel != irelend  ) && !(0))
+          fprintf(stderr, "triggered bug index 6566\n");
+        else
+          fprintf(stderr, "reached bug index 6566\n");
+      }
+      if ((!FIXREVERTER[6566] && (cond_irel != irelend  ))
+      #else
+      if (0
+      #endif
+      )
 	cond_irel->r_info =
 	  ELF32_R_INFO (ELF32_R_SYM (cond_irel->r_info), R_NDS32_NONE);
+	  #ifdef FRCOV
+	  }
+	  #endif
 
       cond_irel =
 	find_relocs_at_address_addr (irel, internal_relocs, irelend,
 				     R_NDS32_INSN16, irel->r_addend);
-      if (cond_irel != irelend)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[6567]) {
+        if ((cond_irel != irelend  ) && !(0))
+          fprintf(stderr, "triggered bug index 6567\n");
+        else
+          fprintf(stderr, "reached bug index 6567\n");
+      }
+      if ((!FIXREVERTER[6567] && (cond_irel != irelend  ))
+      #else
+      if (0
+      #endif
+      )
 	cond_irel->r_info =
 	  ELF32_R_INFO (ELF32_R_SYM (cond_irel->r_info), R_NDS32_NONE);
+	  #ifdef FRCOV
+	  }
+	  #endif
 
     }
   else if (foff >= -CONSERVATIVE_24BIT_S1 && foff < CONSERVATIVE_24BIT_S1)
@@ -10797,9 +11104,24 @@ nds32_elf_relax_longcall6 (bfd *abfd, asection *sec, Elf_Internal_Rela *irel,
       cond_irel =
 	find_relocs_at_address_addr (irel, internal_relocs, irelend,
 				     R_NDS32_INSN16, irel->r_addend);
-      if (cond_irel != irelend)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[6568]) {
+        if ((cond_irel != irelend  ) && !(0))
+          fprintf(stderr, "triggered bug index 6568\n");
+        else
+          fprintf(stderr, "reached bug index 6568\n");
+      }
+      if ((!FIXREVERTER[6568] && (cond_irel != irelend  ))
+      #else
+      if (0
+      #endif
+      )
 	cond_irel->r_info =
 	  ELF32_R_INFO (ELF32_R_SYM (cond_irel->r_info), R_NDS32_NONE);
+	  #ifdef FRCOV
+	  }
+	  #endif
     }
   return true;
 }
@@ -11684,8 +12006,23 @@ nds32_elf_relax_ptr (bfd *abfd, asection *sec, Elf_Internal_Rela *irel,
       return false;
     }
 
-  if (re_irel->r_addend != 1)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[6576]) {
+    if ((re_irel -> r_addend != 1 ) && !(0))
+      fprintf(stderr, "triggered bug index 6576\n");
+    else
+      fprintf(stderr, "reached bug index 6576\n");
+  }
+  if ((!FIXREVERTER[6576] && (re_irel -> r_addend != 1 ))
+  #else
+  if (0
+  #endif
+  )
     return false;
+    #ifdef FRCOV
+    }
+    #endif
 
   /* Pointed target is relaxed and no longer needs this void *,
      change the type to NONE.  */
@@ -11837,12 +12174,28 @@ nds32_relax_adjust_label (bfd *abfd, asection *sec,
       while (insn_rel < irelend && insn_rel->r_offset < label_rel->r_offset)
 	insn_rel++;
 
-      for (;insn_rel < irelend && insn_rel->r_offset == label_rel->r_offset;
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[6577])
+        fprintf(stderr, "reached bug index 6577\n");
+      for (; (FIXREVERTER[6577] && (insn_rel < irelend )) || (!FIXREVERTER[6577] && (insn_rel < irelend && insn_rel -> r_offset == label_rel -> r_offset ))
+      #else
+      for (; insn_rel < irelend 
+      #endif
+      ;
 	   insn_rel++)
 	/* Check if there were R_NDS32_INSN16 and R_NDS32_LABEL at the same
 	   address.  */
+	
+	#ifdef FRCOV
+	{if (!(insn_rel -> r_offset == label_rel -> r_offset ))
+	  fprintf(stderr, "triggered bug index 6577\n");
+	#endif
 	if (ELF32_R_TYPE (insn_rel->r_info) == R_NDS32_INSN16)
 	  break;
+	  #ifdef FRCOV
+	  }}
+	  #endif
 
       if (insn_rel < irelend && insn_rel->r_offset == label_rel->r_offset
 	  && insn_rel < label_rel)
@@ -11867,8 +12220,23 @@ nds32_relax_adjust_label (bfd *abfd, asection *sec,
 	{
 	  if (label_rel == NULL)
 	    {
-	      if (tmp_rel->r_addend < 2)
+	      
+	      #ifdef FRCOV
+	      {if (FIXREVERTER[6579]) {
+	        if ((tmp_rel -> r_addend < 2 ) && !(0))
+	          fprintf(stderr, "triggered bug index 6579\n");
+	        else
+	          fprintf(stderr, "reached bug index 6579\n");
+	      }
+	      if ((!FIXREVERTER[6579] && (tmp_rel -> r_addend < 2 ))
+	      #else
+	      if (0
+	      #endif
+	      )
 		label_rel = tmp_rel;
+		#ifdef FRCOV
+		}
+		#endif
 	      continue;
 	    }
 	  else if (tmp_rel->r_addend > 1)
@@ -11877,8 +12245,23 @@ nds32_relax_adjust_label (bfd *abfd, asection *sec,
 		 including relocations with same offset as tmp_rel.  */
 	      for (tmp2_rel = label_rel; tmp2_rel < tmp_rel; tmp2_rel++)
 		{
-		  if (tmp2_rel->r_offset == tmp_rel->r_offset)
+		  
+		  #ifdef FRCOV
+		  {if (FIXREVERTER[6580]) {
+		    if ((tmp2_rel -> r_offset == tmp_rel -> r_offset ) && !(0))
+		      fprintf(stderr, "triggered bug index 6580\n");
+		    else
+		      fprintf(stderr, "reached bug index 6580\n");
+		  }
+		  if ((!FIXREVERTER[6580] && (tmp2_rel -> r_offset == tmp_rel -> r_offset ))
+		  #else
+		  if (0
+		  #endif
+		  )
 		    break;
+		    #ifdef FRCOV
+		    }
+		    #endif
 
 		  if (ELF32_R_TYPE (tmp2_rel->r_info) == R_NDS32_LABEL
 		      && tmp2_rel->r_addend < 2)
@@ -11906,9 +12289,22 @@ nds32_relax_adjust_label (bfd *abfd, asection *sec,
      We may convert a 16-bit instruction right before a label to
      32-bit, in order to align the label if necessary
      all reloc entries has been sorted by r_offset.  */
-  for (irel = internal_relocs;
-       irel < irelend && irel->r_offset < sec->size; irel++)
-    {
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[6582])
+    fprintf(stderr, "reached bug index 6582\n");
+  for (irel = internal_relocs; (FIXREVERTER[6582] && (irel < irelend )) || (!FIXREVERTER[6582] && (irel < irelend && irel -> r_offset < sec -> size ))
+  #else
+  for (irel = internal_relocs; irel < irelend 
+  #endif
+  ; irel++)
+    {
+      
+    #ifdef FRCOV
+      if (!(irel -> r_offset < sec -> size ))
+        fprintf(stderr, "triggered bug index 6582\n");
+      #endif
+    
       if (ELF32_R_TYPE (irel->r_info) != R_NDS32_INSN16
 	  && ELF32_R_TYPE (irel->r_info) != R_NDS32_LABEL)
 	continue;
@@ -11988,10 +12384,23 @@ nds32_relax_adjust_label (bfd *abfd, asection *sec,
 	      /* Search for INSN16 at LABEL location.  If INSN16 is at
 		 same location and this LABEL alignment is lower than 2,
 		 the INSN16 can be converted to 2-byte.  */
-	      for (tmp_rel = irel;
-		   tmp_rel < irelend && tmp_rel->r_offset == irel->r_offset;
+	      
+	      #ifdef FRCOV
+	      {if (FIXREVERTER[6581])
+	        fprintf(stderr, "reached bug index 6581\n");
+	      for (tmp_rel = irel; (FIXREVERTER[6581] && (tmp_rel < irelend )) || (!FIXREVERTER[6581] && (tmp_rel < irelend && tmp_rel -> r_offset == irel -> r_offset ))
+	      #else
+	      for (tmp_rel = irel; tmp_rel < irelend 
+	      #endif
+	      ;
 		   tmp_rel++)
 		{
+		  
+		#ifdef FRCOV
+		  if (!(tmp_rel -> r_offset == irel -> r_offset ))
+		    fprintf(stderr, "triggered bug index 6581\n");
+		  #endif
+		
 		  if (ELF32_R_TYPE (tmp_rel->r_info) == R_NDS32_INSN16
 		      && (is_convert_32_to_16
 			  (abfd, sec, tmp_rel, internal_relocs,
@@ -12002,6 +12411,9 @@ nds32_relax_adjust_label (bfd *abfd, asection *sec,
 		      break;
 		    }
 		}
+		#ifdef FRCOV
+		}
+		#endif
 	    }
 
 	  if (force_relax || irel->r_addend == 1 || address & 0x2)
@@ -12030,6 +12442,9 @@ nds32_relax_adjust_label (bfd *abfd, asection *sec,
 	  insn_rel = NULL;
 	}
     }
+    #ifdef FRCOV
+    }
+    #endif
 
   address =
     sec->size - get_nds32_elf_blank_total (relax_blank_list, sec->size, 0);
@@ -12101,8 +12516,23 @@ nds32_elf_relax_section (bfd *abfd, asection *sec,
   /* 09.12.11 Workaround.  */
   /*  We have to adjust align for R_NDS32_LABEL if needed.
       The adjust approach only can fix 2-byte align once.  */
-  if (sec->alignment_power > 2)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[6583]) {
+    if ((sec -> alignment_power > 2 ) && !(0))
+      fprintf(stderr, "triggered bug index 6583\n");
+    else
+      fprintf(stderr, "reached bug index 6583\n");
+  }
+  if ((!FIXREVERTER[6583] && (sec -> alignment_power > 2 ))
+  #else
+  if (0
+  #endif
+  )
     return true;
+    #ifdef FRCOV
+    }
+    #endif
 
   /* Do TLS model conversion once at first.  */
   nds32_elf_unify_tls_model (abfd, sec, contents, link_info);
@@ -12132,8 +12562,23 @@ nds32_elf_relax_section (bfd *abfd, asection *sec,
   /* Relocations MUST be kept in memory, because relaxation adjust them.  */
   internal_relocs = _bfd_elf_link_read_relocs (abfd, sec, NULL, NULL,
 					       true /* keep_memory */);
-  if (internal_relocs == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[6584]) {
+    if ((internal_relocs == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 6584\n");
+    else
+      fprintf(stderr, "reached bug index 6584\n");
+  }
+  if ((!FIXREVERTER[6584] && (internal_relocs == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     goto error_return;
+    #ifdef FRCOV
+    }
+    #endif
 
   irelend = internal_relocs + sec->reloc_count;
   irel = find_relocs_at_address (internal_relocs, internal_relocs,
@@ -12659,11 +13104,26 @@ nds32_fag_find_base (struct nds32_fag *head, struct nds32_fag **bestpp)
      and accumulate following fags which are inside the window,
      untill we each the end.  */
 
-  if (head->next == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[6587]) {
+    if ((head -> next == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 6587\n");
+    else
+      fprintf(stderr, "reached bug index 6587\n");
+  }
+  if ((!FIXREVERTER[6587] && (head -> next == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     {
       *bestpp = NULL;
       return 0;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
   /* Initialize base.  */
   base = head->next;
@@ -12742,8 +13202,23 @@ nds32_fag_mark_relax (struct bfd_link_info *link_info,
 	  insn16_rel = find_relocs_at_address
 	    (fag_rel, internal_relocs, irelend, R_NDS32_INSN16);
 
-	  if (insn16_rel != irelend)
+	  
+	  #ifdef FRCOV
+	  {if (FIXREVERTER[6588]) {
+	    if ((insn16_rel != irelend  ) && !(0))
+	      fprintf(stderr, "triggered bug index 6588\n");
+	    else
+	      fprintf(stderr, "reached bug index 6588\n");
+	  }
+	  if ((!FIXREVERTER[6588] && (insn16_rel != irelend  ))
+	  #else
+	  if (0
+	  #endif
+	  )
 	    insn16_rel->r_addend = R_NDS32_INSN16_FP7U2_FLAG;
+	    #ifdef FRCOV
+	    }
+	    #endif
 	}
     }
   return true;
@@ -12855,13 +13330,28 @@ nds32_relax_fp_as_gp (struct bfd_link_info *link_info,
 	  /* End of the region.
 	     Check whether it is worth to do fp-as-gp.  */
 
-	  if (begin_rel == NULL)
+	  
+	  #ifdef FRCOV
+	  {if (FIXREVERTER[6589]) {
+	    if ((begin_rel == (void *) 0 ) && !(0))
+	      fprintf(stderr, "triggered bug index 6589\n");
+	    else
+	      fprintf(stderr, "reached bug index 6589\n");
+	  }
+	  if ((!FIXREVERTER[6589] && (begin_rel == (void *) 0 ))
+	  #else
+	  if (0
+	  #endif
+	  )
 	    {
 	      /* xgettext:c-format */
 	      _bfd_error_handler (_("%pB: unmatched OMIT_FP in %pA"),
 				  abfd, sec);
 	      continue;
 	    }
+	    #ifdef FRCOV
+	    }
+	    #endif
 
 	  accu = nds32_fag_find_base (&fag_head, &best_fag);
 
@@ -13062,8 +13552,23 @@ nds32_elf_get_relocated_section_contents (bfd *abfd,
     return data;
 
   reloc_vector = (arelent **) bfd_malloc (reloc_size);
-  if (reloc_vector == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[6595]) {
+    if ((reloc_vector == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 6595\n");
+    else
+      fprintf(stderr, "reached bug index 6595\n");
+  }
+  if ((!FIXREVERTER[6595] && (reloc_vector == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     return NULL;
+    #ifdef FRCOV
+    }
+    #endif
 
   reloc_count = bfd_canonicalize_reloc (input_bfd, input_section,
 					reloc_vector, symbols);
@@ -13419,22 +13924,67 @@ elf32_nds32_unify_relax_group (bfd *abfd, asection *asec)
 
   do
     {
-      if (0 == relax_group_ptr->count)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[6600]) {
+        if ((0 == relax_group_ptr -> count ) && !(0))
+          fprintf(stderr, "triggered bug index 6600\n");
+        else
+          fprintf(stderr, "reached bug index 6600\n");
+      }
+      if ((!FIXREVERTER[6600] && (0 == relax_group_ptr -> count ))
+      #else
+      if (0
+      #endif
+      )
 	break;
+	#ifdef FRCOV
+	}
+	#endif
 
       /* Check if this section has been handled.  */
       node = elf32_nds32_lookup_section_id (asec->id, &relax_group_section_id_list);
-      if (NULL == node)
-	break; /* Hit, the section id has handled.  */
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[6601]) {
+        if (((void *) 0 == node ) && !(0))
+          fprintf(stderr, "triggered bug index 6601\n");
+        else
+          fprintf(stderr, "reached bug index 6601\n");
+      }
+      if ((!FIXREVERTER[6601] && ((void *) 0 == node ))
+      #else
+      if (0
+      #endif
+      )
+	break;
+	#ifdef FRCOV
+	}
+	#endif /* Hit, the section id has handled.  */
 
       /* Relocations MUST be kept in memory, because relaxation adjust them.  */
       relocs = _bfd_elf_link_read_relocs (abfd, asec, NULL, NULL,
 					  true /* keep_memory  */);
-      if (relocs == NULL)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[6602]) {
+        if ((relocs == (void *) 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 6602\n");
+        else
+          fprintf(stderr, "reached bug index 6602\n");
+      }
+      if ((!FIXREVERTER[6602] && (relocs == (void *) 0 ))
+      #else
+      if (0
+      #endif
+      )
 	{
 	  BFD_ASSERT (0); /* feed me */
 	  break;
 	}
+	#ifdef FRCOV
+	}
+	#endif
 
       /* Allocate group id bias for this bfd!  */
       if (0 == relax_group_ptr->init)
@@ -13500,8 +14050,23 @@ nds32_elf_unify_tls_model (bfd *inbfd, asection *insec, bfd_byte *incontents,
   /* Relocations MUST be kept in memory, because relaxation adjust them.  */
   internal_relocs = _bfd_elf_link_read_relocs (inbfd, insec, NULL, NULL,
 					       true /* keep_memory  */);
-  if (internal_relocs == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[6603]) {
+    if ((internal_relocs == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 6603\n");
+    else
+      fprintf(stderr, "reached bug index 6603\n");
+  }
+  if ((!FIXREVERTER[6603] && (internal_relocs == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     goto error_return;
+    #ifdef FRCOV
+    }
+    #endif
 
   irelend = internal_relocs + insec->reloc_count;
   irel = find_relocs_at_address (internal_relocs, internal_relocs,
diff --git a/bfd/elf32-nds32.h b/bfd/elf32-nds32.h
old mode 100644
new mode 100755
diff --git a/bfd/elf32-nios2.c b/bfd/elf32-nios2.c
old mode 100644
new mode 100755
index 5fb2e5d..09f9276
--- a/bfd/elf32-nios2.c
+++ b/bfd/elf32-nios2.c
@@ -1,3 +1,6 @@
+#ifdef FRCOV
+extern short FIXREVERTER[];
+#endif
 /* 32-bit ELF support for Nios II.
    Copyright (C) 2012-2021 Free Software Foundation, Inc.
    Contributed by Nigel Gray (ngray@altera.com).
@@ -1986,8 +1989,23 @@ stub_hash_newfunc (struct bfd_hash_entry *entry,
     {
       entry = bfd_hash_allocate (table,
 				 sizeof (struct elf32_nios2_stub_hash_entry));
-      if (entry == NULL)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[12301]) {
+        if ((entry == (void *) 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 12301\n");
+        else
+          fprintf(stderr, "reached bug index 12301\n");
+      }
+      if ((!FIXREVERTER[12301] && (entry == (void *) 0 ))
+      #else
+      if (0
+      #endif
+      )
 	return entry;
+	#ifdef FRCOV
+	}
+	#endif
     }
 
   /* Call the allocation method of the superclass.  */
@@ -2021,8 +2039,23 @@ link_hash_newfunc (struct bfd_hash_entry *entry,
     {
       entry = bfd_hash_allocate (table,
 				 sizeof (struct elf32_nios2_link_hash_entry));
-      if (entry == NULL)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[12302]) {
+        if ((entry == (void *) 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 12302\n");
+        else
+          fprintf(stderr, "reached bug index 12302\n");
+      }
+      if ((!FIXREVERTER[12302] && (entry == (void *) 0 ))
+      #else
+      if (0
+      #endif
+      )
 	return entry;
+	#ifdef FRCOV
+	}
+	#endif
     }
 
   /* Call the allocation method of the superclass.  */
diff --git a/bfd/elf32-nios2.h b/bfd/elf32-nios2.h
old mode 100644
new mode 100755
diff --git a/bfd/elf32-or1k.c b/bfd/elf32-or1k.c
old mode 100644
new mode 100755
diff --git a/bfd/elf32-pj.c b/bfd/elf32-pj.c
old mode 100644
new mode 100755
diff --git a/bfd/elf32-ppc.c b/bfd/elf32-ppc.c
old mode 100644
new mode 100755
index 34a6b3f..73e8176
--- a/bfd/elf32-ppc.c
+++ b/bfd/elf32-ppc.c
@@ -1,3 +1,6 @@
+#ifdef FRCOV
+extern short FIXREVERTER[];
+#endif
 /* PowerPC-specific support for 32-bit ELF
    Copyright (C) 1994-2021 Free Software Foundation, Inc.
    Written by Ian Lance Taylor, Cygnus Support.
@@ -2246,8 +2249,23 @@ ppc_elf_link_hash_newfunc (struct bfd_hash_entry *entry,
     {
       entry = bfd_hash_allocate (table,
 				 sizeof (struct ppc_elf_link_hash_entry));
-      if (entry == NULL)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[7110]) {
+        if ((entry == (void *) 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 7110\n");
+        else
+          fprintf(stderr, "reached bug index 7110\n");
+      }
+      if ((!FIXREVERTER[7110] && (entry == (void *) 0 ))
+      #else
+      if (0
+      #endif
+      )
 	return entry;
+	#ifdef FRCOV
+	}
+	#endif
     }
 
   /* Call the allocation method of the superclass.  */
diff --git a/bfd/elf32-ppc.h b/bfd/elf32-ppc.h
old mode 100644
new mode 100755
diff --git a/bfd/elf32-pru.c b/bfd/elf32-pru.c
old mode 100644
new mode 100755
diff --git a/bfd/elf32-rl78.c b/bfd/elf32-rl78.c
old mode 100644
new mode 100755
diff --git a/bfd/elf32-rx.c b/bfd/elf32-rx.c
old mode 100644
new mode 100755
index 7718635..7750679
--- a/bfd/elf32-rx.c
+++ b/bfd/elf32-rx.c
@@ -1,3 +1,6 @@
+#ifdef FRCOV
+extern short FIXREVERTER[];
+#endif
 /* Renesas RX specific support for 32-bit ELF.
    Copyright (C) 2008-2021 Free Software Foundation, Inc.
 
@@ -1634,19 +1637,48 @@ elf32_rx_relax_delete_bytes (bfd *abfd, asection *sec, bfd_vma addr, int count,
     {
       /* If the symbol is in the range of memory we just moved, we
 	 have to adjust its value.  */
-      if (isym->st_shndx == sec_shndx
-	  && isym->st_value > addr
-	  && isym->st_value < toaddr)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[3828]) {
+        fprintf(stderr, "reached bug index 3828\n");
+      }
+      if ((FIXREVERTER[3828] && (isym -> st_shndx == sec_shndx && isym -> st_value > addr )) || (!FIXREVERTER[3828] && (isym -> st_shndx == sec_shndx && isym -> st_value > addr && isym -> st_value < toaddr ))
+      #else
+      if (isym -> st_shndx == sec_shndx && isym -> st_value > addr 
+      #endif
+      )
+	
+	#ifdef FRCOV
+	{if (!(isym -> st_value < toaddr ))
+	  fprintf(stderr, "triggered bug index 3828\n");
+	#endif
 	isym->st_value -= count;
+	#ifdef FRCOV
+	}}
+	#endif
 
       /* If the symbol *spans* the bytes we just deleted (i.e. it's
 	 *end* is in the moved bytes but it's *start* isn't), then we
 	 must adjust its size.  */
-      if (isym->st_shndx == sec_shndx
-	  && isym->st_value < addr
-	  && isym->st_value + isym->st_size > addr
-	  && isym->st_value + isym->st_size < toaddr)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[3829]) {
+        fprintf(stderr, "reached bug index 3829\n");
+      }
+      if ((FIXREVERTER[3829] && (isym -> st_shndx == sec_shndx && isym -> st_value < addr && isym -> st_value + isym -> st_size > addr )) || (!FIXREVERTER[3829] && (isym -> st_shndx == sec_shndx && isym -> st_value < addr && isym -> st_value + isym -> st_size > addr && isym -> st_value + isym -> st_size < toaddr ))
+      #else
+      if (isym -> st_shndx == sec_shndx && isym -> st_value < addr && isym -> st_value + isym -> st_size > addr 
+      #endif
+      )
+	
+	#ifdef FRCOV
+	{if (!(isym -> st_value + isym -> st_size < toaddr ))
+	  fprintf(stderr, "triggered bug index 3829\n");
+	#endif
 	isym->st_size -= count;
+	#ifdef FRCOV
+	}}
+	#endif
     }
 
   /* Now adjust the global symbols defined in this section.  */
@@ -2074,8 +2106,23 @@ elf32_rx_relax_section (bfd *abfd,
       if (bfd_seek (abfd, shndx_hdr->sh_offset, SEEK_SET) != 0)
 	goto error_return;
       shndx_buf = _bfd_malloc_and_read (abfd, amt, amt);
-      if (shndx_buf == NULL)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[3830]) {
+        if ((shndx_buf == (void *) 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 3830\n");
+        else
+          fprintf(stderr, "reached bug index 3830\n");
+      }
+      if ((!FIXREVERTER[3830] && (shndx_buf == (void *) 0 ))
+      #else
+      if (0
+      #endif
+      )
 	goto error_return;
+	#ifdef FRCOV
+	}
+	#endif
       shndx_hdr->contents = shndx_buf;
     }
 
@@ -2087,8 +2134,23 @@ elf32_rx_relax_section (bfd *abfd,
      function itself being called multiple times on the same section...  */
   internal_relocs = _bfd_elf_link_read_relocs
     (abfd, sec, NULL, (Elf_Internal_Rela *) NULL, true);
-  if (internal_relocs == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[3831]) {
+    if ((internal_relocs == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 3831\n");
+    else
+      fprintf(stderr, "reached bug index 3831\n");
+  }
+  if ((!FIXREVERTER[3831] && (internal_relocs == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     goto error_return;
+    #ifdef FRCOV
+    }
+    #endif
 
   /* The RL_ relocs must be just before the operand relocs they go
      with, so we must sort them to guarantee this.  We use bubblesort
@@ -2170,8 +2232,23 @@ elf32_rx_relax_section (bfd *abfd,
 
 	  alignment = 1 << (irel->r_addend & RX_RELAXA_ANUM);
 
-	  if (erel->r_offset - irel->r_offset < alignment)
+	  
+	  #ifdef FRCOV
+	  {if (FIXREVERTER[3833]) {
+	    if ((erel -> r_offset - irel -> r_offset < alignment ) && !(0))
+	      fprintf(stderr, "triggered bug index 3833\n");
+	    else
+	      fprintf(stderr, "reached bug index 3833\n");
+	  }
+	  if ((!FIXREVERTER[3833] && (erel -> r_offset - irel -> r_offset < alignment ))
+	  #else
+	  if (0
+	  #endif
+	  )
 	    continue;
+	    #ifdef FRCOV
+	    }
+	    #endif
 
 	  nbytes = erel->r_offset - irel->r_offset;
 	  nbytes /= alignment;
@@ -2979,10 +3056,23 @@ elf32_rx_relax_section (bfd *abfd,
 	  /* The shortcut happens when the immediate is 0..255,
 	     register r0 to r7, and displacement (scaled) 0..31.  */
 
-	  if (0 <= imm_val && imm_val <= 255
-	      && 0 <= reg && reg <= 7
-	      && disp_val / dscale <= 31)
+	  
+	  #ifdef FRCOV
+	  {if (FIXREVERTER[3836]) {
+	    fprintf(stderr, "reached bug index 3836\n");
+	  }
+	  if ((FIXREVERTER[3836] && (0 <= imm_val && imm_val <= 255 && 0 <= reg && reg <= 7 )) || (!FIXREVERTER[3836] && (0 <= imm_val && imm_val <= 255 && 0 <= reg && reg <= 7 && disp_val / dscale <= 31 ))
+	  #else
+	  if (0 <= imm_val && imm_val <= 255 && 0 <= reg && reg <= 7 
+	  #endif
+	  )
 	    {
+	      
+	    #ifdef FRCOV
+	      if (!(disp_val / dscale <= 31 ))
+	        fprintf(stderr, "triggered bug index 3836\n");
+	      #endif
+	    
 	      insn[0] = 0x3c | (insn[1] & 0x03);
 	      insn[1] = (((disp_val / dscale) << 3) & 0x80) | (reg << 4) | ((disp_val/dscale) & 0x0f);
 	      insn[2] = imm_val;
@@ -3020,6 +3110,9 @@ elf32_rx_relax_section (bfd *abfd,
 	      /* We can't relax this new opcode.  */
 	      irel->r_addend = 0;
 	    }
+	    #ifdef FRCOV
+	    }
+	    #endif
 	}
     }
 
@@ -3457,8 +3550,23 @@ rx_get_section_contents (bfd *	       abfd,
 	  bfd_putb32 (bfd_getl32 (buf), buf);
 
 	  cnt = 4 - (offset % 4);
-	  if (cnt > count)
+	  
+	  #ifdef FRCOV
+	  {if (FIXREVERTER[3841]) {
+	    if ((cnt > count ) && !(0))
+	      fprintf(stderr, "triggered bug index 3841\n");
+	    else
+	      fprintf(stderr, "reached bug index 3841\n");
+	  }
+	  if ((!FIXREVERTER[3841] && (cnt > count ))
+	  #else
+	  if (0
+	  #endif
+	  )
 	    cnt = count;
+	    #ifdef FRCOV
+	    }
+	    #endif
 
 	  memcpy (location, buf + (offset % 4), cnt);
 
@@ -3606,8 +3714,23 @@ rx_set_section_contents (bfd *	       abfd,
       char * cloc = (char *) location;
 
       swapped_data = (char *) bfd_alloc (abfd, count);
-      if (swapped_data == NULL)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[3844]) {
+        if ((swapped_data == (void *) 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 3844\n");
+        else
+          fprintf(stderr, "reached bug index 3844\n");
+      }
+      if ((!FIXREVERTER[3844] && (swapped_data == (void *) 0 ))
+      #else
+      if (0
+      #endif
+      )
 	return false;
+	#ifdef FRCOV
+	}
+	#endif
 
       for (i = 0; i < count; i += 4)
 	{
@@ -3868,8 +3991,23 @@ rx_table_map_2 (struct bfd_hash_entry *vent, void *vinfo)
     if (addr == info->table_handlers[idx])
       info->table_entries[idx] = ent;
 
-  if (addr == info->table_default_handler)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[3847]) {
+    if ((addr == info -> table_default_handler  ) && !(0))
+      fprintf(stderr, "triggered bug index 3847\n");
+    else
+      fprintf(stderr, "reached bug index 3847\n");
+  }
+  if ((!FIXREVERTER[3847] && (addr == info -> table_default_handler  ))
+  #else
+  if (0
+  #endif
+  )
     info->table_default_entry = ent;
+    #ifdef FRCOV
+    }
+    #endif
 
   return true;
 }
diff --git a/bfd/elf32-rx.h b/bfd/elf32-rx.h
old mode 100644
new mode 100755
diff --git a/bfd/elf32-s12z.c b/bfd/elf32-s12z.c
old mode 100644
new mode 100755
diff --git a/bfd/elf32-s390.c b/bfd/elf32-s390.c
old mode 100644
new mode 100755
diff --git a/bfd/elf32-score.c b/bfd/elf32-score.c
old mode 100644
new mode 100755
diff --git a/bfd/elf32-score.h b/bfd/elf32-score.h
old mode 100644
new mode 100755
diff --git a/bfd/elf32-score7.c b/bfd/elf32-score7.c
old mode 100644
new mode 100755
diff --git a/bfd/elf32-sh-relocs.h b/bfd/elf32-sh-relocs.h
old mode 100644
new mode 100755
diff --git a/bfd/elf32-sh.c b/bfd/elf32-sh.c
old mode 100644
new mode 100755
diff --git a/bfd/elf32-sparc.c b/bfd/elf32-sparc.c
old mode 100644
new mode 100755
diff --git a/bfd/elf32-spu.c b/bfd/elf32-spu.c
old mode 100644
new mode 100755
index c3ce2c1..abe8d77
--- a/bfd/elf32-spu.c
+++ b/bfd/elf32-spu.c
@@ -1,3 +1,6 @@
+#ifdef FRCOV
+extern short FIXREVERTER[];
+#endif
 /* SPU specific support for 32-bit ELF
 
    Copyright (C) 2006-2021 Free Software Foundation, Inc.
@@ -252,8 +255,23 @@ spu_elf_new_section_hook (bfd *abfd, asection *sec)
       struct _spu_elf_section_data *sdata;
 
       sdata = bfd_zalloc (abfd, sizeof (*sdata));
-      if (sdata == NULL)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[6815]) {
+        if ((sdata == (void *) 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 6815\n");
+        else
+          fprintf(stderr, "reached bug index 6815\n");
+      }
+      if ((!FIXREVERTER[6815] && (sdata == (void *) 0 ))
+      #else
+      if (0
+      #endif
+      )
 	return false;
+	#ifdef FRCOV
+	}
+	#endif
       sec->used_by_bfd = sdata;
     }
 
@@ -538,12 +556,42 @@ get_sym_h (struct elf_link_hash_entry **hp,
       if (locsyms == NULL)
 	{
 	  locsyms = (Elf_Internal_Sym *) symtab_hdr->contents;
-	  if (locsyms == NULL)
+	  
+	  #ifdef FRCOV
+	  {if (FIXREVERTER[6817]) {
+	    if ((locsyms == (void *) 0 ) && !(0))
+	      fprintf(stderr, "triggered bug index 6817\n");
+	    else
+	      fprintf(stderr, "reached bug index 6817\n");
+	  }
+	  if ((!FIXREVERTER[6817] && (locsyms == (void *) 0 ))
+	  #else
+	  if (0
+	  #endif
+	  )
 	    locsyms = bfd_elf_get_elf_syms (ibfd, symtab_hdr,
 					    symtab_hdr->sh_info,
 					    0, NULL, NULL, NULL);
-	  if (locsyms == NULL)
+					    #ifdef FRCOV
+					    }
+					    #endif
+	  
+	  #ifdef FRCOV
+	  {if (FIXREVERTER[6818]) {
+	    if ((locsyms == (void *) 0 ) && !(0))
+	      fprintf(stderr, "triggered bug index 6818\n");
+	    else
+	      fprintf(stderr, "reached bug index 6818\n");
+	  }
+	  if ((!FIXREVERTER[6818] && (locsyms == (void *) 0 ))
+	  #else
+	  if (0
+	  #endif
+	  )
 	    return false;
+	    #ifdef FRCOV
+	    }
+	    #endif
 	  *locsymsp = locsyms;
 	}
       sym = locsyms + r_symndx;
@@ -1149,8 +1197,23 @@ count_stub (struct spu_link_hash_table *htab,
   if (g == NULL)
     {
       g = bfd_malloc (sizeof *g);
-      if (g == NULL)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[6829]) {
+        if ((g == (void *) 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 6829\n");
+        else
+          fprintf(stderr, "reached bug index 6829\n");
+      }
+      if ((!FIXREVERTER[6829] && (g == (void *) 0 ))
+      #else
+      if (0
+      #endif
+      )
 	return false;
+	#ifdef FRCOV
+	}
+	#endif
       g->ovl = ovl;
       g->addend = addend;
       g->stub_addr = (bfd_vma) -1;
@@ -1236,8 +1299,23 @@ build_stub (struct bfd_link_info *info,
   if (htab->params->ovly_flavour == ovly_soft_icache)
     {
       g = bfd_malloc (sizeof *g);
-      if (g == NULL)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[6831]) {
+        if ((g == (void *) 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 6831\n");
+        else
+          fprintf(stderr, "reached bug index 6831\n");
+      }
+      if ((!FIXREVERTER[6831] && (g == (void *) 0 ))
+      #else
+      if (0
+      #endif
+      )
 	return false;
+	#ifdef FRCOV
+	}
+	#endif
       g->ovl = ovl;
       g->br_addr = 0;
       if (irela != NULL)
@@ -1347,8 +1425,23 @@ build_stub (struct bfd_link_info *info,
 		      || caller->sp_adjust != (bfd_vma) -1)
 		    found = caller;
 		}
-	      if (found != NULL)
+	      
+	      #ifdef FRCOV
+	      {if (FIXREVERTER[6832]) {
+	        if ((found != (void *) 0 ) && !(0))
+	          fprintf(stderr, "triggered bug index 6832\n");
+	        else
+	          fprintf(stderr, "reached bug index 6832\n");
+	      }
+	      if ((!FIXREVERTER[6832] && (found != (void *) 0 ))
+	      #else
+	      if (0
+	      #endif
+	      )
 		caller = found;
+		#ifdef FRCOV
+		}
+		#endif
 	      off = (bfd_vma) -1;
 	    }
 
@@ -1388,10 +1481,25 @@ build_stub (struct bfd_link_info *info,
       if (stub_type > br000_ovl_stub)
 	lrlive = stub_type - br000_ovl_stub;
 
-      if (ovl == 0)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[6833]) {
+        if ((ovl == 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 6833\n");
+        else
+          fprintf(stderr, "reached bug index 6833\n");
+      }
+      if ((!FIXREVERTER[6833] && (ovl == 0 ))
+      #else
+      if (0
+      #endif
+      )
 	to = (htab->ovly_entry[1]->root.u.def.value
 	      + htab->ovly_entry[1]->root.u.def.section->output_offset
 	      + htab->ovly_entry[1]->root.u.def.section->output_section->vma);
+	      #ifdef FRCOV
+	      }
+	      #endif
 
       /* The branch that uses this stub goes to stub_addr + 4.  We'll
 	 set up an xor pattern that can be used by the icache manager
@@ -1446,8 +1554,23 @@ build_stub (struct bfd_link_info *info,
       if (add != 0)
 	len += 1 + 8;
       name = bfd_malloc (len + 1);
-      if (name == NULL)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[6835]) {
+        if ((name == (void *) 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 6835\n");
+        else
+          fprintf(stderr, "reached bug index 6835\n");
+      }
+      if ((!FIXREVERTER[6835] && (name == (void *) 0 ))
+      #else
+      if (0
+      #endif
+      )
 	return false;
+	#ifdef FRCOV
+	}
+	#endif
 
       sprintf (name, "%08x.ovl_call.", g->ovl);
       if (h != NULL)
@@ -1461,8 +1584,23 @@ build_stub (struct bfd_link_info *info,
 
       h = elf_link_hash_lookup (&htab->elf, name, true, true, false);
       free (name);
-      if (h == NULL)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[6836]) {
+        if ((h == (void *) 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 6836\n");
+        else
+          fprintf(stderr, "reached bug index 6836\n");
+      }
+      if ((!FIXREVERTER[6836] && (h == (void *) 0 ))
+      #else
+      if (0
+      #endif
+      )
 	return false;
+	#ifdef FRCOV
+	}
+	#endif
       if (h->root.type == bfd_link_hash_new)
 	{
 	  h->root.type = bfd_link_hash_defined;
@@ -1555,8 +1693,23 @@ process_stubs (struct bfd_link_info *info, bool build)
 
       /* We'll need the symbol table in a second.  */
       symtab_hdr = &elf_tdata (ibfd)->symtab_hdr;
-      if (symtab_hdr->sh_info == 0)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[6837]) {
+        if ((symtab_hdr -> sh_info == 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 6837\n");
+        else
+          fprintf(stderr, "reached bug index 6837\n");
+      }
+      if ((!FIXREVERTER[6837] && (symtab_hdr -> sh_info == 0 ))
+      #else
+      if (0
+      #endif
+      )
 	continue;
+	#ifdef FRCOV
+	}
+	#endif
 
       /* Walk over each section attached to the input bfd.  */
       for (isec = ibfd->sections; isec != NULL; isec = isec->next)
@@ -1574,8 +1727,23 @@ process_stubs (struct bfd_link_info *info, bool build)
 	  /* Get the relocs.  */
 	  internal_relocs = _bfd_elf_link_read_relocs (ibfd, isec, NULL, NULL,
 						       info->keep_memory);
-	  if (internal_relocs == NULL)
+	  
+	  #ifdef FRCOV
+	  {if (FIXREVERTER[6838]) {
+	    if ((internal_relocs == (void *) 0 ) && !(0))
+	      fprintf(stderr, "triggered bug index 6838\n");
+	    else
+	      fprintf(stderr, "reached bug index 6838\n");
+	  }
+	  if ((!FIXREVERTER[6838] && (internal_relocs == (void *) 0 ))
+	  #else
+	  if (0
+	  #endif
+	  )
 	    goto error_ret_free_local;
+	    #ifdef FRCOV
+	    }
+	    #endif
 
 	  /* Now examine each relocation.  */
 	  irela = internal_relocs;
@@ -1620,8 +1788,23 @@ process_stubs (struct bfd_link_info *info, bool build)
 		  bfd_size_type amt;
 		  amt = (htab->num_overlays + 1) * sizeof (*htab->stub_count);
 		  htab->stub_count = bfd_zmalloc (amt);
-		  if (htab->stub_count == NULL)
+		  
+		  #ifdef FRCOV
+		  {if (FIXREVERTER[6839]) {
+		    if ((htab -> stub_count == (void *) 0 ) && !(0))
+		      fprintf(stderr, "triggered bug index 6839\n");
+		    else
+		      fprintf(stderr, "reached bug index 6839\n");
+		  }
+		  if ((!FIXREVERTER[6839] && (htab -> stub_count == (void *) 0 ))
+		  #else
+		  if (0
+		  #endif
+		  )
 		    goto error_ret_free_internal;
+		    #ifdef FRCOV
+		    }
+		    #endif
 		}
 
 	      if (!build)
@@ -1891,8 +2074,23 @@ define_ovtab_symbol (struct spu_link_hash_table *htab, const char *name)
   struct elf_link_hash_entry *h;
 
   h = elf_link_hash_lookup (&htab->elf, name, true, false, false);
-  if (h == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[6842]) {
+    if ((h == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 6842\n");
+    else
+      fprintf(stderr, "reached bug index 6842\n");
+  }
+  if ((!FIXREVERTER[6842] && (h == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     return NULL;
+    #ifdef FRCOV
+    }
+    #endif
 
   if (h->root.type != bfd_link_hash_defined
       || !h->def_regular)
@@ -2009,91 +2207,301 @@ spu_elf_build_stubs (struct bfd_link_info *info)
       bfd_vma off;
 
       h = define_ovtab_symbol (htab, "__icache_tag_array");
-      if (h == NULL)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[6843]) {
+        if ((h == (void *) 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 6843\n");
+        else
+          fprintf(stderr, "reached bug index 6843\n");
+      }
+      if ((!FIXREVERTER[6843] && (h == (void *) 0 ))
+      #else
+      if (0
+      #endif
+      )
 	return false;
+	#ifdef FRCOV
+	}
+	#endif
       h->root.u.def.value = 0;
       h->size = 16 << htab->num_lines_log2;
       off = h->size;
 
       h = define_ovtab_symbol (htab, "__icache_tag_array_size");
-      if (h == NULL)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[6844]) {
+        if ((h == (void *) 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 6844\n");
+        else
+          fprintf(stderr, "reached bug index 6844\n");
+      }
+      if ((!FIXREVERTER[6844] && (h == (void *) 0 ))
+      #else
+      if (0
+      #endif
+      )
 	return false;
+	#ifdef FRCOV
+	}
+	#endif
       h->root.u.def.value = 16 << htab->num_lines_log2;
       h->root.u.def.section = bfd_abs_section_ptr;
 
       h = define_ovtab_symbol (htab, "__icache_rewrite_to");
-      if (h == NULL)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[6845]) {
+        if ((h == (void *) 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 6845\n");
+        else
+          fprintf(stderr, "reached bug index 6845\n");
+      }
+      if ((!FIXREVERTER[6845] && (h == (void *) 0 ))
+      #else
+      if (0
+      #endif
+      )
 	return false;
+	#ifdef FRCOV
+	}
+	#endif
       h->root.u.def.value = off;
       h->size = 16 << htab->num_lines_log2;
       off += h->size;
 
       h = define_ovtab_symbol (htab, "__icache_rewrite_to_size");
-      if (h == NULL)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[6846]) {
+        if ((h == (void *) 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 6846\n");
+        else
+          fprintf(stderr, "reached bug index 6846\n");
+      }
+      if ((!FIXREVERTER[6846] && (h == (void *) 0 ))
+      #else
+      if (0
+      #endif
+      )
 	return false;
+	#ifdef FRCOV
+	}
+	#endif
       h->root.u.def.value = 16 << htab->num_lines_log2;
       h->root.u.def.section = bfd_abs_section_ptr;
 
       h = define_ovtab_symbol (htab, "__icache_rewrite_from");
-      if (h == NULL)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[6847]) {
+        if ((h == (void *) 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 6847\n");
+        else
+          fprintf(stderr, "reached bug index 6847\n");
+      }
+      if ((!FIXREVERTER[6847] && (h == (void *) 0 ))
+      #else
+      if (0
+      #endif
+      )
 	return false;
+	#ifdef FRCOV
+	}
+	#endif
       h->root.u.def.value = off;
       h->size = 16 << (htab->fromelem_size_log2 + htab->num_lines_log2);
       off += h->size;
 
       h = define_ovtab_symbol (htab, "__icache_rewrite_from_size");
-      if (h == NULL)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[6848]) {
+        if ((h == (void *) 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 6848\n");
+        else
+          fprintf(stderr, "reached bug index 6848\n");
+      }
+      if ((!FIXREVERTER[6848] && (h == (void *) 0 ))
+      #else
+      if (0
+      #endif
+      )
 	return false;
+	#ifdef FRCOV
+	}
+	#endif
       h->root.u.def.value = 16 << (htab->fromelem_size_log2
 				   + htab->num_lines_log2);
       h->root.u.def.section = bfd_abs_section_ptr;
 
       h = define_ovtab_symbol (htab, "__icache_log2_fromelemsize");
-      if (h == NULL)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[6849]) {
+        if ((h == (void *) 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 6849\n");
+        else
+          fprintf(stderr, "reached bug index 6849\n");
+      }
+      if ((!FIXREVERTER[6849] && (h == (void *) 0 ))
+      #else
+      if (0
+      #endif
+      )
 	return false;
+	#ifdef FRCOV
+	}
+	#endif
       h->root.u.def.value = htab->fromelem_size_log2;
       h->root.u.def.section = bfd_abs_section_ptr;
 
       h = define_ovtab_symbol (htab, "__icache_base");
-      if (h == NULL)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[6850]) {
+        if ((h == (void *) 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 6850\n");
+        else
+          fprintf(stderr, "reached bug index 6850\n");
+      }
+      if ((!FIXREVERTER[6850] && (h == (void *) 0 ))
+      #else
+      if (0
+      #endif
+      )
 	return false;
+	#ifdef FRCOV
+	}
+	#endif
       h->root.u.def.value = htab->ovl_sec[0]->vma;
       h->root.u.def.section = bfd_abs_section_ptr;
       h->size = htab->num_buf << htab->line_size_log2;
 
       h = define_ovtab_symbol (htab, "__icache_linesize");
-      if (h == NULL)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[6851]) {
+        if ((h == (void *) 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 6851\n");
+        else
+          fprintf(stderr, "reached bug index 6851\n");
+      }
+      if ((!FIXREVERTER[6851] && (h == (void *) 0 ))
+      #else
+      if (0
+      #endif
+      )
 	return false;
+	#ifdef FRCOV
+	}
+	#endif
       h->root.u.def.value = 1 << htab->line_size_log2;
       h->root.u.def.section = bfd_abs_section_ptr;
 
       h = define_ovtab_symbol (htab, "__icache_log2_linesize");
-      if (h == NULL)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[6852]) {
+        if ((h == (void *) 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 6852\n");
+        else
+          fprintf(stderr, "reached bug index 6852\n");
+      }
+      if ((!FIXREVERTER[6852] && (h == (void *) 0 ))
+      #else
+      if (0
+      #endif
+      )
 	return false;
+	#ifdef FRCOV
+	}
+	#endif
       h->root.u.def.value = htab->line_size_log2;
       h->root.u.def.section = bfd_abs_section_ptr;
 
       h = define_ovtab_symbol (htab, "__icache_neg_log2_linesize");
-      if (h == NULL)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[6853]) {
+        if ((h == (void *) 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 6853\n");
+        else
+          fprintf(stderr, "reached bug index 6853\n");
+      }
+      if ((!FIXREVERTER[6853] && (h == (void *) 0 ))
+      #else
+      if (0
+      #endif
+      )
 	return false;
+	#ifdef FRCOV
+	}
+	#endif
       h->root.u.def.value = -htab->line_size_log2;
       h->root.u.def.section = bfd_abs_section_ptr;
 
       h = define_ovtab_symbol (htab, "__icache_cachesize");
-      if (h == NULL)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[6854]) {
+        if ((h == (void *) 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 6854\n");
+        else
+          fprintf(stderr, "reached bug index 6854\n");
+      }
+      if ((!FIXREVERTER[6854] && (h == (void *) 0 ))
+      #else
+      if (0
+      #endif
+      )
 	return false;
+	#ifdef FRCOV
+	}
+	#endif
       h->root.u.def.value = 1 << (htab->num_lines_log2 + htab->line_size_log2);
       h->root.u.def.section = bfd_abs_section_ptr;
 
       h = define_ovtab_symbol (htab, "__icache_log2_cachesize");
-      if (h == NULL)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[6855]) {
+        if ((h == (void *) 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 6855\n");
+        else
+          fprintf(stderr, "reached bug index 6855\n");
+      }
+      if ((!FIXREVERTER[6855] && (h == (void *) 0 ))
+      #else
+      if (0
+      #endif
+      )
 	return false;
+	#ifdef FRCOV
+	}
+	#endif
       h->root.u.def.value = htab->num_lines_log2 + htab->line_size_log2;
       h->root.u.def.section = bfd_abs_section_ptr;
 
       h = define_ovtab_symbol (htab, "__icache_neg_log2_cachesize");
-      if (h == NULL)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[6856]) {
+        if ((h == (void *) 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 6856\n");
+        else
+          fprintf(stderr, "reached bug index 6856\n");
+      }
+      if ((!FIXREVERTER[6856] && (h == (void *) 0 ))
+      #else
+      if (0
+      #endif
+      )
 	return false;
+	#ifdef FRCOV
+	}
+	#endif
       h->root.u.def.value = -(htab->num_lines_log2 + htab->line_size_log2);
       h->root.u.def.section = bfd_abs_section_ptr;
 
@@ -2105,8 +2513,23 @@ spu_elf_build_stubs (struct bfd_link_info *info)
 	    return false;
 
 	  h = define_ovtab_symbol (htab, "__icache_fileoff");
-	  if (h == NULL)
+	  
+	  #ifdef FRCOV
+	  {if (FIXREVERTER[6857]) {
+	    if ((h == (void *) 0 ) && !(0))
+	      fprintf(stderr, "triggered bug index 6857\n");
+	    else
+	      fprintf(stderr, "reached bug index 6857\n");
+	  }
+	  if ((!FIXREVERTER[6857] && (h == (void *) 0 ))
+	  #else
+	  if (0
+	  #endif
+	  )
 	    return false;
+	    #ifdef FRCOV
+	    }
+	    #endif
 	  h->root.u.def.value = 0;
 	  h->root.u.def.section = htab->init;
 	  h->size = 8;
@@ -2136,33 +2559,108 @@ spu_elf_build_stubs (struct bfd_link_info *info)
 	}
 
       h = define_ovtab_symbol (htab, "_ovly_table");
-      if (h == NULL)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[6858]) {
+        if ((h == (void *) 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 6858\n");
+        else
+          fprintf(stderr, "reached bug index 6858\n");
+      }
+      if ((!FIXREVERTER[6858] && (h == (void *) 0 ))
+      #else
+      if (0
+      #endif
+      )
 	return false;
+	#ifdef FRCOV
+	}
+	#endif
       h->root.u.def.value = 16;
       h->size = htab->num_overlays * 16;
 
       h = define_ovtab_symbol (htab, "_ovly_table_end");
-      if (h == NULL)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[6859]) {
+        if ((h == (void *) 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 6859\n");
+        else
+          fprintf(stderr, "reached bug index 6859\n");
+      }
+      if ((!FIXREVERTER[6859] && (h == (void *) 0 ))
+      #else
+      if (0
+      #endif
+      )
 	return false;
+	#ifdef FRCOV
+	}
+	#endif
       h->root.u.def.value = htab->num_overlays * 16 + 16;
       h->size = 0;
 
       h = define_ovtab_symbol (htab, "_ovly_buf_table");
-      if (h == NULL)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[6860]) {
+        if ((h == (void *) 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 6860\n");
+        else
+          fprintf(stderr, "reached bug index 6860\n");
+      }
+      if ((!FIXREVERTER[6860] && (h == (void *) 0 ))
+      #else
+      if (0
+      #endif
+      )
 	return false;
+	#ifdef FRCOV
+	}
+	#endif
       h->root.u.def.value = htab->num_overlays * 16 + 16;
       h->size = htab->num_buf * 4;
 
       h = define_ovtab_symbol (htab, "_ovly_buf_table_end");
-      if (h == NULL)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[6861]) {
+        if ((h == (void *) 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 6861\n");
+        else
+          fprintf(stderr, "reached bug index 6861\n");
+      }
+      if ((!FIXREVERTER[6861] && (h == (void *) 0 ))
+      #else
+      if (0
+      #endif
+      )
 	return false;
+	#ifdef FRCOV
+	}
+	#endif
       h->root.u.def.value = htab->num_overlays * 16 + 16 + htab->num_buf * 4;
       h->size = 0;
     }
 
   h = define_ovtab_symbol (htab, "_EAR_");
-  if (h == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[6862]) {
+    if ((h == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 6862\n");
+    else
+      fprintf(stderr, "reached bug index 6862\n");
+  }
+  if ((!FIXREVERTER[6862] && (h == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     return false;
+    #ifdef FRCOV
+    }
+    #endif
   h->root.u.def.section = htab->toe;
   h->root.u.def.value = 0;
   h->size = 16;
@@ -2241,39 +2739,84 @@ find_function_stack_adjust (asection *sec,
 	  imm = (imm ^ 0x200) - 0x200;
 	  reg[rt] = reg[ra] + imm;
 
-	  if (rt == 1 /* sp */)
+	  
+	  #ifdef FRCOV
+	  {if (FIXREVERTER[6865]) {
+	    if ((rt == 1 ) && !(0))
+	      fprintf(stderr, "triggered bug index 6865\n");
+	    else
+	      fprintf(stderr, "reached bug index 6865\n");
+	  }
+	  if ((!FIXREVERTER[6865] && (rt == 1 ))
+	  #else
+	  if (0
+	  #endif
+	   /* sp */)
 	    {
 	      if (reg[rt] > 0)
 		break;
 	      *sp_adjust = offset;
 	      return reg[rt];
 	    }
+	    #ifdef FRCOV
+	    }
+	    #endif
 	}
       else if (buf[0] == 0x18 && (buf[1] & 0xe0) == 0 /* a */)
 	{
 	  int rb = ((buf[1] & 0x1f) << 2) | ((buf[2] & 0xc0) >> 6);
 
 	  reg[rt] = reg[ra] + reg[rb];
-	  if (rt == 1)
+	  
+	  #ifdef FRCOV
+	  {if (FIXREVERTER[6866]) {
+	    if ((rt == 1 ) && !(0))
+	      fprintf(stderr, "triggered bug index 6866\n");
+	    else
+	      fprintf(stderr, "reached bug index 6866\n");
+	  }
+	  if ((!FIXREVERTER[6866] && (rt == 1 ))
+	  #else
+	  if (0
+	  #endif
+	  )
 	    {
 	      if (reg[rt] > 0)
 		break;
 	      *sp_adjust = offset;
 	      return reg[rt];
 	    }
+	    #ifdef FRCOV
+	    }
+	    #endif
 	}
       else if (buf[0] == 0x08 && (buf[1] & 0xe0) == 0 /* sf */)
 	{
 	  int rb = ((buf[1] & 0x1f) << 2) | ((buf[2] & 0xc0) >> 6);
 
 	  reg[rt] = reg[rb] - reg[ra];
-	  if (rt == 1)
+	  
+	  #ifdef FRCOV
+	  {if (FIXREVERTER[6867]) {
+	    if ((rt == 1 ) && !(0))
+	      fprintf(stderr, "triggered bug index 6867\n");
+	    else
+	      fprintf(stderr, "reached bug index 6867\n");
+	  }
+	  if ((!FIXREVERTER[6867] && (rt == 1 ))
+	  #else
+	  if (0
+	  #endif
+	  )
 	    {
 	      if (reg[rt] > 0)
 		break;
 	      *sp_adjust = offset;
 	      return reg[rt];
 	    }
+	    #ifdef FRCOV
+	    }
+	    #endif
 	}
       else if ((buf[0] & 0xfc) == 0x40 /* il, ilh, ilhu, ila */)
 	{
@@ -2403,8 +2946,23 @@ maybe_insert_function (asection *sec,
   if (sinfo == NULL)
     {
       sinfo = alloc_stack_info (sec, 20);
-      if (sinfo == NULL)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[6870]) {
+        if ((sinfo == (void *) 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 6870\n");
+        else
+          fprintf(stderr, "reached bug index 6870\n");
+      }
+      if ((!FIXREVERTER[6870] && (sinfo == (void *) 0 ))
+      #else
+      if (0
+      #endif
+      )
 	return NULL;
+	#ifdef FRCOV
+	}
+	#endif
     }
 
   if (!global)
@@ -2454,8 +3012,23 @@ maybe_insert_function (asection *sec,
       sinfo->max_fun += 20 + (sinfo->max_fun >> 1);
       amt += (sinfo->max_fun - 1) * sizeof (struct function_info);
       sinfo = bfd_realloc (sinfo, amt);
-      if (sinfo == NULL)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[6871]) {
+        if ((sinfo == (void *) 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 6871\n");
+        else
+          fprintf(stderr, "reached bug index 6871\n");
+      }
+      if ((!FIXREVERTER[6871] && (sinfo == (void *) 0 ))
+      #else
+      if (0
+      #endif
+      )
 	return NULL;
+	#ifdef FRCOV
+	}
+	#endif
       memset ((char *) sinfo + old, 0, amt - old);
       sec_data->u.i.stack_info = sinfo;
     }
@@ -2501,8 +3074,23 @@ func_name (struct function_info *fun)
     {
       size_t len = strlen (sec->name);
       char *name = bfd_malloc (len + 10);
-      if (name == NULL)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[6872]) {
+        if ((name == (void *) 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 6872\n");
+        else
+          fprintf(stderr, "reached bug index 6872\n");
+      }
+      if ((!FIXREVERTER[6872] && (name == (void *) 0 ))
+      #else
+      if (0
+      #endif
+      )
 	return "(null)";
+	#ifdef FRCOV
+	}
+	#endif
       sprintf (name, "%s+%lx", sec->name,
 	       (unsigned long) fun->u.sym->st_value & 0xffffffff);
       return name;
@@ -2540,11 +3128,26 @@ insns_at_end (struct function_info *fun, bfd_vma limit)
 
   while (off < limit && is_nop (fun->sec, off))
     off += 4;
-  if (off < limit)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[6874]) {
+    if ((off < limit ) && !(0))
+      fprintf(stderr, "triggered bug index 6874\n");
+    else
+      fprintf(stderr, "reached bug index 6874\n");
+  }
+  if ((!FIXREVERTER[6874] && (off < limit ))
+  #else
+  if (0
+  #endif
+  )
     {
       fun->hi = off;
       return true;
     }
+    #ifdef FRCOV
+    }
+    #endif
   fun->hi = limit;
   return false;
 }
@@ -2560,8 +3163,23 @@ check_function_ranges (asection *sec, struct bfd_link_info *info)
   int i;
   bool gaps = false;
 
-  if (sinfo == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[6875]) {
+    if ((sinfo == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 6875\n");
+    else
+      fprintf(stderr, "reached bug index 6875\n");
+  }
+  if ((!FIXREVERTER[6875] && (sinfo == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     return false;
+    #ifdef FRCOV
+    }
+    #endif
 
   for (i = 1; i < sinfo->num_fun; i++)
     if (sinfo->fun[i - 1].hi > sinfo->fun[i].lo)
@@ -2664,8 +3282,23 @@ copy_callee (struct function_info *caller, const struct call_info *call)
 {
   struct call_info *callee;
   callee = bfd_malloc (sizeof (*callee));
-  if (callee == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[6876]) {
+    if ((callee == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 6876\n");
+    else
+      fprintf(stderr, "reached bug index 6876\n");
+  }
+  if ((!FIXREVERTER[6876] && (callee == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     return false;
+    #ifdef FRCOV
+    }
+    #endif
   *callee = *call;
   if (!insert_callee (caller, callee))
     free (callee);
@@ -2707,8 +3340,23 @@ mark_functions_via_relocs (asection *sec,
 
   internal_relocs = _bfd_elf_link_read_relocs (sec->owner, sec, NULL, NULL,
 					       info->keep_memory);
-  if (internal_relocs == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[6877]) {
+    if ((internal_relocs == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 6877\n");
+    else
+      fprintf(stderr, "reached bug index 6877\n");
+  }
+  if ((!FIXREVERTER[6877] && (internal_relocs == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     return false;
+    #ifdef FRCOV
+    }
+    #endif
 
   symtab_hdr = &elf_tdata (sec->owner)->symtab_hdr;
   psyms = &symtab_hdr->contents;
@@ -2815,8 +3463,23 @@ mark_functions_via_relocs (asection *sec,
 	  if (irela->r_addend != 0)
 	    {
 	      Elf_Internal_Sym *fake = bfd_zmalloc (sizeof (*fake));
-	      if (fake == NULL)
+	      
+	      #ifdef FRCOV
+	      {if (FIXREVERTER[6880]) {
+	        if ((fake == (void *) 0 ) && !(0))
+	          fprintf(stderr, "triggered bug index 6880\n");
+	        else
+	          fprintf(stderr, "reached bug index 6880\n");
+	      }
+	      if ((!FIXREVERTER[6880] && (fake == (void *) 0 ))
+	      #else
+	      if (0
+	      #endif
+	      )
 		return false;
+		#ifdef FRCOV
+		}
+		#endif
 	      fake->st_value = val;
 	      fake->st_shndx
 		= _bfd_elf_section_from_bfd_section (sym_sec->owner, sym_sec);
@@ -2826,8 +3489,23 @@ mark_functions_via_relocs (asection *sec,
 	    fun = maybe_insert_function (sym_sec, sym, false, is_call);
 	  else
 	    fun = maybe_insert_function (sym_sec, h, true, is_call);
-	  if (fun == NULL)
+	  
+	  #ifdef FRCOV
+	  {if (FIXREVERTER[6881]) {
+	    if ((fun == (void *) 0 ) && !(0))
+	      fprintf(stderr, "triggered bug index 6881\n");
+	    else
+	      fprintf(stderr, "reached bug index 6881\n");
+	  }
+	  if ((!FIXREVERTER[6881] && (fun == (void *) 0 ))
+	  #else
+	  if (0
+	  #endif
+	  )
 	    return false;
+	    #ifdef FRCOV
+	    }
+	    #endif
 	  if (irela->r_addend != 0
 	      && fun->u.sym != sym)
 	    free (sym);
@@ -2835,15 +3513,60 @@ mark_functions_via_relocs (asection *sec,
 	}
 
       caller = find_function (sec, irela->r_offset, info);
-      if (caller == NULL)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[6882]) {
+        if ((caller == (void *) 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 6882\n");
+        else
+          fprintf(stderr, "reached bug index 6882\n");
+      }
+      if ((!FIXREVERTER[6882] && (caller == (void *) 0 ))
+      #else
+      if (0
+      #endif
+      )
 	return false;
+	#ifdef FRCOV
+	}
+	#endif
       callee = bfd_malloc (sizeof *callee);
-      if (callee == NULL)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[6883]) {
+        if ((callee == (void *) 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 6883\n");
+        else
+          fprintf(stderr, "reached bug index 6883\n");
+      }
+      if ((!FIXREVERTER[6883] && (callee == (void *) 0 ))
+      #else
+      if (0
+      #endif
+      )
 	return false;
+	#ifdef FRCOV
+	}
+	#endif
 
       callee->fun = find_function (sym_sec, val, info);
-      if (callee->fun == NULL)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[6884]) {
+        if ((callee -> fun == (void *) 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 6884\n");
+        else
+          fprintf(stderr, "reached bug index 6884\n");
+      }
+      if ((!FIXREVERTER[6884] && (callee -> fun == (void *) 0 ))
+      #else
+      if (0
+      #endif
+      )
 	return false;
+	#ifdef FRCOV
+	}
+	#endif
       callee->is_tail = !is_call;
       callee->is_pasted = false;
       callee->broken_cycle = false;
@@ -2914,8 +3637,23 @@ pasted_function (asection *sec)
   struct function_info *fun, *fun_start;
 
   fake = bfd_zmalloc (sizeof (*fake));
-  if (fake == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[6885]) {
+    if ((fake == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 6885\n");
+    else
+      fprintf(stderr, "reached bug index 6885\n");
+  }
+  if ((!FIXREVERTER[6885] && (fake == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     return false;
+    #ifdef FRCOV
+    }
+    #endif
   fake->st_value = 0;
   fake->st_size = sec->size;
   fake->st_shndx
@@ -2933,8 +3671,23 @@ pasted_function (asection *sec)
 	  if (fun_start != NULL)
 	    {
 	      struct call_info *callee = bfd_malloc (sizeof *callee);
-	      if (callee == NULL)
+	      
+	      #ifdef FRCOV
+	      {if (FIXREVERTER[6886]) {
+	        if ((callee == (void *) 0 ) && !(0))
+	          fprintf(stderr, "triggered bug index 6886\n");
+	        else
+	          fprintf(stderr, "reached bug index 6886\n");
+	      }
+	      if ((!FIXREVERTER[6886] && (callee == (void *) 0 ))
+	      #else
+	      if (0
+	      #endif
+	      )
 		return false;
+		#ifdef FRCOV
+		}
+		#endif
 
 	      fun->start = fun_start;
 	      callee->fun = fun;
@@ -2977,11 +3730,41 @@ discover_functions (struct bfd_link_info *info)
     bfd_idx++;
 
   psym_arr = bfd_zmalloc (bfd_idx * sizeof (*psym_arr));
-  if (psym_arr == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[6887]) {
+    if ((psym_arr == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 6887\n");
+    else
+      fprintf(stderr, "reached bug index 6887\n");
+  }
+  if ((!FIXREVERTER[6887] && (psym_arr == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     return false;
+    #ifdef FRCOV
+    }
+    #endif
   sec_arr = bfd_zmalloc (bfd_idx * sizeof (*sec_arr));
-  if (sec_arr == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[6888]) {
+    if ((sec_arr == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 6888\n");
+    else
+      fprintf(stderr, "reached bug index 6888\n");
+  }
+  if ((!FIXREVERTER[6888] && (sec_arr == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     return false;
+    #ifdef FRCOV
+    }
+    #endif
 
   for (ibfd = info->input_bfds, bfd_idx = 0;
        ibfd != NULL;
@@ -3000,7 +3783,19 @@ discover_functions (struct bfd_link_info *info)
       /* Read all the symbols.  */
       symtab_hdr = &elf_tdata (ibfd)->symtab_hdr;
       symcount = symtab_hdr->sh_size / symtab_hdr->sh_entsize;
-      if (symcount == 0)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[6889]) {
+        if ((symcount == 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 6889\n");
+        else
+          fprintf(stderr, "reached bug index 6889\n");
+      }
+      if ((!FIXREVERTER[6889] && (symcount == 0 ))
+      #else
+      if (0
+      #endif
+      )
 	{
 	  if (!gaps)
 	    for (sec = ibfd->sections; sec != NULL && !gaps; sec = sec->next)
@@ -3011,6 +3806,9 @@ discover_functions (struct bfd_link_info *info)
 		}
 	  continue;
 	}
+	#ifdef FRCOV
+	}
+	#endif
 
       /* Don't use cached symbols since the generic ELF linker
 	 code only reads local symbols, and we need globals too.  */
@@ -3019,17 +3817,62 @@ discover_functions (struct bfd_link_info *info)
       syms = bfd_elf_get_elf_syms (ibfd, symtab_hdr, symcount, 0,
 				   NULL, NULL, NULL);
       symtab_hdr->contents = (void *) syms;
-      if (syms == NULL)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[6890]) {
+        if ((syms == (void *) 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 6890\n");
+        else
+          fprintf(stderr, "reached bug index 6890\n");
+      }
+      if ((!FIXREVERTER[6890] && (syms == (void *) 0 ))
+      #else
+      if (0
+      #endif
+      )
 	return false;
+	#ifdef FRCOV
+	}
+	#endif
 
       /* Select defined function symbols that are going to be output.  */
       psyms = bfd_malloc ((symcount + 1) * sizeof (*psyms));
-      if (psyms == NULL)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[6891]) {
+        if ((psyms == (void *) 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 6891\n");
+        else
+          fprintf(stderr, "reached bug index 6891\n");
+      }
+      if ((!FIXREVERTER[6891] && (psyms == (void *) 0 ))
+      #else
+      if (0
+      #endif
+      )
 	return false;
+	#ifdef FRCOV
+	}
+	#endif
       psym_arr[bfd_idx] = psyms;
       psecs = bfd_malloc (symcount * sizeof (*psecs));
-      if (psecs == NULL)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[6892]) {
+        if ((psecs == (void *) 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 6892\n");
+        else
+          fprintf(stderr, "reached bug index 6892\n");
+      }
+      if ((!FIXREVERTER[6892] && (psecs == (void *) 0 ))
+      #else
+      if (0
+      #endif
+      )
 	return false;
+	#ifdef FRCOV
+	}
+	#endif
       sec_arr[bfd_idx] = psecs;
       for (psy = psyms, p = psecs, sy = syms; sy < syms + symcount; ++p, ++sy)
 	if (ELF_ST_TYPE (sy->st_info) == STT_NOTYPE
@@ -3407,16 +4250,61 @@ sort_calls (const void *a, const void *b)
   int delta;
 
   delta = (*c2)->priority - (*c1)->priority;
-  if (delta != 0)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[6894]) {
+    if ((delta != 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 6894\n");
+    else
+      fprintf(stderr, "reached bug index 6894\n");
+  }
+  if ((!FIXREVERTER[6894] && (delta != 0 ))
+  #else
+  if (0
+  #endif
+  )
     return delta;
+    #ifdef FRCOV
+    }
+    #endif
 
   delta = (*c2)->max_depth - (*c1)->max_depth;
-  if (delta != 0)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[6895]) {
+    if ((delta != 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 6895\n");
+    else
+      fprintf(stderr, "reached bug index 6895\n");
+  }
+  if ((!FIXREVERTER[6895] && (delta != 0 ))
+  #else
+  if (0
+  #endif
+  )
     return delta;
+    #ifdef FRCOV
+    }
+    #endif
 
   delta = (*c2)->count - (*c1)->count;
-  if (delta != 0)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[6896]) {
+    if ((delta != 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 6896\n");
+    else
+      fprintf(stderr, "reached bug index 6896\n");
+  }
+  if ((!FIXREVERTER[6896] && (delta != 0 ))
+  #else
+  if (0
+  #endif
+  )
     return delta;
+    #ifdef FRCOV
+    }
+    #endif
 
   return (char *) c1 - (char *) c2;
 }
@@ -3479,16 +4367,46 @@ mark_overlay_section (struct function_info *fun,
 	  if (strcmp (fun->sec->name, ".text") == 0)
 	    {
 	      name = bfd_malloc (sizeof (".rodata"));
-	      if (name == NULL)
+	      
+	      #ifdef FRCOV
+	      {if (FIXREVERTER[6897]) {
+	        if ((name == (void *) 0 ) && !(0))
+	          fprintf(stderr, "triggered bug index 6897\n");
+	        else
+	          fprintf(stderr, "reached bug index 6897\n");
+	      }
+	      if ((!FIXREVERTER[6897] && (name == (void *) 0 ))
+	      #else
+	      if (0
+	      #endif
+	      )
 		return false;
+		#ifdef FRCOV
+		}
+		#endif
 	      memcpy (name, ".rodata", sizeof (".rodata"));
 	    }
 	  else if (startswith (fun->sec->name, ".text."))
 	    {
 	      size_t len = strlen (fun->sec->name);
 	      name = bfd_malloc (len + 3);
-	      if (name == NULL)
+	      
+	      #ifdef FRCOV
+	      {if (FIXREVERTER[6898]) {
+	        if ((name == (void *) 0 ) && !(0))
+	          fprintf(stderr, "triggered bug index 6898\n");
+	        else
+	          fprintf(stderr, "reached bug index 6898\n");
+	      }
+	      if ((!FIXREVERTER[6898] && (name == (void *) 0 ))
+	      #else
+	      if (0
+	      #endif
+	      )
 		return false;
+		#ifdef FRCOV
+		}
+		#endif
 	      memcpy (name, ".rodata", sizeof (".rodata"));
 	      memcpy (name + 7, fun->sec->name + 5, len - 4);
 	    }
@@ -3496,8 +4414,23 @@ mark_overlay_section (struct function_info *fun,
 	    {
 	      size_t len = strlen (fun->sec->name) + 1;
 	      name = bfd_malloc (len);
-	      if (name == NULL)
+	      
+	      #ifdef FRCOV
+	      {if (FIXREVERTER[6899]) {
+	        if ((name == (void *) 0 ) && !(0))
+	          fprintf(stderr, "triggered bug index 6899\n");
+	        else
+	          fprintf(stderr, "reached bug index 6899\n");
+	      }
+	      if ((!FIXREVERTER[6899] && (name == (void *) 0 ))
+	      #else
+	      if (0
+	      #endif
+	      )
 		return false;
+		#ifdef FRCOV
+		}
+		#endif
 	      memcpy (name, fun->sec->name, len);
 	      name[14] = 'r';
 	    }
@@ -3538,8 +4471,23 @@ mark_overlay_section (struct function_info *fun,
 	      free (name);
 	    }
 	}
-      if (mos_param->max_overlay_size < size)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[6900]) {
+        if ((mos_param -> max_overlay_size < size  ) && !(0))
+          fprintf(stderr, "triggered bug index 6900\n");
+        else
+          fprintf(stderr, "reached bug index 6900\n");
+      }
+      if ((!FIXREVERTER[6900] && (mos_param -> max_overlay_size < size  ))
+      #else
+      if (0
+      #endif
+      )
 	mos_param->max_overlay_size = size;
+	#ifdef FRCOV
+	}
+	#endif
     }
 
   for (count = 0, call = fun->call_list; call != NULL; call = call->next)
@@ -3548,8 +4496,23 @@ mark_overlay_section (struct function_info *fun,
   if (count > 1)
     {
       struct call_info **calls = bfd_malloc (count * sizeof (*calls));
-      if (calls == NULL)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[6901]) {
+        if ((calls == (void *) 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 6901\n");
+        else
+          fprintf(stderr, "reached bug index 6901\n");
+      }
+      if ((!FIXREVERTER[6901] && (calls == (void *) 0 ))
+      #else
+      if (0
+      #endif
+      )
 	return false;
+	#ifdef FRCOV
+	}
+	#endif
 
       for (count = 0, call = fun->call_list; call != NULL; call = call->next)
 	calls[count++] = call;
@@ -3721,8 +4684,23 @@ sort_lib (const void *a, const void *b)
 	delta += sinfo->fun[i].call_count;
     }
 
-  if (delta != 0)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[6902]) {
+    if ((delta != 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 6902\n");
+    else
+      fprintf(stderr, "reached bug index 6902\n");
+  }
+  if ((!FIXREVERTER[6902] && (delta != 0 ))
+  #else
+  if (0
+  #endif
+  )
     return delta;
+    #ifdef FRCOV
+    }
+    #endif
 
   return s1 - s2;
 }
@@ -3757,8 +4735,23 @@ auto_ovl_lib_functions (struct bfd_link_info *info, unsigned int lib_size)
 	  lib_count += 1;
     }
   lib_sections = bfd_malloc (lib_count * 2 * sizeof (*lib_sections));
-  if (lib_sections == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[6903]) {
+    if ((lib_sections == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 6903\n");
+    else
+      fprintf(stderr, "reached bug index 6903\n");
+  }
+  if ((!FIXREVERTER[6903] && (lib_sections == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     return (unsigned int) -1;
+    #ifdef FRCOV
+    }
+    #endif
   collect_lib_param.lib_size = lib_size;
   collect_lib_param.lib_sections = lib_sections;
   if (!for_each_node (collect_lib_sections, info, &collect_lib_param,
@@ -3841,8 +4834,23 @@ auto_ovl_lib_functions (struct bfd_link_info *info, unsigned int lib_size)
 		    {
 		      struct call_info *callee;
 		      callee = bfd_malloc (sizeof (*callee));
-		      if (callee == NULL)
+		      
+		      #ifdef FRCOV
+		      {if (FIXREVERTER[6904]) {
+		        if ((callee == (void *) 0 ) && !(0))
+		          fprintf(stderr, "triggered bug index 6904\n");
+		        else
+		          fprintf(stderr, "reached bug index 6904\n");
+		      }
+		      if ((!FIXREVERTER[6904] && (callee == (void *) 0 ))
+		      #else
+		      if (0
+		      #endif
+		      )
 			return (unsigned int) -1;
+			#ifdef FRCOV
+			}
+			#endif
 		      *callee = *call;
 		      if (!insert_callee (&dummy_caller, callee))
 			free (callee);
@@ -4041,8 +5049,23 @@ sum_stack (struct function_info *fun,
       char *name = bfd_malloc (18 + strlen (f1));
       struct elf_link_hash_entry *h;
 
-      if (name == NULL)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[6905]) {
+        if ((name == (void *) 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 6905\n");
+        else
+          fprintf(stderr, "reached bug index 6905\n");
+      }
+      if ((!FIXREVERTER[6905] && (name == (void *) 0 ))
+      #else
+      if (0
+      #endif
+      )
 	return false;
+	#ifdef FRCOV
+	}
+	#endif
 
       if (fun->global || ELF_ST_BIND (fun->u.sym->st_info) == STB_GLOBAL)
 	sprintf (name, "__stack_%s", f1);
@@ -4290,8 +5313,23 @@ spu_elf_auto_overlay (struct bfd_link_info *info)
   for (ibfd = info->input_bfds; ibfd != NULL; ibfd = ibfd->link.next)
     ++bfd_count;
   bfd_arr = bfd_malloc (bfd_count * sizeof (*bfd_arr));
-  if (bfd_arr == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[6906]) {
+    if ((bfd_arr == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 6906\n");
+    else
+      fprintf(stderr, "reached bug index 6906\n");
+  }
+  if ((!FIXREVERTER[6906] && (bfd_arr == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     goto err_exit;
+    #ifdef FRCOV
+    }
+    #endif
 
   /* Count overlay sections, and subtract their sizes from "fixed_size".  */
   count = 0;
@@ -4414,15 +5452,45 @@ spu_elf_auto_overlay (struct bfd_link_info *info)
   /* Build an array of sections, suitably sorted to place into
      overlays.  */
   ovly_sections = bfd_malloc (2 * count * sizeof (*ovly_sections));
-  if (ovly_sections == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[6907]) {
+    if ((ovly_sections == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 6907\n");
+    else
+      fprintf(stderr, "reached bug index 6907\n");
+  }
+  if ((!FIXREVERTER[6907] && (ovly_sections == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     goto err_exit;
+    #ifdef FRCOV
+    }
+    #endif
   ovly_p = ovly_sections;
   if (!for_each_node (collect_overlays, info, &ovly_p, true))
     goto err_exit;
   count = (size_t) (ovly_p - ovly_sections) / 2;
   ovly_map = bfd_malloc (count * sizeof (*ovly_map));
-  if (ovly_map == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[6908]) {
+    if ((ovly_map == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 6908\n");
+    else
+      fprintf(stderr, "reached bug index 6908\n");
+  }
+  if ((!FIXREVERTER[6908] && (ovly_map == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     goto err_exit;
+    #ifdef FRCOV
+    }
+    #endif
 
   memset (&dummy_caller, 0, sizeof (dummy_caller));
   overlay_size = (htab->local_store - fixed_size) / htab->params->num_lines;
@@ -4544,7 +5612,19 @@ spu_elf_auto_overlay (struct bfd_link_info *info)
 	  rosize = rotmp;
 	}
 
-      if (i == base)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[6911]) {
+        if ((i == base ) && !(0))
+          fprintf(stderr, "triggered bug index 6911\n");
+        else
+          fprintf(stderr, "reached bug index 6911\n");
+      }
+      if ((!FIXREVERTER[6911] && (i == base ))
+      #else
+      if (0
+      #endif
+      )
 	{
 	  /* xgettext:c-format */
 	  info->callbacks->einfo (_("%pB:%pA%s exceeds overlay size\n"),
@@ -4554,6 +5634,9 @@ spu_elf_auto_overlay (struct bfd_link_info *info)
 	  bfd_set_error (bfd_error_bad_value);
 	  goto err_exit;
 	}
+	#ifdef FRCOV
+	}
+	#endif
 
       while (dummy_caller.call_list != NULL)
 	{
@@ -4632,8 +5715,23 @@ spu_elf_auto_overlay (struct bfd_link_info *info)
 	  while (base < count && ovly_map[base] < ovlynum)
 	    base++;
 
-	  if (base == count)
+	  
+	  #ifdef FRCOV
+	  {if (FIXREVERTER[6912]) {
+	    if ((base == count ) && !(0))
+	      fprintf(stderr, "triggered bug index 6912\n");
+	    else
+	      fprintf(stderr, "reached bug index 6912\n");
+	  }
+	  if ((!FIXREVERTER[6912] && (base == count ))
+	  #else
+	  if (0
+	  #endif
+	  )
 	    break;
+	    #ifdef FRCOV
+	    }
+	    #endif
 
 	  if (region == 1)
 	    {
diff --git a/bfd/elf32-spu.h b/bfd/elf32-spu.h
old mode 100644
new mode 100755
diff --git a/bfd/elf32-tic6x.c b/bfd/elf32-tic6x.c
old mode 100644
new mode 100755
index 5754f3c..bb8302e
--- a/bfd/elf32-tic6x.c
+++ b/bfd/elf32-tic6x.c
@@ -1,3 +1,6 @@
+#ifdef FRCOV
+extern short FIXREVERTER[];
+#endif
 /* 32-bit ELF support for TI C6X
    Copyright (C) 2010-2021 Free Software Foundation, Inc.
    Contributed by Joseph Myers <joseph@codesourcery.com>
@@ -1451,8 +1454,23 @@ elf32_tic6x_reloc_type_lookup (bfd *abfd, bfd_reloc_code_real_type code)
 
 	/* Some relocations are RELA-only; do not return them for
 	   REL.  */
-	if (howto->name == NULL)
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[9202]) {
+	  if ((howto -> name == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 9202\n");
+	  else
+	    fprintf(stderr, "reached bug index 9202\n");
+	}
+	if ((!FIXREVERTER[9202] && (howto -> name == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	)
 	  howto = NULL;
+	  #ifdef FRCOV
+	  }
+	  #endif
 
 	return howto;
       }
@@ -2091,8 +2109,23 @@ elf32_tic6x_new_section_hook (bfd *abfd, asection *sec)
       size_t amt = sizeof (*sdata);
 
       sdata = (_tic6x_elf_section_data *) bfd_zalloc (abfd, amt);
-      if (sdata == NULL)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[9206]) {
+        if ((sdata == (void *) 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 9206\n");
+        else
+          fprintf(stderr, "reached bug index 9206\n");
+      }
+      if ((!FIXREVERTER[9206] && (sdata == (void *) 0 ))
+      #else
+      if (0
+      #endif
+      )
 	return false;
+	#ifdef FRCOV
+	}
+	#endif
       sec->used_by_bfd = sdata;
     }
 
diff --git a/bfd/elf32-tic6x.h b/bfd/elf32-tic6x.h
old mode 100644
new mode 100755
diff --git a/bfd/elf32-tilegx.c b/bfd/elf32-tilegx.c
old mode 100644
new mode 100755
diff --git a/bfd/elf32-tilegx.h b/bfd/elf32-tilegx.h
old mode 100644
new mode 100755
diff --git a/bfd/elf32-tilepro.c b/bfd/elf32-tilepro.c
old mode 100644
new mode 100755
diff --git a/bfd/elf32-tilepro.h b/bfd/elf32-tilepro.h
old mode 100644
new mode 100755
diff --git a/bfd/elf32-v850.c b/bfd/elf32-v850.c
old mode 100644
new mode 100755
index a74d713..90a12b0
--- a/bfd/elf32-v850.c
+++ b/bfd/elf32-v850.c
@@ -1,3 +1,6 @@
+#ifdef FRCOV
+extern short FIXREVERTER[];
+#endif
 /* V850-specific support for 32-bit ELF
    Copyright (C) 1996-2021 Free Software Foundation, Inc.
 
@@ -2513,8 +2516,23 @@ v850_elf_merge_notes (bfd * ibfd, bfd *obfd)
 	  ival = bfd_get_32 (ibfd, idata);
 	  oval = bfd_get_32 (obfd, odata);
 
-	  if (ival == 0 || ival == oval)
+	  
+	  #ifdef FRCOV
+	  {if (FIXREVERTER[10928]) {
+	    if ((ival == 0 || ival == oval ) && !(0))
+	      fprintf(stderr, "triggered bug index 10928\n");
+	    else
+	      fprintf(stderr, "reached bug index 10928\n");
+	  }
+	  if ((!FIXREVERTER[10928] && (ival == 0 || ival == oval ))
+	  #else
+	  if (0
+	  #endif
+	  )
 	    continue;
+	    #ifdef FRCOV
+	    }
+	    #endif
 
 	  if (oval == 0)
 	    {
@@ -2674,8 +2692,23 @@ v850_elf_print_notes (bfd * abfd, FILE * file)
   asection * notes = bfd_get_section_by_name (abfd, V850_NOTE_SECNAME);
   enum v850_notes id;
 
-  if (notes == NULL || notes->contents == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[10930]) {
+    if ((notes == (void *) 0 || notes -> contents == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 10930\n");
+    else
+      fprintf(stderr, "reached bug index 10930\n");
+  }
+  if ((!FIXREVERTER[10930] && (notes == (void *) 0 || notes -> contents == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     return;
+    #ifdef FRCOV
+    }
+    #endif
 
   BFD_ASSERT (bfd_section_size (notes) == NUM_V850_NOTES * SIZEOF_V850_NOTE);
 
@@ -2812,8 +2845,23 @@ v850_elf_merge_private_bfd_data (bfd *ibfd, struct bfd_link_info *info)
     }
 
   /* Check flag compatibility.  */
-  if (in_flags == out_flags)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[10932]) {
+    if ((in_flags == out_flags ) && !(0))
+      fprintf(stderr, "triggered bug index 10932\n");
+    else
+      fprintf(stderr, "reached bug index 10932\n");
+  }
+  if ((!FIXREVERTER[10932] && (in_flags == out_flags ))
+  #else
+  if (0
+  #endif
+  )
     return result;
+    #ifdef FRCOV
+    }
+    #endif
 
   if (bfd_get_arch (obfd) == bfd_arch_v850_rh850)
     {
@@ -3264,8 +3312,23 @@ v850_elf_relax_delete_bytes (bfd *abfd,
 				shndx ? shndx + ELF32_R_SYM (irel->r_info) : NULL,
 				& isym);
 
-      if (isym.st_shndx != sec_shndx)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[10935]) {
+        if ((isym . st_shndx != sec_shndx ) && !(0))
+          fprintf(stderr, "triggered bug index 10935\n");
+        else
+          fprintf(stderr, "reached bug index 10935\n");
+      }
+      if ((!FIXREVERTER[10935] && (isym . st_shndx != sec_shndx ))
+      #else
+      if (0
+      #endif
+      )
 	continue;
+	#ifdef FRCOV
+	}
+	#endif
 
       /* Get the value of the symbol referred to by the reloc.  */
       if (ELF32_R_SYM (irel->r_info) < symtab_hdr->sh_info)
@@ -3448,8 +3511,23 @@ v850_elf_relax_section (bfd *abfd,
 
   internal_relocs = (_bfd_elf_link_read_relocs
 		     (abfd, sec, NULL, NULL, link_info->keep_memory));
-  if (internal_relocs == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[10939]) {
+    if ((internal_relocs == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 10939\n");
+    else
+      fprintf(stderr, "reached bug index 10939\n");
+  }
+  if ((!FIXREVERTER[10939] && (internal_relocs == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     goto error_return;
+    #ifdef FRCOV
+    }
+    #endif
 
   irelend = internal_relocs + sec->reloc_count;
 
@@ -3536,16 +3614,64 @@ v850_elf_relax_section (bfd *abfd,
 	    }
 
 	  /* Read this BFD's local symbols if we haven't done so already.  */
-	  if (isymbuf == NULL && symtab_hdr->sh_info != 0)
+	  
+	  #ifdef FRCOV
+	  {if (FIXREVERTER[10943]) {
+	    fprintf(stderr, "reached bug index 10943\n");
+	  }
+	  if ((FIXREVERTER[10943] && (isymbuf == (void *) 0 )) || (!FIXREVERTER[10943] && (isymbuf == (void *) 0 && symtab_hdr -> sh_info != 0 ))
+	  #else
+	  if (isymbuf == (void *) 0 
+	  #endif
+	  )
 	    {
+	      
+	    #ifdef FRCOV
+	      if (!(symtab_hdr -> sh_info != 0 ))
+	        fprintf(stderr, "triggered bug index 10943\n");
+	      #endif
+	    
 	      isymbuf = (Elf_Internal_Sym *) symtab_hdr->contents;
-	      if (isymbuf == NULL)
+	      
+	      #ifdef FRCOV
+	      {if (FIXREVERTER[10941]) {
+	        if ((isymbuf == (void *) 0 ) && !(0))
+	          fprintf(stderr, "triggered bug index 10941\n");
+	        else
+	          fprintf(stderr, "reached bug index 10941\n");
+	      }
+	      if ((!FIXREVERTER[10941] && (isymbuf == (void *) 0 ))
+	      #else
+	      if (0
+	      #endif
+	      )
 		isymbuf = bfd_elf_get_elf_syms (abfd, symtab_hdr,
 						symtab_hdr->sh_info, 0,
 						NULL, NULL, NULL);
-	      if (isymbuf == NULL)
+						#ifdef FRCOV
+						}
+						#endif
+	      
+	      #ifdef FRCOV
+	      {if (FIXREVERTER[10942]) {
+	        if ((isymbuf == (void *) 0 ) && !(0))
+	          fprintf(stderr, "triggered bug index 10942\n");
+	        else
+	          fprintf(stderr, "reached bug index 10942\n");
+	      }
+	      if ((!FIXREVERTER[10942] && (isymbuf == (void *) 0 ))
+	      #else
+	      if (0
+	      #endif
+	      )
 		goto error_return;
+		#ifdef FRCOV
+		}
+		#endif
+	    }
+	    #ifdef FRCOV
 	    }
+	    #endif
 
 	  laddr = irel->r_offset;
 
@@ -3594,7 +3720,19 @@ v850_elf_relax_section (bfd *abfd,
 		  continue;
 		}
 
-	      if (no_match >= 0)
+	      
+	      #ifdef FRCOV
+	      {if (FIXREVERTER[10944]) {
+	        if ((no_match >= 0 ) && !(0))
+	          fprintf(stderr, "triggered bug index 10944\n");
+	        else
+	          fprintf(stderr, "reached bug index 10944\n");
+	      }
+	      if ((!FIXREVERTER[10944] && (no_match >= 0 ))
+	      #else
+	      if (0
+	      #endif
+	      )
 		{
 		  _bfd_error_handler
 		    /* xgettext:c-format */
@@ -3606,6 +3744,9 @@ v850_elf_relax_section (bfd *abfd,
 		     insn[no_match]);
 		  continue;
 		}
+		#ifdef FRCOV
+		}
+		#endif
 
 	      /* Get the reloc for the address from which the register is
 		 being loaded.  This reloc will tell us which function is
@@ -3680,7 +3821,19 @@ v850_elf_relax_section (bfd *abfd,
 		  symval = h->root.u.def.value;
 		}
 
-	      if (symval + irelcall->r_addend != irelcall->r_offset + 4)
+	      
+	      #ifdef FRCOV
+	      {if (FIXREVERTER[10945]) {
+	        if ((symval + irelcall -> r_addend != irelcall -> r_offset + 4 ) && !(0))
+	          fprintf(stderr, "triggered bug index 10945\n");
+	        else
+	          fprintf(stderr, "reached bug index 10945\n");
+	      }
+	      if ((!FIXREVERTER[10945] && (symval + irelcall -> r_addend != irelcall -> r_offset + 4 ))
+	      #else
+	      if (0
+	      #endif
+	      )
 		{
 		  _bfd_error_handler
 		    /* xgettext:c-format */
@@ -3690,6 +3843,9 @@ v850_elf_relax_section (bfd *abfd,
 		     (uint64_t) irelcall->r_offset);
 		  continue;
 		}
+		#ifdef FRCOV
+		}
+		#endif
 
 	      /* Get the value of the symbol referred to by the reloc.  */
 	      if (ELF32_R_SYM (hi_irelfn->r_info) < symtab_hdr->sh_info)
@@ -3833,7 +3989,19 @@ v850_elf_relax_section (bfd *abfd,
 		  continue;
 		}
 
-	      if (no_match >= 0)
+	      
+	      #ifdef FRCOV
+	      {if (FIXREVERTER[10946]) {
+	        if ((no_match >= 0 ) && !(0))
+	          fprintf(stderr, "triggered bug index 10946\n");
+	        else
+	          fprintf(stderr, "reached bug index 10946\n");
+	      }
+	      if ((!FIXREVERTER[10946] && (no_match >= 0 ))
+	      #else
+	      if (0
+	      #endif
+	      )
 		{
 		  _bfd_error_handler
 		    /* xgettext:c-format */
@@ -3845,6 +4013,9 @@ v850_elf_relax_section (bfd *abfd,
 		     insn[no_match]);
 		  continue;
 		}
+		#ifdef FRCOV
+		}
+		#endif
 
 	      /* Get the reloc for the address from which the register is
 		 being loaded.  This reloc will tell us which function is
diff --git a/bfd/elf32-v850.h b/bfd/elf32-v850.h
old mode 100644
new mode 100755
diff --git a/bfd/elf32-vax.c b/bfd/elf32-vax.c
old mode 100644
new mode 100755
diff --git a/bfd/elf32-visium.c b/bfd/elf32-visium.c
old mode 100644
new mode 100755
diff --git a/bfd/elf32-wasm32.c b/bfd/elf32-wasm32.c
old mode 100644
new mode 100755
diff --git a/bfd/elf32-xc16x.c b/bfd/elf32-xc16x.c
old mode 100644
new mode 100755
diff --git a/bfd/elf32-xgate.c b/bfd/elf32-xgate.c
old mode 100644
new mode 100755
diff --git a/bfd/elf32-xstormy16.c b/bfd/elf32-xstormy16.c
old mode 100644
new mode 100755
diff --git a/bfd/elf32-xtensa.c b/bfd/elf32-xtensa.c
old mode 100644
new mode 100755
index 7c5fb55..bb2cd7f
--- a/bfd/elf32-xtensa.c
+++ b/bfd/elf32-xtensa.c
@@ -1,3 +1,6 @@
+#ifdef FRCOV
+extern short FIXREVERTER[];
+#endif
 /* Xtensa-specific support for 32-bit ELF.
    Copyright (C) 2003-2021 Free Software Foundation, Inc.
 
@@ -823,8 +826,23 @@ property_table_compare (const void *ap, const void *bp)
 
   if (a->address == b->address)
     {
-      if (a->size != b->size)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[540]) {
+        if ((a -> size != b -> size ) && !(0))
+          fprintf(stderr, "triggered bug index 540\n");
+        else
+          fprintf(stderr, "reached bug index 540\n");
+      }
+      if ((!FIXREVERTER[540] && (a -> size != b -> size ))
+      #else
+      if (0
+      #endif
+      )
 	return (a->size - b->size);
+	#ifdef FRCOV
+	}
+	#endif
 
       if ((a->flags & XTENSA_PROP_ALIGN) != (b->flags & XTENSA_PROP_ALIGN))
 	return ((b->flags & XTENSA_PROP_ALIGN)
@@ -945,8 +963,23 @@ xtensa_read_table_entries (bfd *abfd,
 		  && ELF32_R_TYPE (irel->r_info) == R_XTENSA_NONE)))
 	{
 	  irel += 1;
-	  if (irel >= rel_end)
+	  
+	  #ifdef FRCOV
+	  {if (FIXREVERTER[542]) {
+	    if ((irel >= rel_end ) && !(0))
+	      fprintf(stderr, "triggered bug index 542\n");
+	    else
+	      fprintf(stderr, "reached bug index 542\n");
+	  }
+	  if ((!FIXREVERTER[542] && (irel >= rel_end ))
+	  #else
+	  if (0
+	  #endif
+	  )
 	    irel = 0;
+	    #ifdef FRCOV
+	    }
+	    #endif
 	}
 
       if (irel && irel->r_offset == off)
@@ -964,9 +997,23 @@ xtensa_read_table_entries (bfd *abfd,
 	}
       else
 	{
-	  if (address < section_addr
-	      || address >= section_addr + section_limit)
+	  
+	  #ifdef FRCOV
+	  {if (FIXREVERTER[543]) {
+	    if ((address < section_addr || address >= section_addr + section_limit ) && !(0))
+	      fprintf(stderr, "triggered bug index 543\n");
+	    else
+	      fprintf(stderr, "reached bug index 543\n");
+	  }
+	  if ((!FIXREVERTER[543] && (address < section_addr || address >= section_addr + section_limit ))
+	  #else
+	  if (0
+	  #endif
+	  )
 	    continue;
+	    #ifdef FRCOV
+	    }
+	    #endif
 	}
 
       blocks[block_count].address = address;
@@ -3429,7 +3476,19 @@ elf_xtensa_merge_private_bfd_data (bfd *ibfd, struct bfd_link_info *info)
 
   out_mach = out_flag & EF_XTENSA_MACH;
   in_mach = in_flag & EF_XTENSA_MACH;
-  if (out_mach != in_mach)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[568]) {
+    if ((out_mach != in_mach ) && !(0))
+      fprintf(stderr, "triggered bug index 568\n");
+    else
+      fprintf(stderr, "reached bug index 568\n");
+  }
+  if ((!FIXREVERTER[568] && (out_mach != in_mach ))
+  #else
+  if (0
+  #endif
+  )
     {
       _bfd_error_handler
 	/* xgettext:c-format */
@@ -3438,6 +3497,9 @@ elf_xtensa_merge_private_bfd_data (bfd *ibfd, struct bfd_link_info *info)
       bfd_set_error (bfd_error_wrong_format);
       return false;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
   if (! elf_flags_init (obfd))
     {
@@ -3977,16 +4039,46 @@ get_relocation_opnd (xtensa_opcode opcode, int r_type)
 	  && xtensa_operand_is_register (isa, opcode, opi) == 0)
 	last_immed = opi;
     }
-  if (last_immed < 0)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[572]) {
+    if ((last_immed < 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 572\n");
+    else
+      fprintf(stderr, "reached bug index 572\n");
+  }
+  if ((!FIXREVERTER[572] && (last_immed < 0 ))
+  #else
+  if (0
+  #endif
+  )
     return XTENSA_UNDEFINED;
+    #ifdef FRCOV
+    }
+    #endif
 
   /* If the operand number was specified in an old-style relocation,
      check for consistency with the operand computed above.  */
   if (r_type >= R_XTENSA_OP0 && r_type <= R_XTENSA_OP2)
     {
       int reloc_opnd = r_type - R_XTENSA_OP0;
-      if (reloc_opnd != last_immed)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[573]) {
+        if ((reloc_opnd != last_immed ) && !(0))
+          fprintf(stderr, "triggered bug index 573\n");
+        else
+          fprintf(stderr, "reached bug index 573\n");
+      }
+      if ((!FIXREVERTER[573] && (reloc_opnd != last_immed ))
+      #else
+      if (0
+      #endif
+      )
 	return XTENSA_UNDEFINED;
+	#ifdef FRCOV
+	}
+	#endif
     }
 
   return last_immed;
@@ -4029,8 +4121,23 @@ get_relocation_opcode (bfd *abfd,
   xtensa_format fmt;
   int slot;
 
-  if (contents == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[575]) {
+    if ((contents == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 575\n");
+    else
+      fprintf(stderr, "reached bug index 575\n");
+  }
+  if ((!FIXREVERTER[575] && (contents == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     return XTENSA_UNDEFINED;
+    #ifdef FRCOV
+    }
+    #endif
 
   if (bfd_get_section_limit (abfd, sec) <= irel->r_offset)
     return XTENSA_UNDEFINED;
@@ -4076,14 +4183,44 @@ get_asm_simplify_size (bfd_byte *contents,
 
   /* Decode the size of the next two instructions.  */
   insnlen = insn_decode_len (contents, content_len, offset);
-  if (insnlen == 0)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[576]) {
+    if ((insnlen == 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 576\n");
+    else
+      fprintf(stderr, "reached bug index 576\n");
+  }
+  if ((!FIXREVERTER[576] && (insnlen == 0 ))
+  #else
+  if (0
+  #endif
+  )
     return 0;
+    #ifdef FRCOV
+    }
+    #endif
 
   size += insnlen;
 
   insnlen = insn_decode_len (contents, content_len, offset + size);
-  if (insnlen == 0)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[577]) {
+    if ((insnlen == 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 577\n");
+    else
+      fprintf(stderr, "reached bug index 577\n");
+  }
+  if ((!FIXREVERTER[577] && (insnlen == 0 ))
+  #else
+  if (0
+  #endif
+  )
     return 0;
+    #ifdef FRCOV
+    }
+    #endif
 
   size += insnlen;
   return size;
@@ -4134,8 +4271,23 @@ insn_decode_len (bfd_byte *contents,
   xtensa_format fmt;
   static xtensa_insnbuf ibuff = NULL;
 
-  if (offset + MIN_INSN_LENGTH > content_len)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[578]) {
+    if ((offset + 2 > content_len ) && !(0))
+      fprintf(stderr, "triggered bug index 578\n");
+    else
+      fprintf(stderr, "reached bug index 578\n");
+  }
+  if ((!FIXREVERTER[578] && (offset + 2 > content_len ))
+  #else
+  if (0
+  #endif
+  )
     return 0;
+    #ifdef FRCOV
+    }
+    #endif
 
   if (ibuff == NULL)
     ibuff = xtensa_insnbuf_alloc (isa);
@@ -4159,8 +4311,23 @@ insn_num_slots (bfd_byte *contents,
   xtensa_format fmt;
   static xtensa_insnbuf ibuff = NULL;
 
-  if (offset + MIN_INSN_LENGTH > content_len)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[580]) {
+    if ((offset + 2 > content_len ) && !(0))
+      fprintf(stderr, "triggered bug index 580\n");
+    else
+      fprintf(stderr, "reached bug index 580\n");
+  }
+  if ((!FIXREVERTER[580] && (offset + 2 > content_len ))
+  #else
+  if (0
+  #endif
+  )
     return XTENSA_UNDEFINED;
+    #ifdef FRCOV
+    }
+    #endif
 
   if (ibuff == NULL)
     ibuff = xtensa_insnbuf_alloc (isa);
@@ -4187,8 +4354,23 @@ insn_decode_opcode (bfd_byte *contents,
   static xtensa_insnbuf insnbuf = NULL;
   static xtensa_insnbuf slotbuf = NULL;
 
-  if (offset + MIN_INSN_LENGTH > content_len)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[582]) {
+    if ((offset + 2 > content_len ) && !(0))
+      fprintf(stderr, "triggered bug index 582\n");
+    else
+      fprintf(stderr, "reached bug index 582\n");
+  }
+  if ((!FIXREVERTER[582] && (offset + 2 > content_len ))
+  #else
+  if (0
+  #endif
+  )
     return XTENSA_UNDEFINED;
+    #ifdef FRCOV
+    }
+    #endif
 
   if (insnbuf == NULL)
     {
@@ -4245,11 +4427,26 @@ check_loop_aligned (bfd_byte *contents,
 
   loop_len = insn_decode_len (contents, content_length, offset);
   insn_len = insn_decode_len (contents, content_length, offset + loop_len);
-  if (loop_len == 0 || insn_len == 0)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[584]) {
+    if ((loop_len == 0 ) && !(insn_len == 0 ))
+      fprintf(stderr, "triggered bug index 584\n");
+    else
+      fprintf(stderr, "reached bug index 584\n");
+  }
+  if ((FIXREVERTER[584] && (insn_len == 0 )) || (!FIXREVERTER[584] && (loop_len == 0 || insn_len == 0 ))
+  #else
+  if (insn_len == 0 
+  #endif
+  )
     {
       BFD_ASSERT (false);
       return false;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
   /* If this is relaxed loop, analyze first instruction of the actual loop
      body.  It must be at offset 27 from the loop instruction address.  */
@@ -4730,11 +4927,26 @@ elf_xtensa_do_asm_simplify (bfd_byte *contents,
       slotbuf = xtensa_insnbuf_alloc (isa);
     }
 
-  if (content_length < address)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[592]) {
+    if ((content_length < address ) && !(0))
+      fprintf(stderr, "triggered bug index 592\n");
+    else
+      fprintf(stderr, "reached bug index 592\n");
+  }
+  if ((!FIXREVERTER[592] && (content_length < address ))
+  #else
+  if (0
+  #endif
+  )
     {
       *error_message = _("attempt to convert L32R/CALLX to CALL failed");
       return bfd_reloc_other;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
   opcode = get_expanded_call_opcode (chbuf, content_length - address, 0);
   direct_call_opcode = swap_callx_for_call_opcode (opcode);
@@ -4902,8 +5114,23 @@ get_expanded_call_opcode (bfd_byte *buf, int bufsize, bool *p_uses_l32r)
 				&call_regno))
     return XTENSA_UNDEFINED;
 
-  if (call_regno != regno)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[597]) {
+    if ((call_regno != regno ) && !(0))
+      fprintf(stderr, "triggered bug index 597\n");
+    else
+      fprintf(stderr, "reached bug index 597\n");
+  }
+  if ((!FIXREVERTER[597] && (call_regno != regno ))
+  #else
+  if (0
+  #endif
+  )
     return XTENSA_UNDEFINED;
+    #ifdef FRCOV
+    }
+    #endif
 
   return opcode;
 }
@@ -4985,8 +5212,23 @@ static bool
 r_reloc_is_defined (const r_reloc *r_rel)
 {
   asection *sec;
-  if (r_rel == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[598]) {
+    if ((r_rel == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 598\n");
+    else
+      fprintf(stderr, "reached bug index 598\n");
+  }
+  if ((!FIXREVERTER[598] && (r_rel == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     return false;
+    #ifdef FRCOV
+    }
+    #endif
 
   sec = r_reloc_get_section (r_rel);
   if (sec == bfd_abs_section_ptr
@@ -5227,8 +5469,23 @@ literal_value_equal (const literal_value *src1,
   if (src1->r_rel.virtual_offset != src2->r_rel.virtual_offset)
     return false;
 
-  if (src1->value != src2->value)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[599]) {
+    if ((src1 -> value != src2 -> value ) && !(0))
+      fprintf(stderr, "triggered bug index 599\n");
+    else
+      fprintf(stderr, "reached bug index 599\n");
+  }
+  if ((!FIXREVERTER[599] && (src1 -> value != src2 -> value ))
+  #else
+  if (0
+  #endif
+  )
     return false;
+    #ifdef FRCOV
+    }
+    #endif
 
   /* Now check for the same section (if defined) or the same elf_hash
      (if undefined or weak).  */
@@ -5271,11 +5528,26 @@ value_map_hash_table_init (void)
   values->count = 0;
   values->buckets = (value_map **)
     bfd_zmalloc (sizeof (value_map *) * values->bucket_count);
-  if (values->buckets == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[600]) {
+    if ((values -> buckets == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 600\n");
+    else
+      fprintf(stderr, "reached bug index 600\n");
+  }
+  if ((!FIXREVERTER[600] && (values -> buckets == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     {
       free (values);
       return NULL;
     }
+    #ifdef FRCOV
+    }
+    #endif
   values->has_last_loc = false;
 
   return values;
@@ -5358,11 +5630,26 @@ add_value_map (value_map_hash_table *map,
   unsigned idx;
 
   value_map *val_e = (value_map *) bfd_zmalloc (sizeof (value_map));
-  if (val_e == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[601]) {
+    if ((val_e == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 601\n");
+    else
+      fprintf(stderr, "reached bug index 601\n");
+  }
+  if ((!FIXREVERTER[601] && (val_e == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     {
       bfd_set_error (bfd_error_no_memory);
       return NULL;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
   BFD_ASSERT (!value_map_get_cached_value (map, val, final_static_link));
   val_e->val = *val;
@@ -5469,8 +5756,23 @@ find_fill_action (text_action_list *l, asection *sec, bfd_vma offset)
   text_action a;
 
   /* It is not necessary to fill at the end of a section.  */
-  if (sec->size == offset)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[602]) {
+    if ((sec -> size == offset ) && !(0))
+      fprintf(stderr, "triggered bug index 602\n");
+    else
+      fprintf(stderr, "reached bug index 602\n");
+  }
+  if ((!FIXREVERTER[602] && (sec -> size == offset ))
+  #else
+  if (0
+  #endif
+  )
     return NULL;
+    #ifdef FRCOV
+    }
+    #endif
 
   a.offset = offset;
   a.action = ta_fill;
@@ -5672,8 +5974,23 @@ removed_by_actions (text_action_list *action_list,
 
   while (r)
     {
-      if (r->offset > offset)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[604]) {
+        if ((r -> offset > offset ) && !(0))
+          fprintf(stderr, "triggered bug index 604\n");
+        else
+          fprintf(stderr, "reached bug index 604\n");
+      }
+      if ((!FIXREVERTER[604] && (r -> offset > offset ))
+      #else
+      if (0
+      #endif
+      )
 	break;
+	#ifdef FRCOV
+	}
+	#endif
 
       if (r->offset == offset
 	  && (before_fill || r->action != ta_fill || r->removed_bytes >= 0))
@@ -6105,8 +6422,23 @@ elf_xtensa_new_section_hook (bfd *abfd, asection *sec)
       size_t amt = sizeof (*sdata);
 
       sdata = bfd_zalloc (abfd, amt);
-      if (sdata == NULL)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[607]) {
+        if ((sdata == (void *) 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 607\n");
+        else
+          fprintf(stderr, "reached bug index 607\n");
+      }
+      if ((!FIXREVERTER[607] && (sdata == (void *) 0 ))
+      #else
+      if (0
+      #endif
+      )
 	return false;
+	#ifdef FRCOV
+	}
+	#endif
       sec->used_by_bfd = sdata;
     }
 
@@ -6331,8 +6663,23 @@ section_cache_section (section_cache_t *sec_cache,
   Elf_Internal_Rela *internal_relocs = NULL;
   bfd_size_type sec_size;
 
-  if (sec == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[613]) {
+    if ((sec == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 613\n");
+    else
+      fprintf(stderr, "reached bug index 613\n");
+  }
+  if ((!FIXREVERTER[613] && (sec == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     return false;
+    #ifdef FRCOV
+    }
+    #endif
   if (sec == sec_cache->sec)
     return true;
 
@@ -6351,8 +6698,23 @@ section_cache_section (section_cache_t *sec_cache,
   /* Get the entry table.  */
   ptblsize = xtensa_read_table_entries (abfd, sec, &prop_table,
 					XTENSA_PROP_SEC_NAME, false);
-  if (ptblsize < 0)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[614]) {
+    if ((ptblsize < 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 614\n");
+    else
+      fprintf(stderr, "reached bug index 614\n");
+  }
+  if ((!FIXREVERTER[614] && (ptblsize < 0 ))
+  #else
+  if (0
+  #endif
+  )
     goto err;
+    #ifdef FRCOV
+    }
+    #endif
 
   /* Fill in the new section cache.  */
   free_section_cache (sec_cache);
@@ -6564,7 +6926,19 @@ extend_ebb_bounds_forward (ebb_t *ebb)
 	insn_block_decodable_len (ebb->contents, ebb->content_length,
 				  ebb->end_offset,
 				  entry_end - ebb->end_offset);
-      if (insn_block_len != (entry_end - ebb->end_offset))
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[615]) {
+        if ((insn_block_len != entry_end - ebb -> end_offset ) && !(0))
+          fprintf(stderr, "triggered bug index 615\n");
+        else
+          fprintf(stderr, "reached bug index 615\n");
+      }
+      if ((!FIXREVERTER[615] && (insn_block_len != entry_end - ebb -> end_offset ))
+      #else
+      if (0
+      #endif
+      )
 	{
 	  _bfd_error_handler
 	    /* xgettext:c-format */
@@ -6574,6 +6948,9 @@ extend_ebb_bounds_forward (ebb_t *ebb)
 	     (uint64_t) (ebb->end_offset + insn_block_len));
 	  return false;
 	}
+	#ifdef FRCOV
+	}
+	#endif
       ebb->end_offset += insn_block_len;
 
       if (ebb->end_offset == ebb->sec->size)
@@ -6596,8 +6973,23 @@ extend_ebb_bounds_forward (ebb_t *ebb)
 	  || ((the_entry->flags & XTENSA_PROP_ALIGN) != 0))
 	break;
 
-      if (the_entry->address + the_entry->size != new_entry->address)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[617]) {
+        if ((the_entry -> address + the_entry -> size != new_entry -> address ) && !(0))
+          fprintf(stderr, "triggered bug index 617\n");
+        else
+          fprintf(stderr, "reached bug index 617\n");
+      }
+      if ((!FIXREVERTER[617] && (the_entry -> address + the_entry -> size != new_entry -> address ))
+      #else
+      if (0
+      #endif
+      )
 	break;
+	#ifdef FRCOV
+	}
+	#endif
 
       the_entry = new_entry;
       ebb->end_ptbl_idx++;
@@ -6643,7 +7035,19 @@ extend_ebb_bounds_backward (ebb_t *ebb)
 	insn_block_decodable_len (ebb->contents, ebb->content_length,
 				  block_begin,
 				  ebb->start_offset - block_begin);
-      if (insn_block_len != ebb->start_offset - block_begin)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[618]) {
+        if ((insn_block_len != ebb -> start_offset - block_begin ) && !(0))
+          fprintf(stderr, "triggered bug index 618\n");
+        else
+          fprintf(stderr, "reached bug index 618\n");
+      }
+      if ((!FIXREVERTER[618] && (insn_block_len != ebb -> start_offset - block_begin ))
+      #else
+      if (0
+      #endif
+      )
 	{
 	  _bfd_error_handler
 	    /* xgettext:c-format */
@@ -6653,6 +7057,9 @@ extend_ebb_bounds_backward (ebb_t *ebb)
 	     (uint64_t) (ebb->end_offset + insn_block_len));
 	  return false;
 	}
+	#ifdef FRCOV
+	}
+	#endif
       ebb->start_offset -= insn_block_len;
 
       /* Update the reloc counter.  */
@@ -6671,8 +7078,23 @@ extend_ebb_bounds_backward (ebb_t *ebb)
 	  || ((new_entry->flags & XTENSA_PROP_NO_TRANSFORM) != 0)
 	  || ((new_entry->flags & XTENSA_PROP_ALIGN) != 0))
 	return true;
-      if (new_entry->address + new_entry->size != the_entry->address)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[620]) {
+        if ((new_entry -> address + new_entry -> size != the_entry -> address ) && !(0))
+          fprintf(stderr, "triggered bug index 620\n");
+        else
+          fprintf(stderr, "reached bug index 620\n");
+      }
+      if ((!FIXREVERTER[620] && (new_entry -> address + new_entry -> size != the_entry -> address ))
+      #else
+      if (0
+      #endif
+      )
 	return true;
+	#ifdef FRCOV
+	}
+	#endif
 
       the_entry = new_entry;
       ebb->start_ptbl_idx--;
@@ -6694,8 +7116,23 @@ insn_block_decodable_len (bfd_byte *contents,
       bfd_size_type insn_len = 0;
 
       insn_len = insn_decode_len (contents, content_len, offset);
-      if (insn_len == 0)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[621]) {
+        if ((insn_len == 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 621\n");
+        else
+          fprintf(stderr, "reached bug index 621\n");
+      }
+      if ((!FIXREVERTER[621] && (insn_len == 0 ))
+      #else
+      if (0
+      #endif
+      )
 	return (offset - block_offset);
+	#ifdef FRCOV
+	}
+	#endif
       offset += insn_len;
     }
   return (offset - block_offset);
@@ -6759,9 +7196,24 @@ retrieve_internal_relocs (bfd *abfd, asection *sec, bool keep_memory)
     return NULL;
 
   internal_relocs = elf_section_data (sec)->relocs;
-  if (internal_relocs == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[622]) {
+    if ((internal_relocs == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 622\n");
+    else
+      fprintf(stderr, "reached bug index 622\n");
+  }
+  if ((!FIXREVERTER[622] && (internal_relocs == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     internal_relocs = (_bfd_elf_link_read_relocs
 		       (abfd, sec, NULL, NULL, keep_memory));
+		       #ifdef FRCOV
+		       }
+		       #endif
   return internal_relocs;
 }
 
@@ -6790,8 +7242,23 @@ retrieve_contents (bfd *abfd, asection *sec, bool keep_memory)
   sec_size = bfd_get_section_limit (abfd, sec);
   contents = elf_section_data (sec)->this_hdr.contents;
 
-  if (contents == NULL && sec_size != 0)
-    {
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[623]) {
+    fprintf(stderr, "reached bug index 623\n");
+  }
+  if ((FIXREVERTER[623] && (sec_size != 0 )) || (!FIXREVERTER[623] && (contents == (void *) 0 && sec_size != 0 ))
+  #else
+  if (sec_size != 0 
+  #endif
+  )
+    {
+      
+    #ifdef FRCOV
+      if (!(contents == (void *) 0 ))
+        fprintf(stderr, "triggered bug index 623\n");
+      #endif
+    
       if (!bfd_malloc_and_get_section (abfd, sec, &contents))
 	{
 	  free (contents);
@@ -6800,6 +7267,9 @@ retrieve_contents (bfd *abfd, asection *sec, bool keep_memory)
       if (keep_memory)
 	elf_section_data (sec)->this_hdr.contents = contents;
     }
+    #ifdef FRCOV
+    }
+    #endif
   return contents;
 }
 
@@ -6830,9 +7300,26 @@ retrieve_local_syms (bfd *input_bfd)
   locsymcount = symtab_hdr->sh_info;
 
   isymbuf = (Elf_Internal_Sym *) symtab_hdr->contents;
-  if (isymbuf == NULL && locsymcount != 0)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[624]) {
+    fprintf(stderr, "reached bug index 624\n");
+  }
+  if ((FIXREVERTER[624] && (isymbuf == (void *) 0 )) || (!FIXREVERTER[624] && (isymbuf == (void *) 0 && locsymcount != 0 ))
+  #else
+  if (isymbuf == (void *) 0 
+  #endif
+  )
+    
+    #ifdef FRCOV
+    {if (!(locsymcount != 0 ))
+      fprintf(stderr, "triggered bug index 624\n");
+    #endif
     isymbuf = bfd_elf_get_elf_syms (input_bfd, symtab_hdr, locsymcount, 0,
 				    NULL, NULL, NULL);
+				    #ifdef FRCOV
+				    }}
+				    #endif
 
   /* Save the symbols for this input file so they won't be read again.  */
   if (isymbuf && isymbuf != (Elf_Internal_Sym *) symtab_hdr->contents)
@@ -7071,8 +7558,23 @@ find_relaxable_sections (bfd *abfd,
 
   internal_relocs = retrieve_internal_relocs (abfd, sec,
 					      link_info->keep_memory);
-  if (internal_relocs == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[626]) {
+    if ((internal_relocs == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 626\n");
+    else
+      fprintf(stderr, "reached bug index 626\n");
+  }
+  if ((!FIXREVERTER[626] && (internal_relocs == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     return ok;
+    #ifdef FRCOV
+    }
+    #endif
 
   contents = retrieve_contents (abfd, sec, link_info->keep_memory);
   if (contents == NULL && sec->size != 0)
@@ -7164,8 +7666,23 @@ collect_source_relocs (bfd *abfd,
 
   internal_relocs = retrieve_internal_relocs (abfd, sec,
 					      link_info->keep_memory);
-  if (internal_relocs == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[627]) {
+    if ((internal_relocs == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 627\n");
+    else
+      fprintf(stderr, "reached bug index 627\n");
+  }
+  if ((!FIXREVERTER[627] && (internal_relocs == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     return ok;
+    #ifdef FRCOV
+    }
+    #endif
 
   sec_size = bfd_get_section_limit (abfd, sec);
   contents = retrieve_contents (abfd, sec, link_info->keep_memory);
@@ -7255,8 +7772,23 @@ collect_source_relocs (bfd *abfd,
 	     associated literal.  */
 	  l32r_irel = find_associated_l32r_irel (abfd, sec, contents,
 						 irel, internal_relocs);
-	  if (l32r_irel == NULL)
+	  
+	  #ifdef FRCOV
+	  {if (FIXREVERTER[628]) {
+	    if ((l32r_irel == (void *) 0 ) && !(0))
+	      fprintf(stderr, "triggered bug index 628\n");
+	    else
+	      fprintf(stderr, "reached bug index 628\n");
+	  }
+	  if ((!FIXREVERTER[628] && (l32r_irel == (void *) 0 ))
+	  #else
+	  if (0
+	  #endif
+	  )
 	    continue;
+	    #ifdef FRCOV
+	    }
+	    #endif
 
 	  r_reloc_init (&r_rel, abfd, l32r_irel, contents, sec_size);
 
@@ -7488,8 +8020,23 @@ find_associated_l32r_irel (bfd *abfd,
 
       if (irel == other_irel)
 	continue;
-      if (irel->r_offset != other_irel->r_offset)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[629]) {
+        if ((irel -> r_offset != other_irel -> r_offset ) && !(0))
+          fprintf(stderr, "triggered bug index 629\n");
+        else
+          fprintf(stderr, "reached bug index 629\n");
+      }
+      if ((!FIXREVERTER[629] && (irel -> r_offset != other_irel -> r_offset ))
+      #else
+      if (0
+      #endif
+      )
 	continue;
+	#ifdef FRCOV
+	}
+	#endif
       if (is_l32r_relocation (abfd, sec, contents, irel))
 	return irel;
     }
@@ -7556,8 +8103,23 @@ reloc_range_compare (const void *a, const void *b)
   const reloc_range *ra = a;
   const reloc_range *rb = b;
 
-  if (ra->addr != rb->addr)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[630]) {
+    if ((ra -> addr != rb -> addr ) && !(0))
+      fprintf(stderr, "triggered bug index 630\n");
+    else
+      fprintf(stderr, "reached bug index 630\n");
+  }
+  if ((!FIXREVERTER[630] && (ra -> addr != rb -> addr ))
+  #else
+  if (0
+  #endif
+  )
     return ra->addr < rb->addr ? -1 : 1;
+    #ifdef FRCOV
+    }
+    #endif
   if (ra->add != rb->add)
     return ra->add ? -1 : 1;
   return 0;
@@ -7916,8 +8478,23 @@ prev_instr_is_a_loop (bfd_byte *contents,
 {
   xtensa_opcode prev_opcode;
 
-  if (offset < 3)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[631]) {
+    if ((offset < 3 ) && !(0))
+      fprintf(stderr, "triggered bug index 631\n");
+    else
+      fprintf(stderr, "reached bug index 631\n");
+  }
+  if ((!FIXREVERTER[631] && (offset < 3 ))
+  #else
+  if (0
+  #endif
+  )
     return false;
+    #ifdef FRCOV
+    }
+    #endif
   prev_opcode = insn_decode_opcode (contents, content_length, offset-3, 0);
   return (xtensa_opcode_is_loop (xtensa_default_isa, prev_opcode) == 1);
 }
@@ -8361,8 +8938,23 @@ xlate_compare (const void *a_v, const void *b_v)
 {
   const xlate_map_entry_t *a = (const xlate_map_entry_t *) a_v;
   const xlate_map_entry_t *b = (const xlate_map_entry_t *) b_v;
-  if (a->orig_address < b->orig_address)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[632]) {
+    if ((a -> orig_address < b -> orig_address ) && !(0))
+      fprintf(stderr, "triggered bug index 632\n");
+    else
+      fprintf(stderr, "reached bug index 632\n");
+  }
+  if ((!FIXREVERTER[632] && (a -> orig_address < b -> orig_address ))
+  #else
+  if (0
+  #endif
+  )
     return -1;
+    #ifdef FRCOV
+    }
+    #endif
   if (a->orig_address > (b->orig_address + b->size - 1))
     return 1;
   return 0;
@@ -8378,11 +8970,41 @@ xlate_offset_with_removed_text (const xlate_map_t *map,
   xlate_map_entry_t *e;
   struct xlate_map_entry se;
 
-  if (map == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[633]) {
+    if ((map == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 633\n");
+    else
+      fprintf(stderr, "reached bug index 633\n");
+  }
+  if ((!FIXREVERTER[633] && (map == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     return offset_with_removed_text (action_list, offset);
+    #ifdef FRCOV
+    }
+    #endif
 
-  if (map->entry_count == 0)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[634]) {
+    if ((map -> entry_count == 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 634\n");
+    else
+      fprintf(stderr, "reached bug index 634\n");
+  }
+  if ((!FIXREVERTER[634] && (map -> entry_count == 0 ))
+  #else
+  if (0
+  #endif
+  )
     return offset;
+    #ifdef FRCOV
+    }
+    #endif
 
   se.orig_address = offset;
   r = bsearch (&se, map->entry, map->entry_count,
@@ -8398,8 +9020,23 @@ xlate_offset_with_removed_text (const xlate_map_t *map,
 	e = NULL;
     }
   BFD_ASSERT (e != NULL);
-  if (e == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[635]) {
+    if ((e == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 635\n");
+    else
+      fprintf(stderr, "reached bug index 635\n");
+  }
+  if ((!FIXREVERTER[635] && (e == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     return offset;
+    #ifdef FRCOV
+    }
+    #endif
   return e->new_address - e->orig_address + offset;
 }
 
@@ -8464,8 +9101,23 @@ build_xlate_map (asection *sec, xtensa_relax_info *relax_info)
 
   ctx.map = (xlate_map_t *) bfd_malloc (sizeof (xlate_map_t));
 
-  if (ctx.map == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[636]) {
+    if ((ctx . map == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 636\n");
+    else
+      fprintf(stderr, "reached bug index 636\n");
+  }
+  if ((!FIXREVERTER[636] && (ctx . map == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     return NULL;
+    #ifdef FRCOV
+    }
+    #endif
 
   num_actions = action_list_count (action_list);
   ctx.map->entry = (xlate_map_entry_t *)
@@ -10231,8 +10883,23 @@ shrink_dynamic_reloc_sections (struct bfd_link_info *info,
   bool dynamic_symbol;
 
   htab = elf_xtensa_hash_table (info);
-  if (htab == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[641]) {
+    if ((htab == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 641\n");
+    else
+      fprintf(stderr, "reached bug index 641\n");
+  }
+  if ((!FIXREVERTER[641] && (htab == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     return;
+    #ifdef FRCOV
+    }
+    #endif
 
   symtab_hdr = &elf_tdata (abfd)->symtab_hdr;
   sym_hashes = elf_sym_hashes (abfd);
@@ -10777,8 +11444,23 @@ relax_property_section (bfd *abfd,
 	  /* Clear the removed bytes.  */
 	  memset (&contents[sec->size - removed_bytes], 0, removed_bytes);
 
-	  if (sec->rawsize == 0)
+	  
+	  #ifdef FRCOV
+	  {if (FIXREVERTER[643]) {
+	    if ((sec -> rawsize == 0  ) && !(0))
+	      fprintf(stderr, "triggered bug index 643\n");
+	    else
+	      fprintf(stderr, "reached bug index 643\n");
+	  }
+	  if ((!FIXREVERTER[643] && (sec -> rawsize == 0  ))
+	  #else
+	  if (0
+	  #endif
+	  )
 	    sec->rawsize = sec->size;
+	    #ifdef FRCOV
+	    }
+	    #endif
 	  sec->size -= removed_bytes;
 
 	  if (xtensa_is_littable_section (sec))
@@ -11063,8 +11745,23 @@ get_elf_r_symndx_hash_entry (bfd *abfd, unsigned long r_symndx)
   struct elf_link_hash_entry *h;
   Elf_Internal_Shdr *symtab_hdr = &elf_tdata (abfd)->symtab_hdr;
 
-  if (r_symndx < symtab_hdr->sh_info)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[651]) {
+    if ((r_symndx < symtab_hdr -> sh_info ) && !(0))
+      fprintf(stderr, "triggered bug index 651\n");
+    else
+      fprintf(stderr, "reached bug index 651\n");
+  }
+  if ((!FIXREVERTER[651] && (r_symndx < symtab_hdr -> sh_info ))
+  #else
+  if (0
+  #endif
+  )
     return NULL;
+    #ifdef FRCOV
+    }
+    #endif
 
   indx = r_symndx - symtab_hdr->sh_info;
   h = elf_sym_hashes (abfd)[indx];
@@ -11185,8 +11882,23 @@ internal_reloc_compare (const void *ap, const void *bp)
   const Elf_Internal_Rela *a = (const Elf_Internal_Rela *) ap;
   const Elf_Internal_Rela *b = (const Elf_Internal_Rela *) bp;
 
-  if (a->r_offset != b->r_offset)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[652]) {
+    if ((a -> r_offset != b -> r_offset ) && !(0))
+      fprintf(stderr, "triggered bug index 652\n");
+    else
+      fprintf(stderr, "reached bug index 652\n");
+  }
+  if ((!FIXREVERTER[652] && (a -> r_offset != b -> r_offset ))
+  #else
+  if (0
+  #endif
+  )
     return (a->r_offset - b->r_offset);
+    #ifdef FRCOV
+    }
+    #endif
 
   /* We don't need to sort on these criteria for correctness,
      but enforcing a more strict ordering prevents unstable qsort
@@ -11195,8 +11907,23 @@ internal_reloc_compare (const void *ap, const void *bp)
      on Solaris 2.7 and 2.8.  We would like to always produce the
      same results no matter the host.  */
 
-  if (a->r_info != b->r_info)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[653]) {
+    if ((a -> r_info != b -> r_info ) && !(0))
+      fprintf(stderr, "triggered bug index 653\n");
+    else
+      fprintf(stderr, "reached bug index 653\n");
+  }
+  if ((!FIXREVERTER[653] && (a -> r_info != b -> r_info ))
+  #else
+  if (0
+  #endif
+  )
     return (a->r_info - b->r_info);
+    #ifdef FRCOV
+    }
+    #endif
 
   return (a->r_addend - b->r_addend);
 }
@@ -11261,8 +11988,23 @@ xtensa_property_section_name (asection *sec, const char *base_name,
   if (group_name)
     {
       suffix = strrchr (sec->name, '.');
-      if (suffix == sec->name)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[656]) {
+        if ((suffix == sec -> name ) && !(0))
+          fprintf(stderr, "triggered bug index 656\n");
+        else
+          fprintf(stderr, "reached bug index 656\n");
+      }
+      if ((!FIXREVERTER[656] && (suffix == sec -> name ))
+      #else
+      if (0
+      #endif
+      )
 	suffix = 0;
+	#ifdef FRCOV
+	}
+	#endif
       prop_sec_name = xtensa_add_names (base_name, suffix);
     }
   else if (startswith (sec->name, ".gnu.linkonce."))
diff --git a/bfd/elf32-z80.c b/bfd/elf32-z80.c
old mode 100644
new mode 100755
diff --git a/bfd/elf32.c b/bfd/elf32.c
old mode 100644
new mode 100755
diff --git a/bfd/elf64-alpha.c b/bfd/elf64-alpha.c
old mode 100644
new mode 100755
diff --git a/bfd/elf64-bpf.c b/bfd/elf64-bpf.c
old mode 100644
new mode 100755
diff --git a/bfd/elf64-gen.c b/bfd/elf64-gen.c
old mode 100644
new mode 100755
diff --git a/bfd/elf64-hppa.c b/bfd/elf64-hppa.c
old mode 100644
new mode 100755
index 2338d6c..9d87e80
--- a/bfd/elf64-hppa.c
+++ b/bfd/elf64-hppa.c
@@ -1,3 +1,6 @@
+#ifdef FRCOV
+extern short FIXREVERTER[];
+#endif
 /* Support for HPPA 64-bit ELF
    Copyright (C) 1999-2021 Free Software Foundation, Inc.
 
@@ -2895,8 +2898,23 @@ elf_hppa_final_link (bfd *abfd, struct bfd_link_info *info)
   struct stat buf;
   struct elf64_hppa_link_hash_table *hppa_info = hppa_link_hash_table (info);
 
-  if (hppa_info == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[7529]) {
+    if ((hppa_info == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 7529\n");
+    else
+      fprintf(stderr, "reached bug index 7529\n");
+  }
+  if ((!FIXREVERTER[7529] && (hppa_info == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     return false;
+    #ifdef FRCOV
+    }
+    #endif
 
   if (! bfd_link_relocatable (info))
     {
diff --git a/bfd/elf64-hppa.h b/bfd/elf64-hppa.h
old mode 100644
new mode 100755
diff --git a/bfd/elf64-ia64-vms.c b/bfd/elf64-ia64-vms.c
old mode 100644
new mode 100755
diff --git a/bfd/elf64-mips.c b/bfd/elf64-mips.c
old mode 100644
new mode 100755
diff --git a/bfd/elf64-mmix.c b/bfd/elf64-mmix.c
old mode 100644
new mode 100755
diff --git a/bfd/elf64-nfp.c b/bfd/elf64-nfp.c
old mode 100644
new mode 100755
diff --git a/bfd/elf64-ppc.c b/bfd/elf64-ppc.c
old mode 100644
new mode 100755
index a4a0530..69979d6
--- a/bfd/elf64-ppc.c
+++ b/bfd/elf64-ppc.c
@@ -1,3 +1,6 @@
+#ifdef FRCOV
+extern short FIXREVERTER[];
+#endif
 /* PowerPC64-specific support for 64-bit ELF.
    Copyright (C) 1999-2021 Free Software Foundation, Inc.
    Written by Linus Nordberg, Swox AB <info@swox.com>,
@@ -1437,8 +1440,23 @@ ppc64_elf_ha_reloc (bfd *abfd, arelent *reloc_entry, asymbol *symbol,
   insn &= ~0x1fffc1;
   insn |= (value & 0xffc1) | ((value & 0x3e) << 15);
   bfd_put_32 (abfd, insn, (bfd_byte *) data + octets);
-  if (value + 0x8000 > 0xffff)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[5987]) {
+    if ((value + 32768 > 65535 ) && !(0))
+      fprintf(stderr, "triggered bug index 5987\n");
+    else
+      fprintf(stderr, "reached bug index 5987\n");
+  }
+  if ((!FIXREVERTER[5987] && (value + 32768 > 65535 ))
+  #else
+  if (0
+  #endif
+  )
     return bfd_reloc_overflow;
+    #ifdef FRCOV
+    }
+    #endif
   return bfd_reloc_ok;
 }
 
@@ -1604,8 +1622,23 @@ ppc64_elf_toc_reloc (bfd *abfd, arelent *reloc_entry, asymbol *symbol,
 				  input_section, output_bfd, error_message);
 
   TOCstart = _bfd_get_gp_value (input_section->output_section->owner);
-  if (TOCstart == 0)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[5988]) {
+    if ((TOCstart == 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 5988\n");
+    else
+      fprintf(stderr, "reached bug index 5988\n");
+  }
+  if ((!FIXREVERTER[5988] && (TOCstart == 0 ))
+  #else
+  if (0
+  #endif
+  )
     TOCstart = ppc64_elf_set_toc (NULL, input_section->output_section->owner);
+    #ifdef FRCOV
+    }
+    #endif
 
   /* Subtract the TOC base address.  */
   reloc_entry->addend -= TOCstart + TOC_BASE_OFF;
@@ -1627,8 +1660,23 @@ ppc64_elf_toc_ha_reloc (bfd *abfd, arelent *reloc_entry, asymbol *symbol,
 				  input_section, output_bfd, error_message);
 
   TOCstart = _bfd_get_gp_value (input_section->output_section->owner);
-  if (TOCstart == 0)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[5989]) {
+    if ((TOCstart == 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 5989\n");
+    else
+      fprintf(stderr, "reached bug index 5989\n");
+  }
+  if ((!FIXREVERTER[5989] && (TOCstart == 0 ))
+  #else
+  if (0
+  #endif
+  )
     TOCstart = ppc64_elf_set_toc (NULL, input_section->output_section->owner);
+    #ifdef FRCOV
+    }
+    #endif
 
   /* Subtract the TOC base address.  */
   reloc_entry->addend -= TOCstart + TOC_BASE_OFF;
@@ -1654,8 +1702,23 @@ ppc64_elf_toc64_reloc (bfd *abfd, arelent *reloc_entry, asymbol *symbol,
 				  input_section, output_bfd, error_message);
 
   TOCstart = _bfd_get_gp_value (input_section->output_section->owner);
-  if (TOCstart == 0)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[5990]) {
+    if ((TOCstart == 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 5990\n");
+    else
+      fprintf(stderr, "reached bug index 5990\n");
+  }
+  if ((!FIXREVERTER[5990] && (TOCstart == 0 ))
+  #else
+  if (0
+  #endif
+  )
     TOCstart = ppc64_elf_set_toc (NULL, input_section->output_section->owner);
+    #ifdef FRCOV
+    }
+    #endif
 
   octets = reloc_entry->address * OCTETS_PER_BYTE (abfd, input_section);
   bfd_put_64 (abfd, TOCstart + TOC_BASE_OFF, (bfd_byte *) data + octets);
@@ -2029,8 +2092,23 @@ ppc64_elf_new_section_hook (bfd *abfd, asection *sec)
       size_t amt = sizeof (*sdata);
 
       sdata = bfd_zalloc (abfd, amt);
-      if (sdata == NULL)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[5999]) {
+        if ((sdata == (void *) 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 5999\n");
+        else
+          fprintf(stderr, "reached bug index 5999\n");
+      }
+      if ((!FIXREVERTER[5999] && (sdata == (void *) 0 ))
+      #else
+      if (0
+      #endif
+      )
 	return false;
+	#ifdef FRCOV
+	}
+	#endif
       sec->used_by_bfd = sdata;
     }
 
@@ -2148,10 +2226,40 @@ compare_symbols (const void *ap, const void *bp)
      BSF_DYNAMIC.  Since we are sorting the symbol pointers which were
      originally in the same order as the symbols (and we're not
      sorting the symbols themselves), this ensures a stable sort.  */
-  if (a < b)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[6000]) {
+    if ((a < b ) && !(0))
+      fprintf(stderr, "triggered bug index 6000\n");
+    else
+      fprintf(stderr, "reached bug index 6000\n");
+  }
+  if ((!FIXREVERTER[6000] && (a < b ))
+  #else
+  if (0
+  #endif
+  )
     return -1;
-  if (a > b)
+    #ifdef FRCOV
+    }
+    #endif
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[6001]) {
+    if ((a > b ) && !(0))
+      fprintf(stderr, "triggered bug index 6001\n");
+    else
+      fprintf(stderr, "reached bug index 6001\n");
+  }
+  if ((!FIXREVERTER[6001] && (a > b ))
+  #else
+  if (0
+  #endif
+  )
     return 1;
+    #ifdef FRCOV
+    }
+    #endif
   return 0;
 }
 
@@ -3913,14 +4021,44 @@ move_plt_plist (struct ppc_link_hash_entry *from,
 	      struct plt_entry *dent;
 
 	      for (dent = to->elf.plt.plist; dent != NULL; dent = dent->next)
-		if (dent->addend == ent->addend)
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[6030]) {
+		  if ((dent -> addend == ent -> addend ) && !(0))
+		    fprintf(stderr, "triggered bug index 6030\n");
+		  else
+		    fprintf(stderr, "reached bug index 6030\n");
+		}
+		if ((!FIXREVERTER[6030] && (dent -> addend == ent -> addend ))
+		#else
+		if (0
+		#endif
+		)
 		  {
 		    dent->plt.refcount += ent->plt.refcount;
 		    *entp = ent->next;
 		    break;
 		  }
-	      if (dent == NULL)
+		  #ifdef FRCOV
+		  }
+		  #endif
+	      
+	      #ifdef FRCOV
+	      {if (FIXREVERTER[6031]) {
+	        if ((dent == (void *) 0 ) && !(0))
+	          fprintf(stderr, "triggered bug index 6031\n");
+	        else
+	          fprintf(stderr, "reached bug index 6031\n");
+	      }
+	      if ((!FIXREVERTER[6031] && (dent == (void *) 0 ))
+	      #else
+	      if (0
+	      #endif
+	      )
 		entp = &ent->next;
+		#ifdef FRCOV
+		}
+		#endif
 	    }
 	  *entp = to->elf.plt.plist;
 	}
@@ -4058,8 +4196,23 @@ lookup_fdh (struct ppc_link_hash_entry *fh, struct ppc_link_hash_table *htab)
 
       fdh = ppc_elf_hash_entry (elf_link_hash_lookup (&htab->elf, fd_name,
 						      false, false, false));
-      if (fdh == NULL)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[6035]) {
+        if ((fdh == (void *) 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 6035\n");
+        else
+          fprintf(stderr, "reached bug index 6035\n");
+      }
+      if ((!FIXREVERTER[6035] && (fdh == (void *) 0 ))
+      #else
+      if (0
+      #endif
+      )
 	return fdh;
+	#ifdef FRCOV
+	}
+	#endif
 
       fdh->is_func_descriptor = 1;
       fdh->oh = fh;
@@ -5386,8 +5539,23 @@ opd_entry_value (asection *opd_sec,
 	}
 
       /* PR 17512: file: 64b9dfbb.  */
-      if (offset + 7 >= opd_sec->size || offset + 7 < offset)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[6060]) {
+        if ((offset + 7 >= opd_sec -> size || offset + 7 < offset ) && !(0))
+          fprintf(stderr, "triggered bug index 6060\n");
+        else
+          fprintf(stderr, "reached bug index 6060\n");
+      }
+      if ((!FIXREVERTER[6060] && (offset + 7 >= opd_sec -> size || offset + 7 < offset ))
+      #else
+      if (0
+      #endif
+      )
 	return (bfd_vma) -1;
+	#ifdef FRCOV
+	}
+	#endif
 
       val = bfd_get_64 (opd_bfd, contents + offset);
       if (code_sec != NULL)
@@ -5422,11 +5590,41 @@ opd_entry_value (asection *opd_sec,
   BFD_ASSERT (is_ppc64_elf (opd_bfd));
 
   relocs = ppc64_elf_tdata (opd_bfd)->opd.relocs;
-  if (relocs == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[6061]) {
+    if ((relocs == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 6061\n");
+    else
+      fprintf(stderr, "reached bug index 6061\n");
+  }
+  if ((!FIXREVERTER[6061] && (relocs == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     relocs = _bfd_elf_link_read_relocs (opd_bfd, opd_sec, NULL, NULL, true);
+    #ifdef FRCOV
+    }
+    #endif
   /* PR 17512: file: df8e1fd6.  */
-  if (relocs == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[6062]) {
+    if ((relocs == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 6062\n");
+    else
+      fprintf(stderr, "reached bug index 6062\n");
+  }
+  if ((!FIXREVERTER[6062] && (relocs == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     return (bfd_vma) -1;
+    #ifdef FRCOV
+    }
+    #endif
 
   /* Go find the opd reloc at the sym address.  */
   lo = relocs;
@@ -5484,8 +5682,23 @@ opd_entry_value (asection *opd_sec,
 			  sym = bfd_elf_get_elf_syms (opd_bfd, symtab_hdr,
 						      symcnt, 0,
 						      NULL, NULL, NULL);
-			  if (sym == NULL)
+			  
+			  #ifdef FRCOV
+			  {if (FIXREVERTER[6063]) {
+			    if ((sym == (void *) 0 ) && !(0))
+			      fprintf(stderr, "triggered bug index 6063\n");
+			    else
+			      fprintf(stderr, "reached bug index 6063\n");
+			  }
+			  if ((!FIXREVERTER[6063] && (sym == (void *) 0 ))
+			  #else
+			  if (0
+			  #endif
+			  )
 			    break;
+			    #ifdef FRCOV
+			    }
+			    #endif
 			  symtab_hdr->contents = (bfd_byte *) sym;
 			}
 		      sym += symndx;
@@ -5495,12 +5708,42 @@ opd_entry_value (asection *opd_sec,
 		      sym = bfd_elf_get_elf_syms (opd_bfd, symtab_hdr,
 						  1, symndx,
 						  NULL, NULL, NULL);
-		      if (sym == NULL)
+		      
+		      #ifdef FRCOV
+		      {if (FIXREVERTER[6064]) {
+		        if ((sym == (void *) 0 ) && !(0))
+		          fprintf(stderr, "triggered bug index 6064\n");
+		        else
+		          fprintf(stderr, "reached bug index 6064\n");
+		      }
+		      if ((!FIXREVERTER[6064] && (sym == (void *) 0 ))
+		      #else
+		      if (0
+		      #endif
+		      )
 			break;
+			#ifdef FRCOV
+			}
+			#endif
 		    }
 		  sec = bfd_section_from_elf_index (opd_bfd, sym->st_shndx);
-		  if (sec == NULL)
+		  
+		  #ifdef FRCOV
+		  {if (FIXREVERTER[6065]) {
+		    if ((sec == (void *) 0 ) && !(0))
+		      fprintf(stderr, "triggered bug index 6065\n");
+		    else
+		      fprintf(stderr, "reached bug index 6065\n");
+		  }
+		  if ((!FIXREVERTER[6065] && (sec == (void *) 0 ))
+		  #else
+		  if (0
+		  #endif
+		  )
 		    break;
+		    #ifdef FRCOV
+		    }
+		    #endif
 		  BFD_ASSERT ((sec->flags & SEC_MERGE) == 0);
 		  val = sym->st_value;
 		}
@@ -6265,8 +6508,23 @@ func_desc_adjust (struct elf_link_hash_entry *h, void *inf)
 
   info = inf;
   htab = ppc_hash_table (info);
-  if (htab == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[6075]) {
+    if ((htab == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 6075\n");
+    else
+      fprintf(stderr, "reached bug index 6075\n");
+  }
+  if ((!FIXREVERTER[6075] && (htab == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     return false;
+    #ifdef FRCOV
+    }
+    #endif
 
   /* Find the corresponding function descriptor symbol.  */
   fdh = lookup_fdh (fh, htab);
@@ -6298,8 +6556,23 @@ func_desc_adjust (struct elf_link_hash_entry *h, void *inf)
       for (ent = fh->elf.plt.plist; ent != NULL; ent = ent->next)
 	if (ent->plt.refcount > 0)
 	  break;
-      if (ent == NULL)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[6076]) {
+        if ((ent == (void *) 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 6076\n");
+        else
+          fprintf(stderr, "reached bug index 6076\n");
+      }
+      if ((!FIXREVERTER[6076] && (ent == (void *) 0 ))
+      #else
+      if (0
+      #endif
+      )
 	return true;
+	#ifdef FRCOV
+	}
+	#endif
     }
 
   /* Create a descriptor as undefined if necessary.  */
@@ -6309,8 +6582,23 @@ func_desc_adjust (struct elf_link_hash_entry *h, void *inf)
 	  || fh->elf.root.type == bfd_link_hash_undefweak))
     {
       fdh = make_fdh (info, fh);
-      if (fdh == NULL)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[6077]) {
+        if ((fdh == (void *) 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 6077\n");
+        else
+          fprintf(stderr, "reached bug index 6077\n");
+      }
+      if ((!FIXREVERTER[6077] && (fdh == (void *) 0 ))
+      #else
+      if (0
+      #endif
+      )
 	return false;
+	#ifdef FRCOV
+	}
+	#endif
     }
 
   /* We can't support overriding of symbols on a fake descriptor.  */
@@ -11335,8 +11623,23 @@ get_relocs (asection *sec, int count)
       bfd_size_type relsize;
       relsize = sec->reloc_count * sizeof (*relocs);
       relocs = bfd_alloc (sec->owner, relsize);
-      if (relocs == NULL)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[6101]) {
+        if ((relocs == (void *) 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 6101\n");
+        else
+          fprintf(stderr, "reached bug index 6101\n");
+      }
+      if ((!FIXREVERTER[6101] && (relocs == (void *) 0 ))
+      #else
+      if (0
+      #endif
+      )
 	return NULL;
+	#ifdef FRCOV
+	}
+	#endif
       elfsec_data->relocs = relocs;
       elfsec_data->rela.hdr = bfd_zalloc (sec->owner,
 					  sizeof (Elf_Internal_Shdr));
@@ -11379,8 +11682,23 @@ use_global_in_relocs (struct ppc_link_hash_table *htab,
 	 hashes array.  */
       hsize = (htab->stub_globals + 1) * sizeof (*hashes);
       hashes = bfd_zalloc (htab->params->stub_bfd, hsize);
-      if (hashes == NULL)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[6102]) {
+        if ((hashes == (void *) 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 6102\n");
+        else
+          fprintf(stderr, "reached bug index 6102\n");
+      }
+      if ((!FIXREVERTER[6102] && (hashes == (void *) 0 ))
+      #else
+      if (0
+      #endif
+      )
 	return false;
+	#ifdef FRCOV
+	}
+	#endif
       elf_sym_hashes (htab->params->stub_bfd) = hashes;
       htab->stub_globals = 1;
     }
@@ -11485,8 +11803,23 @@ ppc_build_one_stub (struct bfd_hash_entry *gen_entry, void *in_arg)
 			    stub_entry->target_section);
 
   htab = ppc_hash_table (info);
-  if (htab == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[6104]) {
+    if ((htab == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 6104\n");
+    else
+      fprintf(stderr, "reached bug index 6104\n");
+  }
+  if ((!FIXREVERTER[6104] && (htab == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     return false;
+    #ifdef FRCOV
+    }
+    #endif
 
   BFD_ASSERT (stub_entry->stub_offset >= stub_entry->group->stub_sec->size);
   loc = stub_entry->group->stub_sec->contents + stub_entry->stub_offset;
@@ -11548,8 +11881,23 @@ ppc_build_one_stub (struct bfd_hash_entry *gen_entry, void *in_arg)
       if (info->emitrelocations)
 	{
 	  r = get_relocs (stub_entry->group->stub_sec, 1);
-	  if (r == NULL)
+	  
+	  #ifdef FRCOV
+	  {if (FIXREVERTER[6105]) {
+	    if ((r == (void *) 0 ) && !(0))
+	      fprintf(stderr, "triggered bug index 6105\n");
+	    else
+	      fprintf(stderr, "reached bug index 6105\n");
+	  }
+	  if ((!FIXREVERTER[6105] && (r == (void *) 0 ))
+	  #else
+	  if (0
+	  #endif
+	  )
 	    return false;
+	    #ifdef FRCOV
+	    }
+	    #endif
 	  r->r_offset = p - 4 - stub_entry->group->stub_sec->contents;
 	  r->r_info = ELF64_R_INFO (0, R_PPC64_REL24);
 	  r->r_addend = targ;
@@ -11564,13 +11912,28 @@ ppc_build_one_stub (struct bfd_hash_entry *gen_entry, void *in_arg)
       br_entry = ppc_branch_hash_lookup (&htab->branch_hash_table,
 					 stub_entry->root.string + 9,
 					 false, false);
-      if (br_entry == NULL)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[6106]) {
+        if ((br_entry == (void *) 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 6106\n");
+        else
+          fprintf(stderr, "reached bug index 6106\n");
+      }
+      if ((!FIXREVERTER[6106] && (br_entry == (void *) 0 ))
+      #else
+      if (0
+      #endif
+      )
 	{
 	  _bfd_error_handler (_("can't find branch stub `%s'"),
 			      stub_entry->root.string);
 	  htab->stub_error = true;
 	  return false;
 	}
+	#ifdef FRCOV
+	}
+	#endif
 
       targ = (stub_entry->target_value
 	      + stub_entry->target_section->output_offset
@@ -11605,8 +11968,23 @@ ppc_build_one_stub (struct bfd_hash_entry *gen_entry, void *in_arg)
 	  else if (info->emitrelocations)
 	    {
 	      r = get_relocs (htab->brlt, 1);
-	      if (r == NULL)
+	      
+	      #ifdef FRCOV
+	      {if (FIXREVERTER[6107]) {
+	        if ((r == (void *) 0 ) && !(0))
+	          fprintf(stderr, "triggered bug index 6107\n");
+	        else
+	          fprintf(stderr, "reached bug index 6107\n");
+	      }
+	      if ((!FIXREVERTER[6107] && (r == (void *) 0 ))
+	      #else
+	      if (0
+	      #endif
+	      )
 		return false;
+		#ifdef FRCOV
+		}
+		#endif
 	      /* brlt, being SEC_LINKER_CREATED does not go through the
 		 normal reloc processing.  Symbols and offsets are not
 		 translated from input file to output file form, so
@@ -11640,8 +12018,23 @@ ppc_build_one_stub (struct bfd_hash_entry *gen_entry, void *in_arg)
       if (info->emitrelocations)
 	{
 	  r = get_relocs (stub_entry->group->stub_sec, 1 + (PPC_HA (off) != 0));
-	  if (r == NULL)
+	  
+	  #ifdef FRCOV
+	  {if (FIXREVERTER[6108]) {
+	    if ((r == (void *) 0 ) && !(0))
+	      fprintf(stderr, "triggered bug index 6108\n");
+	    else
+	      fprintf(stderr, "reached bug index 6108\n");
+	  }
+	  if ((!FIXREVERTER[6108] && (r == (void *) 0 ))
+	  #else
+	  if (0
+	  #endif
+	  )
 	    return false;
+	    #ifdef FRCOV
+	    }
+	    #endif
 	  r[0].r_offset = loc - stub_entry->group->stub_sec->contents;
 	  if (bfd_big_endian (info->output_bfd))
 	    r[0].r_offset += 2;
@@ -11835,8 +12228,23 @@ ppc_build_one_stub (struct bfd_hash_entry *gen_entry, void *in_arg)
 	      roff += 16;
 	    }
 	  r = get_relocs (stub_entry->group->stub_sec, num_rel);
-	  if (r == NULL)
+	  
+	  #ifdef FRCOV
+	  {if (FIXREVERTER[6109]) {
+	    if ((r == (void *) 0 ) && !(0))
+	      fprintf(stderr, "triggered bug index 6109\n");
+	    else
+	      fprintf(stderr, "reached bug index 6109\n");
+	  }
+	  if ((!FIXREVERTER[6109] && (r == (void *) 0 ))
+	  #else
+	  if (0
+	  #endif
+	  )
 	    return false;
+	    #ifdef FRCOV
+	    }
+	    #endif
 	  if (htab->params->power10_stubs != 0)
 	    r = emit_relocs_for_power10_offset (info, r, roff, targ, off, odd);
 	  else
@@ -11913,8 +12321,23 @@ ppc_build_one_stub (struct bfd_hash_entry *gen_entry, void *in_arg)
 			      ? 2 + (htab->params->plt_static_chain
 				     && PPC_HA (off + 16) == PPC_HA (off))
 			      : 1)));
-	  if (r == NULL)
+	  
+	  #ifdef FRCOV
+	  {if (FIXREVERTER[6110]) {
+	    if ((r == (void *) 0 ) && !(0))
+	      fprintf(stderr, "triggered bug index 6110\n");
+	    else
+	      fprintf(stderr, "reached bug index 6110\n");
+	  }
+	  if ((!FIXREVERTER[6110] && (r == (void *) 0 ))
+	  #else
+	  if (0
+	  #endif
+	  )
 	    return false;
+	    #ifdef FRCOV
+	    }
+	    #endif
 	  r[0].r_offset = loc - stub_entry->group->stub_sec->contents;
 	  if (bfd_big_endian (info->output_bfd))
 	    r[0].r_offset += 2;
@@ -11967,14 +12390,44 @@ ppc_build_one_stub (struct bfd_hash_entry *gen_entry, void *in_arg)
       len1 = strlen (stub_str[stub_entry->stub_type - 1]);
       len2 = strlen (stub_entry->root.string);
       name = bfd_malloc (len1 + len2 + 2);
-      if (name == NULL)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[6111]) {
+        if ((name == (void *) 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 6111\n");
+        else
+          fprintf(stderr, "reached bug index 6111\n");
+      }
+      if ((!FIXREVERTER[6111] && (name == (void *) 0 ))
+      #else
+      if (0
+      #endif
+      )
 	return false;
+	#ifdef FRCOV
+	}
+	#endif
       memcpy (name, stub_entry->root.string, 9);
       memcpy (name + 9, stub_str[stub_entry->stub_type - 1], len1);
       memcpy (name + len1 + 9, stub_entry->root.string + 8, len2 - 8 + 1);
       h = elf_link_hash_lookup (&htab->elf, name, true, false, false);
-      if (h == NULL)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[6112]) {
+        if ((h == (void *) 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 6112\n");
+        else
+          fprintf(stderr, "reached bug index 6112\n");
+      }
+      if ((!FIXREVERTER[6112] && (h == (void *) 0 ))
+      #else
+      if (0
+      #endif
+      )
 	return false;
+	#ifdef FRCOV
+	}
+	#endif
       if (h->root.type == bfd_link_hash_new)
 	{
 	  h->root.type = bfd_link_hash_defined;
@@ -12011,8 +12464,23 @@ ppc_size_one_stub (struct bfd_hash_entry *gen_entry, void *in_arg)
   info = in_arg;
 
   htab = ppc_hash_table (info);
-  if (htab == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[6113]) {
+    if ((htab == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 6113\n");
+    else
+      fprintf(stderr, "reached bug index 6113\n");
+  }
+  if ((!FIXREVERTER[6113] && (htab == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     return false;
+    #ifdef FRCOV
+    }
+    #endif
 
   /* Fail if the target section could not be assigned to an output
      section.  The user should fix his linker script.  */
@@ -12097,13 +12565,28 @@ ppc_size_one_stub (struct bfd_hash_entry *gen_entry, void *in_arg)
 	  br_entry = ppc_branch_hash_lookup (&htab->branch_hash_table,
 					     stub_entry->root.string + 9,
 					     true, false);
-	  if (br_entry == NULL)
+	  
+	  #ifdef FRCOV
+	  {if (FIXREVERTER[6114]) {
+	    if ((br_entry == (void *) 0 ) && !(0))
+	      fprintf(stderr, "triggered bug index 6114\n");
+	    else
+	      fprintf(stderr, "reached bug index 6114\n");
+	  }
+	  if ((!FIXREVERTER[6114] && (br_entry == (void *) 0 ))
+	  #else
+	  if (0
+	  #endif
+	  )
 	    {
 	      _bfd_error_handler (_("can't build branch stub `%s'"),
 				  stub_entry->root.string);
 	      htab->stub_error = true;
 	      return false;
 	    }
+	    #ifdef FRCOV
+	    }
+	    #endif
 
 	  if (br_entry->iter != htab->stub_iteration)
 	    {
@@ -14038,8 +14521,23 @@ ppc64_elf_set_toc (struct bfd_link_info *info, bfd *obfd)
     }
 
   TOCstart = 0;
-  if (s != NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[6130]) {
+    if ((s != (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 6130\n");
+    else
+      fprintf(stderr, "reached bug index 6130\n");
+  }
+  if ((!FIXREVERTER[6130] && (s != (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     TOCstart = s->output_section->vma + s->output_offset;
+    #ifdef FRCOV
+    }
+    #endif
 
   /* Force alignment.  */
   adjust = TOCstart & (TOC_BASE_ALIGN - 1);
@@ -14085,8 +14583,23 @@ build_global_entry_stubs_and_plt (struct elf_link_hash_entry *h, void *inf)
 
   info = inf;
   htab = ppc_hash_table (info);
-  if (htab == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[6131]) {
+    if ((htab == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 6131\n");
+    else
+      fprintf(stderr, "reached bug index 6131\n");
+  }
+  if ((!FIXREVERTER[6131] && (htab == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     return false;
+    #ifdef FRCOV
+    }
+    #endif
 
   for (ent = h->plt.plist; ent != NULL; ent = ent->next)
     if (ent->plt.offset != (bfd_vma) -1)
@@ -14173,8 +14686,23 @@ build_global_entry_stubs_and_plt (struct elf_link_hash_entry *h, void *inf)
     return true;
 
   s = htab->global_entry;
-  if (s == NULL || s->size == 0)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[6132]) {
+    if ((s == (void *) 0 || s -> size == 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 6132\n");
+    else
+      fprintf(stderr, "reached bug index 6132\n");
+  }
+  if ((!FIXREVERTER[6132] && (s == (void *) 0 || s -> size == 0 ))
+  #else
+  if (0
+  #endif
+  )
     return true;
+    #ifdef FRCOV
+    }
+    #endif
 
   for (ent = h->plt.plist; ent != NULL; ent = ent->next)
     if (ent->plt.offset != (bfd_vma) -1
@@ -14211,13 +14739,43 @@ build_global_entry_stubs_and_plt (struct elf_link_hash_entry *h, void *inf)
 	    size_t len = strlen (h->root.root.string);
 	    char *name = bfd_malloc (sizeof "12345678.global_entry." + len);
 
-	    if (name == NULL)
+	    
+	    #ifdef FRCOV
+	    {if (FIXREVERTER[6133]) {
+	      if ((name == (void *) 0 ) && !(0))
+	        fprintf(stderr, "triggered bug index 6133\n");
+	      else
+	        fprintf(stderr, "reached bug index 6133\n");
+	    }
+	    if ((!FIXREVERTER[6133] && (name == (void *) 0 ))
+	    #else
+	    if (0
+	    #endif
+	    )
 	      return false;
+	      #ifdef FRCOV
+	      }
+	      #endif
 
 	    sprintf (name, "%08x.global_entry.%s", s->id, h->root.root.string);
 	    h = elf_link_hash_lookup (&htab->elf, name, true, false, false);
-	    if (h == NULL)
+	    
+	    #ifdef FRCOV
+	    {if (FIXREVERTER[6134]) {
+	      if ((h == (void *) 0 ) && !(0))
+	        fprintf(stderr, "triggered bug index 6134\n");
+	      else
+	        fprintf(stderr, "reached bug index 6134\n");
+	    }
+	    if ((!FIXREVERTER[6134] && (h == (void *) 0 ))
+	    #else
+	    if (0
+	    #endif
+	    )
 	      return false;
+	      #ifdef FRCOV
+	      }
+	      #endif
 	    if (h->root.type == bfd_link_hash_new)
 	      {
 		h->root.type = bfd_link_hash_defined;
diff --git a/bfd/elf64-ppc.h b/bfd/elf64-ppc.h
old mode 100644
new mode 100755
diff --git a/bfd/elf64-s390.c b/bfd/elf64-s390.c
old mode 100644
new mode 100755
diff --git a/bfd/elf64-sparc.c b/bfd/elf64-sparc.c
old mode 100644
new mode 100755
index 035ebdd..cc1df84
--- a/bfd/elf64-sparc.c
+++ b/bfd/elf64-sparc.c
@@ -1,3 +1,6 @@
+#ifdef FRCOV
+extern short FIXREVERTER[];
+#endif
 /* SPARC-specific support for 64-bit ELF
    Copyright (C) 1993-2021 Free Software Foundation, Inc.
 
@@ -707,8 +710,23 @@ elf64_sparc_merge_private_bfd_data (bfd *ibfd, struct bfd_link_info *info)
 	  new_mm = (new_flags & EF_SPARCV9_MM);
 	  old_flags &= ~EF_SPARCV9_MM;
 	  new_flags &= ~EF_SPARCV9_MM;
-	  if (new_mm < old_mm)
+	  
+	  #ifdef FRCOV
+	  {if (FIXREVERTER[5199]) {
+	    if ((new_mm < old_mm ) && !(0))
+	      fprintf(stderr, "triggered bug index 5199\n");
+	    else
+	      fprintf(stderr, "reached bug index 5199\n");
+	  }
+	  if ((!FIXREVERTER[5199] && (new_mm < old_mm ))
+	  #else
+	  if (0
+	  #endif
+	  )
 	    old_mm = new_mm;
+	    #ifdef FRCOV
+	    }
+	    #endif
 	  old_flags |= old_mm;
 	  new_flags |= old_mm;
 	}
diff --git a/bfd/elf64-tilegx.c b/bfd/elf64-tilegx.c
old mode 100644
new mode 100755
diff --git a/bfd/elf64-tilegx.h b/bfd/elf64-tilegx.h
old mode 100644
new mode 100755
diff --git a/bfd/elf64-x86-64.c b/bfd/elf64-x86-64.c
old mode 100644
new mode 100755
diff --git a/bfd/elf64.c b/bfd/elf64.c
old mode 100644
new mode 100755
diff --git a/bfd/elfcode.h b/bfd/elfcode.h
old mode 100644
new mode 100755
diff --git a/bfd/elfcore.h b/bfd/elfcore.h
old mode 100644
new mode 100755
diff --git a/bfd/elflink.c b/bfd/elflink.c
old mode 100644
new mode 100755
index 0e1871a..8735943
--- a/bfd/elflink.c
+++ b/bfd/elflink.c
@@ -1,3 +1,6 @@
+#ifdef FRCOV
+extern short FIXREVERTER[];
+#endif
 /* ELF linking support for BFD.
    Copyright (C) 1995-2021 Free Software Foundation, Inc.
 
@@ -240,8 +243,23 @@ _bfd_elf_link_create_dynstrtab (bfd *abfd, struct bfd_link_info *info)
   if (hash_table->dynstr == NULL)
     {
       hash_table->dynstr = _bfd_elf_strtab_init ();
-      if (hash_table->dynstr == NULL)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[8811]) {
+        if ((hash_table -> dynstr == (void *) 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 8811\n");
+        else
+          fprintf(stderr, "reached bug index 8811\n");
+      }
+      if ((!FIXREVERTER[8811] && (hash_table -> dynstr == (void *) 0 ))
+      #else
+      if (0
+      #endif
+      )
 	return false;
+	#ifdef FRCOV
+	}
+	#endif
     }
   return true;
 }
@@ -1029,8 +1047,23 @@ elf_merge_st_other (bfd *abfd, struct elf_link_hash_entry *h,
 
       /* Keep the most constraining visibility.  Leave the remainder
 	 of the st_other field to elf_backend_merge_symbol_attribute.  */
-      if (symvis - 1 < hvis - 1)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[8815]) {
+        if ((symvis - 1 < hvis - 1  ) && !(0))
+          fprintf(stderr, "triggered bug index 8815\n");
+        else
+          fprintf(stderr, "reached bug index 8815\n");
+      }
+      if ((!FIXREVERTER[8815] && (symvis - 1 < hvis - 1  ))
+      #else
+      if (0
+      #endif
+      )
 	h->other = symvis | (h->other & ~ELF_ST_VISIBILITY (-1));
+	#ifdef FRCOV
+	}
+	#endif
     }
   else if (definition
 	   && ELF_ST_VISIBILITY (st_other) != STV_DEFAULT
@@ -1091,8 +1124,23 @@ _bfd_elf_merge_symbol (bfd *abfd,
   else
     h = ((struct elf_link_hash_entry *)
 	 bfd_wrapped_link_hash_lookup (abfd, info, name, true, false, false));
-  if (h == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[8816]) {
+    if ((h == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 8816\n");
+    else
+      fprintf(stderr, "reached bug index 8816\n");
+  }
+  if ((!FIXREVERTER[8816] && (h == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     return false;
+    #ifdef FRCOV
+    }
+    #endif
   *sym_hash = h;
 
   bed = get_elf_backend_data (abfd);
@@ -1631,8 +1679,23 @@ _bfd_elf_merge_symbol (bfd *abfd,
 
       (*info->callbacks->multiple_common) (info, &h->root, abfd,
 					   bfd_link_hash_common, sym->st_size);
-      if (sym->st_size > h->size)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[8817]) {
+        if ((sym -> st_size > h -> size  ) && !(0))
+          fprintf(stderr, "triggered bug index 8817\n");
+        else
+          fprintf(stderr, "reached bug index 8817\n");
+      }
+      if ((!FIXREVERTER[8817] && (sym -> st_size > h -> size  ))
+      #else
+      if (0
+      #endif
+      )
 	h->size = sym->st_size;
+	#ifdef FRCOV
+	}
+	#endif
 
       *size_change_ok = true;
     }
@@ -1895,8 +1958,23 @@ _bfd_elf_add_default_symbol (bfd *abfd,
     {
       /* PR ld/19073: We may see an unversioned definition after the
 	 default version.  */
-      if (p == NULL)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[8818]) {
+        if ((p == (void *) 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 8818\n");
+        else
+          fprintf(stderr, "reached bug index 8818\n");
+      }
+      if ((!FIXREVERTER[8818] && (p == (void *) 0 ))
+      #else
+      if (0
+      #endif
+      )
 	return true;
+	#ifdef FRCOV
+	}
+	#endif
     }
 
   bed = get_elf_backend_data (abfd);
@@ -1905,8 +1983,23 @@ _bfd_elf_add_default_symbol (bfd *abfd,
 
   shortlen = p - name;
   shortname = (char *) bfd_hash_allocate (&info->hash->table, shortlen + 1);
-  if (shortname == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[8819]) {
+    if ((shortname == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 8819\n");
+    else
+      fprintf(stderr, "reached bug index 8819\n");
+  }
+  if ((!FIXREVERTER[8819] && (shortname == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     return false;
+    #ifdef FRCOV
+    }
+    #endif
   memcpy (shortname, name, shortlen);
   shortname[shortlen] = '\0';
 
@@ -2068,8 +2161,23 @@ _bfd_elf_add_default_symbol (bfd *abfd,
  nondefault:
   len = strlen (name);
   shortname = (char *) bfd_hash_allocate (&info->hash->table, len);
-  if (shortname == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[8821]) {
+    if ((shortname == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 8821\n");
+    else
+      fprintf(stderr, "reached bug index 8821\n");
+  }
+  if ((!FIXREVERTER[8821] && (shortname == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     return false;
+    #ifdef FRCOV
+    }
+    #endif
   memcpy (shortname, name, shortlen);
   memcpy (shortname + shortlen, p + 1, len - shortlen);
 
@@ -2236,11 +2344,26 @@ _bfd_elf_link_find_version_dependencies (struct elf_link_hash_entry *h,
     {
       amt = sizeof *t;
       t = (Elf_Internal_Verneed *) bfd_zalloc (rinfo->info->output_bfd, amt);
-      if (t == NULL)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[8824]) {
+        if ((t == (void *) 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 8824\n");
+        else
+          fprintf(stderr, "reached bug index 8824\n");
+      }
+      if ((!FIXREVERTER[8824] && (t == (void *) 0 ))
+      #else
+      if (0
+      #endif
+      )
 	{
 	  rinfo->failed = true;
 	  return false;
 	}
+	#ifdef FRCOV
+	}
+	#endif
 
       t->vn_bfd = h->verinfo.verdef->vd_bfd;
       t->vn_nextref = elf_tdata (rinfo->info->output_bfd)->verref;
@@ -2249,11 +2372,26 @@ _bfd_elf_link_find_version_dependencies (struct elf_link_hash_entry *h,
 
   amt = sizeof *a;
   a = (Elf_Internal_Vernaux *) bfd_zalloc (rinfo->info->output_bfd, amt);
-  if (a == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[8825]) {
+    if ((a == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 8825\n");
+    else
+      fprintf(stderr, "reached bug index 8825\n");
+  }
+  if ((!FIXREVERTER[8825] && (a == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     {
       rinfo->failed = true;
       return false;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
   /* Note that we are copying a string pointer here, and testing it
      above.  If bfd_elf_string_from_elf_section is ever changed to
@@ -2297,8 +2435,23 @@ _bfd_elf_link_hide_versioned_symbol (struct bfd_link_info *info,
 
 	  len = version_p - h->root.root.string;
 	  alc = (char *) bfd_malloc (len);
-	  if (alc == NULL)
+	  
+	  #ifdef FRCOV
+	  {if (FIXREVERTER[8826]) {
+	    if ((alc == (void *) 0 ) && !(0))
+	      fprintf(stderr, "triggered bug index 8826\n");
+	    else
+	      fprintf(stderr, "reached bug index 8826\n");
+	  }
+	  if ((!FIXREVERTER[8826] && (alc == (void *) 0 ))
+	  #else
+	  if (0
+	  #endif
+	  )
 	    return false;
+	    #ifdef FRCOV
+	    }
+	    #endif
 	  memcpy (alc, h->root.root.string, len - 1);
 	  alc[len - 1] = '\0';
 	  if (alc[len - 2] == ELF_VER_CHR)
@@ -2462,11 +2615,26 @@ _bfd_elf_link_assign_sym_version (struct elf_link_hash_entry *h, void *data)
 
 	  t = (struct bfd_elf_version_tree *) bfd_zalloc (info->output_bfd,
 							  sizeof *t);
-	  if (t == NULL)
+	  
+	  #ifdef FRCOV
+	  {if (FIXREVERTER[8827]) {
+	    if ((t == (void *) 0 ) && !(0))
+	      fprintf(stderr, "triggered bug index 8827\n");
+	    else
+	      fprintf(stderr, "reached bug index 8827\n");
+	  }
+	  if ((!FIXREVERTER[8827] && (t == (void *) 0 ))
+	  #else
+	  if (0
+	  #endif
+	  )
 	    {
 	      sinfo->failed = true;
 	      return false;
 	    }
+	    #ifdef FRCOV
+	    }
+	    #endif
 
 	  t->name = p;
 	  t->name_indx = (unsigned int) -1;
@@ -2637,8 +2805,23 @@ _bfd_elf_link_read_relocs (bfd *abfd,
   if (esdo->relocs != NULL)
     return esdo->relocs;
 
-  if (o->reloc_count == 0)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[8829]) {
+    if ((o -> reloc_count == 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 8829\n");
+    else
+      fprintf(stderr, "reached bug index 8829\n");
+  }
+  if ((!FIXREVERTER[8829] && (o -> reloc_count == 0 ))
+  #else
+  if (0
+  #endif
+  )
     return NULL;
+    #ifdef FRCOV
+    }
+    #endif
 
   if (internal_relocs == NULL)
     {
@@ -2649,8 +2832,23 @@ _bfd_elf_link_read_relocs (bfd *abfd,
 	internal_relocs = alloc2 = (Elf_Internal_Rela *) bfd_alloc (abfd, size);
       else
 	internal_relocs = alloc2 = (Elf_Internal_Rela *) bfd_malloc (size);
-      if (internal_relocs == NULL)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[8830]) {
+        if ((internal_relocs == (void *) 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 8830\n");
+        else
+          fprintf(stderr, "reached bug index 8830\n");
+      }
+      if ((!FIXREVERTER[8830] && (internal_relocs == (void *) 0 ))
+      #else
+      if (0
+      #endif
+      )
 	goto error_return;
+	#ifdef FRCOV
+	}
+	#endif
     }
 
   if (external_relocs == NULL)
@@ -2663,8 +2861,23 @@ _bfd_elf_link_read_relocs (bfd *abfd,
 	size += esdo->rela.hdr->sh_size;
 
       alloc1 = bfd_malloc (size);
-      if (alloc1 == NULL)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[8831]) {
+        if ((alloc1 == (void *) 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 8831\n");
+        else
+          fprintf(stderr, "reached bug index 8831\n");
+      }
+      if ((!FIXREVERTER[8831] && (alloc1 == (void *) 0 ))
+      #else
+      if (0
+      #endif
+      )
 	goto error_return;
+	#ifdef FRCOV
+	}
+	#endif
       external_relocs = alloc1;
     }
 
@@ -2736,8 +2949,23 @@ _bfd_elf_link_size_reloc_section (bfd *abfd,
 
       p = ((struct elf_link_hash_entry **)
 	   bfd_zmalloc (reldata->count * sizeof (*p)));
-      if (p == NULL)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[8832]) {
+        if ((p == (void *) 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 8832\n");
+        else
+          fprintf(stderr, "reached bug index 8832\n");
+      }
+      if ((!FIXREVERTER[8832] && (p == (void *) 0 ))
+      #else
+      if (0
+      #endif
+      )
 	return false;
+	#ifdef FRCOV
+	}
+	#endif
 
       reldata->hashes = p;
     }
@@ -3741,8 +3969,23 @@ elf_sort_symbol (const void *arg1, const void *arg2)
     return vdiff > 0 ? 1 : -1;
 
   sdiff = h1->root.u.def.section->id - h2->root.u.def.section->id;
-  if (sdiff != 0)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[8841]) {
+    if ((sdiff != 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 8841\n");
+    else
+      fprintf(stderr, "reached bug index 8841\n");
+  }
+  if ((!FIXREVERTER[8841] && (sdiff != 0 ))
+  #else
+  if (0
+  #endif
+  )
     return sdiff;
+    #ifdef FRCOV
+    }
+    #endif
 
   /* Sort so that sized symbols are selected over zero size symbols.  */
   vdiff = h1->size - h2->size;
@@ -3750,8 +3993,23 @@ elf_sort_symbol (const void *arg1, const void *arg2)
     return vdiff > 0 ? 1 : -1;
 
   /* Sort so that STT_OBJECT is selected over STT_NOTYPE.  */
-  if (h1->type != h2->type)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[8843]) {
+    if ((h1 -> type != h2 -> type ) && !(0))
+      fprintf(stderr, "triggered bug index 8843\n");
+    else
+      fprintf(stderr, "reached bug index 8843\n");
+  }
+  if ((!FIXREVERTER[8843] && (h1 -> type != h2 -> type ))
+  #else
+  if (0
+  #endif
+  )
     return h1->type - h2->type;
+    #ifdef FRCOV
+    }
+    #endif
 
   /* If symbols are properly sized and typed, and multiple strong
      aliases are not defined in a shared library by the user we
@@ -4158,8 +4416,23 @@ elf_link_add_object_symbols (bfd *abfd, struct bfd_link_info *info)
 
 	  sz = s->size;
 	  msg = (char *) bfd_alloc (abfd, sz + 1);
-	  if (msg == NULL)
+	  
+	  #ifdef FRCOV
+	  {if (FIXREVERTER[8844]) {
+	    if ((msg == (void *) 0 ) && !(0))
+	      fprintf(stderr, "triggered bug index 8844\n");
+	    else
+	      fprintf(stderr, "reached bug index 8844\n");
+	  }
+	  if ((!FIXREVERTER[8844] && (msg == (void *) 0 ))
+	  #else
+	  if (0
+	  #endif
+	  )
 	    goto error_return;
+	    #ifdef FRCOV
+	    }
+	    #endif
 
 	  if (! bfd_get_section_contents (abfd, s, msg, 0, sz))
 	    goto error_return;
@@ -4267,8 +4540,23 @@ elf_link_add_object_symbols (bfd *abfd, struct bfd_link_info *info)
 		{
 		  unsigned int tagv = dyn.d_un.d_val;
 		  soname = bfd_elf_string_from_elf_section (abfd, shlink, tagv);
-		  if (soname == NULL)
+		  
+		  #ifdef FRCOV
+		  {if (FIXREVERTER[8845]) {
+		    if ((soname == (void *) 0 ) && !(0))
+		      fprintf(stderr, "triggered bug index 8845\n");
+		    else
+		      fprintf(stderr, "reached bug index 8845\n");
+		  }
+		  if ((!FIXREVERTER[8845] && (soname == (void *) 0 ))
+		  #else
+		  if (0
+		  #endif
+		  )
 		    goto error_free_dyn;
+		    #ifdef FRCOV
+		    }
+		    #endif
 		}
 	      if (dyn.d_tag == DT_NEEDED)
 		{
@@ -4279,12 +4567,42 @@ elf_link_add_object_symbols (bfd *abfd, struct bfd_link_info *info)
 
 		  n = (struct bfd_link_needed_list *) bfd_alloc (abfd, amt);
 		  fnm = bfd_elf_string_from_elf_section (abfd, shlink, tagv);
-		  if (n == NULL || fnm == NULL)
+		  
+		  #ifdef FRCOV
+		  {if (FIXREVERTER[8846]) {
+		    if ((n == (void *) 0 || fnm == (void *) 0 ) && !(0))
+		      fprintf(stderr, "triggered bug index 8846\n");
+		    else
+		      fprintf(stderr, "reached bug index 8846\n");
+		  }
+		  if ((!FIXREVERTER[8846] && (n == (void *) 0 || fnm == (void *) 0 ))
+		  #else
+		  if (0
+		  #endif
+		  )
 		    goto error_free_dyn;
+		    #ifdef FRCOV
+		    }
+		    #endif
 		  amt = strlen (fnm) + 1;
 		  anm = (char *) bfd_alloc (abfd, amt);
-		  if (anm == NULL)
+		  
+		  #ifdef FRCOV
+		  {if (FIXREVERTER[8847]) {
+		    if ((anm == (void *) 0 ) && !(0))
+		      fprintf(stderr, "triggered bug index 8847\n");
+		    else
+		      fprintf(stderr, "reached bug index 8847\n");
+		  }
+		  if ((!FIXREVERTER[8847] && (anm == (void *) 0 ))
+		  #else
+		  if (0
+		  #endif
+		  )
 		    goto error_free_dyn;
+		    #ifdef FRCOV
+		    }
+		    #endif
 		  memcpy (anm, fnm, amt);
 		  n->name = anm;
 		  n->by = abfd;
@@ -4302,12 +4620,42 @@ elf_link_add_object_symbols (bfd *abfd, struct bfd_link_info *info)
 
 		  n = (struct bfd_link_needed_list *) bfd_alloc (abfd, amt);
 		  fnm = bfd_elf_string_from_elf_section (abfd, shlink, tagv);
-		  if (n == NULL || fnm == NULL)
+		  
+		  #ifdef FRCOV
+		  {if (FIXREVERTER[8849]) {
+		    if ((n == (void *) 0 || fnm == (void *) 0 ) && !(0))
+		      fprintf(stderr, "triggered bug index 8849\n");
+		    else
+		      fprintf(stderr, "reached bug index 8849\n");
+		  }
+		  if ((!FIXREVERTER[8849] && (n == (void *) 0 || fnm == (void *) 0 ))
+		  #else
+		  if (0
+		  #endif
+		  )
 		    goto error_free_dyn;
+		    #ifdef FRCOV
+		    }
+		    #endif
 		  amt = strlen (fnm) + 1;
 		  anm = (char *) bfd_alloc (abfd, amt);
-		  if (anm == NULL)
+		  
+		  #ifdef FRCOV
+		  {if (FIXREVERTER[8850]) {
+		    if ((anm == (void *) 0 ) && !(0))
+		      fprintf(stderr, "triggered bug index 8850\n");
+		    else
+		      fprintf(stderr, "reached bug index 8850\n");
+		  }
+		  if ((!FIXREVERTER[8850] && (anm == (void *) 0 ))
+		  #else
+		  if (0
+		  #endif
+		  )
 		    goto error_free_dyn;
+		    #ifdef FRCOV
+		    }
+		    #endif
 		  memcpy (anm, fnm, amt);
 		  n->name = anm;
 		  n->by = abfd;
@@ -4328,12 +4676,42 @@ elf_link_add_object_symbols (bfd *abfd, struct bfd_link_info *info)
 
 		  n = (struct bfd_link_needed_list *) bfd_alloc (abfd, amt);
 		  fnm = bfd_elf_string_from_elf_section (abfd, shlink, tagv);
-		  if (n == NULL || fnm == NULL)
+		  
+		  #ifdef FRCOV
+		  {if (FIXREVERTER[8852]) {
+		    if ((n == (void *) 0 || fnm == (void *) 0 ) && !(0))
+		      fprintf(stderr, "triggered bug index 8852\n");
+		    else
+		      fprintf(stderr, "reached bug index 8852\n");
+		  }
+		  if ((!FIXREVERTER[8852] && (n == (void *) 0 || fnm == (void *) 0 ))
+		  #else
+		  if (0
+		  #endif
+		  )
 		    goto error_free_dyn;
+		    #ifdef FRCOV
+		    }
+		    #endif
 		  amt = strlen (fnm) + 1;
 		  anm = (char *) bfd_alloc (abfd, amt);
-		  if (anm == NULL)
+		  
+		  #ifdef FRCOV
+		  {if (FIXREVERTER[8853]) {
+		    if ((anm == (void *) 0 ) && !(0))
+		      fprintf(stderr, "triggered bug index 8853\n");
+		    else
+		      fprintf(stderr, "reached bug index 8853\n");
+		  }
+		  if ((!FIXREVERTER[8853] && (anm == (void *) 0 ))
+		  #else
+		  if (0
+		  #endif
+		  )
 		    goto error_free_dyn;
+		    #ifdef FRCOV
+		    }
+		    #endif
 		  memcpy (anm, fnm, amt);
 		  n->name = anm;
 		  n->by = abfd;
@@ -4372,7 +4750,19 @@ elf_link_add_object_symbols (bfd *abfd, struct bfd_link_info *info)
 	 shared library sections appear as they will at run-time.  */
       phdr = elf_tdata (abfd)->phdr + elf_elfheader (abfd)->e_phnum;
       while (phdr-- > elf_tdata (abfd)->phdr)
-	if (phdr->p_type == PT_GNU_RELRO)
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[8855]) {
+	  if ((phdr -> p_type == 1610612736 + 74769746 ) && !(0))
+	    fprintf(stderr, "triggered bug index 8855\n");
+	  else
+	    fprintf(stderr, "reached bug index 8855\n");
+	}
+	if ((!FIXREVERTER[8855] && (phdr -> p_type == 1610612736 + 74769746 ))
+	#else
+	if (0
+	#endif
+	)
 	  {
 	    for (s = abfd->sections; s != NULL; s = s->next)
 	      {
@@ -4385,6 +4775,9 @@ elf_link_add_object_symbols (bfd *abfd, struct bfd_link_info *info)
 	      }
 	    break;
 	  }
+	  #ifdef FRCOV
+	  }
+	  #endif
 
       /* We do not want to include any of the sections in a dynamic
 	 object in the output file.  We hack by simply clobbering the
@@ -4463,8 +4856,23 @@ elf_link_add_object_symbols (bfd *abfd, struct bfd_link_info *info)
     {
       isymbuf = bfd_elf_get_elf_syms (abfd, hdr, extsymcount, extsymoff,
 				      NULL, NULL, NULL);
-      if (isymbuf == NULL)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[8856]) {
+        if ((isymbuf == (void *) 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 8856\n");
+        else
+          fprintf(stderr, "reached bug index 8856\n");
+      }
+      if ((!FIXREVERTER[8856] && (isymbuf == (void *) 0 ))
+      #else
+      if (0
+      #endif
+      )
 	goto error_return;
+	#ifdef FRCOV
+	}
+	#endif
 
       if (sym_hash == NULL)
 	{
@@ -4472,8 +4880,23 @@ elf_link_add_object_symbols (bfd *abfd, struct bfd_link_info *info)
 	     external symbol.  */
 	  size_t amt = extsymcount * sizeof (struct elf_link_hash_entry *);
 	  sym_hash = (struct elf_link_hash_entry **) bfd_zalloc (abfd, amt);
-	  if (sym_hash == NULL)
+	  
+	  #ifdef FRCOV
+	  {if (FIXREVERTER[8857]) {
+	    if ((sym_hash == (void *) 0 ) && !(0))
+	      fprintf(stderr, "triggered bug index 8857\n");
+	    else
+	      fprintf(stderr, "reached bug index 8857\n");
+	  }
+	  if ((!FIXREVERTER[8857] && (sym_hash == (void *) 0 ))
+	  #else
+	  if (0
+	  #endif
+	  )
 	    goto error_free_sym;
+	    #ifdef FRCOV
+	    }
+	    #endif
 	  elf_sym_hashes (abfd) = sym_hash;
 	}
     }
@@ -4496,8 +4919,23 @@ elf_link_add_object_symbols (bfd *abfd, struct bfd_link_info *info)
 	    goto error_free_sym;
 	  extversym = (Elf_External_Versym *)
 	    _bfd_malloc_and_read (abfd, amt, amt);
-	  if (extversym == NULL)
+	  
+	  #ifdef FRCOV
+	  {if (FIXREVERTER[8858]) {
+	    if ((extversym == (void *) 0 ) && !(0))
+	      fprintf(stderr, "triggered bug index 8858\n");
+	    else
+	      fprintf(stderr, "reached bug index 8858\n");
+	  }
+	  if ((!FIXREVERTER[8858] && (extversym == (void *) 0 ))
+	  #else
+	  if (0
+	  #endif
+	  )
 	    goto error_free_sym;
+	    #ifdef FRCOV
+	    }
+	    #endif
 	  extversym_end = extversym + amt / sizeof (*extversym);
 	}
     }
@@ -4531,14 +4969,44 @@ elf_link_add_object_symbols (bfd *abfd, struct bfd_link_info *info)
 
       tabsize = htab->root.table.size * sizeof (struct bfd_hash_entry *);
       old_tab = bfd_malloc (tabsize + entsize);
-      if (old_tab == NULL)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[8859]) {
+        if ((old_tab == (void *) 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 8859\n");
+        else
+          fprintf(stderr, "reached bug index 8859\n");
+      }
+      if ((!FIXREVERTER[8859] && (old_tab == (void *) 0 ))
+      #else
+      if (0
+      #endif
+      )
 	goto error_free_vers;
+	#ifdef FRCOV
+	}
+	#endif
 
       /* Remember the current objalloc pointer, so that all mem for
 	 symbols added can later be reclaimed.  */
       alloc_mark = bfd_hash_allocate (&htab->root.table, 1);
-      if (alloc_mark == NULL)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[8860]) {
+        if ((alloc_mark == (void *) 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 8860\n");
+        else
+          fprintf(stderr, "reached bug index 8860\n");
+      }
+      if ((!FIXREVERTER[8860] && (alloc_mark == (void *) 0 ))
+      #else
+      if (0
+      #endif
+      )
 	goto error_free_vers;
+	#ifdef FRCOV
+	}
+	#endif
 
       /* Make a special call to the linker "notice" function to
 	 tell it that we are about to handle an as-needed lib.  */
@@ -4558,8 +5026,23 @@ elf_link_add_object_symbols (bfd *abfd, struct bfd_link_info *info)
       if (htab->dynstr != NULL)
 	{
 	  old_strtab = _bfd_elf_strtab_save (htab->dynstr);
-	  if (old_strtab == NULL)
+	  
+	  #ifdef FRCOV
+	  {if (FIXREVERTER[8861]) {
+	    if ((old_strtab == (void *) 0 ) && !(0))
+	      fprintf(stderr, "triggered bug index 8861\n");
+	    else
+	      fprintf(stderr, "reached bug index 8861\n");
+	  }
+	  if ((!FIXREVERTER[8861] && (old_strtab == (void *) 0 ))
+	  #else
+	  if (0
+	  #endif
+	  )
 	    goto error_free_vers;
+	    #ifdef FRCOV
+	    }
+	    #endif
 	}
 
       for (i = 0; i < htab->root.table.size; i++)
@@ -4723,8 +5206,23 @@ elf_link_add_object_symbols (bfd *abfd, struct bfd_link_info *info)
 
       name = bfd_elf_string_from_elf_section (abfd, hdr->sh_link,
 					      isym->st_name);
-      if (name == NULL)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[8862]) {
+        if ((name == (void *) 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 8862\n");
+        else
+          fprintf(stderr, "reached bug index 8862\n");
+      }
+      if ((!FIXREVERTER[8862] && (name == (void *) 0 ))
+      #else
+      if (0
+      #endif
+      )
 	goto error_free_vers;
+	#ifdef FRCOV
+	}
+	#endif
 
       if (isym->st_shndx == SHN_COMMON
 	  && (abfd->flags & BFD_PLUGIN) != 0)
@@ -4736,8 +5234,23 @@ elf_link_add_object_symbols (bfd *abfd, struct bfd_link_info *info)
 	      flagword sflags = (SEC_ALLOC | SEC_IS_COMMON | SEC_KEEP
 				 | SEC_EXCLUDE);
 	      xc = bfd_make_section_with_flags (abfd, "COMMON", sflags);
-	      if (xc == NULL)
+	      
+	      #ifdef FRCOV
+	      {if (FIXREVERTER[8863]) {
+	        if ((xc == (void *) 0 ) && !(0))
+	          fprintf(stderr, "triggered bug index 8863\n");
+	        else
+	          fprintf(stderr, "reached bug index 8863\n");
+	      }
+	      if ((!FIXREVERTER[8863] && (xc == (void *) 0 ))
+	      #else
+	      if (0
+	      #endif
+	      )
 		goto error_free_vers;
+		#ifdef FRCOV
+		}
+		#endif
 	    }
 	  sec = xc;
 	}
@@ -4752,8 +5265,23 @@ elf_link_add_object_symbols (bfd *abfd, struct bfd_link_info *info)
 	      flagword sflags = (SEC_ALLOC | SEC_THREAD_LOCAL | SEC_IS_COMMON
 				 | SEC_LINKER_CREATED);
 	      tcomm = bfd_make_section_with_flags (abfd, ".tcommon", sflags);
-	      if (tcomm == NULL)
+	      
+	      #ifdef FRCOV
+	      {if (FIXREVERTER[8864]) {
+	        if ((tcomm == (void *) 0 ) && !(0))
+	          fprintf(stderr, "triggered bug index 8864\n");
+	        else
+	          fprintf(stderr, "reached bug index 8864\n");
+	      }
+	      if ((!FIXREVERTER[8864] && (tcomm == (void *) 0 ))
+	      #else
+	      if (0
+	      #endif
+	      )
 		goto error_free_vers;
+		#ifdef FRCOV
+		}
+		#endif
 	    }
 	  sec = tcomm;
 	}
@@ -4765,8 +5293,23 @@ elf_link_add_object_symbols (bfd *abfd, struct bfd_link_info *info)
 
 	  /* The hook function sets the name to NULL if this symbol
 	     should be skipped for some reason.  */
-	  if (name == NULL)
+	  
+	  #ifdef FRCOV
+	  {if (FIXREVERTER[8865]) {
+	    if ((name == (void *) 0 ) && !(0))
+	      fprintf(stderr, "triggered bug index 8865\n");
+	    else
+	      fprintf(stderr, "reached bug index 8865\n");
+	  }
+	  if ((!FIXREVERTER[8865] && (name == (void *) 0 ))
+	  #else
+	  if (0
+	  #endif
+	  )
 	    continue;
+	    #ifdef FRCOV
+	    }
+	    #endif
 	}
 
       /* Sanity check that all possibilities were handled.  */
@@ -4845,7 +5388,19 @@ elf_link_add_object_symbols (bfd *abfd, struct bfd_link_info *info)
 		  else
 		    verstr = "";
 
-		  if (verstr == NULL)
+		  
+		  #ifdef FRCOV
+		  {if (FIXREVERTER[8866]) {
+		    if ((verstr == (void *) 0 ) && !(0))
+		      fprintf(stderr, "triggered bug index 8866\n");
+		    else
+		      fprintf(stderr, "reached bug index 8866\n");
+		  }
+		  if ((!FIXREVERTER[8866] && (verstr == (void *) 0 ))
+		  #else
+		  if (0
+		  #endif
+		  )
 		    {
 		      _bfd_error_handler
 			/* xgettext:c-format */
@@ -4855,6 +5410,9 @@ elf_link_add_object_symbols (bfd *abfd, struct bfd_link_info *info)
 		      bfd_set_error (bfd_error_bad_value);
 		      goto error_free_vers;
 		    }
+		    #ifdef FRCOV
+		    }
+		    #endif
 		}
 	      else
 		{
@@ -4873,16 +5431,43 @@ elf_link_add_object_symbols (bfd *abfd, struct bfd_link_info *info)
 
 		      for (a = t->vn_auxptr; a != NULL; a = a->vna_nextptr)
 			{
-			  if (a->vna_other == vernum)
+			  
+			  #ifdef FRCOV
+			  {if (FIXREVERTER[8867]) {
+			    if ((a -> vna_other == vernum ) && !(0))
+			      fprintf(stderr, "triggered bug index 8867\n");
+			    else
+			      fprintf(stderr, "reached bug index 8867\n");
+			  }
+			  if ((!FIXREVERTER[8867] && (a -> vna_other == vernum ))
+			  #else
+			  if (0
+			  #endif
+			  )
 			    {
 			      verstr = a->vna_nodename;
 			      break;
 			    }
+			    #ifdef FRCOV
+			    }
+			    #endif
 			}
 		      if (a != NULL)
 			break;
 		    }
-		  if (verstr == NULL)
+		  
+		  #ifdef FRCOV
+		  {if (FIXREVERTER[8868]) {
+		    if ((verstr == (void *) 0 ) && !(0))
+		      fprintf(stderr, "triggered bug index 8868\n");
+		    else
+		      fprintf(stderr, "reached bug index 8868\n");
+		  }
+		  if ((!FIXREVERTER[8868] && (verstr == (void *) 0 ))
+		  #else
+		  if (0
+		  #endif
+		  )
 		    {
 		      _bfd_error_handler
 			/* xgettext:c-format */
@@ -4891,6 +5476,9 @@ elf_link_add_object_symbols (bfd *abfd, struct bfd_link_info *info)
 		      bfd_set_error (bfd_error_bad_value);
 		      goto error_free_vers;
 		    }
+		    #ifdef FRCOV
+		    }
+		    #endif
 		}
 
 	      namelen = strlen (name);
@@ -4901,8 +5489,23 @@ elf_link_add_object_symbols (bfd *abfd, struct bfd_link_info *info)
 		++newlen;
 
 	      newname = (char *) bfd_hash_allocate (&htab->root.table, newlen);
-	      if (newname == NULL)
+	      
+	      #ifdef FRCOV
+	      {if (FIXREVERTER[8869]) {
+	        if ((newname == (void *) 0 ) && !(0))
+	          fprintf(stderr, "triggered bug index 8869\n");
+	        else
+	          fprintf(stderr, "reached bug index 8869\n");
+	      }
+	      if ((!FIXREVERTER[8869] && (newname == (void *) 0 ))
+	      #else
+	      if (0
+	      #endif
+	      )
 		goto error_free_vers;
+		#ifdef FRCOV
+		}
+		#endif
 	      memcpy (newname, name, namelen);
 	      p = newname + namelen;
 	      *p++ = ELF_VER_CHR;
@@ -5038,8 +5641,23 @@ elf_link_add_object_symbols (bfd *abfd, struct bfd_link_info *info)
 	      if (! definition)
 		{
 		  h->ref_regular = 1;
-		  if (bind != STB_WEAK)
+		  
+		  #ifdef FRCOV
+		  {if (FIXREVERTER[8872]) {
+		    if ((bind != 2  ) && !(0))
+		      fprintf(stderr, "triggered bug index 8872\n");
+		    else
+		      fprintf(stderr, "reached bug index 8872\n");
+		  }
+		  if ((!FIXREVERTER[8872] && (bind != 2  ))
+		  #else
+		  if (0
+		  #endif
+		  )
 		    h->ref_regular_nonweak = 1;
+		    #ifdef FRCOV
+		    }
+		    #endif
 		}
 	      else
 		{
@@ -5118,8 +5736,23 @@ elf_link_add_object_symbols (bfd *abfd, struct bfd_link_info *info)
 		       & (DYNAMIC | BFD_PLUGIN)) == 0)
 		{
 		  normal_align = h->root.u.def.section->alignment_power;
-		  if (normal_align > symbol_align)
+		  
+		  #ifdef FRCOV
+		  {if (FIXREVERTER[8873]) {
+		    if ((normal_align > symbol_align ) && !(0))
+		      fprintf(stderr, "triggered bug index 8873\n");
+		    else
+		      fprintf(stderr, "reached bug index 8873\n");
+		  }
+		  if ((!FIXREVERTER[8873] && (normal_align > symbol_align ))
+		  #else
+		  if (0
+		  #endif
+		  )
 		    normal_align = symbol_align;
+		    #ifdef FRCOV
+		    }
+		    #endif
 		}
 	      else
 		normal_align = symbol_align;
@@ -5357,8 +5990,23 @@ elf_link_add_object_symbols (bfd *abfd, struct bfd_link_info *info)
 	  internal_relocs = _bfd_elf_link_read_relocs (abfd, s, NULL,
 						       NULL,
 						       info->keep_memory);
-	  if (internal_relocs == NULL)
+	  
+	  #ifdef FRCOV
+	  {if (FIXREVERTER[8874]) {
+	    if ((internal_relocs == (void *) 0 ) && !(0))
+	      fprintf(stderr, "triggered bug index 8874\n");
+	    else
+	      fprintf(stderr, "reached bug index 8874\n");
+	  }
+	  if ((!FIXREVERTER[8874] && (internal_relocs == (void *) 0 ))
+	  #else
+	  if (0
+	  #endif
+	  )
 	    goto error_free_vers;
+	    #ifdef FRCOV
+	    }
+	    #endif
 
 	  rel = internal_relocs;
 	  relend = rel + s->reloc_count;
@@ -5368,8 +6016,23 @@ elf_link_add_object_symbols (bfd *abfd, struct bfd_link_info *info)
 	      struct elf_link_hash_entry *h;
 
 	      /* Skip local symbols.  */
-	      if (r_symndx < extsymoff)
+	      
+	      #ifdef FRCOV
+	      {if (FIXREVERTER[8875]) {
+	        if ((r_symndx < extsymoff ) && !(0))
+	          fprintf(stderr, "triggered bug index 8875\n");
+	        else
+	          fprintf(stderr, "reached bug index 8875\n");
+	      }
+	      if ((!FIXREVERTER[8875] && (r_symndx < extsymoff ))
+	      #else
+	      if (0
+	      #endif
+	      )
 		continue;
+		#ifdef FRCOV
+		}
+		#endif
 
 	      h = sym_hash[r_symndx - extsymoff];
 	      if (h != NULL)
@@ -5537,8 +6200,23 @@ elf_link_add_object_symbols (bfd *abfd, struct bfd_link_info *info)
 	 O(N^2). Binary search will cut it down to O(NlogN).  */
       amt = extsymcount * sizeof (*sorted_sym_hash);
       sorted_sym_hash = bfd_malloc (amt);
-      if (sorted_sym_hash == NULL)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[8876]) {
+        if ((sorted_sym_hash == (void *) 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 8876\n");
+        else
+          fprintf(stderr, "reached bug index 8876\n");
+      }
+      if ((!FIXREVERTER[8876] && (sorted_sym_hash == (void *) 0 ))
+      #else
+      if (0
+      #endif
+      )
 	goto error_return;
+	#ifdef FRCOV
+	}
+	#endif
       sym_hash = sorted_sym_hash;
       hpp = elf_sym_hashes (abfd);
       hppend = hpp + extsymcount;
@@ -5602,8 +6280,23 @@ elf_link_add_object_symbols (bfd *abfd, struct bfd_link_info *info)
 	    }
 
 	  /* We didn't find a value/section match.  */
-	  if (i == j)
+	  
+	  #ifdef FRCOV
+	  {if (FIXREVERTER[8877]) {
+	    if ((i == j ) && !(0))
+	      fprintf(stderr, "triggered bug index 8877\n");
+	    else
+	      fprintf(stderr, "reached bug index 8877\n");
+	  }
+	  if ((!FIXREVERTER[8877] && (i == j ))
+	  #else
+	  if (0
+	  #endif
+	  )
 	    continue;
+	    #ifdef FRCOV
+	    }
+	    #endif
 
 	  /* With multiple aliases, or when the weak symbol is already
 	     strongly defined, we have multiple matching symbols and
@@ -5716,8 +6409,23 @@ elf_link_add_object_symbols (bfd *abfd, struct bfd_link_info *info)
       struct elf_link_loaded_list *n;
 
       n = (struct elf_link_loaded_list *) bfd_alloc (abfd, sizeof (*n));
-      if (n == NULL)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[8878]) {
+        if ((n == (void *) 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 8878\n");
+        else
+          fprintf(stderr, "reached bug index 8878\n");
+      }
+      if ((!FIXREVERTER[8878] && (n == (void *) 0 ))
+      #else
+      if (0
+      #endif
+      )
 	goto error_return;
+	#ifdef FRCOV
+	}
+	#endif
       n->abfd = abfd;
       n->next = htab->dyn_loaded;
       htab->dyn_loaded = n;
@@ -5829,8 +6537,23 @@ elf_link_add_archive_symbols (bfd *abfd, struct bfd_link_info *info)
     return true;
   amt = c * sizeof (*included);
   included = (unsigned char *) bfd_zmalloc (amt);
-  if (included == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[8882]) {
+    if ((included == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 8882\n");
+    else
+      fprintf(stderr, "reached bug index 8882\n");
+  }
+  if ((!FIXREVERTER[8882] && (included == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     return false;
+    #ifdef FRCOV
+    }
+    #endif
 
   symdefs = bfd_ardata (abfd)->symdefs;
   bed = get_elf_backend_data (abfd);
@@ -5857,18 +6580,48 @@ elf_link_add_archive_symbols (bfd *abfd, struct bfd_link_info *info)
 
 	  if (included[i])
 	    continue;
-	  if (symdef->file_offset == last)
+	  
+	  #ifdef FRCOV
+	  {if (FIXREVERTER[8883]) {
+	    if ((symdef -> file_offset == last ) && !(0))
+	      fprintf(stderr, "triggered bug index 8883\n");
+	    else
+	      fprintf(stderr, "reached bug index 8883\n");
+	  }
+	  if ((!FIXREVERTER[8883] && (symdef -> file_offset == last ))
+	  #else
+	  if (0
+	  #endif
+	  )
 	    {
 	      included[i] = true;
 	      continue;
 	    }
+	    #ifdef FRCOV
+	    }
+	    #endif
 
 	  h = archive_symbol_lookup (abfd, info, symdef->name);
 	  if (h == (struct bfd_link_hash_entry *) -1)
 	    goto error_return;
 
-	  if (h == NULL)
+	  
+	  #ifdef FRCOV
+	  {if (FIXREVERTER[8884]) {
+	    if ((h == (void *) 0 ) && !(0))
+	      fprintf(stderr, "triggered bug index 8884\n");
+	    else
+	      fprintf(stderr, "reached bug index 8884\n");
+	  }
+	  if ((!FIXREVERTER[8884] && (h == (void *) 0 ))
+	  #else
+	  if (0
+	  #endif
+	  )
 	    continue;
+	    #ifdef FRCOV
+	    }
+	    #endif
 
 	  if (h->type == bfd_link_hash_undefined)
 	    {
@@ -5906,8 +6659,23 @@ elf_link_add_archive_symbols (bfd *abfd, struct bfd_link_info *info)
 
 	  /* We need to include this archive member.  */
 	  element = _bfd_get_elt_at_filepos (abfd, symdef->file_offset);
-	  if (element == NULL)
+	  
+	  #ifdef FRCOV
+	  {if (FIXREVERTER[8885]) {
+	    if ((element == (void *) 0 ) && !(0))
+	      fprintf(stderr, "triggered bug index 8885\n");
+	    else
+	      fprintf(stderr, "reached bug index 8885\n");
+	  }
+	  if ((!FIXREVERTER[8885] && (element == (void *) 0 ))
+	  #else
+	  if (0
+	  #endif
+	  )
 	    goto error_return;
+	    #ifdef FRCOV
+	    }
+	    #endif
 
 	  if (! bfd_check_format (element, bfd_object))
 	    goto error_return;
@@ -6003,11 +6771,26 @@ elf_collect_hash_codes (struct elf_link_hash_entry *h, void *data)
       if (p != NULL)
 	{
 	  alc = (char *) bfd_malloc (p - name + 1);
-	  if (alc == NULL)
+	  
+	  #ifdef FRCOV
+	  {if (FIXREVERTER[8887]) {
+	    if ((alc == (void *) 0 ) && !(0))
+	      fprintf(stderr, "triggered bug index 8887\n");
+	    else
+	      fprintf(stderr, "reached bug index 8887\n");
+	  }
+	  if ((!FIXREVERTER[8887] && (alc == (void *) 0 ))
+	  #else
+	  if (0
+	  #endif
+	  )
 	    {
 	      inf->error = true;
 	      return false;
 	    }
+	    #ifdef FRCOV
+	    }
+	    #endif
 	  memcpy (alc, name, p - name);
 	  alc[p - name] = '\0';
 	  name = alc;
@@ -6076,11 +6859,26 @@ elf_collect_gnu_hash_codes (struct elf_link_hash_entry *h, void *data)
       if (p != NULL)
 	{
 	  alc = (char *) bfd_malloc (p - name + 1);
-	  if (alc == NULL)
+	  
+	  #ifdef FRCOV
+	  {if (FIXREVERTER[8888]) {
+	    if ((alc == (void *) 0 ) && !(0))
+	      fprintf(stderr, "triggered bug index 8888\n");
+	    else
+	      fprintf(stderr, "reached bug index 8888\n");
+	  }
+	  if ((!FIXREVERTER[8888] && (alc == (void *) 0 ))
+	  #else
+	  if (0
+	  #endif
+	  )
 	    {
 	      s->error = true;
 	      return false;
 	    }
+	    #ifdef FRCOV
+	    }
+	    #endif
 	  memcpy (alc, name, p - name);
 	  alc[p - name] = '\0';
 	  name = alc;
@@ -7689,8 +8487,23 @@ _bfd_elf_link_hash_newfunc (struct bfd_hash_entry *entry,
     {
       entry = (struct bfd_hash_entry *)
 	bfd_hash_allocate (table, sizeof (struct elf_link_hash_entry));
-      if (entry == NULL)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[8893]) {
+        if ((entry == (void *) 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 8893\n");
+        else
+          fprintf(stderr, "reached bug index 8893\n");
+      }
+      if ((!FIXREVERTER[8893] && (entry == (void *) 0 ))
+      #else
+      if (0
+      #endif
+      )
 	return entry;
+	#ifdef FRCOV
+	}
+	#endif
     }
 
   /* Call the allocation method of the superclass.  */
@@ -8098,8 +8911,23 @@ elf_sort_elf_symbol (const void *arg1, const void *arg2)
   const Elf_Internal_Sym *s1 = *(const Elf_Internal_Sym **) arg1;
   const Elf_Internal_Sym *s2 = *(const Elf_Internal_Sym **) arg2;
 
-  if (s1->st_shndx != s2->st_shndx)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[8896]) {
+    if ((s1 -> st_shndx != s2 -> st_shndx ) && !(0))
+      fprintf(stderr, "triggered bug index 8896\n");
+    else
+      fprintf(stderr, "reached bug index 8896\n");
+  }
+  if ((!FIXREVERTER[8896] && (s1 -> st_shndx != s2 -> st_shndx ))
+  #else
+  if (0
+  #endif
+  )
     return s1->st_shndx > s2->st_shndx ? 1 : -1;
+    #ifdef FRCOV
+    }
+    #endif
   /* Final sort by the address of the sym in the symbuf ensures
      a stable sort.  */
   if (s1 != s2)
@@ -8113,8 +8941,23 @@ elf_sym_name_compare (const void *arg1, const void *arg2)
   const struct elf_symbol *s1 = (const struct elf_symbol *) arg1;
   const struct elf_symbol *s2 = (const struct elf_symbol *) arg2;
   int ret = strcmp (s1->name, s2->name);
-  if (ret != 0)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[8897]) {
+    if ((ret != 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 8897\n");
+    else
+      fprintf(stderr, "reached bug index 8897\n");
+  }
+  if ((!FIXREVERTER[8897] && (ret != 0 ))
+  #else
+  if (0
+  #endif
+  )
     return ret;
+    #ifdef FRCOV
+    }
+    #endif
   if (s1->u.p != s2->u.p)
     return s1->u.p > s2->u.p ? 1 : -1;
   return 0;
@@ -8130,8 +8973,23 @@ elf_create_symbuf (size_t symcount, Elf_Internal_Sym *isymbuf)
 
   amt = symcount * sizeof (*indbuf);
   indbuf = (Elf_Internal_Sym **) bfd_malloc (amt);
-  if (indbuf == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[8898]) {
+    if ((indbuf == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 8898\n");
+    else
+      fprintf(stderr, "reached bug index 8898\n");
+  }
+  if ((!FIXREVERTER[8898] && (indbuf == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     return NULL;
+    #ifdef FRCOV
+    }
+    #endif
 
   for (ind = indbuf, i = 0; i < symcount; i++)
     if (isymbuf[i].st_shndx != SHN_UNDEF)
@@ -8150,11 +9008,26 @@ elf_create_symbuf (size_t symcount, Elf_Internal_Sym *isymbuf)
   total_size = ((shndx_count + 1) * sizeof (*ssymbuf)
 		+ (indbufend - indbuf) * sizeof (*ssym));
   ssymbuf = (struct elf_symbuf_head *) bfd_malloc (total_size);
-  if (ssymbuf == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[8899]) {
+    if ((ssymbuf == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 8899\n");
+    else
+      fprintf(stderr, "reached bug index 8899\n");
+  }
+  if ((!FIXREVERTER[8899] && (ssymbuf == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     {
       free (indbuf);
       return NULL;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
   ssym = (struct elf_symbuf_symbol *) (ssymbuf + shndx_count + 1);
   ssymbuf->ssym = NULL;
@@ -8225,8 +9098,23 @@ bfd_elf_match_symbols_in_sections (asection *sec1, asection *sec2,
   hdr2 = &elf_tdata (bfd2)->symtab_hdr;
   symcount2 = hdr2->sh_size / bed2->s->sizeof_sym;
 
-  if (symcount1 == 0 || symcount2 == 0)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[8901]) {
+    if ((symcount1 == 0 || symcount2 == 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 8901\n");
+    else
+      fprintf(stderr, "reached bug index 8901\n");
+  }
+  if ((!FIXREVERTER[8901] && (symcount1 == 0 || symcount2 == 0 ))
+  #else
+  if (0
+  #endif
+  )
     return false;
+    #ifdef FRCOV
+    }
+    #endif
 
   result = false;
   isymbuf1 = NULL;
@@ -8245,8 +9133,23 @@ bfd_elf_match_symbols_in_sections (asection *sec1, asection *sec2,
     {
       isymbuf1 = bfd_elf_get_elf_syms (bfd1, hdr1, symcount1, 0,
 				       NULL, NULL, NULL);
-      if (isymbuf1 == NULL)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[8902]) {
+        if ((isymbuf1 == (void *) 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 8902\n");
+        else
+          fprintf(stderr, "reached bug index 8902\n");
+      }
+      if ((!FIXREVERTER[8902] && (isymbuf1 == (void *) 0 ))
+      #else
+      if (0
+      #endif
+      )
 	goto done;
+	#ifdef FRCOV
+	}
+	#endif
 
       if (info != NULL && !info->reduce_memory_overheads)
 	{
@@ -8259,8 +9162,23 @@ bfd_elf_match_symbols_in_sections (asection *sec1, asection *sec2,
     {
       isymbuf2 = bfd_elf_get_elf_syms (bfd2, hdr2, symcount2, 0,
 				       NULL, NULL, NULL);
-      if (isymbuf2 == NULL)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[8903]) {
+        if ((isymbuf2 == (void *) 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 8903\n");
+        else
+          fprintf(stderr, "reached bug index 8903\n");
+      }
+      if ((!FIXREVERTER[8903] && (isymbuf2 == (void *) 0 ))
+      #else
+      if (0
+      #endif
+      )
 	goto done;
+	#ifdef FRCOV
+	}
+	#endif
 
       if (ssymbuf1 != NULL && info != NULL && !info->reduce_memory_overheads)
 	{
@@ -8330,15 +9248,45 @@ bfd_elf_match_symbols_in_sections (asection *sec1, asection *sec2,
 	  count2 -= sec_count2;
 	}
 
-      if (count1 == 0 || count2 == 0 || count1 != count2)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[8904]) {
+        if ((count1 == 0 || count2 == 0 || count1 != count2 ) && !(0))
+          fprintf(stderr, "triggered bug index 8904\n");
+        else
+          fprintf(stderr, "reached bug index 8904\n");
+      }
+      if ((!FIXREVERTER[8904] && (count1 == 0 || count2 == 0 || count1 != count2 ))
+      #else
+      if (0
+      #endif
+      )
 	goto done;
+	#ifdef FRCOV
+	}
+	#endif
 
       symtable1
 	= (struct elf_symbol *) bfd_malloc (count1 * sizeof (*symtable1));
       symtable2
 	= (struct elf_symbol *) bfd_malloc (count2 * sizeof (*symtable2));
-      if (symtable1 == NULL || symtable2 == NULL)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[8905]) {
+        if ((symtable1 == (void *) 0 || symtable2 == (void *) 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 8905\n");
+        else
+          fprintf(stderr, "reached bug index 8905\n");
+      }
+      if ((!FIXREVERTER[8905] && (symtable1 == (void *) 0 || symtable2 == (void *) 0 ))
+      #else
+      if (0
+      #endif
+      )
 	goto done;
+	#ifdef FRCOV
+	}
+	#endif
 
       symp = symtable1;
       for (ssym = ssymbuf1->ssym, ssymend = ssym + count1 + sec_count1;
@@ -8387,8 +9335,23 @@ bfd_elf_match_symbols_in_sections (asection *sec1, asection *sec2,
       bfd_malloc (symcount1 * sizeof (struct elf_symbol));
   symtable2 = (struct elf_symbol *)
       bfd_malloc (symcount2 * sizeof (struct elf_symbol));
-  if (symtable1 == NULL || symtable2 == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[8906]) {
+    if ((symtable1 == (void *) 0 || symtable2 == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 8906\n");
+    else
+      fprintf(stderr, "reached bug index 8906\n");
+  }
+  if ((!FIXREVERTER[8906] && (symtable1 == (void *) 0 || symtable2 == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     goto done;
+    #ifdef FRCOV
+    }
+    #endif
 
   /* Count definitions in the section.  */
   count1 = 0;
@@ -8405,8 +9368,23 @@ bfd_elf_match_symbols_in_sections (asection *sec1, asection *sec2,
 	    || ELF_ST_TYPE (isym->st_info) != STT_SECTION))
       symtable2[count2++].u.isym = isym;
 
-  if (count1 == 0 || count2 == 0 || count1 != count2)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[8907]) {
+    if ((count1 == 0 || count2 == 0 || count1 != count2 ) && !(0))
+      fprintf(stderr, "triggered bug index 8907\n");
+    else
+      fprintf(stderr, "reached bug index 8907\n");
+  }
+  if ((!FIXREVERTER[8907] && (count1 == 0 || count2 == 0 || count1 != count2 ))
+  #else
+  if (0
+  #endif
+  )
     goto done;
+    #ifdef FRCOV
+    }
+    #endif
 
   for (i = 0; i < count1; i++)
     symtable1[i].name
@@ -8525,8 +9503,23 @@ local_hash_newfunc (struct bfd_hash_entry *entry,
     {
       entry = bfd_hash_allocate (table,
 				 sizeof (struct local_hash_entry));
-      if (entry == NULL)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[8908]) {
+        if ((entry == (void *) 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 8908\n");
+        else
+          fprintf(stderr, "reached bug index 8908\n");
+      }
+      if ((!FIXREVERTER[8908] && (entry == (void *) 0 ))
+      #else
+      if (0
+      #endif
+      )
         return entry;
+        #ifdef FRCOV
+        }
+        #endif
     }
 
   /* Call the allocation method of the superclass.  */
@@ -8712,8 +9705,23 @@ resolve_section (const char *name,
   for (curr = sections; curr; curr = curr->next)
     {
       len = strlen (curr->name);
-      if (len > strlen (name))
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[8909]) {
+        if ((len > strlen ( name ) ) && !(0))
+          fprintf(stderr, "triggered bug index 8909\n");
+        else
+          fprintf(stderr, "reached bug index 8909\n");
+      }
+      if ((!FIXREVERTER[8909] && (len > strlen ( name ) ))
+      #else
+      if (0
+      #endif
+      )
 	continue;
+	#ifdef FRCOV
+	}
+	#endif
 
       if (strncmp (curr->name, name, len) == 0)
 	{
@@ -8762,11 +9770,26 @@ eval_symbol (bfd_vma *result,
   len = strlen (sym);
   symend = sym + len;
 
-  if (len < 1 || len > sizeof (symbuf))
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[8911]) {
+    if ((len < 1 || len > sizeof ( symbuf ) ) && !(0))
+      fprintf(stderr, "triggered bug index 8911\n");
+    else
+      fprintf(stderr, "reached bug index 8911\n");
+  }
+  if ((!FIXREVERTER[8911] && (len < 1 || len > sizeof ( symbuf ) ))
+  #else
+  if (0
+  #endif
+  )
     {
       bfd_set_error (bfd_error_invalid_operation);
       return false;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
   switch (* sym)
     {
@@ -8788,11 +9811,26 @@ eval_symbol (bfd_vma *result,
       symlen = strtol (sym, (char **) symp, 10);
       sym = *symp + 1; /* Skip the trailing ':'.  */
 
-      if (symend < sym || symlen + 1 > sizeof (symbuf))
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[8912]) {
+        if ((symend < sym || symlen + 1 > sizeof ( symbuf ) ) && !(0))
+          fprintf(stderr, "triggered bug index 8912\n");
+        else
+          fprintf(stderr, "reached bug index 8912\n");
+      }
+      if ((!FIXREVERTER[8912] && (symend < sym || symlen + 1 > sizeof ( symbuf ) ))
+      #else
+      if (0
+      #endif
+      )
 	{
 	  bfd_set_error (bfd_error_invalid_operation);
 	  return false;
 	}
+	#ifdef FRCOV
+	}
+	#endif
 
       memcpy (symbuf, sym, symlen);
       symbuf[symlen] = '\0';
@@ -8872,19 +9910,49 @@ eval_symbol (bfd_vma *result,
     default:
       UNARY_OP  (0-);
       BINARY_OP_HEAD (<<);
-      if (b >= sizeof (a) * CHAR_BIT)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[8914]) {
+        if ((b >= sizeof ( a ) * 8 ) && !(0))
+          fprintf(stderr, "triggered bug index 8914\n");
+        else
+          fprintf(stderr, "reached bug index 8914\n");
+      }
+      if ((!FIXREVERTER[8914] && (b >= sizeof ( a ) * 8 ))
+      #else
+      if (0
+      #endif
+      )
 	{
 	  *result = 0;
 	  return true;
 	}
+	#ifdef FRCOV
+	}
+	#endif
       signed_p = 0;
       BINARY_OP_TAIL (<<);
       BINARY_OP_HEAD (>>);
-      if (b >= sizeof (a) * CHAR_BIT)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[8915]) {
+        if ((b >= sizeof ( a ) * 8 ) && !(0))
+          fprintf(stderr, "triggered bug index 8915\n");
+        else
+          fprintf(stderr, "reached bug index 8915\n");
+      }
+      if ((!FIXREVERTER[8915] && (b >= sizeof ( a ) * 8 ))
+      #else
+      if (0
+      #endif
+      )
 	{
 	  *result = signed_p && (bfd_signed_vma) a < 0 ? -1 : 0;
 	  return true;
 	}
+	#ifdef FRCOV
+	}
+	#endif
       BINARY_OP_TAIL (>>);
       BINARY_OP (==);
       BINARY_OP (!=);
@@ -8896,20 +9964,50 @@ eval_symbol (bfd_vma *result,
       UNARY_OP  (!);
       BINARY_OP (*);
       BINARY_OP_HEAD (/);
-      if (b == 0)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[8916]) {
+        if ((b == 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 8916\n");
+        else
+          fprintf(stderr, "reached bug index 8916\n");
+      }
+      if ((!FIXREVERTER[8916] && (b == 0 ))
+      #else
+      if (0
+      #endif
+      )
 	{
 	  _bfd_error_handler (_("division by zero"));
 	  bfd_set_error (bfd_error_bad_value);
 	  return false;
 	}
+	#ifdef FRCOV
+	}
+	#endif
       BINARY_OP_TAIL (/);
       BINARY_OP_HEAD (%);
-      if (b == 0)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[8917]) {
+        if ((b == 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 8917\n");
+        else
+          fprintf(stderr, "reached bug index 8917\n");
+      }
+      if ((!FIXREVERTER[8917] && (b == 0 ))
+      #else
+      if (0
+      #endif
+      )
 	{
 	  _bfd_error_handler (_("division by zero"));
 	  bfd_set_error (bfd_error_bad_value);
 	  return false;
 	}
+	#ifdef FRCOV
+	}
+	#endif
       BINARY_OP_TAIL (%);
       BINARY_OP (^);
       BINARY_OP (|);
@@ -9365,8 +10463,23 @@ elf_link_adjust_relocs (bfd *abfd,
 	      if (buf == NULL)
 		{
 		  buf = bfd_malloc (buf_size);
-		  if (buf == NULL)
+		  
+		  #ifdef FRCOV
+		  {if (FIXREVERTER[8922]) {
+		    if ((buf == (void *) 0 ) && !(0))
+		      fprintf(stderr, "triggered bug index 8922\n");
+		    else
+		      fprintf(stderr, "reached bug index 8922\n");
+		  }
+		  if ((!FIXREVERTER[8922] && (buf == (void *) 0 ))
+		  #else
+		  if (0
+		  #endif
+		  )
 		    return false;
+		    #ifdef FRCOV
+		    }
+		    #endif
 		}
 	      if (runlen < sortlen)
 		{
@@ -9635,23 +10748,68 @@ elf_link_sort_relocs (bfd *abfd, struct bfd_link_info *info, asection **psec)
     if (lo->type == bfd_indirect_link_order)
       size += lo->u.indirect.section->size;
 
-  if (size != dynamic_relocs->size)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[8929]) {
+    if ((size != dynamic_relocs -> size ) && !(0))
+      fprintf(stderr, "triggered bug index 8929\n");
+    else
+      fprintf(stderr, "reached bug index 8929\n");
+  }
+  if ((!FIXREVERTER[8929] && (size != dynamic_relocs -> size ))
+  #else
+  if (0
+  #endif
+  )
     return 0;
+    #ifdef FRCOV
+    }
+    #endif
 
   sort_elt = (sizeof (struct elf_link_sort_rela)
 	      + (i2e - 1) * sizeof (Elf_Internal_Rela));
 
   count = dynamic_relocs->size / ext_size;
-  if (count == 0)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[8930]) {
+    if ((count == 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 8930\n");
+    else
+      fprintf(stderr, "reached bug index 8930\n");
+  }
+  if ((!FIXREVERTER[8930] && (count == 0 ))
+  #else
+  if (0
+  #endif
+  )
     return 0;
+    #ifdef FRCOV
+    }
+    #endif
   sort = (bfd_byte *) bfd_zmalloc (sort_elt * count);
 
-  if (sort == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[8931]) {
+    if ((sort == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 8931\n");
+    else
+      fprintf(stderr, "reached bug index 8931\n");
+  }
+  if ((!FIXREVERTER[8931] && (sort == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     {
       (*info->callbacks->warning)
 	(info, _("not enough memory to sort relocations"), 0, abfd, 0, 0);
       return 0;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
   if (bed->s->arch_size == 32)
     r_sym_mask = ~(bfd_vma) 0xff;
@@ -9817,8 +10975,23 @@ elf_link_output_symstrtab (void *finf,
 		  size_t base_len;
 		  size_t len = strlen (name);
 		  versioned_name = bfd_alloc (flinfo->output_bfd, len);
-		  if (versioned_name == NULL)
+		  
+		  #ifdef FRCOV
+		  {if (FIXREVERTER[8933]) {
+		    if ((versioned_name == (void *) 0 ) && !(0))
+		      fprintf(stderr, "triggered bug index 8933\n");
+		    else
+		      fprintf(stderr, "reached bug index 8933\n");
+		  }
+		  if ((!FIXREVERTER[8933] && (versioned_name == (void *) 0 ))
+		  #else
+		  if (0
+		  #endif
+		  )
 		    return 0;
+		    #ifdef FRCOV
+		    }
+		    #endif
 		  base_len = base_end - name;
 		  memcpy (versioned_name, name, base_len);
 		  memcpy (versioned_name + base_len, version,
@@ -9841,8 +11014,23 @@ elf_link_output_symstrtab (void *finf,
 	    default:
 	      lh = (struct local_hash_entry *) bfd_hash_lookup
 		     (&flinfo->local_hash_table, name, true, false);
-	      if (lh == NULL)
+	      
+	      #ifdef FRCOV
+	      {if (FIXREVERTER[8937]) {
+	        if ((lh == (void *) 0 ) && !(0))
+	          fprintf(stderr, "triggered bug index 8937\n");
+	        else
+	          fprintf(stderr, "reached bug index 8937\n");
+	      }
+	      if ((!FIXREVERTER[8937] && (lh == (void *) 0 ))
+	      #else
+	      if (0
+	      #endif
+	      )
 		return 0;
+		#ifdef FRCOV
+		}
+		#endif
 	      /* Always append ".COUNT" to local symbols to avoid
 		 potential conflicts with local symbol "XXX.COUNT".  */
 	      sprintf (buf, "%lx", lh->count);
@@ -9855,8 +11043,23 @@ elf_link_output_symstrtab (void *finf,
 	      count_len = strlen (buf);
 	      versioned_name = bfd_alloc (flinfo->output_bfd,
 					  base_len + count_len + 2);
-	      if (versioned_name == NULL)
+	      
+	      #ifdef FRCOV
+	      {if (FIXREVERTER[8938]) {
+	        if ((versioned_name == (void *) 0 ) && !(0))
+	          fprintf(stderr, "triggered bug index 8938\n");
+	        else
+	          fprintf(stderr, "reached bug index 8938\n");
+	      }
+	      if ((!FIXREVERTER[8938] && (versioned_name == (void *) 0 ))
+	      #else
+	      if (0
+	      #endif
+	      )
 		return 0;
+		#ifdef FRCOV
+		}
+		#endif
 	      memcpy (versioned_name, name, base_len);
 	      versioned_name[base_len] = '.';
 	      memcpy (versioned_name + base_len + 1, buf,
@@ -9882,8 +11085,23 @@ elf_link_output_symstrtab (void *finf,
       hash_table->strtab
 	= (struct elf_sym_strtab *) bfd_realloc (hash_table->strtab,
 						 strtabsize);
-      if (hash_table->strtab == NULL)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[8940]) {
+        if ((hash_table -> strtab == (void *) 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 8940\n");
+        else
+          fprintf(stderr, "reached bug index 8940\n");
+      }
+      if ((!FIXREVERTER[8940] && (hash_table -> strtab == (void *) 0 ))
+      #else
+      if (0
+      #endif
+      )
 	return 0;
+	#ifdef FRCOV
+	}
+	#endif
     }
   hash_table->strtab[hash_table->strtabcount].sym = *elfsym;
   hash_table->strtab[hash_table->strtabcount].dest_index
@@ -9921,19 +11139,49 @@ elf_link_swap_symbols_out (struct elf_final_link_info *flinfo)
 
   amt = bed->s->sizeof_sym * hash_table->strtabcount;
   symbuf = (bfd_byte *) bfd_malloc (amt);
-  if (symbuf == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[8941]) {
+    if ((symbuf == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 8941\n");
+    else
+      fprintf(stderr, "reached bug index 8941\n");
+  }
+  if ((!FIXREVERTER[8941] && (symbuf == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     return false;
+    #ifdef FRCOV
+    }
+    #endif
 
   if (flinfo->symshndxbuf)
     {
       amt = sizeof (Elf_External_Sym_Shndx);
       amt *= bfd_get_symcount (flinfo->output_bfd);
       flinfo->symshndxbuf = (Elf_External_Sym_Shndx *) bfd_zmalloc (amt);
-      if (flinfo->symshndxbuf == NULL)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[8942]) {
+        if ((flinfo -> symshndxbuf == (void *) 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 8942\n");
+        else
+          fprintf(stderr, "reached bug index 8942\n");
+      }
+      if ((!FIXREVERTER[8942] && (flinfo -> symshndxbuf == (void *) 0 ))
+      #else
+      if (0
+      #endif
+      )
 	{
 	  free (symbuf);
 	  return false;
 	}
+	#ifdef FRCOV
+	}
+	#endif
     }
 
   /* Now swap out the symbols.  */
@@ -10085,13 +11333,43 @@ elf_link_check_versioned_symbol (struct bfd_link_info *info,
 	  extsymoff = hdr->sh_info;
 	}
 
-      if (extsymcount == 0)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[8943]) {
+        if ((extsymcount == 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 8943\n");
+        else
+          fprintf(stderr, "reached bug index 8943\n");
+      }
+      if ((!FIXREVERTER[8943] && (extsymcount == 0 ))
+      #else
+      if (0
+      #endif
+      )
 	continue;
+	#ifdef FRCOV
+	}
+	#endif
 
       isymbuf = bfd_elf_get_elf_syms (input, hdr, extsymcount, extsymoff,
 				      NULL, NULL, NULL);
-      if (isymbuf == NULL)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[8944]) {
+        if ((isymbuf == (void *) 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 8944\n");
+        else
+          fprintf(stderr, "reached bug index 8944\n");
+      }
+      if ((!FIXREVERTER[8944] && (isymbuf == (void *) 0 ))
+      #else
+      if (0
+      #endif
+      )
 	return false;
+	#ifdef FRCOV
+	}
+	#endif
 
       /* Read in any version definitions.  */
       versymhdr = &elf_tdata (input)->dynversym_hdr;
@@ -10484,8 +11762,23 @@ elf_link_output_extsym (struct bfd_hash_entry *bh, void *data)
       type = ELF_ST_TYPE (sym.st_info);
 
       /* Turn an undefined IFUNC symbol into a normal FUNC symbol. */
-      if (type == STT_GNU_IFUNC)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[8946]) {
+        if ((type == 10 ) && !(0))
+          fprintf(stderr, "triggered bug index 8946\n");
+        else
+          fprintf(stderr, "reached bug index 8946\n");
+      }
+      if ((!FIXREVERTER[8946] && (type == 10 ))
+      #else
+      if (0
+      #endif
+      )
 	type = STT_FUNC;
+	#ifdef FRCOV
+	}
+	#endif
 
       if (h->ref_regular_nonweak)
 	bindtype = STB_GLOBAL;
@@ -10858,15 +12151,48 @@ elf_link_input_bfd (struct elf_final_link_info *flinfo, bfd *input_bfd)
 
   /* Read the local symbols.  */
   isymbuf = (Elf_Internal_Sym *) symtab_hdr->contents;
-  if (isymbuf == NULL && locsymcount != 0)
-    {
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[8948]) {
+    fprintf(stderr, "reached bug index 8948\n");
+  }
+  if ((FIXREVERTER[8948] && (isymbuf == (void *) 0 )) || (!FIXREVERTER[8948] && (isymbuf == (void *) 0 && locsymcount != 0 ))
+  #else
+  if (isymbuf == (void *) 0 
+  #endif
+  )
+    {
+      
+    #ifdef FRCOV
+      if (!(locsymcount != 0 ))
+        fprintf(stderr, "triggered bug index 8948\n");
+      #endif
+    
       isymbuf = bfd_elf_get_elf_syms (input_bfd, symtab_hdr, locsymcount, 0,
 				      flinfo->internal_syms,
 				      flinfo->external_syms,
 				      flinfo->locsym_shndx);
-      if (isymbuf == NULL)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[8947]) {
+        if ((isymbuf == (void *) 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 8947\n");
+        else
+          fprintf(stderr, "reached bug index 8947\n");
+      }
+      if ((!FIXREVERTER[8947] && (isymbuf == (void *) 0 ))
+      #else
+      if (0
+      #endif
+      )
 	return false;
+	#ifdef FRCOV
+	}
+	#endif
     }
+    #ifdef FRCOV
+    }
+    #endif
 
   /* Find local symbol sections and adjust values of symbols in
      SEC_MERGE sections.  Write out those local symbols we know are
@@ -10967,8 +12293,23 @@ elf_link_input_bfd (struct elf_final_link_info *flinfo, bfd *input_bfd)
       /* Get the name of the symbol.  */
       name = bfd_elf_string_from_elf_section (input_bfd, symtab_hdr->sh_link,
 					      isym->st_name);
-      if (name == NULL)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[8949]) {
+        if ((name == (void *) 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 8949\n");
+        else
+          fprintf(stderr, "reached bug index 8949\n");
+      }
+      if ((!FIXREVERTER[8949] && (name == (void *) 0 ))
+      #else
+      if (0
+      #endif
+      )
 	return false;
+	#ifdef FRCOV
+	}
+	#endif
 
       /* See if we are discarding symbols with this name.  */
       if ((flinfo->info->strip == strip_some
@@ -11117,8 +12458,23 @@ elf_link_input_bfd (struct elf_final_link_info *flinfo, bfd *input_bfd)
 		  name = bfd_elf_string_from_elf_section (input_bfd,
 							  symtab_hdr->sh_link,
 							  sym.st_name);
-		  if (name == NULL)
+		  
+		  #ifdef FRCOV
+		  {if (FIXREVERTER[8950]) {
+		    if ((name == (void *) 0 ) && !(0))
+		      fprintf(stderr, "triggered bug index 8950\n");
+		    else
+		      fprintf(stderr, "reached bug index 8950\n");
+		  }
+		  if ((!FIXREVERTER[8950] && (name == (void *) 0 ))
+		  #else
+		  if (0
+		  #endif
+		  )
 		    return false;
+		    #ifdef FRCOV
+		    }
+		    #endif
 
 		  sym.st_shndx = _bfd_elf_section_from_bfd_section (output_bfd,
 								    sec);
@@ -11235,8 +12591,23 @@ elf_link_input_bfd (struct elf_final_link_info *flinfo, bfd *input_bfd)
 	      struct elf_link_hash_entry *h = NULL;
 	      const char *sym_name;
 
-	      if (r_symndx == STN_UNDEF)
+	      
+	      #ifdef FRCOV
+	      {if (FIXREVERTER[8952]) {
+	        if ((r_symndx == 0 ) && !(0))
+	          fprintf(stderr, "triggered bug index 8952\n");
+	        else
+	          fprintf(stderr, "reached bug index 8952\n");
+	      }
+	      if ((!FIXREVERTER[8952] && (r_symndx == 0 ))
+	      #else
+	      if (0
+	      #endif
+	      )
 		continue;
+		#ifdef FRCOV
+		}
+		#endif
 
 	      if (r_symndx >= locsymcount
 		  || (elf_bad_symtab (input_bfd)
@@ -11247,7 +12618,19 @@ elf_link_input_bfd (struct elf_final_link_info *flinfo, bfd *input_bfd)
 		  /* Badly formatted input files can contain relocs that
 		     reference non-existant symbols.  Check here so that
 		     we do not seg fault.  */
-		  if (h == NULL)
+		  
+		  #ifdef FRCOV
+		  {if (FIXREVERTER[8953]) {
+		    if ((h == (void *) 0 ) && !(0))
+		      fprintf(stderr, "triggered bug index 8953\n");
+		    else
+		      fprintf(stderr, "reached bug index 8953\n");
+		  }
+		  if ((!FIXREVERTER[8953] && (h == (void *) 0 ))
+		  #else
+		  if (0
+		  #endif
+		  )
 		    {
 		      _bfd_error_handler
 			/* xgettext:c-format */
@@ -11257,6 +12640,9 @@ elf_link_input_bfd (struct elf_final_link_info *flinfo, bfd *input_bfd)
 		      bfd_set_error (bfd_error_bad_value);
 		      return false;
 		    }
+		    #ifdef FRCOV
+		    }
+		    #endif
 
 		  while (h->root.type == bfd_link_hash_indirect
 			 || h->root.type == bfd_link_hash_warning)
@@ -11579,8 +12965,23 @@ elf_link_input_bfd (struct elf_final_link_info *flinfo, bfd *input_bfd)
 			  shlink = symtab_hdr->sh_link;
 			  name = (bfd_elf_string_from_elf_section
 				  (input_bfd, shlink, sym.st_name));
-			  if (name == NULL)
+			  
+			  #ifdef FRCOV
+			  {if (FIXREVERTER[8955]) {
+			    if ((name == (void *) 0 ) && !(0))
+			      fprintf(stderr, "triggered bug index 8955\n");
+			    else
+			      fprintf(stderr, "reached bug index 8955\n");
+			  }
+			  if ((!FIXREVERTER[8955] && (name == (void *) 0 ))
+			  #else
+			  if (0
+			  #endif
+			  )
 			    return false;
+			    #ifdef FRCOV
+			    }
+			    #endif
 
 			  osec = sec->output_section;
 			  sym.st_shndx =
@@ -11756,11 +13157,26 @@ elf_reloc_link_order (bfd *output_bfd,
   struct bfd_elf_section_data *esdo = elf_section_data (output_section);
 
   howto = bfd_reloc_type_lookup (output_bfd, link_order->u.reloc.p->reloc);
-  if (howto == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[8957]) {
+    if ((howto == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 8957\n");
+    else
+      fprintf(stderr, "reached bug index 8957\n");
+  }
+  if ((!FIXREVERTER[8957] && (howto == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     {
       bfd_set_error (bfd_error_bad_value);
       return false;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
   addend = link_order->u.reloc.p->addend;
 
@@ -11951,12 +13367,42 @@ elf_output_implib (bfd *abfd, struct bfd_link_info *info)
 
   /* Read in the symbol table.  */
   sympp = (asymbol **) bfd_malloc (symsize);
-  if (sympp == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[8959]) {
+    if ((sympp == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 8959\n");
+    else
+      fprintf(stderr, "reached bug index 8959\n");
+  }
+  if ((!FIXREVERTER[8959] && (sympp == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     return false;
+    #ifdef FRCOV
+    }
+    #endif
 
   symcount = bfd_canonicalize_symtab (abfd, sympp);
-  if (symcount < 0)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[8960]) {
+    if ((symcount < 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 8960\n");
+    else
+      fprintf(stderr, "reached bug index 8960\n");
+  }
+  if ((!FIXREVERTER[8960] && (symcount < 0 ))
+  #else
+  if (0
+  #endif
+  )
     goto free_sym_buf;
+    #ifdef FRCOV
+    }
+    #endif
 
   /* Allow the BFD backend to copy any private header data it
      understands from the output BFD to the import library BFD.  */
@@ -11969,20 +13415,50 @@ elf_output_implib (bfd *abfd, struct bfd_link_info *info)
 						       symcount);
   else
     symcount = _bfd_elf_filter_global_symbols (abfd, info, sympp, symcount);
-  if (symcount == 0)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[8961]) {
+    if ((symcount == 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 8961\n");
+    else
+      fprintf(stderr, "reached bug index 8961\n");
+  }
+  if ((!FIXREVERTER[8961] && (symcount == 0 ))
+  #else
+  if (0
+  #endif
+  )
     {
       bfd_set_error (bfd_error_no_symbols);
       _bfd_error_handler (_("%pB: no symbol found for import library"),
 			  implib_bfd);
       goto free_sym_buf;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
 
   /* Make symbols absolute.  */
   amt = symcount * sizeof (*osymbuf);
   osymbuf = (elf_symbol_type *) bfd_alloc (implib_bfd, amt);
-  if (osymbuf == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[8962]) {
+    if ((osymbuf == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 8962\n");
+    else
+      fprintf(stderr, "reached bug index 8962\n");
+  }
+  if ((!FIXREVERTER[8962] && (osymbuf == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     goto free_sym_buf;
+    #ifdef FRCOV
+    }
+    #endif
 
   for (src_count = 0; src_count < symcount; src_count++)
     {
@@ -13269,11 +14745,26 @@ init_reloc_cookie (struct elf_reloc_cookie *cookie,
       cookie->locsyms = bfd_elf_get_elf_syms (abfd, symtab_hdr,
 					      cookie->locsymcount, 0,
 					      NULL, NULL, NULL);
-      if (cookie->locsyms == NULL)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[8963]) {
+        if ((cookie -> locsyms == (void *) 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 8963\n");
+        else
+          fprintf(stderr, "reached bug index 8963\n");
+      }
+      if ((!FIXREVERTER[8963] && (cookie -> locsyms == (void *) 0 ))
+      #else
+      if (0
+      #endif
+      )
 	{
 	  info->callbacks->einfo (_("%P%X: can not read symbols: %E\n"));
 	  return false;
 	}
+	#ifdef FRCOV
+	}
+	#endif
       if (info->keep_memory)
 	symtab_hdr->contents = (bfd_byte *) cookie->locsyms;
     }
@@ -13434,8 +14925,23 @@ _bfd_elf_gc_mark_rsec (struct bfd_link_info *info, asection *sec,
   struct elf_link_hash_entry *h, *hw;
 
   r_symndx = cookie->rel->r_info >> cookie->r_sym_shift;
-  if (r_symndx == STN_UNDEF)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[8966]) {
+    if ((r_symndx == 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 8966\n");
+    else
+      fprintf(stderr, "reached bug index 8966\n");
+  }
+  if ((!FIXREVERTER[8966] && (r_symndx == 0 ))
+  #else
+  if (0
+  #endif
+  )
     return NULL;
+    #ifdef FRCOV
+    }
+    #endif
 
   if (r_symndx >= cookie->locsymcount
       || ELF_ST_BIND (cookie->locsyms[r_symndx].st_info) != STB_LOCAL)
@@ -13443,12 +14949,27 @@ _bfd_elf_gc_mark_rsec (struct bfd_link_info *info, asection *sec,
       bool was_marked;
 
       h = cookie->sym_hashes[r_symndx - cookie->extsymoff];
-      if (h == NULL)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[8967]) {
+        if ((h == (void *) 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 8967\n");
+        else
+          fprintf(stderr, "reached bug index 8967\n");
+      }
+      if ((!FIXREVERTER[8967] && (h == (void *) 0 ))
+      #else
+      if (0
+      #endif
+      )
 	{
 	  info->callbacks->einfo (_("%F%P: corrupt input: %pB\n"),
 				  sec->owner);
 	  return NULL;
 	}
+	#ifdef FRCOV
+	}
+	#endif
       while (h->root.type == bfd_link_hash_indirect
 	     || h->root.type == bfd_link_hash_warning)
 	h = (struct elf_link_hash_entry *) h->root.u.i.link;
@@ -13780,8 +15301,23 @@ elf_gc_sweep (bfd *abfd, struct bfd_link_info *info)
 	  || !(*bed->relocs_compatible) (sub->xvec, abfd->xvec))
 	continue;
       o = sub->sections;
-      if (o == NULL || o->sec_info_type == SEC_INFO_TYPE_JUST_SYMS)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[8968]) {
+        if ((o == (void *) 0 || o -> sec_info_type == 4 ) && !(0))
+          fprintf(stderr, "triggered bug index 8968\n");
+        else
+          fprintf(stderr, "reached bug index 8968\n");
+      }
+      if ((!FIXREVERTER[8968] && (o == (void *) 0 || o -> sec_info_type == 4 ))
+      #else
+      if (0
+      #endif
+      )
 	continue;
+	#ifdef FRCOV
+	}
+	#endif
 
       for (o = sub->sections; o != NULL; o = o->next)
 	{
@@ -13908,8 +15444,23 @@ elf_gc_smash_unused_vtentry_relocs (struct elf_link_hash_entry *h, void *okp)
   relend = relstart + sec->reloc_count;
 
   for (rel = relstart; rel < relend; ++rel)
-    if (rel->r_offset >= hstart && rel->r_offset < hend)
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[8969]) {
+      fprintf(stderr, "reached bug index 8969\n");
+    }
+    if ((FIXREVERTER[8969] && (rel -> r_offset < hend )) || (!FIXREVERTER[8969] && (rel -> r_offset >= hstart && rel -> r_offset < hend ))
+    #else
+    if (rel -> r_offset < hend 
+    #endif
+    )
       {
+        
+      #ifdef FRCOV
+        if (!(rel -> r_offset >= hstart ))
+          fprintf(stderr, "triggered bug index 8969\n");
+        #endif
+      
 	/* If the entry is in use, do nothing.  */
 	if (h->u2.vtable->used
 	    && (rel->r_offset - hstart) < h->u2.vtable->size)
@@ -13921,6 +15472,9 @@ elf_gc_smash_unused_vtentry_relocs (struct elf_link_hash_entry *h, void *okp)
 	/* Otherwise, kill it.  */
 	rel->r_offset = rel->r_info = rel->r_addend = 0;
       }
+      #ifdef FRCOV
+      }
+      #endif
 
   return true;
 }
diff --git a/bfd/elfn32-mips.c b/bfd/elfn32-mips.c
old mode 100644
new mode 100755
diff --git a/bfd/elfnn-aarch64.c b/bfd/elfnn-aarch64.c
old mode 100644
new mode 100755
diff --git a/bfd/elfnn-ia64.c b/bfd/elfnn-ia64.c
old mode 100644
new mode 100755
diff --git a/bfd/elfnn-riscv.c b/bfd/elfnn-riscv.c
old mode 100644
new mode 100755
diff --git a/bfd/elfxx-aarch64.c b/bfd/elfxx-aarch64.c
old mode 100644
new mode 100755
diff --git a/bfd/elfxx-aarch64.h b/bfd/elfxx-aarch64.h
old mode 100644
new mode 100755
diff --git a/bfd/elfxx-ia64.c b/bfd/elfxx-ia64.c
old mode 100644
new mode 100755
diff --git a/bfd/elfxx-ia64.h b/bfd/elfxx-ia64.h
old mode 100644
new mode 100755
diff --git a/bfd/elfxx-mips.c b/bfd/elfxx-mips.c
old mode 100644
new mode 100755
index 426f432..2090220
--- a/bfd/elfxx-mips.c
+++ b/bfd/elfxx-mips.c
@@ -1,3 +1,6 @@
+#ifdef FRCOV
+extern short FIXREVERTER[];
+#endif
 /* MIPS-specific support for ELF
    Copyright (C) 1993-2021 Free Software Foundation, Inc.
 
@@ -1519,35 +1522,110 @@ mips_elf_create_procedure_table (void *handle, bfd *abfd,
       size = swap->external_pdr_size;
 
       epdr = bfd_malloc (size * count);
-      if (epdr == NULL)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[7642]) {
+        if ((epdr == (void *) 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 7642\n");
+        else
+          fprintf(stderr, "reached bug index 7642\n");
+      }
+      if ((!FIXREVERTER[7642] && (epdr == (void *) 0 ))
+      #else
+      if (0
+      #endif
+      )
 	goto error_return;
+	#ifdef FRCOV
+	}
+	#endif
 
       if (! _bfd_ecoff_get_accumulated_pdr (handle, (bfd_byte *) epdr))
 	goto error_return;
 
       size = sizeof (RPDR);
       rp = rpdr = bfd_malloc (size * count);
-      if (rpdr == NULL)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[7643]) {
+        if ((rpdr == (void *) 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 7643\n");
+        else
+          fprintf(stderr, "reached bug index 7643\n");
+      }
+      if ((!FIXREVERTER[7643] && (rpdr == (void *) 0 ))
+      #else
+      if (0
+      #endif
+      )
 	goto error_return;
+	#ifdef FRCOV
+	}
+	#endif
 
       size = sizeof (char *);
       sv = bfd_malloc (size * count);
-      if (sv == NULL)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[7644]) {
+        if ((sv == (void *) 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 7644\n");
+        else
+          fprintf(stderr, "reached bug index 7644\n");
+      }
+      if ((!FIXREVERTER[7644] && (sv == (void *) 0 ))
+      #else
+      if (0
+      #endif
+      )
 	goto error_return;
+	#ifdef FRCOV
+	}
+	#endif
 
       count = hdr->isymMax;
       size = swap->external_sym_size;
       esym = bfd_malloc (size * count);
-      if (esym == NULL)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[7645]) {
+        if ((esym == (void *) 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 7645\n");
+        else
+          fprintf(stderr, "reached bug index 7645\n");
+      }
+      if ((!FIXREVERTER[7645] && (esym == (void *) 0 ))
+      #else
+      if (0
+      #endif
+      )
 	goto error_return;
+	#ifdef FRCOV
+	}
+	#endif
 
       if (! _bfd_ecoff_get_accumulated_sym (handle, (bfd_byte *) esym))
 	goto error_return;
 
       count = hdr->issMax;
       ss = bfd_malloc (count);
-      if (ss == NULL)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[7646]) {
+        if ((ss == (void *) 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 7646\n");
+        else
+          fprintf(stderr, "reached bug index 7646\n");
+      }
+      if ((!FIXREVERTER[7646] && (ss == (void *) 0 ))
+      #else
+      if (0
+      #endif
+      )
 	goto error_return;
+	#ifdef FRCOV
+	}
+	#endif
       if (! _bfd_ecoff_get_accumulated_ss (handle, (bfd_byte *) ss))
 	goto error_return;
 
@@ -1573,11 +1651,26 @@ mips_elf_create_procedure_table (void *handle, bfd *abfd,
   size = sizeof (struct rpdr_ext) * (count + 2) + sindex;
   size = BFD_ALIGN (size, 16);
   rtproc = bfd_alloc (abfd, size);
-  if (rtproc == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[7647]) {
+    if ((rtproc == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 7647\n");
+    else
+      fprintf(stderr, "reached bug index 7647\n");
+  }
+  if ((!FIXREVERTER[7647] && (rtproc == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     {
       mips_elf_hash_table (info)->procedure_count = 0;
       goto error_return;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
   mips_elf_hash_table (info)->procedure_count = count + 2;
 
@@ -2839,13 +2932,58 @@ sort_dynamic_relocs (const void *arg1, const void *arg2)
   bfd_elf32_swap_reloc_in (reldyn_sorting_bfd, arg2, &int_reloc2);
 
   diff = ELF32_R_SYM (int_reloc1.r_info) - ELF32_R_SYM (int_reloc2.r_info);
-  if (diff != 0)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[7658]) {
+    if ((diff != 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 7658\n");
+    else
+      fprintf(stderr, "reached bug index 7658\n");
+  }
+  if ((!FIXREVERTER[7658] && (diff != 0 ))
+  #else
+  if (0
+  #endif
+  )
     return diff;
+    #ifdef FRCOV
+    }
+    #endif
 
-  if (int_reloc1.r_offset < int_reloc2.r_offset)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[7659]) {
+    if ((int_reloc1 . r_offset < int_reloc2 . r_offset ) && !(0))
+      fprintf(stderr, "triggered bug index 7659\n");
+    else
+      fprintf(stderr, "reached bug index 7659\n");
+  }
+  if ((!FIXREVERTER[7659] && (int_reloc1 . r_offset < int_reloc2 . r_offset ))
+  #else
+  if (0
+  #endif
+  )
     return -1;
-  if (int_reloc1.r_offset > int_reloc2.r_offset)
+    #ifdef FRCOV
+    }
+    #endif
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[7660]) {
+    if ((int_reloc1 . r_offset > int_reloc2 . r_offset ) && !(0))
+      fprintf(stderr, "triggered bug index 7660\n");
+    else
+      fprintf(stderr, "reached bug index 7660\n");
+  }
+  if ((!FIXREVERTER[7660] && (int_reloc1 . r_offset > int_reloc2 . r_offset ))
+  #else
+  if (0
+  #endif
+  )
     return 1;
+    #ifdef FRCOV
+    }
+    #endif
   return 0;
 }
 
@@ -3885,8 +4023,23 @@ mips_elf_sort_hash_table (bfd *abfd, struct bfd_link_info *info)
     return true;
 
   g = htab->got_info;
-  if (g == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[7670]) {
+    if ((g == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 7670\n");
+    else
+      fprintf(stderr, "reached bug index 7670\n");
+  }
+  if ((!FIXREVERTER[7670] && (g == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     return true;
+    #ifdef FRCOV
+    }
+    #endif
 
   hsd.low = NULL;
   hsd.max_unref_got_dynindx
@@ -10705,11 +10858,26 @@ mips_elf_create_la25_stub (void **slot, void *data)
   if (loc == NULL)
     {
       loc = bfd_malloc (s->size);
-      if (loc == NULL)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[7698]) {
+        if ((loc == (void *) 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 7698\n");
+        else
+          fprintf(stderr, "reached bug index 7698\n");
+      }
+      if ((!FIXREVERTER[7698] && (loc == (void *) 0 ))
+      #else
+      if (0
+      #endif
+      )
 	{
 	  hti->error = true;
 	  return false;
 	}
+	#ifdef FRCOV
+	}
+	#endif
       s->contents = loc;
     }
 
@@ -13230,15 +13398,45 @@ _bfd_elf_mips_get_relocated_section_contents
   if (!bfd_get_full_section_contents (input_bfd, input_section, &data))
     return NULL;
 
-  if (data == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[7703]) {
+    if ((data == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 7703\n");
+    else
+      fprintf(stderr, "reached bug index 7703\n");
+  }
+  if ((!FIXREVERTER[7703] && (data == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     return NULL;
+    #ifdef FRCOV
+    }
+    #endif
 
   if (reloc_size == 0)
     return data;
 
   reloc_vector = (arelent **) bfd_malloc (reloc_size);
-  if (reloc_vector == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[7705]) {
+    if ((reloc_vector == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 7705\n");
+    else
+      fprintf(stderr, "reached bug index 7705\n");
+  }
+  if ((!FIXREVERTER[7705] && (reloc_vector == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     return NULL;
+    #ifdef FRCOV
+    }
+    #endif
 
   reloc_count = bfd_canonicalize_reloc (input_bfd,
 					input_section,
@@ -13305,7 +13503,19 @@ _bfd_elf_mips_get_relocated_section_contents
 	  symbol = *(*parent)->sym_ptr_ptr;
 	  /* PR ld/19628: A specially crafted input file
 	     can result in a NULL symbol pointer here.  */
-	  if (symbol == NULL)
+	  
+	  #ifdef FRCOV
+	  {if (FIXREVERTER[7707]) {
+	    if ((symbol == (void *) 0 ) && !(0))
+	      fprintf(stderr, "triggered bug index 7707\n");
+	    else
+	      fprintf(stderr, "reached bug index 7707\n");
+	  }
+	  if ((!FIXREVERTER[7707] && (symbol == (void *) 0 ))
+	  #else
+	  if (0
+	  #endif
+	  )
 	    {
 	      link_info->callbacks->einfo
 		/* xgettext:c-format */
@@ -13313,6 +13523,9 @@ _bfd_elf_mips_get_relocated_section_contents
 		 abfd, input_section, (* parent)->address);
 	      goto error_return;
 	    }
+	    #ifdef FRCOV
+	    }
+	    #endif
 
 	  /* Zap reloc field when the symbol is from a discarded
 	     section, ignoring any addend.  Do the same when called
@@ -15406,8 +15619,23 @@ mips_elf_merge_obj_e_flags (bfd *ibfd, struct bfd_link_info *info)
   if ((ibfd->flags & DYNAMIC) != 0)
     new_flags |= EF_MIPS_PIC | EF_MIPS_CPIC;
 
-  if (new_flags == old_flags)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[7722]) {
+    if ((new_flags == old_flags ) && !(0))
+      fprintf(stderr, "triggered bug index 7722\n");
+    else
+      fprintf(stderr, "reached bug index 7722\n");
+  }
+  if ((!FIXREVERTER[7722] && (new_flags == old_flags ))
+  #else
+  if (0
+  #endif
+  )
     return true;
+    #ifdef FRCOV
+    }
+    #endif
 
   ok = true;
 
@@ -15669,8 +15897,23 @@ mips_elf_merge_obj_attributes (bfd *ibfd, struct bfd_link_info *info)
 		 really relevant to the error message.  */
 	      if (in_fp == Val_GNU_MIPS_ABI_FP_SOFT)
 		out_string = "-mhard-float";
-	      else if (out_fp == Val_GNU_MIPS_ABI_FP_SOFT)
+	      else 
+	      #ifdef FRCOV
+	      {if (FIXREVERTER[7723]) {
+	        if ((out_fp == Val_GNU_MIPS_ABI_FP_SOFT ) && !(0))
+	          fprintf(stderr, "triggered bug index 7723\n");
+	        else
+	          fprintf(stderr, "reached bug index 7723\n");
+	      }
+	      if ((!FIXREVERTER[7723] && (out_fp == Val_GNU_MIPS_ABI_FP_SOFT ))
+	      #else
+	      if (0
+	      #endif
+	      )
 		in_string = "-mhard-float";
+		#ifdef FRCOV
+		}
+		#endif
 	      _bfd_error_handler
 		/* xgettext:c-format */
 		(_("warning: %pB uses %s (set by %pB), %pB uses %s"),
diff --git a/bfd/elfxx-mips.h b/bfd/elfxx-mips.h
old mode 100644
new mode 100755
diff --git a/bfd/elfxx-riscv.c b/bfd/elfxx-riscv.c
old mode 100644
new mode 100755
index 7206ec8..c68281f
--- a/bfd/elfxx-riscv.c
+++ b/bfd/elfxx-riscv.c
@@ -1,3 +1,6 @@
+#ifdef FRCOV
+extern short FIXREVERTER[];
+#endif
 /* RISC-V-specific support for ELF.
    Copyright (C) 2011-2021 Free Software Foundation, Inc.
 
@@ -1669,11 +1672,26 @@ riscv_parse_prefixed_ext (riscv_parse_subset_t *rps,
 				      &minor_version, false);
       *q = '\0';
 
-      if (end_of_version == NULL)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[10583]) {
+        if ((end_of_version == (void *) 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 10583\n");
+        else
+          fprintf(stderr, "reached bug index 10583\n");
+      }
+      if ((!FIXREVERTER[10583] && (end_of_version == (void *) 0 ))
+      #else
+      if (0
+      #endif
+      )
 	{
 	  free (subset);
 	  return NULL;
 	}
+	#ifdef FRCOV
+	}
+	#endif
 
       /* Check if the prefix extension is known.
 	 For 'x', anything goes but it cannot simply be 'x'.
@@ -1863,8 +1881,23 @@ riscv_estimate_digit (unsigned num)
 static size_t
 riscv_estimate_arch_strlen1 (const riscv_subset_t *subset)
 {
-  if (subset == NULL)
-    return 6; /* For rv32/rv64/rv128 and string terminator.  */
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[10585]) {
+    if ((subset == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 10585\n");
+    else
+      fprintf(stderr, "reached bug index 10585\n");
+  }
+  if ((!FIXREVERTER[10585] && (subset == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
+    return 6;
+    #ifdef FRCOV
+    }
+    #endif /* For rv32/rv64/rv128 and string terminator.  */
 
   return riscv_estimate_arch_strlen1 (subset->next)
 	 + strlen (subset->name)
@@ -1891,8 +1924,23 @@ riscv_arch_str1 (riscv_subset_t *subset,
   const char *underline = "_";
   riscv_subset_t *subset_t = subset;
 
-  if (subset_t == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[10586]) {
+    if ((subset_t == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 10586\n");
+    else
+      fprintf(stderr, "reached bug index 10586\n");
+  }
+  if ((!FIXREVERTER[10586] && (subset_t == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     return;
+    #ifdef FRCOV
+    }
+    #endif
 
   /* No underline between rvXX and i/e.  */
   if ((strcasecmp (subset_t->name, "i") == 0)
diff --git a/bfd/elfxx-riscv.h b/bfd/elfxx-riscv.h
old mode 100644
new mode 100755
diff --git a/bfd/elfxx-sparc.c b/bfd/elfxx-sparc.c
old mode 100644
new mode 100755
diff --git a/bfd/elfxx-sparc.h b/bfd/elfxx-sparc.h
old mode 100644
new mode 100755
diff --git a/bfd/elfxx-target.h b/bfd/elfxx-target.h
old mode 100644
new mode 100755
diff --git a/bfd/elfxx-tilegx.c b/bfd/elfxx-tilegx.c
old mode 100644
new mode 100755
diff --git a/bfd/elfxx-tilegx.h b/bfd/elfxx-tilegx.h
old mode 100644
new mode 100755
diff --git a/bfd/elfxx-x86.c b/bfd/elfxx-x86.c
old mode 100644
new mode 100755
diff --git a/bfd/elfxx-x86.h b/bfd/elfxx-x86.h
old mode 100644
new mode 100755
diff --git a/bfd/format.c b/bfd/format.c
old mode 100644
new mode 100755
index 5d08d1d..cecc620
--- a/bfd/format.c
+++ b/bfd/format.c
@@ -1,3 +1,6 @@
+#ifdef FRCOV
+extern short FIXREVERTER[];
+#endif
 /* Generic BFD support for file formats.
    Copyright (C) 1990-2021 Free Software Foundation, Inc.
    Written by Cygnus Support.
@@ -133,8 +136,23 @@ bfd_preserve_save (bfd *abfd, struct bfd_preserve *preserve,
   preserve->marker = bfd_alloc (abfd, 1);
   preserve->build_id = abfd->build_id;
   preserve->cleanup = cleanup;
-  if (preserve->marker == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[3346]) {
+    if ((preserve -> marker == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 3346\n");
+    else
+      fprintf(stderr, "reached bug index 3346\n");
+  }
+  if ((!FIXREVERTER[3346] && (preserve -> marker == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     return false;
+    #ifdef FRCOV
+    }
+    #endif
 
   return bfd_hash_table_init (&abfd->section_htab, bfd_section_hash_newfunc,
 			      sizeof (struct section_hash_entry));
diff --git a/bfd/gen-aout.c b/bfd/gen-aout.c
old mode 100644
new mode 100755
diff --git a/bfd/genlink.h b/bfd/genlink.h
old mode 100644
new mode 100755
diff --git a/bfd/go32stub.h b/bfd/go32stub.h
old mode 100644
new mode 100755
diff --git a/bfd/hash.c b/bfd/hash.c
old mode 100644
new mode 100755
index 06969fe..d27f2d5
--- a/bfd/hash.c
+++ b/bfd/hash.c
@@ -1,3 +1,6 @@
+#ifdef FRCOV
+extern short FIXREVERTER[];
+#endif
 /* hash.c -- hash table routines for BFD
    Copyright (C) 1993-2021 Free Software Foundation, Inc.
    Written by Steve Chamberlain <sac@cygnus.com>
@@ -508,8 +511,23 @@ bfd_hash_insert (struct bfd_hash_table *table,
   unsigned int _index;
 
   hashp = (*table->newfunc) (NULL, table, string);
-  if (hashp == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[3855]) {
+    if ((hashp == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 3855\n");
+    else
+      fprintf(stderr, "reached bug index 3855\n");
+  }
+  if ((!FIXREVERTER[3855] && (hashp == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     return NULL;
+    #ifdef FRCOV
+    }
+    #endif
   hashp->string = string;
   hashp->hash = hash;
   _index = hash % table->size;
@@ -534,11 +552,26 @@ bfd_hash_insert (struct bfd_hash_table *table,
 
       newtable = ((struct bfd_hash_entry **)
 		  objalloc_alloc ((struct objalloc *) table->memory, alloc));
-      if (newtable == NULL)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[3856]) {
+        if ((newtable == (void *) 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 3856\n");
+        else
+          fprintf(stderr, "reached bug index 3856\n");
+      }
+      if ((!FIXREVERTER[3856] && (newtable == (void *) 0 ))
+      #else
+      if (0
+      #endif
+      )
 	{
 	  table->frozen = 1;
 	  return hashp;
 	}
+	#ifdef FRCOV
+	}
+	#endif
       memset (newtable, 0, alloc);
 
       for (hi = 0; hi < table->size; hi ++)
@@ -633,9 +666,24 @@ bfd_hash_newfunc (struct bfd_hash_entry *entry,
 		  struct bfd_hash_table *table,
 		  const char *string ATTRIBUTE_UNUSED)
 {
-  if (entry == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[3858]) {
+    if ((entry == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 3858\n");
+    else
+      fprintf(stderr, "reached bug index 3858\n");
+  }
+  if ((!FIXREVERTER[3858] && (entry == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     entry = (struct bfd_hash_entry *) bfd_hash_allocate (table,
 							 sizeof (* entry));
+							 #ifdef FRCOV
+							 }
+							 #endif
   return entry;
 }
 
@@ -730,11 +778,41 @@ strtab_hash_newfunc (struct bfd_hash_entry *entry,
 
   /* Allocate the structure if it has not already been allocated by a
      subclass.  */
-  if (ret == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[3859]) {
+    if ((ret == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 3859\n");
+    else
+      fprintf(stderr, "reached bug index 3859\n");
+  }
+  if ((!FIXREVERTER[3859] && (ret == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     ret = (struct strtab_hash_entry *) bfd_hash_allocate (table,
 							  sizeof (* ret));
-  if (ret == NULL)
+							  #ifdef FRCOV
+							  }
+							  #endif
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[3860]) {
+    if ((ret == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 3860\n");
+    else
+      fprintf(stderr, "reached bug index 3860\n");
+  }
+  if ((!FIXREVERTER[3860] && (ret == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     return NULL;
+    #ifdef FRCOV
+    }
+    #endif
 
   /* Call the allocation method of the superclass.  */
   ret = (struct strtab_hash_entry *)
@@ -765,8 +843,23 @@ _bfd_stringtab_init (void)
   size_t amt = sizeof (* table);
 
   table = (struct bfd_strtab_hash *) bfd_malloc (amt);
-  if (table == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[3861]) {
+    if ((table == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 3861\n");
+    else
+      fprintf(stderr, "reached bug index 3861\n");
+  }
+  if ((!FIXREVERTER[3861] && (table == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     return NULL;
+    #ifdef FRCOV
+    }
+    #endif
 
   if (!bfd_hash_table_init (&table->table, strtab_hash_newfunc,
 			    sizeof (struct strtab_hash_entry)))
@@ -823,15 +916,45 @@ _bfd_stringtab_add (struct bfd_strtab_hash *tab,
   if (hash)
     {
       entry = strtab_hash_lookup (tab, str, true, copy);
-      if (entry == NULL)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[3862]) {
+        if ((entry == (void *) 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 3862\n");
+        else
+          fprintf(stderr, "reached bug index 3862\n");
+      }
+      if ((!FIXREVERTER[3862] && (entry == (void *) 0 ))
+      #else
+      if (0
+      #endif
+      )
 	return (bfd_size_type) -1;
+	#ifdef FRCOV
+	}
+	#endif
     }
   else
     {
       entry = (struct strtab_hash_entry *) bfd_hash_allocate (&tab->table,
 							      sizeof (* entry));
-      if (entry == NULL)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[3863]) {
+        if ((entry == (void *) 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 3863\n");
+        else
+          fprintf(stderr, "reached bug index 3863\n");
+      }
+      if ((!FIXREVERTER[3863] && (entry == (void *) 0 ))
+      #else
+      if (0
+      #endif
+      )
 	return (bfd_size_type) -1;
+	#ifdef FRCOV
+	}
+	#endif
       if (! copy)
 	entry->root.string = str;
       else
@@ -840,8 +963,23 @@ _bfd_stringtab_add (struct bfd_strtab_hash *tab,
 	  char *n;
 
 	  n = (char *) bfd_hash_allocate (&tab->table, len);
-	  if (n == NULL)
+	  
+	  #ifdef FRCOV
+	  {if (FIXREVERTER[3864]) {
+	    if ((n == (void *) 0 ) && !(0))
+	      fprintf(stderr, "triggered bug index 3864\n");
+	    else
+	      fprintf(stderr, "reached bug index 3864\n");
+	  }
+	  if ((!FIXREVERTER[3864] && (n == (void *) 0 ))
+	  #else
+	  if (0
+	  #endif
+	  )
 	    return (bfd_size_type) -1;
+	    #ifdef FRCOV
+	    }
+	    #endif
 	  memcpy (n, str, len);
 	  entry->root.string = n;
 	}
diff --git a/bfd/host-aout.c b/bfd/host-aout.c
old mode 100644
new mode 100755
diff --git a/bfd/hosts/alphalinux.h b/bfd/hosts/alphalinux.h
old mode 100644
new mode 100755
diff --git a/bfd/hosts/alphavms.h b/bfd/hosts/alphavms.h
old mode 100644
new mode 100755
diff --git a/bfd/hosts/decstation.h b/bfd/hosts/decstation.h
old mode 100644
new mode 100755
diff --git a/bfd/hosts/dpx2.h b/bfd/hosts/dpx2.h
old mode 100644
new mode 100755
diff --git a/bfd/hosts/i386bsd.h b/bfd/hosts/i386bsd.h
old mode 100644
new mode 100755
diff --git a/bfd/hosts/i386linux.h b/bfd/hosts/i386linux.h
old mode 100644
new mode 100755
diff --git a/bfd/hosts/i386mach3.h b/bfd/hosts/i386mach3.h
old mode 100644
new mode 100755
diff --git a/bfd/hosts/i386sco.h b/bfd/hosts/i386sco.h
old mode 100644
new mode 100755
diff --git a/bfd/hosts/m68klinux.h b/bfd/hosts/m68klinux.h
old mode 100644
new mode 100755
diff --git a/bfd/hosts/mipsbsd.h b/bfd/hosts/mipsbsd.h
old mode 100644
new mode 100755
diff --git a/bfd/hosts/mipsmach3.h b/bfd/hosts/mipsmach3.h
old mode 100644
new mode 100755
diff --git a/bfd/hosts/news-mips.h b/bfd/hosts/news-mips.h
old mode 100644
new mode 100755
diff --git a/bfd/hosts/pc532mach.h b/bfd/hosts/pc532mach.h
old mode 100644
new mode 100755
diff --git a/bfd/hosts/riscos.h b/bfd/hosts/riscos.h
old mode 100644
new mode 100755
diff --git a/bfd/hosts/symmetry.h b/bfd/hosts/symmetry.h
old mode 100644
new mode 100755
diff --git a/bfd/hosts/vaxbsd.h b/bfd/hosts/vaxbsd.h
old mode 100644
new mode 100755
diff --git a/bfd/hosts/vaxlinux.h b/bfd/hosts/vaxlinux.h
old mode 100644
new mode 100755
diff --git a/bfd/hosts/vaxult.h b/bfd/hosts/vaxult.h
old mode 100644
new mode 100755
diff --git a/bfd/hosts/vaxult2.h b/bfd/hosts/vaxult2.h
old mode 100644
new mode 100755
diff --git a/bfd/hosts/x86-64linux.h b/bfd/hosts/x86-64linux.h
old mode 100644
new mode 100755
diff --git a/bfd/hppabsd-core.c b/bfd/hppabsd-core.c
old mode 100644
new mode 100755
diff --git a/bfd/hpux-core.c b/bfd/hpux-core.c
old mode 100644
new mode 100755
diff --git a/bfd/i386aout.c b/bfd/i386aout.c
old mode 100644
new mode 100755
diff --git a/bfd/i386bsd.c b/bfd/i386bsd.c
old mode 100644
new mode 100755
diff --git a/bfd/i386lynx.c b/bfd/i386lynx.c
old mode 100644
new mode 100755
diff --git a/bfd/i386msdos.c b/bfd/i386msdos.c
old mode 100644
new mode 100755
diff --git a/bfd/ihex.c b/bfd/ihex.c
old mode 100644
new mode 100755
diff --git a/bfd/init.c b/bfd/init.c
old mode 100644
new mode 100755
diff --git a/bfd/irix-core.c b/bfd/irix-core.c
old mode 100644
new mode 100755
diff --git a/bfd/libaout.h b/bfd/libaout.h
old mode 100644
new mode 100755
diff --git a/bfd/libbfd-in.h b/bfd/libbfd-in.h
old mode 100644
new mode 100755
diff --git a/bfd/libbfd.c b/bfd/libbfd.c
old mode 100644
new mode 100755
index 892f291..e4d7bb0
--- a/bfd/libbfd.c
+++ b/bfd/libbfd.c
@@ -1,3 +1,6 @@
+#ifdef FRCOV
+extern short FIXREVERTER[];
+#endif
 /* Assorted BFD support routines, only used internally.
    Copyright (C) 1990-2021 Free Software Foundation, Inc.
    Written by Cygnus Support.
@@ -322,8 +325,23 @@ bfd_realloc (void *ptr, bfd_size_type size)
   void *ret;
   size_t sz = (size_t) size;
 
-  if (ptr == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[1951]) {
+    if ((ptr == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 1951\n");
+    else
+      fprintf(stderr, "reached bug index 1951\n");
+  }
+  if ((!FIXREVERTER[1951] && (ptr == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     return bfd_malloc (size);
+    #ifdef FRCOV
+    }
+    #endif
 
   if (size != sz
       /* This is to pacify memory checkers like valgrind.  */
diff --git a/bfd/libbfd.h b/bfd/libbfd.h
old mode 100644
new mode 100755
diff --git a/bfd/libcoff-in.h b/bfd/libcoff-in.h
old mode 100644
new mode 100755
diff --git a/bfd/libcoff.h b/bfd/libcoff.h
old mode 100644
new mode 100755
diff --git a/bfd/libecoff.h b/bfd/libecoff.h
old mode 100644
new mode 100755
diff --git a/bfd/libhppa.h b/bfd/libhppa.h
old mode 100644
new mode 100755
diff --git a/bfd/libpei.h b/bfd/libpei.h
old mode 100644
new mode 100755
diff --git a/bfd/libxcoff.h b/bfd/libxcoff.h
old mode 100644
new mode 100755
diff --git a/bfd/linker.c b/bfd/linker.c
old mode 100644
new mode 100755
index c350cd3..665f5e4
--- a/bfd/linker.c
+++ b/bfd/linker.c
@@ -1,3 +1,6 @@
+#ifdef FRCOV
+extern short FIXREVERTER[];
+#endif
 /* linker.c -- BFD linker routines
    Copyright (C) 1993-2021 Free Software Foundation, Inc.
    Written by Steve Chamberlain and Ian Lance Taylor, Cygnus Support
@@ -434,8 +437,23 @@ _bfd_link_hash_newfunc (struct bfd_hash_entry *entry,
     {
       entry = (struct bfd_hash_entry *)
 	  bfd_hash_allocate (table, sizeof (struct bfd_link_hash_entry));
-      if (entry == NULL)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[4035]) {
+        if ((entry == (void *) 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 4035\n");
+        else
+          fprintf(stderr, "reached bug index 4035\n");
+      }
+      if ((!FIXREVERTER[4035] && (entry == (void *) 0 ))
+      #else
+      if (0
+      #endif
+      )
 	return entry;
+	#ifdef FRCOV
+	}
+	#endif
     }
 
   /* Call the allocation method of the superclass.  */
@@ -508,8 +526,23 @@ bfd_link_hash_lookup (struct bfd_link_hash_table *table,
 {
   struct bfd_link_hash_entry *ret;
 
-  if (table == NULL || string == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[4036]) {
+    if ((table == (void *) 0 || string == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 4036\n");
+    else
+      fprintf(stderr, "reached bug index 4036\n");
+  }
+  if ((!FIXREVERTER[4036] && (table == (void *) 0 || string == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     return NULL;
+    #ifdef FRCOV
+    }
+    #endif
 
   ret = ((struct bfd_link_hash_entry *)
 	 bfd_hash_lookup (&table->table, string, create, copy));
@@ -563,8 +596,23 @@ bfd_wrapped_link_hash_lookup (bfd *abfd,
 
 	  amt = strlen (l) + sizeof WRAP + 1;
 	  n = (char *) bfd_malloc (amt);
-	  if (n == NULL)
+	  
+	  #ifdef FRCOV
+	  {if (FIXREVERTER[4037]) {
+	    if ((n == (void *) 0 ) && !(0))
+	      fprintf(stderr, "triggered bug index 4037\n");
+	    else
+	      fprintf(stderr, "reached bug index 4037\n");
+	  }
+	  if ((!FIXREVERTER[4037] && (n == (void *) 0 ))
+	  #else
+	  if (0
+	  #endif
+	  )
 	    return NULL;
+	    #ifdef FRCOV
+	    }
+	    #endif
 
 	  n[0] = prefix;
 	  n[1] = '\0';
@@ -592,8 +640,23 @@ bfd_wrapped_link_hash_lookup (bfd *abfd,
 
 	  amt = strlen (l + sizeof REAL - 1) + 2;
 	  n = (char *) bfd_malloc (amt);
-	  if (n == NULL)
+	  
+	  #ifdef FRCOV
+	  {if (FIXREVERTER[4038]) {
+	    if ((n == (void *) 0 ) && !(0))
+	      fprintf(stderr, "triggered bug index 4038\n");
+	    else
+	      fprintf(stderr, "reached bug index 4038\n");
+	  }
+	  if ((!FIXREVERTER[4038] && (n == (void *) 0 ))
+	  #else
+	  if (0
+	  #endif
+	  )
 	    return NULL;
+	    #ifdef FRCOV
+	    }
+	    #endif
 
 	  n[0] = prefix;
 	  n[1] = '\0';
@@ -1111,8 +1174,23 @@ generic_link_check_archive_element (bfd *abfd,
 	  h->u.c.size = size;
 
 	  power = bfd_log2 (size);
-	  if (power > 4)
+	  
+	  #ifdef FRCOV
+	  {if (FIXREVERTER[4042]) {
+	    if ((power > 4 ) && !(0))
+	      fprintf(stderr, "triggered bug index 4042\n");
+	    else
+	      fprintf(stderr, "reached bug index 4042\n");
+	  }
+	  if ((!FIXREVERTER[4042] && (power > 4 ))
+	  #else
+	  if (0
+	  #endif
+	  )
 	    power = 4;
+	    #ifdef FRCOV
+	    }
+	    #endif
 	  h->u.c.p->alignment_power = power;
 
 	  if (p->section == bfd_com_section_ptr)
@@ -1965,8 +2043,23 @@ generic_add_output_symbol (bfd *output_bfd, size_t *psymalloc, asymbol *sym)
       amt = *psymalloc;
       amt *= sizeof (asymbol *);
       newsyms = (asymbol **) bfd_realloc (bfd_get_outsymbols (output_bfd), amt);
-      if (newsyms == NULL)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[4044]) {
+        if ((newsyms == (void *) 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 4044\n");
+        else
+          fprintf(stderr, "reached bug index 4044\n");
+      }
+      if ((!FIXREVERTER[4044] && (newsyms == (void *) 0 ))
+      #else
+      if (0
+      #endif
+      )
 	return false;
+	#ifdef FRCOV
+	}
+	#endif
       output_bfd->outsymbols = newsyms;
     }
 
@@ -2492,8 +2585,23 @@ default_data_link_order (bfd *abfd,
   BFD_ASSERT ((sec->flags & SEC_HAS_CONTENTS) != 0);
 
   size = link_order->size;
-  if (size == 0)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[4045]) {
+    if ((size == 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 4045\n");
+    else
+      fprintf(stderr, "reached bug index 4045\n");
+  }
+  if ((!FIXREVERTER[4045] && (size == 0 ))
+  #else
+  if (0
+  #endif
+  )
     return true;
+    #ifdef FRCOV
+    }
+    #endif
 
   fill = link_order->u.data.contents;
   fill_size = link_order->u.data.size;
@@ -2501,15 +2609,45 @@ default_data_link_order (bfd *abfd,
     {
       fill = abfd->arch_info->fill (size, info->big_endian,
 				    (sec->flags & SEC_CODE) != 0);
-      if (fill == NULL)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[4046]) {
+        if ((fill == (void *) 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 4046\n");
+        else
+          fprintf(stderr, "reached bug index 4046\n");
+      }
+      if ((!FIXREVERTER[4046] && (fill == (void *) 0 ))
+      #else
+      if (0
+      #endif
+      )
 	return false;
+	#ifdef FRCOV
+	}
+	#endif
     }
   else if (fill_size < size)
     {
       bfd_byte *p;
       fill = (bfd_byte *) bfd_malloc (size);
-      if (fill == NULL)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[4047]) {
+        if ((fill == (void *) 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 4047\n");
+        else
+          fprintf(stderr, "reached bug index 4047\n");
+      }
+      if ((!FIXREVERTER[4047] && (fill == (void *) 0 ))
+      #else
+      if (0
+      #endif
+      )
 	return false;
+	#ifdef FRCOV
+	}
+	#endif
       p = fill;
       if (fill_size == 1)
 	memset (p, (int) link_order->u.data.contents[0], (size_t) size);
@@ -2997,8 +3135,23 @@ _bfd_nearby_section (bfd *obfd, asection *s, bfd_vma addr)
   best = next;
   if (prev == NULL)
     {
-      if (next == NULL)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[4050]) {
+        if ((next == (void *) 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 4050\n");
+        else
+          fprintf(stderr, "reached bug index 4050\n");
+      }
+      if ((!FIXREVERTER[4050] && (next == (void *) 0 ))
+      #else
+      if (0
+      #endif
+      )
 	best = bfd_abs_section_ptr;
+	#ifdef FRCOV
+	}
+	#endif
     }
   else if (next == NULL)
     best = prev;
@@ -3029,8 +3182,23 @@ _bfd_nearby_section (bfd *obfd, asection *s, bfd_vma addr)
     {
       /* Flags we care about are the same.  Prefer the following
 	 section if that will result in a positive valued sym.  */
-      if (addr < next->vma)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[4051]) {
+        if ((addr < next -> vma ) && !(0))
+          fprintf(stderr, "triggered bug index 4051\n");
+        else
+          fprintf(stderr, "reached bug index 4051\n");
+      }
+      if ((!FIXREVERTER[4051] && (addr < next -> vma ))
+      #else
+      if (0
+      #endif
+      )
 	best = prev;
+	#ifdef FRCOV
+	}
+	#endif
     }
 
   return best;
@@ -3293,8 +3461,23 @@ bfd_find_version_for_sym (struct bfd_elf_version_tree *verdefs,
       return global_ver;
     }
 
-  if (local_ver == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[4053]) {
+    if ((local_ver == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 4053\n");
+    else
+      fprintf(stderr, "reached bug index 4053\n");
+  }
+  if ((!FIXREVERTER[4053] && (local_ver == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     local_ver = star_local_ver;
+    #ifdef FRCOV
+    }
+    #endif
 
   if (local_ver != NULL)
     {
diff --git a/bfd/lynx-core.c b/bfd/lynx-core.c
old mode 100644
new mode 100755
diff --git a/bfd/mach-o-aarch64.c b/bfd/mach-o-aarch64.c
old mode 100644
new mode 100755
diff --git a/bfd/mach-o-arm.c b/bfd/mach-o-arm.c
old mode 100644
new mode 100755
diff --git a/bfd/mach-o-i386.c b/bfd/mach-o-i386.c
old mode 100644
new mode 100755
diff --git a/bfd/mach-o-target.c b/bfd/mach-o-target.c
old mode 100644
new mode 100755
diff --git a/bfd/mach-o-x86-64.c b/bfd/mach-o-x86-64.c
old mode 100644
new mode 100755
diff --git a/bfd/mach-o.c b/bfd/mach-o.c
old mode 100644
new mode 100755
index ff18ded..0c2ccd4
--- a/bfd/mach-o.c
+++ b/bfd/mach-o.c
@@ -1,3 +1,6 @@
+#ifdef FRCOV
+extern short FIXREVERTER[];
+#endif
 /* Mach-O support for BFD.
    Copyright (C) 1999-2021 Free Software Foundation, Inc.
 
@@ -392,8 +395,23 @@ bfd_mach_o_convert_section_name_to_bfd (bfd *abfd, const char *segname,
     {
       len = strlen (xlat->bfd_name);
       res = bfd_alloc (abfd, len + 1);
-      if (res == NULL)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[1057]) {
+        if ((res == (void *) 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 1057\n");
+        else
+          fprintf(stderr, "reached bug index 1057\n");
+      }
+      if ((!FIXREVERTER[1057] && (res == (void *) 0 ))
+      #else
+      if (0
+      #endif
+      )
 	return;
+	#ifdef FRCOV
+	}
+	#endif
       memcpy (res, xlat->bfd_name, len+1);
       *name = res;
       *flags = xlat->bfd_flags;
@@ -416,8 +434,23 @@ bfd_mach_o_convert_section_name_to_bfd (bfd *abfd, const char *segname,
     }
 
   res = bfd_alloc (abfd, len);
-  if (res == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[1060]) {
+    if ((res == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 1060\n");
+    else
+      fprintf(stderr, "reached bug index 1060\n");
+  }
+  if ((!FIXREVERTER[1060] && (res == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     return;
+    #ifdef FRCOV
+    }
+    #endif
   snprintf (res, len, "%s%.16s.%.16s", pfx, segname, secname);
   *name = res;
 }
@@ -488,8 +521,23 @@ bfd_mach_o_convert_section_name_to_mach_o (bfd *abfd ATTRIBUTE_UNUSED,
     return NULL;
 
   /* Just duplicate the name into both segment and section.  */
-  if (len > 16)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[1063]) {
+    if ((len > 16 ) && !(0))
+      fprintf(stderr, "triggered bug index 1063\n");
+    else
+      fprintf(stderr, "reached bug index 1063\n");
+  }
+  if ((!FIXREVERTER[1063] && (len > 16 ))
+  #else
+  if (0
+  #endif
+  )
     len = 16;
+    #ifdef FRCOV
+    }
+    #endif
   memcpy (section->segname, name, len);
   section->segname[len] = 0;
   memcpy (section->sectname, name, len);
@@ -875,8 +923,23 @@ bfd_mach_o_count_symbols (bfd *abfd)
 {
   bfd_mach_o_data_struct *mdata = bfd_mach_o_get_data (abfd);
 
-  if (mdata->symtab == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[1067]) {
+    if ((mdata -> symtab == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 1067\n");
+    else
+      fprintf(stderr, "reached bug index 1067\n");
+  }
+  if ((!FIXREVERTER[1067] && (mdata -> symtab == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     return 0;
+    #ifdef FRCOV
+    }
+    #endif
   return mdata->symtab->nsyms;
 }
 
@@ -896,15 +959,45 @@ bfd_mach_o_canonicalize_symtab (bfd *abfd, asymbol **alocation)
   bfd_mach_o_symtab_command *sym = mdata->symtab;
   unsigned long j;
 
-  if (nsyms < 0)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[1068]) {
+    if ((nsyms < 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 1068\n");
+    else
+      fprintf(stderr, "reached bug index 1068\n");
+  }
+  if ((!FIXREVERTER[1068] && (nsyms < 0 ))
+  #else
+  if (0
+  #endif
+  )
     return nsyms;
+    #ifdef FRCOV
+    }
+    #endif
 
-  if (nsyms == 0)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[1069]) {
+    if ((nsyms == 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 1069\n");
+    else
+      fprintf(stderr, "reached bug index 1069\n");
+  }
+  if ((!FIXREVERTER[1069] && (nsyms == 0 ))
+  #else
+  if (0
+  #endif
+  )
     {
       /* Do not try to read symbols if there are none.  */
       alocation[0] = NULL;
       return 0;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
   if (!bfd_mach_o_read_symtab_symbols (abfd))
     {
@@ -1624,8 +1717,23 @@ bfd_mach_o_canonicalize_relocs (bfd *abfd, unsigned long filepos,
     return -1;
   native_relocs = (struct mach_o_reloc_info_external *)
     _bfd_malloc_and_read (abfd, native_size, native_size);
-  if (native_relocs == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[1079]) {
+    if ((native_relocs == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 1079\n");
+    else
+      fprintf(stderr, "reached bug index 1079\n");
+  }
+  if ((!FIXREVERTER[1079] && (native_relocs == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     return -1;
+    #ifdef FRCOV
+    }
+    #endif
 
   for (i = 0; i < count; i++)
     {
@@ -1651,12 +1759,42 @@ bfd_mach_o_canonicalize_reloc (bfd *abfd, asection *asect,
   unsigned long i;
   arelent *res;
 
-  if (asect->reloc_count == 0)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[1080]) {
+    if ((asect -> reloc_count == 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 1080\n");
+    else
+      fprintf(stderr, "reached bug index 1080\n");
+  }
+  if ((!FIXREVERTER[1080] && (asect -> reloc_count == 0 ))
+  #else
+  if (0
+  #endif
+  )
     return 0;
+    #ifdef FRCOV
+    }
+    #endif
 
   /* No need to go further if we don't know how to read relocs.  */
-  if (bed->_bfd_mach_o_canonicalize_one_reloc == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[1081]) {
+    if ((bed -> _bfd_mach_o_canonicalize_one_reloc == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 1081\n");
+    else
+      fprintf(stderr, "reached bug index 1081\n");
+  }
+  if ((!FIXREVERTER[1081] && (bed -> _bfd_mach_o_canonicalize_one_reloc == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     return 0;
+    #ifdef FRCOV
+    }
+    #endif
 
   if (asect->relocation == NULL)
     {
@@ -1665,8 +1803,23 @@ bfd_mach_o_canonicalize_reloc (bfd *abfd, asection *asect,
       if (_bfd_mul_overflow (asect->reloc_count, sizeof (arelent), &amt))
 	return -1;
       res = bfd_malloc (amt);
-      if (res == NULL)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[1082]) {
+        if ((res == (void *) 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 1082\n");
+        else
+          fprintf(stderr, "reached bug index 1082\n");
+      }
+      if ((!FIXREVERTER[1082] && (res == (void *) 0 ))
+      #else
+      if (0
+      #endif
+      )
 	return -1;
+	#ifdef FRCOV
+	}
+	#endif
 
       if (bfd_mach_o_canonicalize_relocs (abfd, asect->rel_filepos,
 					  asect->reloc_count, res, syms) < 0)
@@ -1690,8 +1843,23 @@ bfd_mach_o_get_dynamic_reloc_upper_bound (bfd *abfd)
 {
   bfd_mach_o_data_struct *mdata = bfd_mach_o_get_data (abfd);
 
-  if (mdata->dysymtab == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[1083]) {
+    if ((mdata -> dysymtab == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 1083\n");
+    else
+      fprintf(stderr, "reached bug index 1083\n");
+  }
+  if ((!FIXREVERTER[1083] && (mdata -> dysymtab == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     return 1;
+    #ifdef FRCOV
+    }
+    #endif
   return (mdata->dysymtab->nextrel + mdata->dysymtab->nlocrel + 1)
     * sizeof (arelent *);
 }
@@ -1813,8 +1981,23 @@ bfd_mach_o_write_relocs (bfd *abfd, bfd_mach_o_section *section)
   bfd_mach_o_backend_data *bed = bfd_mach_o_get_backend_data (abfd);
 
   sec = section->bfdsection;
-  if (sec->reloc_count == 0)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[1087]) {
+    if ((sec -> reloc_count == 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 1087\n");
+    else
+      fprintf(stderr, "reached bug index 1087\n");
+  }
+  if ((!FIXREVERTER[1087] && (sec -> reloc_count == 0 ))
+  #else
+  if (0
+  #endif
+  )
     return true;
+    #ifdef FRCOV
+    }
+    #endif
 
   if (bed->_bfd_mach_o_swap_reloc_out == NULL)
     return true;
@@ -1994,8 +2177,23 @@ bfd_mach_o_write_symtab_content (bfd *abfd, bfd_mach_o_symtab_command *sym)
     return false;
 
   strtab = _bfd_stringtab_init ();
-  if (strtab == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[1095]) {
+    if ((strtab == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 1095\n");
+    else
+      fprintf(stderr, "reached bug index 1095\n");
+  }
+  if ((!FIXREVERTER[1095] && (strtab == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     return false;
+    #ifdef FRCOV
+    }
+    #endif
 
   if (sym->nsyms > 0)
     /* Although we don't strictly need to do this, for compatibility with
@@ -2060,8 +2258,23 @@ bfd_mach_o_write_symtab_content (bfd *abfd, bfd_mach_o_symtab_command *sym)
 
   /* Pad string table.  */
   padlen = bfd_mach_o_pad4 (abfd, sym->strsize);
-  if (padlen < 0)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[1096]) {
+    if ((padlen < 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 1096\n");
+    else
+      fprintf(stderr, "reached bug index 1096\n");
+  }
+  if ((!FIXREVERTER[1096] && (padlen < 0 ))
+  #else
+  if (0
+  #endif
+  )
     return false;
+    #ifdef FRCOV
+    }
+    #endif
   mdata->filelen += padlen;
   sym->strsize += padlen;
 
@@ -2131,14 +2344,27 @@ bfd_mach_o_build_dysymtab (bfd *abfd, bfd_mach_o_dysymtab_command *cmd)
   /* TODO:
      We are not going to try and fill these in yet and, moreover, we are
      going to bail if they are already set.  */
-  if (cmd->nmodtab != 0
-      || cmd->ntoc != 0
-      || cmd->nextrefsyms != 0)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[1097]) {
+    if ((cmd -> nmodtab != 0 || cmd -> ntoc != 0 || cmd -> nextrefsyms != 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 1097\n");
+    else
+      fprintf(stderr, "reached bug index 1097\n");
+  }
+  if ((!FIXREVERTER[1097] && (cmd -> nmodtab != 0 || cmd -> ntoc != 0 || cmd -> nextrefsyms != 0 ))
+  #else
+  if (0
+  #endif
+  )
     {
       _bfd_error_handler (_("sorry: modtab, toc and extrefsyms are not yet"
 			    " implemented for dysymtab commands."));
       return false;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
   cmd->ilocalsym = 0;
 
@@ -2191,8 +2417,23 @@ bfd_mach_o_build_dysymtab (bfd *abfd, bfd_mach_o_dysymtab_command *cmd)
       mdata->filelen += amt;
 
       cmd->indirect_syms = bfd_zalloc (abfd, amt);
-      if (cmd->indirect_syms == NULL)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[1098]) {
+        if ((cmd -> indirect_syms == (void *) 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 1098\n");
+        else
+          fprintf(stderr, "reached bug index 1098\n");
+      }
+      if ((!FIXREVERTER[1098] && (cmd -> indirect_syms == (void *) 0 ))
+      #else
+      if (0
+      #endif
+      )
 	return false;
+	#ifdef FRCOV
+	}
+	#endif
 
       n = 0;
       for (i = 0; i < mdata->nsects; ++i)
@@ -2209,8 +2450,23 @@ bfd_mach_o_build_dysymtab (bfd *abfd, bfd_mach_o_dysymtab_command *cmd)
 		  bfd_mach_o_asymbol **isyms = sec->indirect_syms;
 
 		  num = bfd_mach_o_section_get_nbr_indirect (abfd, sec);
-		  if (isyms == NULL || num == 0)
+		  
+		  #ifdef FRCOV
+		  {if (FIXREVERTER[1099]) {
+		    if ((isyms == (void *) 0 ) && !(num == 0 ))
+		      fprintf(stderr, "triggered bug index 1099\n");
+		    else
+		      fprintf(stderr, "reached bug index 1099\n");
+		  }
+		  if ((FIXREVERTER[1099] && (num == 0 )) || (!FIXREVERTER[1099] && (isyms == (void *) 0 || num == 0 ))
+		  #else
+		  if (num == 0 
+		  #endif
+		  )
 		    break;
+		    #ifdef FRCOV
+		    }
+		    #endif
 		  /* Record the starting index in the reserved1 field.  */
 		  sec->reserved1 = n;
 		  for (j = 0; j < num; j++, n++)
@@ -2494,8 +2750,23 @@ bfd_mach_o_mangle_symbols (bfd *abfd)
   unsigned long i;
   asymbol **symbols = bfd_get_outsymbols (abfd);
 
-  if (symbols == NULL || bfd_get_symcount (abfd) == 0)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[1106]) {
+    if ((symbols == (void *) 0 ) && !(bfd_get_symcount ( abfd ) == 0 ))
+      fprintf(stderr, "triggered bug index 1106\n");
+    else
+      fprintf(stderr, "reached bug index 1106\n");
+  }
+  if ((FIXREVERTER[1106] && (bfd_get_symcount ( abfd ) == 0 )) || (!FIXREVERTER[1106] && (symbols == (void *) 0 || bfd_get_symcount ( abfd ) == 0 ))
+  #else
+  if (bfd_get_symcount ( abfd ) == 0 
+  #endif
+  )
     return true;
+    #ifdef FRCOV
+    }
+    #endif
 
   for (i = 0; i < bfd_get_symcount (abfd); i++)
     {
@@ -2581,18 +2852,48 @@ bfd_mach_o_mangle_sections (bfd *abfd, bfd_mach_o_data_struct *mdata)
     return true;
 
   /* We need to check that this can be done...  */
-  if (nsect > 255)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[1107]) {
+    if ((nsect > 255 ) && !(0))
+      fprintf(stderr, "triggered bug index 1107\n");
+    else
+      fprintf(stderr, "reached bug index 1107\n");
+  }
+  if ((!FIXREVERTER[1107] && (nsect > 255 ))
+  #else
+  if (0
+  #endif
+  )
     {
       _bfd_error_handler (_("mach-o: there are too many sections (%u)"
 			    " maximum is 255,\n"), nsect);
       return false;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
   mdata->nsects = nsect;
   amt = mdata->nsects * sizeof (bfd_mach_o_section *);
   mdata->sections = bfd_alloc (abfd, amt);
-  if (mdata->sections == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[1108]) {
+    if ((mdata -> sections == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 1108\n");
+    else
+      fprintf(stderr, "reached bug index 1108\n");
+  }
+  if ((!FIXREVERTER[1108] && (mdata -> sections == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     return false;
+    #ifdef FRCOV
+    }
+    #endif
 
   /* Create Mach-O sections.
      Section type, attribute and align should have been set when the
@@ -2932,12 +3233,27 @@ bfd_mach_o_build_obj_seg_command (bfd *abfd, bfd_mach_o_segment_command *seg)
       asection *sec = ms->bfdsection;
 
       ms->nreloc = sec->reloc_count;
-      if (ms->nreloc == 0)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[1109]) {
+        if ((ms -> nreloc == 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 1109\n");
+        else
+          fprintf(stderr, "reached bug index 1109\n");
+      }
+      if ((!FIXREVERTER[1109] && (ms -> nreloc == 0 ))
+      #else
+      if (0
+      #endif
+      )
 	{
 	  /* Clear nreloc and reloff if there is no relocs.  */
 	  ms->reloff = 0;
 	  continue;
 	}
+	#ifdef FRCOV
+	}
+	#endif
       sec->rel_filepos = mdata->filelen;
       ms->reloff = sec->rel_filepos;
       mdata->filelen += sec->reloc_count * BFD_MACH_O_RELENT_SIZE;
@@ -2975,7 +3291,19 @@ bfd_mach_o_build_exec_seg_command (bfd *abfd, bfd_mach_o_segment_command *seg)
 
       bfd_mach_o_append_section_to_segment (seg, s);
 
-      if (s->addr < vma)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[1110]) {
+        if ((s -> addr < vma ) && !(0))
+          fprintf(stderr, "triggered bug index 1110\n");
+        else
+          fprintf(stderr, "reached bug index 1110\n");
+      }
+      if ((!FIXREVERTER[1110] && (s -> addr < vma ))
+      #else
+      if (0
+      #endif
+      )
 	{
 	  _bfd_error_handler
 	    /* xgettext:c-format */
@@ -2984,6 +3312,9 @@ bfd_mach_o_build_exec_seg_command (bfd *abfd, bfd_mach_o_segment_command *seg)
 	       (uint64_t) s->addr, (uint64_t) vma);
 	  return false;
 	}
+	#ifdef FRCOV
+	}
+	#endif
 
       vma = s->addr + s->size;
     }
@@ -3439,8 +3770,23 @@ bfd_mach_o_make_empty_symbol (bfd *abfd)
   asymbol *new_symbol;
 
   new_symbol = bfd_zalloc (abfd, sizeof (bfd_mach_o_asymbol));
-  if (new_symbol == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[1111]) {
+    if ((new_symbol == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 1111\n");
+    else
+      fprintf(stderr, "reached bug index 1111\n");
+  }
+  if ((!FIXREVERTER[1111] && (new_symbol == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     return new_symbol;
+    #ifdef FRCOV
+    }
+    #endif
   new_symbol->the_bfd = abfd;
   new_symbol->udata.i = SYM_MACHO_FIELDS_UNSET;
   return new_symbol;
@@ -3622,8 +3968,23 @@ bfd_mach_o_make_bfd_section (bfd *abfd,
 
   bfd_mach_o_convert_section_name_to_bfd
     (abfd, (const char *)segname, (const char *)sectname, &sname, &flags);
-  if (sname == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[1112]) {
+    if ((sname == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 1112\n");
+    else
+      fprintf(stderr, "reached bug index 1112\n");
+  }
+  if ((!FIXREVERTER[1112] && (sname == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     return NULL;
+    #ifdef FRCOV
+    }
+    #endif
 
   return bfd_make_section_anyway_with_flags (abfd, sname, flags);
 }
@@ -3640,8 +4001,23 @@ bfd_mach_o_read_section_32 (bfd *abfd, unsigned long prot)
     return NULL;
 
   sec = bfd_mach_o_make_bfd_section (abfd, raw.segname, raw.sectname);
-  if (sec == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[1113]) {
+    if ((sec == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 1113\n");
+    else
+      fprintf(stderr, "reached bug index 1113\n");
+  }
+  if ((!FIXREVERTER[1113] && (sec == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     return NULL;
+    #ifdef FRCOV
+    }
+    #endif
 
   section = bfd_mach_o_get_mach_o_section (sec);
   memcpy (section->segname, raw.segname, sizeof (raw.segname));
@@ -3684,8 +4060,23 @@ bfd_mach_o_read_section_64 (bfd *abfd, unsigned long prot)
     return NULL;
 
   sec = bfd_mach_o_make_bfd_section (abfd, raw.segname, raw.sectname);
-  if (sec == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[1114]) {
+    if ((sec == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 1114\n");
+    else
+      fprintf(stderr, "reached bug index 1114\n");
+  }
+  if ((!FIXREVERTER[1114] && (sec == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     return NULL;
+    #ifdef FRCOV
+    }
+    #endif
 
   section = bfd_mach_o_get_mach_o_section (sec);
   memcpy (section->segname, raw.segname, sizeof (raw.segname));
@@ -3765,7 +4156,19 @@ bfd_mach_o_read_symtab_symbol (bfd *abfd,
   else
     value = bfd_h_get_32 (abfd, raw.n_value);
 
-  if (stroff >= sym->strsize)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[1115]) {
+    if ((stroff >= sym -> strsize ) && !(0))
+      fprintf(stderr, "triggered bug index 1115\n");
+    else
+      fprintf(stderr, "reached bug index 1115\n");
+  }
+  if ((!FIXREVERTER[1115] && (stroff >= sym -> strsize ))
+  #else
+  if (0
+  #endif
+  )
     {
       _bfd_error_handler
 	/* xgettext:c-format */
@@ -3774,6 +4177,9 @@ bfd_mach_o_read_symtab_symbol (bfd *abfd,
 	 sym->strsize);
       return false;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
   s->symbol.the_bfd = abfd;
   s->symbol.name = sym->strtab + stroff;
@@ -4033,14 +4439,44 @@ bfd_mach_o_read_dylinker (bfd *abfd, bfd_mach_o_load_command *command)
   unsigned int nameoff;
   unsigned int namelen;
 
-  if (command->len < sizeof (raw) + 8)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[1116]) {
+    if ((command -> len < sizeof ( raw ) + 8 ) && !(0))
+      fprintf(stderr, "triggered bug index 1116\n");
+    else
+      fprintf(stderr, "reached bug index 1116\n");
+  }
+  if ((!FIXREVERTER[1116] && (command -> len < sizeof ( raw ) + 8 ))
+  #else
+  if (0
+  #endif
+  )
     return false;
+    #ifdef FRCOV
+    }
+    #endif
   if (bfd_bread (&raw, sizeof (raw), abfd) != sizeof (raw))
     return false;
 
   nameoff = bfd_h_get_32 (abfd, raw.str);
-  if (nameoff > command->len)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[1117]) {
+    if ((nameoff > command -> len ) && !(0))
+      fprintf(stderr, "triggered bug index 1117\n");
+    else
+      fprintf(stderr, "reached bug index 1117\n");
+  }
+  if ((!FIXREVERTER[1117] && (nameoff > command -> len ))
+  #else
+  if (0
+  #endif
+  )
     return false;
+    #ifdef FRCOV
+    }
+    #endif
 
   cmd->name_offset = nameoff;
   namelen = command->len - nameoff;
@@ -4059,8 +4495,23 @@ bfd_mach_o_read_dylib (bfd *abfd, bfd_mach_o_load_command *command)
   unsigned int namelen;
   file_ptr pos;
 
-  if (command->len < sizeof (raw) + 8)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[1118]) {
+    if ((command -> len < sizeof ( raw ) + 8 ) && !(0))
+      fprintf(stderr, "triggered bug index 1118\n");
+    else
+      fprintf(stderr, "reached bug index 1118\n");
+  }
+  if ((!FIXREVERTER[1118] && (command -> len < sizeof ( raw ) + 8 ))
+  #else
+  if (0
+  #endif
+  )
     return false;
+    #ifdef FRCOV
+    }
+    #endif
   switch (command->type)
     {
     case BFD_MACH_O_LC_LOAD_DYLIB:
@@ -4079,8 +4530,23 @@ bfd_mach_o_read_dylib (bfd *abfd, bfd_mach_o_load_command *command)
     return false;
 
   nameoff = bfd_h_get_32 (abfd, raw.name);
-  if (nameoff > command->len)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[1119]) {
+    if ((nameoff > command -> len ) && !(0))
+      fprintf(stderr, "triggered bug index 1119\n");
+    else
+      fprintf(stderr, "reached bug index 1119\n");
+  }
+  if ((!FIXREVERTER[1119] && (nameoff > command -> len ))
+  #else
+  if (0
+  #endif
+  )
     return false;
+    #ifdef FRCOV
+    }
+    #endif
   cmd->timestamp = bfd_h_get_32 (abfd, raw.timestamp);
   cmd->current_version = bfd_h_get_32 (abfd, raw.current_version);
   cmd->compatibility_version = bfd_h_get_32 (abfd, raw.compatibility_version);
@@ -4103,20 +4569,65 @@ bfd_mach_o_read_prebound_dylib (bfd *abfd,
   unsigned int str_len;
   unsigned char *str;
 
-  if (command->len < sizeof (raw) + 8)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[1120]) {
+    if ((command -> len < sizeof ( raw ) + 8 ) && !(0))
+      fprintf(stderr, "triggered bug index 1120\n");
+    else
+      fprintf(stderr, "reached bug index 1120\n");
+  }
+  if ((!FIXREVERTER[1120] && (command -> len < sizeof ( raw ) + 8 ))
+  #else
+  if (0
+  #endif
+  )
     return false;
+    #ifdef FRCOV
+    }
+    #endif
   if (bfd_bread (&raw, sizeof (raw), abfd) != sizeof (raw))
     return false;
 
   nameoff = bfd_h_get_32 (abfd, raw.name);
   modoff = bfd_h_get_32 (abfd, raw.linked_modules);
-  if (nameoff > command->len || modoff > command->len)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[1121]) {
+    if ((nameoff > command -> len || modoff > command -> len ) && !(0))
+      fprintf(stderr, "triggered bug index 1121\n");
+    else
+      fprintf(stderr, "reached bug index 1121\n");
+  }
+  if ((!FIXREVERTER[1121] && (nameoff > command -> len || modoff > command -> len ))
+  #else
+  if (0
+  #endif
+  )
     return false;
+    #ifdef FRCOV
+    }
+    #endif
 
   str_len = command->len - sizeof (raw);
   str = _bfd_alloc_and_read (abfd, str_len, str_len);
-  if (str == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[1122]) {
+    if ((str == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 1122\n");
+    else
+      fprintf(stderr, "reached bug index 1122\n");
+  }
+  if ((!FIXREVERTER[1122] && (str == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     return false;
+    #ifdef FRCOV
+    }
+    #endif
 
   cmd->name_offset = command->offset + nameoff;
   cmd->nmodules = bfd_h_get_32 (abfd, raw.nmodules);
@@ -4134,8 +4645,23 @@ bfd_mach_o_read_prebind_cksum (bfd *abfd,
   bfd_mach_o_prebind_cksum_command *cmd = &command->command.prebind_cksum;
   struct mach_o_prebind_cksum_command_external raw;
 
-  if (command->len < sizeof (raw) + 8)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[1123]) {
+    if ((command -> len < sizeof ( raw ) + 8 ) && !(0))
+      fprintf(stderr, "triggered bug index 1123\n");
+    else
+      fprintf(stderr, "reached bug index 1123\n");
+  }
+  if ((!FIXREVERTER[1123] && (command -> len < sizeof ( raw ) + 8 ))
+  #else
+  if (0
+  #endif
+  )
     return false;
+    #ifdef FRCOV
+    }
+    #endif
   if (bfd_bread (&raw, sizeof (raw), abfd) != sizeof (raw))
     return false;
 
@@ -4150,8 +4676,23 @@ bfd_mach_o_read_twolevel_hints (bfd *abfd,
   bfd_mach_o_twolevel_hints_command *cmd = &command->command.twolevel_hints;
   struct mach_o_twolevel_hints_command_external raw;
 
-  if (command->len < sizeof (raw) + 8)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[1124]) {
+    if ((command -> len < sizeof ( raw ) + 8 ) && !(0))
+      fprintf(stderr, "triggered bug index 1124\n");
+    else
+      fprintf(stderr, "reached bug index 1124\n");
+  }
+  if ((!FIXREVERTER[1124] && (command -> len < sizeof ( raw ) + 8 ))
+  #else
+  if (0
+  #endif
+  )
     return false;
+    #ifdef FRCOV
+    }
+    #endif
   if (bfd_bread (&raw, sizeof (raw), abfd) != sizeof (raw))
     return false;
 
@@ -4168,14 +4709,44 @@ bfd_mach_o_read_fvmlib (bfd *abfd, bfd_mach_o_load_command *command)
   unsigned int nameoff;
   unsigned int namelen;
 
-  if (command->len < sizeof (raw) + 8)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[1125]) {
+    if ((command -> len < sizeof ( raw ) + 8 ) && !(0))
+      fprintf(stderr, "triggered bug index 1125\n");
+    else
+      fprintf(stderr, "reached bug index 1125\n");
+  }
+  if ((!FIXREVERTER[1125] && (command -> len < sizeof ( raw ) + 8 ))
+  #else
+  if (0
+  #endif
+  )
     return false;
+    #ifdef FRCOV
+    }
+    #endif
   if (bfd_bread (&raw, sizeof (raw), abfd) != sizeof (raw))
     return false;
 
   nameoff = bfd_h_get_32 (abfd, raw.name);
-  if (nameoff > command->len)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[1126]) {
+    if ((nameoff > command -> len ) && !(0))
+      fprintf(stderr, "triggered bug index 1126\n");
+    else
+      fprintf(stderr, "reached bug index 1126\n");
+  }
+  if ((!FIXREVERTER[1126] && (nameoff > command -> len ))
+  #else
+  if (0
+  #endif
+  )
     return false;
+    #ifdef FRCOV
+    }
+    #endif
   fvm->minor_version = bfd_h_get_32 (abfd, raw.minor_version);
   fvm->header_addr = bfd_h_get_32 (abfd, raw.header_addr);
 
@@ -4218,8 +4789,23 @@ bfd_mach_o_read_thread (bfd *abfd, bfd_mach_o_load_command *command)
       offset += sizeof (raw) + count * 4;
       nflavours++;
     }
-  if (nflavours == 0 || offset != command->len)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[1127]) {
+    if ((nflavours == 0 || offset != command -> len ) && !(0))
+      fprintf(stderr, "triggered bug index 1127\n");
+    else
+      fprintf(stderr, "reached bug index 1127\n");
+  }
+  if ((!FIXREVERTER[1127] && (nflavours == 0 || offset != command -> len ))
+  #else
+  if (0
+  #endif
+  )
     return false;
+    #ifdef FRCOV
+    }
+    #endif
 
   /* Allocate threads.  */
   if (_bfd_mul_overflow (nflavours, sizeof (bfd_mach_o_thread_flavour), &amt))
@@ -4228,8 +4814,23 @@ bfd_mach_o_read_thread (bfd *abfd, bfd_mach_o_load_command *command)
       return false;
     }
   cmd->flavours = bfd_alloc (abfd, amt);
-  if (cmd->flavours == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[1128]) {
+    if ((cmd -> flavours == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 1128\n");
+    else
+      fprintf(stderr, "reached bug index 1128\n");
+  }
+  if ((!FIXREVERTER[1128] && (cmd -> flavours == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     return false;
+    #ifdef FRCOV
+    }
+    #endif
   cmd->nflavours = nflavours;
 
   offset = 8;
@@ -4275,8 +4876,23 @@ bfd_mach_o_read_thread (bfd *abfd, bfd_mach_o_load_command *command)
 
       snamelen = strlen (prefix) + 1 + 20 + 1 + strlen (flavourstr) + 1;
       sname = bfd_alloc (abfd, snamelen);
-      if (sname == NULL)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[1129]) {
+        if ((sname == (void *) 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 1129\n");
+        else
+          fprintf(stderr, "reached bug index 1129\n");
+      }
+      if ((!FIXREVERTER[1129] && (sname == (void *) 0 ))
+      #else
+      if (0
+      #endif
+      )
 	return false;
+	#ifdef FRCOV
+	}
+	#endif
 
       for (;;)
 	{
@@ -4312,8 +4928,23 @@ bfd_mach_o_read_dysymtab (bfd *abfd, bfd_mach_o_load_command *command,
   {
     struct mach_o_dysymtab_command_external raw;
 
-    if (command->len < sizeof (raw) + 8)
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[1130]) {
+      if ((command -> len < sizeof ( raw ) + 8 ) && !(0))
+        fprintf(stderr, "triggered bug index 1130\n");
+      else
+        fprintf(stderr, "reached bug index 1130\n");
+    }
+    if ((!FIXREVERTER[1130] && (command -> len < sizeof ( raw ) + 8 ))
+    #else
+    if (0
+    #endif
+    )
       return false;
+      #ifdef FRCOV
+      }
+      #endif
     if (bfd_bread (&raw, sizeof (raw), abfd) != sizeof (raw))
       return false;
 
@@ -4357,8 +4988,23 @@ bfd_mach_o_read_dysymtab (bfd *abfd, bfd_mach_o_load_command *command,
 	  return false;
 	}
       cmd->dylib_module = bfd_alloc (abfd, amt);
-      if (cmd->dylib_module == NULL)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[1131]) {
+        if ((cmd -> dylib_module == (void *) 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 1131\n");
+        else
+          fprintf(stderr, "reached bug index 1131\n");
+      }
+      if ((!FIXREVERTER[1131] && (cmd -> dylib_module == (void *) 0 ))
+      #else
+      if (0
+      #endif
+      )
 	return false;
+	#ifdef FRCOV
+	}
+	#endif
 
       if (bfd_seek (abfd, cmd->modtaboff, SEEK_SET) != 0)
 	return false;
@@ -4419,8 +5065,23 @@ bfd_mach_o_read_dysymtab (bfd *abfd, bfd_mach_o_load_command *command,
 	  return false;
 	}
       cmd->dylib_toc = bfd_alloc (abfd, amt);
-      if (cmd->dylib_toc == NULL)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[1133]) {
+        if ((cmd -> dylib_toc == (void *) 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 1133\n");
+        else
+          fprintf(stderr, "reached bug index 1133\n");
+      }
+      if ((!FIXREVERTER[1133] && (cmd -> dylib_toc == (void *) 0 ))
+      #else
+      if (0
+      #endif
+      )
 	return false;
+	#ifdef FRCOV
+	}
+	#endif
 
       if (bfd_seek (abfd, cmd->tocoff, SEEK_SET) != 0)
 	return false;
@@ -4454,8 +5115,23 @@ bfd_mach_o_read_dysymtab (bfd *abfd, bfd_mach_o_load_command *command,
 	  return false;
 	}
       cmd->indirect_syms = bfd_alloc (abfd, amt);
-      if (cmd->indirect_syms == NULL)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[1134]) {
+        if ((cmd -> indirect_syms == (void *) 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 1134\n");
+        else
+          fprintf(stderr, "reached bug index 1134\n");
+      }
+      if ((!FIXREVERTER[1134] && (cmd -> indirect_syms == (void *) 0 ))
+      #else
+      if (0
+      #endif
+      )
 	return false;
+	#ifdef FRCOV
+	}
+	#endif
 
       if (bfd_seek (abfd, cmd->indirectsymoff, SEEK_SET) != 0)
 	return false;
@@ -4491,8 +5167,23 @@ bfd_mach_o_read_dysymtab (bfd *abfd, bfd_mach_o_load_command *command,
 	  return false;
 	}
       cmd->ext_refs = bfd_alloc (abfd, amt);
-      if (cmd->ext_refs == NULL)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[1136]) {
+        if ((cmd -> ext_refs == (void *) 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 1136\n");
+        else
+          fprintf(stderr, "reached bug index 1136\n");
+      }
+      if ((!FIXREVERTER[1136] && (cmd -> ext_refs == (void *) 0 ))
+      #else
+      if (0
+      #endif
+      )
 	return false;
+	#ifdef FRCOV
+	}
+	#endif
 
       if (bfd_seek (abfd, cmd->extrefsymoff, SEEK_SET) != 0)
 	return false;
@@ -4538,8 +5229,23 @@ bfd_mach_o_read_symtab (bfd *abfd, bfd_mach_o_load_command *command,
 
   BFD_ASSERT (command->type == BFD_MACH_O_LC_SYMTAB);
 
-  if (command->len < sizeof (raw) + 8)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[1138]) {
+    if ((command -> len < sizeof ( raw ) + 8 ) && !(0))
+      fprintf(stderr, "triggered bug index 1138\n");
+    else
+      fprintf(stderr, "reached bug index 1138\n");
+  }
+  if ((!FIXREVERTER[1138] && (command -> len < sizeof ( raw ) + 8 ))
+  #else
+  if (0
+  #endif
+  )
     return false;
+    #ifdef FRCOV
+    }
+    #endif
   if (bfd_bread (&raw, sizeof (raw), abfd) != sizeof (raw))
     return false;
 
@@ -4575,8 +5281,23 @@ bfd_mach_o_read_uuid (bfd *abfd, bfd_mach_o_load_command *command)
 
   BFD_ASSERT (command->type == BFD_MACH_O_LC_UUID);
 
-  if (command->len < 16 + 8)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[1139]) {
+    if ((command -> len < 16 + 8 ) && !(0))
+      fprintf(stderr, "triggered bug index 1139\n");
+    else
+      fprintf(stderr, "reached bug index 1139\n");
+  }
+  if ((!FIXREVERTER[1139] && (command -> len < 16 + 8 ))
+  #else
+  if (0
+  #endif
+  )
     return false;
+    #ifdef FRCOV
+    }
+    #endif
   if (bfd_bread (cmd->uuid, 16, abfd) != 16)
     return false;
 
@@ -4589,8 +5310,23 @@ bfd_mach_o_read_linkedit (bfd *abfd, bfd_mach_o_load_command *command)
   bfd_mach_o_linkedit_command *cmd = &command->command.linkedit;
   struct mach_o_linkedit_data_command_external raw;
 
-  if (command->len < sizeof (raw) + 8)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[1140]) {
+    if ((command -> len < sizeof ( raw ) + 8 ) && !(0))
+      fprintf(stderr, "triggered bug index 1140\n");
+    else
+      fprintf(stderr, "reached bug index 1140\n");
+  }
+  if ((!FIXREVERTER[1140] && (command -> len < sizeof ( raw ) + 8 ))
+  #else
+  if (0
+  #endif
+  )
     return false;
+    #ifdef FRCOV
+    }
+    #endif
   if (bfd_bread (&raw, sizeof (raw), abfd) != sizeof (raw))
     return false;
 
@@ -4606,14 +5342,44 @@ bfd_mach_o_read_str (bfd *abfd, bfd_mach_o_load_command *command)
   struct mach_o_str_command_external raw;
   unsigned long off;
 
-  if (command->len < sizeof (raw) + 8)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[1141]) {
+    if ((command -> len < sizeof ( raw ) + 8 ) && !(0))
+      fprintf(stderr, "triggered bug index 1141\n");
+    else
+      fprintf(stderr, "reached bug index 1141\n");
+  }
+  if ((!FIXREVERTER[1141] && (command -> len < sizeof ( raw ) + 8 ))
+  #else
+  if (0
+  #endif
+  )
     return false;
+    #ifdef FRCOV
+    }
+    #endif
   if (bfd_bread (&raw, sizeof (raw), abfd) != sizeof (raw))
     return false;
 
   off = bfd_get_32 (abfd, raw.str);
-  if (off > command->len)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[1142]) {
+    if ((off > command -> len ) && !(0))
+      fprintf(stderr, "triggered bug index 1142\n");
+    else
+      fprintf(stderr, "reached bug index 1142\n");
+  }
+  if ((!FIXREVERTER[1142] && (off > command -> len ))
+  #else
+  if (0
+  #endif
+  )
     return false;
+    #ifdef FRCOV
+    }
+    #endif
 
   cmd->stroff = command->offset + off;
   cmd->str_len = command->len - off;
@@ -4626,49 +5392,214 @@ static bool
 bfd_mach_o_read_dyld_content (bfd *abfd, bfd_mach_o_dyld_info_command *cmd)
 {
   /* Read rebase content.  */
-  if (cmd->rebase_content == NULL && cmd->rebase_size != 0)
-    {
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[1144]) {
+    fprintf(stderr, "reached bug index 1144\n");
+  }
+  if ((FIXREVERTER[1144] && (cmd -> rebase_content == (void *) 0 )) || (!FIXREVERTER[1144] && (cmd -> rebase_content == (void *) 0 && cmd -> rebase_size != 0 ))
+  #else
+  if (cmd -> rebase_content == (void *) 0 
+  #endif
+  )
+    {
+      
+    #ifdef FRCOV
+      if (!(cmd -> rebase_size != 0 ))
+        fprintf(stderr, "triggered bug index 1144\n");
+      #endif
+    
       cmd->rebase_content
 	= bfd_mach_o_alloc_and_read (abfd, cmd->rebase_off, cmd->rebase_size);
-      if (cmd->rebase_content == NULL)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[1143]) {
+        if ((cmd -> rebase_content == (void *) 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 1143\n");
+        else
+          fprintf(stderr, "reached bug index 1143\n");
+      }
+      if ((!FIXREVERTER[1143] && (cmd -> rebase_content == (void *) 0 ))
+      #else
+      if (0
+      #endif
+      )
 	return false;
+	#ifdef FRCOV
+	}
+	#endif
+    }
+    #ifdef FRCOV
     }
+    #endif
 
   /* Read bind content.  */
-  if (cmd->bind_content == NULL && cmd->bind_size != 0)
-    {
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[1146]) {
+    fprintf(stderr, "reached bug index 1146\n");
+  }
+  if ((FIXREVERTER[1146] && (cmd -> bind_content == (void *) 0 )) || (!FIXREVERTER[1146] && (cmd -> bind_content == (void *) 0 && cmd -> bind_size != 0 ))
+  #else
+  if (cmd -> bind_content == (void *) 0 
+  #endif
+  )
+    {
+      
+    #ifdef FRCOV
+      if (!(cmd -> bind_size != 0 ))
+        fprintf(stderr, "triggered bug index 1146\n");
+      #endif
+    
       cmd->bind_content
 	= bfd_mach_o_alloc_and_read (abfd, cmd->bind_off, cmd->bind_size);
-      if (cmd->bind_content == NULL)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[1145]) {
+        if ((cmd -> bind_content == (void *) 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 1145\n");
+        else
+          fprintf(stderr, "reached bug index 1145\n");
+      }
+      if ((!FIXREVERTER[1145] && (cmd -> bind_content == (void *) 0 ))
+      #else
+      if (0
+      #endif
+      )
 	return false;
+	#ifdef FRCOV
+	}
+	#endif
+    }
+    #ifdef FRCOV
     }
+    #endif
 
   /* Read weak bind content.  */
-  if (cmd->weak_bind_content == NULL && cmd->weak_bind_size != 0)
-    {
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[1148]) {
+    fprintf(stderr, "reached bug index 1148\n");
+  }
+  if ((FIXREVERTER[1148] && (cmd -> weak_bind_content == (void *) 0 )) || (!FIXREVERTER[1148] && (cmd -> weak_bind_content == (void *) 0 && cmd -> weak_bind_size != 0 ))
+  #else
+  if (cmd -> weak_bind_content == (void *) 0 
+  #endif
+  )
+    {
+      
+    #ifdef FRCOV
+      if (!(cmd -> weak_bind_size != 0 ))
+        fprintf(stderr, "triggered bug index 1148\n");
+      #endif
+    
       cmd->weak_bind_content = bfd_mach_o_alloc_and_read
 	(abfd, cmd->weak_bind_off, cmd->weak_bind_size);
-      if (cmd->weak_bind_content == NULL)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[1147]) {
+        if ((cmd -> weak_bind_content == (void *) 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 1147\n");
+        else
+          fprintf(stderr, "reached bug index 1147\n");
+      }
+      if ((!FIXREVERTER[1147] && (cmd -> weak_bind_content == (void *) 0 ))
+      #else
+      if (0
+      #endif
+      )
 	return false;
+	#ifdef FRCOV
+	}
+	#endif
     }
+    #ifdef FRCOV
+    }
+    #endif
 
   /* Read lazy bind content.  */
-  if (cmd->lazy_bind_content == NULL && cmd->lazy_bind_size != 0)
-    {
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[1150]) {
+    fprintf(stderr, "reached bug index 1150\n");
+  }
+  if ((FIXREVERTER[1150] && (cmd -> lazy_bind_content == (void *) 0 )) || (!FIXREVERTER[1150] && (cmd -> lazy_bind_content == (void *) 0 && cmd -> lazy_bind_size != 0 ))
+  #else
+  if (cmd -> lazy_bind_content == (void *) 0 
+  #endif
+  )
+    {
+      
+    #ifdef FRCOV
+      if (!(cmd -> lazy_bind_size != 0 ))
+        fprintf(stderr, "triggered bug index 1150\n");
+      #endif
+    
       cmd->lazy_bind_content = bfd_mach_o_alloc_and_read
 	(abfd, cmd->lazy_bind_off, cmd->lazy_bind_size);
-      if (cmd->lazy_bind_content == NULL)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[1149]) {
+        if ((cmd -> lazy_bind_content == (void *) 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 1149\n");
+        else
+          fprintf(stderr, "reached bug index 1149\n");
+      }
+      if ((!FIXREVERTER[1149] && (cmd -> lazy_bind_content == (void *) 0 ))
+      #else
+      if (0
+      #endif
+      )
 	return false;
+	#ifdef FRCOV
+	}
+	#endif
     }
+    #ifdef FRCOV
+    }
+    #endif
 
   /* Read export content.  */
-  if (cmd->export_content == NULL && cmd->export_size != 0)
-    {
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[1152]) {
+    fprintf(stderr, "reached bug index 1152\n");
+  }
+  if ((FIXREVERTER[1152] && (cmd -> export_content == (void *) 0 )) || (!FIXREVERTER[1152] && (cmd -> export_content == (void *) 0 && cmd -> export_size != 0 ))
+  #else
+  if (cmd -> export_content == (void *) 0 
+  #endif
+  )
+    {
+      
+    #ifdef FRCOV
+      if (!(cmd -> export_size != 0 ))
+        fprintf(stderr, "triggered bug index 1152\n");
+      #endif
+    
       cmd->export_content = bfd_mach_o_alloc_and_read
 	(abfd, cmd->export_off, cmd->export_size);
-      if (cmd->export_content == NULL)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[1151]) {
+        if ((cmd -> export_content == (void *) 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 1151\n");
+        else
+          fprintf(stderr, "reached bug index 1151\n");
+      }
+      if ((!FIXREVERTER[1151] && (cmd -> export_content == (void *) 0 ))
+      #else
+      if (0
+      #endif
+      )
 	return false;
+	#ifdef FRCOV
+	}
+	#endif
+    }
+    #ifdef FRCOV
     }
+    #endif
 
   return true;
 }
@@ -4679,8 +5610,23 @@ bfd_mach_o_read_dyld_info (bfd *abfd, bfd_mach_o_load_command *command)
   bfd_mach_o_dyld_info_command *cmd = &command->command.dyld_info;
   struct mach_o_dyld_info_command_external raw;
 
-  if (command->len < sizeof (raw) + 8)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[1153]) {
+    if ((command -> len < sizeof ( raw ) + 8 ) && !(0))
+      fprintf(stderr, "triggered bug index 1153\n");
+    else
+      fprintf(stderr, "reached bug index 1153\n");
+  }
+  if ((!FIXREVERTER[1153] && (command -> len < sizeof ( raw ) + 8 ))
+  #else
+  if (0
+  #endif
+  )
     return false;
+    #ifdef FRCOV
+    }
+    #endif
   if (bfd_bread (&raw, sizeof (raw), abfd) != sizeof (raw))
     return false;
 
@@ -4708,8 +5654,23 @@ bfd_mach_o_read_version_min (bfd *abfd, bfd_mach_o_load_command *command)
   bfd_mach_o_version_min_command *cmd = &command->command.version_min;
   struct mach_o_version_min_command_external raw;
 
-  if (command->len < sizeof (raw) + 8)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[1154]) {
+    if ((command -> len < sizeof ( raw ) + 8 ) && !(0))
+      fprintf(stderr, "triggered bug index 1154\n");
+    else
+      fprintf(stderr, "reached bug index 1154\n");
+  }
+  if ((!FIXREVERTER[1154] && (command -> len < sizeof ( raw ) + 8 ))
+  #else
+  if (0
+  #endif
+  )
     return false;
+    #ifdef FRCOV
+    }
+    #endif
   if (bfd_bread (&raw, sizeof (raw), abfd) != sizeof (raw))
     return false;
 
@@ -4724,8 +5685,23 @@ bfd_mach_o_read_encryption_info (bfd *abfd, bfd_mach_o_load_command *command)
   bfd_mach_o_encryption_info_command *cmd = &command->command.encryption_info;
   struct mach_o_encryption_info_command_external raw;
 
-  if (command->len < sizeof (raw) + 8)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[1155]) {
+    if ((command -> len < sizeof ( raw ) + 8 ) && !(0))
+      fprintf(stderr, "triggered bug index 1155\n");
+    else
+      fprintf(stderr, "reached bug index 1155\n");
+  }
+  if ((!FIXREVERTER[1155] && (command -> len < sizeof ( raw ) + 8 ))
+  #else
+  if (0
+  #endif
+  )
     return false;
+    #ifdef FRCOV
+    }
+    #endif
   if (bfd_bread (&raw, sizeof (raw), abfd) != sizeof (raw))
     return false;
 
@@ -4741,8 +5717,23 @@ bfd_mach_o_read_encryption_info_64 (bfd *abfd, bfd_mach_o_load_command *command)
   bfd_mach_o_encryption_info_command *cmd = &command->command.encryption_info;
   struct mach_o_encryption_info_64_command_external raw;
 
-  if (command->len < sizeof (raw) + 8)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[1156]) {
+    if ((command -> len < sizeof ( raw ) + 8 ) && !(0))
+      fprintf(stderr, "triggered bug index 1156\n");
+    else
+      fprintf(stderr, "reached bug index 1156\n");
+  }
+  if ((!FIXREVERTER[1156] && (command -> len < sizeof ( raw ) + 8 ))
+  #else
+  if (0
+  #endif
+  )
     return false;
+    #ifdef FRCOV
+    }
+    #endif
   if (bfd_bread (&raw, sizeof (raw), abfd) != sizeof (raw))
     return false;
 
@@ -4758,8 +5749,23 @@ bfd_mach_o_read_main (bfd *abfd, bfd_mach_o_load_command *command)
   bfd_mach_o_main_command *cmd = &command->command.main;
   struct mach_o_entry_point_command_external raw;
 
-  if (command->len < sizeof (raw) + 8)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[1157]) {
+    if ((command -> len < sizeof ( raw ) + 8 ) && !(0))
+      fprintf(stderr, "triggered bug index 1157\n");
+    else
+      fprintf(stderr, "reached bug index 1157\n");
+  }
+  if ((!FIXREVERTER[1157] && (command -> len < sizeof ( raw ) + 8 ))
+  #else
+  if (0
+  #endif
+  )
     return false;
+    #ifdef FRCOV
+    }
+    #endif
   if (bfd_bread (&raw, sizeof (raw), abfd) != sizeof (raw))
     return false;
 
@@ -4775,8 +5781,23 @@ bfd_mach_o_read_source_version (bfd *abfd, bfd_mach_o_load_command *command)
   struct mach_o_source_version_command_external raw;
   bfd_uint64_t ver;
 
-  if (command->len < sizeof (raw) + 8)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[1158]) {
+    if ((command -> len < sizeof ( raw ) + 8 ) && !(0))
+      fprintf(stderr, "triggered bug index 1158\n");
+    else
+      fprintf(stderr, "reached bug index 1158\n");
+  }
+  if ((!FIXREVERTER[1158] && (command -> len < sizeof ( raw ) + 8 ))
+  #else
+  if (0
+  #endif
+  )
     return false;
+    #ifdef FRCOV
+    }
+    #endif
   if (bfd_bread (&raw, sizeof (raw), abfd) != sizeof (raw))
     return false;
 
@@ -4802,8 +5823,23 @@ bfd_mach_o_read_note (bfd *abfd, bfd_mach_o_load_command *command)
   bfd_mach_o_note_command *cmd = &command->command.note;
   struct mach_o_note_command_external raw;
 
-  if (command->len < sizeof (raw) + 8)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[1159]) {
+    if ((command -> len < sizeof ( raw ) + 8 ) && !(0))
+      fprintf(stderr, "triggered bug index 1159\n");
+    else
+      fprintf(stderr, "reached bug index 1159\n");
+  }
+  if ((!FIXREVERTER[1159] && (command -> len < sizeof ( raw ) + 8 ))
+  #else
+  if (0
+  #endif
+  )
     return false;
+    #ifdef FRCOV
+    }
+    #endif
   if (bfd_bread (&raw, sizeof (raw), abfd) != sizeof (raw))
     return false;
 
@@ -4819,8 +5855,23 @@ bfd_mach_o_read_build_version (bfd *abfd, bfd_mach_o_load_command *command)
   bfd_mach_o_build_version_command *cmd = &command->command.build_version;
   struct mach_o_build_version_command_external raw;
 
-  if (command->len < sizeof (raw) + 8)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[1161]) {
+    if ((command -> len < sizeof ( raw ) + 8 ) && !(0))
+      fprintf(stderr, "triggered bug index 1161\n");
+    else
+      fprintf(stderr, "reached bug index 1161\n");
+  }
+  if ((!FIXREVERTER[1161] && (command -> len < sizeof ( raw ) + 8 ))
+  #else
+  if (0
+  #endif
+  )
     return false;
+    #ifdef FRCOV
+    }
+    #endif
   if (bfd_bread (&raw, sizeof (raw), abfd) != sizeof (raw))
     return false;
 
@@ -4845,8 +5896,23 @@ bfd_mach_o_read_segment (bfd *abfd,
 
       BFD_ASSERT (command->type == BFD_MACH_O_LC_SEGMENT_64);
 
-      if (command->len < sizeof (raw) + 8)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[1162]) {
+        if ((command -> len < sizeof ( raw ) + 8 ) && !(0))
+          fprintf(stderr, "triggered bug index 1162\n");
+        else
+          fprintf(stderr, "reached bug index 1162\n");
+      }
+      if ((!FIXREVERTER[1162] && (command -> len < sizeof ( raw ) + 8 ))
+      #else
+      if (0
+      #endif
+      )
 	return false;
+	#ifdef FRCOV
+	}
+	#endif
       if (bfd_bread (&raw, sizeof (raw), abfd) != sizeof (raw))
 	return false;
 
@@ -4868,8 +5934,23 @@ bfd_mach_o_read_segment (bfd *abfd,
 
       BFD_ASSERT (command->type == BFD_MACH_O_LC_SEGMENT);
 
-      if (command->len < sizeof (raw) + 8)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[1164]) {
+        if ((command -> len < sizeof ( raw ) + 8 ) && !(0))
+          fprintf(stderr, "triggered bug index 1164\n");
+        else
+          fprintf(stderr, "reached bug index 1164\n");
+      }
+      if ((!FIXREVERTER[1164] && (command -> len < sizeof ( raw ) + 8 ))
+      #else
+      if (0
+      #endif
+      )
 	return false;
+	#ifdef FRCOV
+	}
+	#endif
       if (bfd_bread (&raw, sizeof (raw), abfd) != sizeof (raw))
 	return false;
 
@@ -4893,8 +5974,23 @@ bfd_mach_o_read_segment (bfd *abfd,
       asection *sec;
 
       sec = bfd_mach_o_read_section (abfd, seg->initprot, wide);
-      if (sec == NULL)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[1166]) {
+        if ((sec == (void *) 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 1166\n");
+        else
+          fprintf(stderr, "reached bug index 1166\n");
+      }
+      if ((!FIXREVERTER[1166] && (sec == (void *) 0 ))
+      #else
+      if (0
+      #endif
+      )
 	return false;
+	#ifdef FRCOV
+	}
+	#endif
 
       bfd_mach_o_append_section_to_segment
 	(seg, bfd_mach_o_get_mach_o_section (sec));
@@ -5149,8 +6245,23 @@ bfd_mach_o_scan_start_address (bfd *abfd)
       }
 
   /* An object file has no start address, so do not fail if not found.  */
-  if (thr == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[1167]) {
+    if ((thr == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 1167\n");
+    else
+      fprintf(stderr, "reached bug index 1167\n");
+  }
+  if ((!FIXREVERTER[1167] && (thr == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     return true;
+    #ifdef FRCOV
+    }
+    #endif
 
   /* FIXME: create a subtarget hook ?  */
   for (i = 0; i < thr->nflavours; i++)
@@ -5290,8 +6401,23 @@ bfd_mach_o_scan (bfd *abfd,
 	  return false;
 	}
       cmd = bfd_alloc (abfd, amt);
-      if (cmd == NULL)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[1173]) {
+        if ((cmd == (void *) 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 1173\n");
+        else
+          fprintf(stderr, "reached bug index 1173\n");
+      }
+      if ((!FIXREVERTER[1173] && (cmd == (void *) 0 ))
+      #else
+      if (0
+      #endif
+      )
 	return false;
+	#ifdef FRCOV
+	}
+	#endif
 
       for (i = 0; i < header->ncmds; i++)
 	{
@@ -5430,8 +6556,23 @@ bfd_mach_o_header_p (bfd *abfd,
     }
 
   mdata = (bfd_mach_o_data_struct *) bfd_zalloc (abfd, sizeof (*mdata));
-  if (mdata == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[1174]) {
+    if ((mdata == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 1174\n");
+    else
+      fprintf(stderr, "reached bug index 1174\n");
+  }
+  if ((!FIXREVERTER[1174] && (mdata == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     goto fail;
+    #ifdef FRCOV
+    }
+    #endif
   mdata->hdr_offset = hdr_off;
 
   if (!bfd_mach_o_scan (abfd, &header, mdata))
@@ -5515,18 +6656,63 @@ bfd_mach_o_fat_archive_p (bfd *abfd)
     goto error;
 
   adata = bfd_alloc (abfd, sizeof (mach_o_fat_data_struct));
-  if (adata == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[1176]) {
+    if ((adata == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 1176\n");
+    else
+      fprintf(stderr, "reached bug index 1176\n");
+  }
+  if ((!FIXREVERTER[1176] && (adata == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     goto error;
+    #ifdef FRCOV
+    }
+    #endif
 
   adata->magic = bfd_getb32 (hdr.magic);
   adata->nfat_arch = bfd_getb32 (hdr.nfat_arch);
-  if (adata->magic != 0xcafebabe)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[1177]) {
+    if ((adata -> magic != -889275714 ) && !(0))
+      fprintf(stderr, "triggered bug index 1177\n");
+    else
+      fprintf(stderr, "reached bug index 1177\n");
+  }
+  if ((!FIXREVERTER[1177] && (adata -> magic != -889275714 ))
+  #else
+  if (0
+  #endif
+  )
     goto error;
+    #ifdef FRCOV
+    }
+    #endif
   /* Avoid matching Java bytecode files, which have the same magic number.
      In the Java bytecode file format this field contains the JVM version,
      which starts at 43.0.  */
-  if (adata->nfat_arch > 30)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[1178]) {
+    if ((adata -> nfat_arch > 30 ) && !(0))
+      fprintf(stderr, "triggered bug index 1178\n");
+    else
+      fprintf(stderr, "reached bug index 1178\n");
+  }
+  if ((!FIXREVERTER[1178] && (adata -> nfat_arch > 30 ))
+  #else
+  if (0
+  #endif
+  )
     goto error;
+    #ifdef FRCOV
+    }
+    #endif
 
   if (_bfd_mul_overflow (adata->nfat_arch,
 			 sizeof (mach_o_fat_archentry), &amt))
@@ -5535,8 +6721,23 @@ bfd_mach_o_fat_archive_p (bfd *abfd)
       goto error;
     }
   adata->archentries = bfd_alloc (abfd, amt);
-  if (adata->archentries == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[1179]) {
+    if ((adata -> archentries == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 1179\n");
+    else
+      fprintf(stderr, "reached bug index 1179\n");
+  }
+  if ((!FIXREVERTER[1179] && (adata -> archentries == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     goto error;
+    #ifdef FRCOV
+    }
+    #endif
 
   for (i = 0; i < adata->nfat_arch; i++)
     {
@@ -5671,11 +6872,26 @@ bfd_mach_o_fat_openr_next_archived_file (bfd *archive, bfd *prev)
 static int
 bfd_mach_o_fat_stat_arch_elt (bfd *abfd, struct stat *buf)
 {
-  if (abfd->arelt_data == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[1185]) {
+    if ((abfd -> arelt_data == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 1185\n");
+    else
+      fprintf(stderr, "reached bug index 1185\n");
+  }
+  if ((!FIXREVERTER[1185] && (abfd -> arelt_data == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     {
       bfd_set_error (bfd_error_invalid_operation);
       return -1;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
   buf->st_mtime = 0;
   buf->st_uid = 0;
@@ -5898,20 +7114,65 @@ bfd_mach_o_core_fetch_environment (bfd *abfd,
 	  unsigned char *buf = bfd_malloc (1024);
 	  unsigned long size = 1024;
 
-	  if (buf == NULL)
+	  
+	  #ifdef FRCOV
+	  {if (FIXREVERTER[1189]) {
+	    if ((buf == (void *) 0 ) && !(0))
+	      fprintf(stderr, "triggered bug index 1189\n");
+	    else
+	      fprintf(stderr, "reached bug index 1189\n");
+	  }
+	  if ((!FIXREVERTER[1189] && (buf == (void *) 0 ))
+	  #else
+	  if (0
+	  #endif
+	  )
 	    return -1;
+	    #ifdef FRCOV
+	    }
+	    #endif
 	  for (;;)
 	    {
 	      bfd_size_type nread = 0;
 	      unsigned long offset;
 	      int found_nonnull = 0;
 
-	      if (size > (end - start))
+	      
+	      #ifdef FRCOV
+	      {if (FIXREVERTER[1190]) {
+	        if ((size > end - start ) && !(0))
+	          fprintf(stderr, "triggered bug index 1190\n");
+	        else
+	          fprintf(stderr, "reached bug index 1190\n");
+	      }
+	      if ((!FIXREVERTER[1190] && (size > end - start ))
+	      #else
+	      if (0
+	      #endif
+	      )
 		size = (end - start);
+		#ifdef FRCOV
+		}
+		#endif
 
 	      buf = bfd_realloc_or_free (buf, size);
-	      if (buf == NULL)
+	      
+	      #ifdef FRCOV
+	      {if (FIXREVERTER[1191]) {
+	        if ((buf == (void *) 0 ) && !(0))
+	          fprintf(stderr, "triggered bug index 1191\n");
+	        else
+	          fprintf(stderr, "reached bug index 1191\n");
+	      }
+	      if ((!FIXREVERTER[1191] && (buf == (void *) 0 ))
+	      #else
+	      if (0
+	      #endif
+	      )
 		return -1;
+		#ifdef FRCOV
+		}
+		#endif
 
 	      if (bfd_seek (abfd, end - size, SEEK_SET) != 0)
 		{
@@ -5921,11 +7182,26 @@ bfd_mach_o_core_fetch_environment (bfd *abfd,
 
 	      nread = bfd_bread (buf, size, abfd);
 
-	      if (nread != size)
+	      
+	      #ifdef FRCOV
+	      {if (FIXREVERTER[1192]) {
+	        if ((nread != size ) && !(0))
+	          fprintf(stderr, "triggered bug index 1192\n");
+	        else
+	          fprintf(stderr, "reached bug index 1192\n");
+	      }
+	      if ((!FIXREVERTER[1192] && (nread != size ))
+	      #else
+	      if (0
+	      #endif
+	      )
 		{
 		  free (buf);
 		  return -1;
 		}
+		#ifdef FRCOV
+		}
+		#endif
 
 	      for (offset = 4; offset <= size; offset += 4)
 		{
@@ -5956,8 +7232,23 @@ bfd_mach_o_core_fetch_environment (bfd *abfd,
 		    }
 		}
 
-	      if (size == (end - start))
+	      
+	      #ifdef FRCOV
+	      {if (FIXREVERTER[1194]) {
+	        if ((size == end - start ) && !(0))
+	          fprintf(stderr, "triggered bug index 1194\n");
+	        else
+	          fprintf(stderr, "reached bug index 1194\n");
+	      }
+	      if ((!FIXREVERTER[1194] && (size == end - start ))
+	      #else
+	      if (0
+	      #endif
+	      )
 		break;
+		#ifdef FRCOV
+		}
+		#endif
 
 	      size *= 2;
 	    }
diff --git a/bfd/mach-o.h b/bfd/mach-o.h
old mode 100644
new mode 100755
diff --git a/bfd/makefile.vms b/bfd/makefile.vms
old mode 100644
new mode 100755
diff --git a/bfd/merge.c b/bfd/merge.c
old mode 100644
new mode 100755
index b7a895d..89a5a38
--- a/bfd/merge.c
+++ b/bfd/merge.c
@@ -1,3 +1,6 @@
+#ifdef FRCOV
+extern short FIXREVERTER[];
+#endif
 /* SEC_MERGE support.
    Copyright (C) 2001-2021 Free Software Foundation, Inc.
    Written by Jakub Jelinek <jakub@redhat.com>.
@@ -108,11 +111,41 @@ sec_merge_hash_newfunc (struct bfd_hash_entry *entry,
 {
   /* Allocate the structure if it has not already been allocated by a
      subclass.  */
-  if (entry == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[10046]) {
+    if ((entry == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 10046\n");
+    else
+      fprintf(stderr, "reached bug index 10046\n");
+  }
+  if ((!FIXREVERTER[10046] && (entry == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     entry = (struct bfd_hash_entry *)
 	bfd_hash_allocate (table, sizeof (struct sec_merge_hash_entry));
-  if (entry == NULL)
+	#ifdef FRCOV
+	}
+	#endif
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[10047]) {
+    if ((entry == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 10047\n");
+    else
+      fprintf(stderr, "reached bug index 10047\n");
+  }
+  if ((!FIXREVERTER[10047] && (entry == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     return NULL;
+    #ifdef FRCOV
+    }
+    #endif
 
   /* Call the allocation method of the superclass.  */
   entry = bfd_hash_newfunc (entry, table, string);
@@ -166,8 +199,23 @@ sec_merge_hash_lookup (struct sec_merge_hash *table, const char *string,
 	      for (i = 0; i < table->entsize; ++i)
 		if (s[i] != '\0')
 		  break;
-	      if (i == table->entsize)
+	      
+	      #ifdef FRCOV
+	      {if (FIXREVERTER[10048]) {
+	        if ((i == table -> entsize ) && !(0))
+	          fprintf(stderr, "triggered bug index 10048\n");
+	        else
+	          fprintf(stderr, "reached bug index 10048\n");
+	      }
+	      if ((!FIXREVERTER[10048] && (i == table -> entsize ))
+	      #else
+	      if (0
+	      #endif
+	      )
 		break;
+		#ifdef FRCOV
+		}
+		#endif
 	      for (i = 0; i < table->entsize; ++i)
 		{
 		  c = *s++;
@@ -204,7 +252,19 @@ sec_merge_hash_lookup (struct sec_merge_hash *table, const char *string,
 	{
 	  /* If the string we found does not have at least the required
 	     alignment, we need to insert another copy.  */
-	  if (hashp->alignment < alignment)
+	  
+	  #ifdef FRCOV
+	  {if (FIXREVERTER[10049]) {
+	    if ((hashp -> alignment < alignment ) && !(0))
+	      fprintf(stderr, "triggered bug index 10049\n");
+	    else
+	      fprintf(stderr, "reached bug index 10049\n");
+	  }
+	  if ((!FIXREVERTER[10049] && (hashp -> alignment < alignment ))
+	  #else
+	  if (0
+	  #endif
+	  )
 	    {
 	      if (create)
 		{
@@ -214,6 +274,9 @@ sec_merge_hash_lookup (struct sec_merge_hash *table, const char *string,
 		}
 	      break;
 	    }
+	    #ifdef FRCOV
+	    }
+	    #endif
 	  return hashp;
 	}
     }
@@ -223,8 +286,23 @@ sec_merge_hash_lookup (struct sec_merge_hash *table, const char *string,
 
   hashp = ((struct sec_merge_hash_entry *)
 	   bfd_hash_insert (&table->table, string, hash));
-  if (hashp == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[10050]) {
+    if ((hashp == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 10050\n");
+    else
+      fprintf(stderr, "reached bug index 10050\n");
+  }
+  if ((!FIXREVERTER[10050] && (hashp == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     return NULL;
+    #ifdef FRCOV
+    }
+    #endif
   hashp->len = len;
   hashp->alignment = alignment;
   return hashp;
@@ -238,8 +316,23 @@ sec_merge_init (unsigned int entsize, bool strings)
   struct sec_merge_hash *table;
 
   table = (struct sec_merge_hash *) bfd_malloc (sizeof (struct sec_merge_hash));
-  if (table == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[10051]) {
+    if ((table == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 10051\n");
+    else
+      fprintf(stderr, "reached bug index 10051\n");
+  }
+  if ((!FIXREVERTER[10051] && (table == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     return NULL;
+    #ifdef FRCOV
+    }
+    #endif
 
   if (! bfd_hash_table_init_n (&table->table, sec_merge_hash_newfunc,
 			       sizeof (struct sec_merge_hash_entry), 16699))
@@ -267,8 +360,23 @@ sec_merge_add (struct sec_merge_hash *tab, const char *str,
   struct sec_merge_hash_entry *entry;
 
   entry = sec_merge_hash_lookup (tab, str, alignment, true);
-  if (entry == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[10052]) {
+    if ((entry == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 10052\n");
+    else
+      fprintf(stderr, "reached bug index 10052\n");
+  }
+  if ((!FIXREVERTER[10052] && (entry == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     return NULL;
+    #ifdef FRCOV
+    }
+    #endif
 
   if (entry->secinfo == NULL)
     {
@@ -301,8 +409,23 @@ sec_merge_emit (bfd *abfd, struct sec_merge_hash_entry *entry,
   pad_len = alignment_power ? ((bfd_size_type) 1 << alignment_power) : 16;
 
   pad = (char *) bfd_zmalloc (pad_len);
-  if (pad == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[10053]) {
+    if ((pad == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 10053\n");
+    else
+      fprintf(stderr, "reached bug index 10053\n");
+  }
+  if ((!FIXREVERTER[10053] && (pad == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     return false;
+    #ifdef FRCOV
+    }
+    #endif
 
   for (; entry != NULL && entry->secinfo == secinfo; entry = entry->next)
     {
@@ -526,8 +649,23 @@ record_section (struct sec_merge_info *sinfo,
 		  for (i = 0; i < sec->entsize; i++)
 		    if (p[i] != '\0')
 		      break;
-		  if (i != sec->entsize)
+		  
+		  #ifdef FRCOV
+		  {if (FIXREVERTER[10057]) {
+		    if ((i != sec -> entsize ) && !(0))
+		      fprintf(stderr, "triggered bug index 10057\n");
+		    else
+		      fprintf(stderr, "reached bug index 10057\n");
+		  }
+		  if ((!FIXREVERTER[10057] && (i != sec -> entsize ))
+		  #else
+		  if (0
+		  #endif
+		  )
 		    break;
+		    #ifdef FRCOV
+		    }
+		    #endif
 		  if (!nul && !((p - secinfo->contents) & mask))
 		    {
 		      nul = true;
@@ -599,8 +737,23 @@ strrevcmp_align (const void *a, const void *b)
   int l = lenA < lenB ? lenA : lenB;
   int tail_align = (lenA & (A->alignment - 1)) - (lenB & (A->alignment - 1));
 
-  if (tail_align != 0)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[10058]) {
+    if ((tail_align != 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 10058\n");
+    else
+      fprintf(stderr, "reached bug index 10058\n");
+  }
+  if ((!FIXREVERTER[10058] && (tail_align != 0 ))
+  #else
+  if (0
+  #endif
+  )
     return tail_align;
+    #ifdef FRCOV
+    }
+    #endif
 
   while (l)
     {
@@ -617,10 +770,25 @@ static inline int
 is_suffix (const struct sec_merge_hash_entry *A,
 	   const struct sec_merge_hash_entry *B)
 {
-  if (A->len <= B->len)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[10059]) {
+    if ((A -> len <= B -> len ) && !(0))
+      fprintf(stderr, "triggered bug index 10059\n");
+    else
+      fprintf(stderr, "reached bug index 10059\n");
+  }
+  if ((!FIXREVERTER[10059] && (A -> len <= B -> len ))
+  #else
+  if (0
+  #endif
+  )
     /* B cannot be a suffix of A unless A is equal to B, which is guaranteed
        not to be equal by the hash table.  */
     return 0;
+    #ifdef FRCOV
+    }
+    #endif
 
   return memcmp (A->root.string + (A->len - B->len),
 		 B->root.string, B->len) == 0;
@@ -639,8 +807,23 @@ merge_strings (struct sec_merge_info *sinfo)
   /* Now sort the strings */
   amt = sinfo->htab->size * sizeof (struct sec_merge_hash_entry *);
   array = (struct sec_merge_hash_entry **) bfd_malloc (amt);
-  if (array == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[10060]) {
+    if ((array == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 10060\n");
+    else
+      fprintf(stderr, "reached bug index 10060\n");
+  }
+  if ((!FIXREVERTER[10060] && (array == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     return NULL;
+    #ifdef FRCOV
+    }
+    #endif
 
   for (e = sinfo->htab->first, a = array; e; e = e->next)
     if (e->alignment)
@@ -887,7 +1070,19 @@ _bfd_merged_section_offset (bfd *output_bfd ATTRIBUTE_UNUSED, asection **psec,
   if (!secinfo)
     return offset;
 
-  if (offset >= sec->rawsize)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[10061]) {
+    if ((offset >= sec -> rawsize ) && !(0))
+      fprintf(stderr, "triggered bug index 10061\n");
+    else
+      fprintf(stderr, "reached bug index 10061\n");
+  }
+  if ((!FIXREVERTER[10061] && (offset >= sec -> rawsize ))
+  #else
+  if (0
+  #endif
+  )
     {
       if (offset > sec->rawsize)
 	_bfd_error_handler
@@ -896,6 +1091,9 @@ _bfd_merged_section_offset (bfd *output_bfd ATTRIBUTE_UNUSED, asection **psec,
 	   sec->owner, (int64_t) offset);
       return secinfo->first_str ? sec->size : 0;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
   if (secinfo->htab->strings)
     {
@@ -917,8 +1115,23 @@ _bfd_merged_section_offset (bfd *output_bfd ATTRIBUTE_UNUSED, asection **psec,
 	      for (i = 0; i < sec->entsize; ++i)
 		if (p[i] != '\0')
 		  break;
-	      if (i == sec->entsize)
+	      
+	      #ifdef FRCOV
+	      {if (FIXREVERTER[10062]) {
+	        if ((i == sec -> entsize ) && !(0))
+	          fprintf(stderr, "triggered bug index 10062\n");
+	        else
+	          fprintf(stderr, "reached bug index 10062\n");
+	      }
+	      if ((!FIXREVERTER[10062] && (i == sec -> entsize ))
+	      #else
+	      if (0
+	      #endif
+	      )
 		break;
+		#ifdef FRCOV
+		}
+		#endif
 	      p -= sec->entsize;
 	    }
 	  p += sec->entsize;
diff --git a/bfd/mmo.c b/bfd/mmo.c
old mode 100644
new mode 100755
diff --git a/bfd/netbsd-core.c b/bfd/netbsd-core.c
old mode 100644
new mode 100755
diff --git a/bfd/netbsd.h b/bfd/netbsd.h
old mode 100644
new mode 100755
diff --git a/bfd/ns32k.h b/bfd/ns32k.h
old mode 100644
new mode 100755
diff --git a/bfd/ns32knetbsd.c b/bfd/ns32knetbsd.c
old mode 100644
new mode 100755
diff --git a/bfd/opncls.c b/bfd/opncls.c
old mode 100644
new mode 100755
index 74df4c2..cd81ca9
--- a/bfd/opncls.c
+++ b/bfd/opncls.c
@@ -1,3 +1,6 @@
+#ifdef FRCOV
+extern short FIXREVERTER[];
+#endif
 /* opncls.c -- open and close a BFD.
    Copyright (C) 1990-2021 Free Software Foundation, Inc.
 
@@ -60,8 +63,23 @@ _bfd_new_bfd (void)
   bfd *nbfd;
 
   nbfd = (bfd *) bfd_zmalloc (sizeof (bfd));
-  if (nbfd == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[11919]) {
+    if ((nbfd == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 11919\n");
+    else
+      fprintf(stderr, "reached bug index 11919\n");
+  }
+  if ((!FIXREVERTER[11919] && (nbfd == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     return NULL;
+    #ifdef FRCOV
+    }
+    #endif
 
   if (bfd_use_reserved_id)
     {
@@ -72,12 +90,27 @@ _bfd_new_bfd (void)
     nbfd->id = bfd_id_counter++;
 
   nbfd->memory = objalloc_create ();
-  if (nbfd->memory == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[11920]) {
+    if ((nbfd -> memory == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 11920\n");
+    else
+      fprintf(stderr, "reached bug index 11920\n");
+  }
+  if ((!FIXREVERTER[11920] && (nbfd -> memory == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     {
       bfd_set_error (bfd_error_no_memory);
       free (nbfd);
       return NULL;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
   nbfd->arch_info = &bfd_default_arch_struct;
 
@@ -102,8 +135,23 @@ _bfd_new_bfd_contained_in (bfd *obfd)
   bfd *nbfd;
 
   nbfd = _bfd_new_bfd ();
-  if (nbfd == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[11921]) {
+    if ((nbfd == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 11921\n");
+    else
+      fprintf(stderr, "reached bug index 11921\n");
+  }
+  if ((!FIXREVERTER[11921] && (nbfd == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     return NULL;
+    #ifdef FRCOV
+    }
+    #endif
   nbfd->xvec = obfd->xvec;
   nbfd->iovec = obfd->iovec;
   if (obfd->iovec == &opncls_iovec)
@@ -222,21 +270,51 @@ bfd_fopen (const char *filename, const char *target, const char *mode, int fd)
   const bfd_target *target_vec;
 
   nbfd = _bfd_new_bfd ();
-  if (nbfd == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[11922]) {
+    if ((nbfd == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 11922\n");
+    else
+      fprintf(stderr, "reached bug index 11922\n");
+  }
+  if ((!FIXREVERTER[11922] && (nbfd == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     {
       if (fd != -1)
 	close (fd);
       return NULL;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
   target_vec = bfd_find_target (target, nbfd);
-  if (target_vec == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[11923]) {
+    if ((target_vec == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 11923\n");
+    else
+      fprintf(stderr, "reached bug index 11923\n");
+  }
+  if ((!FIXREVERTER[11923] && (target_vec == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     {
       if (fd != -1)
 	close (fd);
       _bfd_delete_bfd (nbfd);
       return NULL;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
 #ifdef HAVE_FDOPEN
   if (fd != -1)
@@ -593,8 +671,23 @@ opncls_bclose (struct bfd *abfd)
      free it.  */
   int status = 0;
 
-  if (vec->close != NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[11927]) {
+    if ((vec -> close != (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 11927\n");
+    else
+      fprintf(stderr, "reached bug index 11927\n");
+  }
+  if ((!FIXREVERTER[11927] && (vec -> close != (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     status = (vec->close) (abfd, vec->stream);
+    #ifdef FRCOV
+    }
+    #endif
   abfd->iostream = NULL;
   return status;
 }
diff --git a/bfd/osf-core.c b/bfd/osf-core.c
old mode 100644
new mode 100755
diff --git a/bfd/pc532-mach.c b/bfd/pc532-mach.c
old mode 100644
new mode 100755
diff --git a/bfd/pdp11.c b/bfd/pdp11.c
old mode 100644
new mode 100755
index 2c9fe0a..13f91e2
--- a/bfd/pdp11.c
+++ b/bfd/pdp11.c
@@ -1,3 +1,6 @@
+#ifdef FRCOV
+extern short FIXREVERTER[];
+#endif
 /* BFD back-end for PDP-11 a.out binaries.
    Copyright (C) 2001-2021 Free Software Foundation, Inc.
 
@@ -3030,11 +3033,41 @@ aout_link_includes_newfunc (struct bfd_hash_entry *entry,
 
   /* Allocate the structure if it has not already been allocated by a
      subclass.  */
-  if (ret == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[2684]) {
+    if ((ret == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 2684\n");
+    else
+      fprintf(stderr, "reached bug index 2684\n");
+  }
+  if ((!FIXREVERTER[2684] && (ret == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     ret = bfd_hash_allocate (table,
 			     sizeof (struct aout_link_includes_entry));
-  if (ret == NULL)
+			     #ifdef FRCOV
+			     }
+			     #endif
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[2685]) {
+    if ((ret == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 2685\n");
+    else
+      fprintf(stderr, "reached bug index 2685\n");
+  }
+  if ((!FIXREVERTER[2685] && (ret == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     return NULL;
+    #ifdef FRCOV
+    }
+    #endif
 
   /* Call the allocation method of the superclass.  */
   ret = ((struct aout_link_includes_entry *)
diff --git a/bfd/pe-arm-wince.c b/bfd/pe-arm-wince.c
old mode 100644
new mode 100755
diff --git a/bfd/pe-arm.c b/bfd/pe-arm.c
old mode 100644
new mode 100755
diff --git a/bfd/pe-i386.c b/bfd/pe-i386.c
old mode 100644
new mode 100755
diff --git a/bfd/pe-mcore.c b/bfd/pe-mcore.c
old mode 100644
new mode 100755
diff --git a/bfd/pe-sh.c b/bfd/pe-sh.c
old mode 100644
new mode 100755
diff --git a/bfd/pe-x86_64.c b/bfd/pe-x86_64.c
old mode 100644
new mode 100755
diff --git a/bfd/peXXigen.c b/bfd/peXXigen.c
old mode 100644
new mode 100755
diff --git a/bfd/pef-traceback.h b/bfd/pef-traceback.h
old mode 100644
new mode 100755
diff --git a/bfd/pef.c b/bfd/pef.c
old mode 100644
new mode 100755
index f55e532..8ad6857
--- a/bfd/pef.c
+++ b/bfd/pef.c
@@ -1,3 +1,6 @@
+#ifdef FRCOV
+extern short FIXREVERTER[];
+#endif
 /* PEF support for BFD.
    Copyright (C) 1999-2021 Free Software Foundation, Inc.
 
@@ -86,8 +89,23 @@ bfd_pef_parse_traceback_table (bfd *abfd,
   const char *s;
   asymbol tmpsymbol;
 
-  if (sym == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[3368]) {
+    if ((sym == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 3368\n");
+    else
+      fprintf(stderr, "reached bug index 3368\n");
+  }
+  if ((!FIXREVERTER[3368] && (sym == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     sym = & tmpsymbol;
+    #ifdef FRCOV
+    }
+    #endif
 
   sym->name = NULL;
   sym->value = 0;
@@ -97,8 +115,23 @@ bfd_pef_parse_traceback_table (bfd *abfd,
   sym->udata.i = 0;
 
   /* memcpy is fine since all fields are unsigned char.  */
-  if ((pos + 8) > len)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[3369]) {
+    if ((pos + 8 > len ) && !(0))
+      fprintf(stderr, "triggered bug index 3369\n");
+    else
+      fprintf(stderr, "reached bug index 3369\n");
+  }
+  if ((!FIXREVERTER[3369] && (pos + 8 > len ))
+  #else
+  if (0
+  #endif
+  )
     return -1;
+    #ifdef FRCOV
+    }
+    #endif
   memcpy (&table, buf + pos, 8);
 
   /* Calling code relies on returned symbols having a name and
@@ -172,8 +205,23 @@ bfd_pef_parse_traceback_table (bfd *abfd,
 	return -1;
 
       namebuf = bfd_alloc (abfd, name.name_len + 1);
-      if (namebuf == NULL)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[3372]) {
+        if ((namebuf == (void *) 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 3372\n");
+        else
+          fprintf(stderr, "reached bug index 3372\n");
+      }
+      if ((!FIXREVERTER[3372] && (namebuf == (void *) 0 ))
+      #else
+      if (0
+      #endif
+      )
 	return -1;
+	#ifdef FRCOV
+	}
+	#endif
 
       memcpy (namebuf, buf + pos + offset, name.name_len);
       namebuf[name.name_len] = '\0';
@@ -303,8 +351,23 @@ bfd_pef_make_bfd_section (bfd *abfd, bfd_pef_section *section)
   const char *name = bfd_pef_section_name (section);
 
   bfdsec = bfd_make_section_anyway (abfd, name);
-  if (bfdsec == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[3373]) {
+    if ((bfdsec == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 3373\n");
+    else
+      fprintf(stderr, "reached bug index 3373\n");
+  }
+  if ((!FIXREVERTER[3373] && (bfdsec == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     return NULL;
+    #ifdef FRCOV
+    }
+    #endif
 
   bfdsec->vma = section->default_address + section->container_offset;
   bfdsec->lma = section->default_address + section->container_offset;
@@ -401,8 +464,23 @@ bfd_pef_scan_section (bfd *abfd, bfd_pef_section *section)
   section->reserved = buf[27];
 
   section->bfd_section = bfd_pef_make_bfd_section (abfd, section);
-  if (section->bfd_section == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[3375]) {
+    if ((section -> bfd_section == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 3375\n");
+    else
+      fprintf(stderr, "reached bug index 3375\n");
+  }
+  if ((!FIXREVERTER[3375] && (section -> bfd_section == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     return -1;
+    #ifdef FRCOV
+    }
+    #endif
 
   return 0;
 }
@@ -476,31 +554,106 @@ bfd_pef_scan_start_address (bfd *abfd)
   int ret;
 
   loadersec = bfd_get_section_by_name (abfd, "loader");
-  if (loadersec == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[3379]) {
+    if ((loadersec == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 3379\n");
+    else
+      fprintf(stderr, "reached bug index 3379\n");
+  }
+  if ((!FIXREVERTER[3379] && (loadersec == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     goto end;
+    #ifdef FRCOV
+    }
+    #endif
 
   loaderlen = loadersec->size;
-  if (loaderlen < 56)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[3380]) {
+    if ((loaderlen < 56 ) && !(0))
+      fprintf(stderr, "triggered bug index 3380\n");
+    else
+      fprintf(stderr, "reached bug index 3380\n");
+  }
+  if ((!FIXREVERTER[3380] && (loaderlen < 56 ))
+  #else
+  if (0
+  #endif
+  )
     goto error;
+    #ifdef FRCOV
+    }
+    #endif
   if (bfd_seek (abfd, loadersec->filepos, SEEK_SET) != 0)
     goto error;
   loaderbuf = _bfd_malloc_and_read (abfd, loaderlen, loaderlen);
-  if (loaderbuf == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[3381]) {
+    if ((loaderbuf == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 3381\n");
+    else
+      fprintf(stderr, "reached bug index 3381\n");
+  }
+  if ((!FIXREVERTER[3381] && (loaderbuf == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     goto error;
+    #ifdef FRCOV
+    }
+    #endif
 
   ret = bfd_pef_parse_loader_header (abfd, loaderbuf, 56, &header);
   if (ret < 0)
     goto error;
 
-  if (header.main_section < 0)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[3383]) {
+    if ((header . main_section < 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 3383\n");
+    else
+      fprintf(stderr, "reached bug index 3383\n");
+  }
+  if ((!FIXREVERTER[3383] && (header . main_section < 0 ))
+  #else
+  if (0
+  #endif
+  )
     goto end;
+    #ifdef FRCOV
+    }
+    #endif
 
   for (section = abfd->sections; section != NULL; section = section->next)
     if ((long) (section->index + 1) == header.main_section)
       break;
 
-  if (section == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[3384]) {
+    if ((section == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 3384\n");
+    else
+      fprintf(stderr, "reached bug index 3384\n");
+  }
+  if ((!FIXREVERTER[3384] && (section == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     goto error;
+    #ifdef FRCOV
+    }
+    #endif
 
   abfd->start_address = section->vma + header.main_offset;
 
@@ -542,8 +695,23 @@ bfd_pef_scan (bfd *abfd,
     {
       mdata->sections = bfd_alloc (abfd, header->section_count * sizeof (bfd_pef_section));
 
-      if (mdata->sections == NULL)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[3385]) {
+        if ((mdata -> sections == (void *) 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 3385\n");
+        else
+          fprintf(stderr, "reached bug index 3385\n");
+      }
+      if ((!FIXREVERTER[3385] && (mdata -> sections == (void *) 0 ))
+      #else
+      if (0
+      #endif
+      )
 	return -1;
+	#ifdef FRCOV
+	}
+	#endif
 
       for (i = 0; i < header->section_count; i++)
 	{
@@ -596,12 +764,42 @@ bfd_pef_object_p (bfd *abfd)
   if (bfd_pef_read_header (abfd, &header) != 0)
     goto wrong;
 
-  if (header.tag1 != BFD_PEF_TAG1 || header.tag2 != BFD_PEF_TAG2)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[3387]) {
+    if ((header . tag1 != 1248819489 || header . tag2 != 1885693542 ) && !(0))
+      fprintf(stderr, "triggered bug index 3387\n");
+    else
+      fprintf(stderr, "reached bug index 3387\n");
+  }
+  if ((!FIXREVERTER[3387] && (header . tag1 != 1248819489 || header . tag2 != 1885693542 ))
+  #else
+  if (0
+  #endif
+  )
     goto wrong;
+    #ifdef FRCOV
+    }
+    #endif
 
   mdata = (bfd_pef_data_struct *) bfd_zalloc (abfd, sizeof (*mdata));
-  if (mdata == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[3388]) {
+    if ((mdata == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 3388\n");
+    else
+      fprintf(stderr, "reached bug index 3388\n");
+  }
+  if ((!FIXREVERTER[3388] && (mdata == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     goto fail;
+    #ifdef FRCOV
+    }
+    #endif
 
   if (bfd_pef_scan (abfd, &header, mdata))
     goto wrong;
@@ -651,17 +849,47 @@ bfd_pef_parse_traceback_tables (bfd *abfd,
 	  pos += 4;
 	}
 
-      if ((pos + 4) > len)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[3389]) {
+        if ((pos + 4 > len ) && !(0))
+          fprintf(stderr, "triggered bug index 3389\n");
+        else
+          fprintf(stderr, "reached bug index 3389\n");
+      }
+      if ((!FIXREVERTER[3389] && (pos + 4 > len ))
+      #else
+      if (0
+      #endif
+      )
 	break;
+	#ifdef FRCOV
+	}
+	#endif
 
       ret = bfd_pef_parse_traceback_table (abfd, sec, buf, len, pos + 4,
 					   &function, 0);
-      if (ret < 0)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[3390]) {
+        if ((ret < 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 3390\n");
+        else
+          fprintf(stderr, "reached bug index 3390\n");
+      }
+      if ((!FIXREVERTER[3390] && (ret < 0 ))
+      #else
+      if (0
+      #endif
+      )
 	{
 	  /* Skip over 0x0L to advance to next possible traceback table.  */
 	  pos += 4;
 	  continue;
 	}
+	#ifdef FRCOV
+	}
+	#endif
 
       BFD_ASSERT (function.name != NULL);
 
@@ -671,12 +899,27 @@ bfd_pef_parse_traceback_tables (bfd *abfd,
 	{
 	  tbnamelen = strlen (tbprefix) + strlen (function.name);
 	  name = bfd_alloc (abfd, tbnamelen + 1);
-	  if (name == NULL)
+	  
+	  #ifdef FRCOV
+	  {if (FIXREVERTER[3391]) {
+	    if ((name == (void *) 0 ) && !(0))
+	      fprintf(stderr, "triggered bug index 3391\n");
+	    else
+	      fprintf(stderr, "reached bug index 3391\n");
+	  }
+	  if ((!FIXREVERTER[3391] && (name == (void *) 0 ))
+	  #else
+	  if (0
+	  #endif
+	  )
 	    {
 	      bfd_release (abfd, (void *) function.name);
 	      function.name = NULL;
 	      break;
 	    }
+	    #ifdef FRCOV
+	    }
+	    #endif
 	  snprintf (name, tbnamelen + 1, "%s%s", tbprefix, function.name);
 	  traceback.name = name;
 	  traceback.value = pos;
@@ -754,8 +997,23 @@ bfd_pef_parse_function_stubs (bfd *abfd,
     (header.imported_library_count * sizeof (bfd_pef_imported_library));
   imports = bfd_malloc
     (header.total_imported_symbol_count * sizeof (bfd_pef_imported_symbol));
-  if (libraries == NULL || imports == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[3394]) {
+    if ((libraries == (void *) 0 || imports == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 3394\n");
+    else
+      fprintf(stderr, "reached bug index 3394\n");
+  }
+  if ((!FIXREVERTER[3394] && (libraries == (void *) 0 || imports == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     goto error;
+    #ifdef FRCOV
+    }
+    #endif
 
   if (loaderlen < (56 + (header.imported_library_count * 24)))
     goto error;
@@ -802,8 +1060,23 @@ bfd_pef_parse_function_stubs (bfd *abfd,
 	  codepos += 4;
 	}
 
-      if ((codepos + 24) > codelen)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[3397]) {
+        if ((codepos + 24 > codelen ) && !(0))
+          fprintf(stderr, "triggered bug index 3397\n");
+        else
+          fprintf(stderr, "reached bug index 3397\n");
+      }
+      if ((!FIXREVERTER[3397] && (codepos + 24 > codelen ))
+      #else
+      if (0
+      #endif
+      )
 	break;
+	#ifdef FRCOV
+	}
+	#endif
 
       ret = bfd_pef_parse_function_stub (abfd, codebuf + codepos, 24, &sym_index);
       if (ret < 0)
@@ -812,11 +1085,26 @@ bfd_pef_parse_function_stubs (bfd *abfd,
 	  continue;
 	}
 
-      if (sym_index >= header.total_imported_symbol_count)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[3399]) {
+        if ((sym_index >= header . total_imported_symbol_count ) && !(0))
+          fprintf(stderr, "triggered bug index 3399\n");
+        else
+          fprintf(stderr, "reached bug index 3399\n");
+      }
+      if ((!FIXREVERTER[3399] && (sym_index >= header . total_imported_symbol_count ))
+      #else
+      if (0
+      #endif
+      )
 	{
 	  codepos += 24;
 	  continue;
 	}
+	#ifdef FRCOV
+	}
+	#endif
 
       {
 	size_t max, namelen;
@@ -841,8 +1129,23 @@ bfd_pef_parse_function_stubs (bfd *abfd,
 	  goto error;
 
 	name = bfd_alloc (abfd, strlen (sprefix) + namelen + 1);
-	if (name == NULL)
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[3400]) {
+	  if ((name == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 3400\n");
+	  else
+	    fprintf(stderr, "reached bug index 3400\n");
+	}
+	if ((!FIXREVERTER[3400] && (name == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	)
 	  break;
+	  #ifdef FRCOV
+	  }
+	  #endif
 
 	snprintf (name, strlen (sprefix) + namelen + 1, "%s%s",
 		  sprefix, symname);
@@ -898,8 +1201,23 @@ bfd_pef_parse_symbols (bfd *abfd, asymbol **csym)
       if (bfd_seek (abfd, codesec->filepos, SEEK_SET) != 0)
 	goto end;
       codebuf = _bfd_malloc_and_read (abfd, codelen, codelen);
-      if (codebuf == NULL)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[3401]) {
+        if ((codebuf == (void *) 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 3401\n");
+        else
+          fprintf(stderr, "reached bug index 3401\n");
+      }
+      if ((!FIXREVERTER[3401] && (codebuf == (void *) 0 ))
+      #else
+      if (0
+      #endif
+      )
 	goto end;
+	#ifdef FRCOV
+	}
+	#endif
     }
 
   loadersec = bfd_get_section_by_name (abfd, "loader");
@@ -909,8 +1227,23 @@ bfd_pef_parse_symbols (bfd *abfd, asymbol **csym)
       if (bfd_seek (abfd, loadersec->filepos, SEEK_SET) != 0)
 	goto end;
       loaderbuf = _bfd_malloc_and_read (abfd, loaderlen, loaderlen);
-      if (loaderbuf == NULL)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[3402]) {
+        if ((loaderbuf == (void *) 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 3402\n");
+        else
+          fprintf(stderr, "reached bug index 3402\n");
+      }
+      if ((!FIXREVERTER[3402] && (loaderbuf == (void *) 0 ))
+      #else
+      if (0
+      #endif
+      )
 	goto end;
+	#ifdef FRCOV
+	}
+	#endif
     }
 
   count = 0;
@@ -951,8 +1284,23 @@ bfd_pef_get_symtab_upper_bound (bfd *abfd)
 {
   long nsyms = bfd_pef_count_symbols (abfd);
 
-  if (nsyms < 0)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[3403]) {
+    if ((nsyms < 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 3403\n");
+    else
+      fprintf(stderr, "reached bug index 3403\n");
+  }
+  if ((!FIXREVERTER[3403] && (nsyms < 0 ))
+  #else
+  if (0
+  #endif
+  )
     return nsyms;
+    #ifdef FRCOV
+    }
+    #endif
   return ((nsyms + 1) * sizeof (asymbol *));
 }
 
@@ -964,12 +1312,42 @@ bfd_pef_canonicalize_symtab (bfd *abfd, asymbol **alocation)
   long ret;
   long nsyms = bfd_pef_count_symbols (abfd);
 
-  if (nsyms < 0)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[3404]) {
+    if ((nsyms < 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 3404\n");
+    else
+      fprintf(stderr, "reached bug index 3404\n");
+  }
+  if ((!FIXREVERTER[3404] && (nsyms < 0 ))
+  #else
+  if (0
+  #endif
+  )
     return nsyms;
+    #ifdef FRCOV
+    }
+    #endif
 
   syms = bfd_alloc (abfd, nsyms * sizeof (asymbol));
-  if (syms == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[3405]) {
+    if ((syms == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 3405\n");
+    else
+      fprintf(stderr, "reached bug index 3405\n");
+  }
+  if ((!FIXREVERTER[3405] && (syms == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     return -1;
+    #ifdef FRCOV
+    }
+    #endif
 
   for (i = 0; i < nsyms; i++)
     alocation[i] = &syms[i];
@@ -977,8 +1355,23 @@ bfd_pef_canonicalize_symtab (bfd *abfd, asymbol **alocation)
   alocation[nsyms] = NULL;
 
   ret = bfd_pef_parse_symbols (abfd, alocation);
-  if (ret != nsyms)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[3406]) {
+    if ((ret != nsyms ) && !(0))
+      fprintf(stderr, "triggered bug index 3406\n");
+    else
+      fprintf(stderr, "reached bug index 3406\n");
+  }
+  if ((!FIXREVERTER[3406] && (ret != nsyms ))
+  #else
+  if (0
+  #endif
+  )
     return 0;
+    #ifdef FRCOV
+    }
+    #endif
 
   return ret;
 }
@@ -1104,8 +1497,23 @@ bfd_pef_xlib_scan (bfd *abfd, bfd_pef_xlib_header *header)
   bfd_pef_xlib_data_struct *mdata = NULL;
 
   mdata = bfd_alloc (abfd, sizeof (* mdata));
-  if (mdata == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[3408]) {
+    if ((mdata == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 3408\n");
+    else
+      fprintf(stderr, "reached bug index 3408\n");
+  }
+  if ((!FIXREVERTER[3408] && (mdata == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     return -1;
+    #ifdef FRCOV
+    }
+    #endif
 
   mdata->header = *header;
 
diff --git a/bfd/pef.h b/bfd/pef.h
old mode 100644
new mode 100755
diff --git a/bfd/pei-arm-wince.c b/bfd/pei-arm-wince.c
old mode 100644
new mode 100755
diff --git a/bfd/pei-arm.c b/bfd/pei-arm.c
old mode 100644
new mode 100755
diff --git a/bfd/pei-i386.c b/bfd/pei-i386.c
old mode 100644
new mode 100755
diff --git a/bfd/pei-ia64.c b/bfd/pei-ia64.c
old mode 100644
new mode 100755
diff --git a/bfd/pei-mcore.c b/bfd/pei-mcore.c
old mode 100644
new mode 100755
diff --git a/bfd/pei-sh.c b/bfd/pei-sh.c
old mode 100644
new mode 100755
diff --git a/bfd/pei-x86_64.c b/bfd/pei-x86_64.c
old mode 100644
new mode 100755
diff --git a/bfd/peicode.h b/bfd/peicode.h
old mode 100644
new mode 100755
diff --git a/bfd/plugin.c b/bfd/plugin.c
old mode 100644
new mode 100755
index c4f2be8..e23353b
--- a/bfd/plugin.c
+++ b/bfd/plugin.c
@@ -1,3 +1,6 @@
+#ifdef FRCOV
+extern short FIXREVERTER[];
+#endif
 /* Plugin support for BFD.
    Copyright (C) 2009-2021 Free Software Foundation, Inc.
 
@@ -288,14 +291,44 @@ try_load_plugin (const char *pname,
       size_t length_plugin_name = strlen (pname) + 1;
       char *plugin_name = bfd_malloc (length_plugin_name);
 
-      if (plugin_name == NULL)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[1743]) {
+        if ((plugin_name == (void *) 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 1743\n");
+        else
+          fprintf(stderr, "reached bug index 1743\n");
+      }
+      if ((!FIXREVERTER[1743] && (plugin_name == (void *) 0 ))
+      #else
+      if (0
+      #endif
+      )
 	goto short_circuit;
+	#ifdef FRCOV
+	}
+	#endif
       plugin_list_iter = bfd_malloc (sizeof *plugin_list_iter);
-      if (plugin_list_iter == NULL)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[1744]) {
+        if ((plugin_list_iter == (void *) 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 1744\n");
+        else
+          fprintf(stderr, "reached bug index 1744\n");
+      }
+      if ((!FIXREVERTER[1744] && (plugin_list_iter == (void *) 0 ))
+      #else
+      if (0
+      #endif
+      )
 	{
 	  free (plugin_name);
 	  goto short_circuit;
 	}
+	#ifdef FRCOV
+	}
+	#endif
       /* Make a copy of PNAME since PNAME from load_plugin () will be
 	 freed.  */
       memcpy (plugin_name, pname, length_plugin_name);
@@ -690,8 +723,23 @@ static asymbol *
 bfd_plugin_make_empty_symbol (bfd *abfd)
 {
   asymbol *new_symbol = bfd_zalloc (abfd, sizeof (asymbol));
-  if (new_symbol == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[1748]) {
+    if ((new_symbol == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 1748\n");
+    else
+      fprintf(stderr, "reached bug index 1748\n");
+  }
+  if ((!FIXREVERTER[1748] && (new_symbol == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     return new_symbol;
+    #ifdef FRCOV
+    }
+    #endif
   new_symbol->the_bfd = abfd;
   return new_symbol;
 }
diff --git a/bfd/plugin.h b/bfd/plugin.h
old mode 100644
new mode 100755
diff --git a/bfd/po/.cvsignore b/bfd/po/.cvsignore
old mode 100644
new mode 100755
diff --git a/bfd/po/BLD-POTFILES.in b/bfd/po/BLD-POTFILES.in
old mode 100644
new mode 100755
diff --git a/bfd/po/Make-in b/bfd/po/Make-in
old mode 100644
new mode 100755
diff --git a/bfd/po/SRC-POTFILES.in b/bfd/po/SRC-POTFILES.in
old mode 100644
new mode 100755
diff --git a/bfd/po/bfd.pot b/bfd/po/bfd.pot
old mode 100644
new mode 100755
diff --git a/bfd/po/da.po b/bfd/po/da.po
old mode 100644
new mode 100755
diff --git a/bfd/po/es.po b/bfd/po/es.po
old mode 100644
new mode 100755
diff --git a/bfd/po/fi.po b/bfd/po/fi.po
old mode 100644
new mode 100755
diff --git a/bfd/po/fr.po b/bfd/po/fr.po
old mode 100644
new mode 100755
diff --git a/bfd/po/hr.po b/bfd/po/hr.po
old mode 100644
new mode 100755
diff --git a/bfd/po/id.po b/bfd/po/id.po
old mode 100644
new mode 100755
diff --git a/bfd/po/ja.po b/bfd/po/ja.po
old mode 100644
new mode 100755
diff --git a/bfd/po/pt.po b/bfd/po/pt.po
old mode 100644
new mode 100755
diff --git a/bfd/po/ro.po b/bfd/po/ro.po
old mode 100644
new mode 100755
diff --git a/bfd/po/ru.po b/bfd/po/ru.po
old mode 100644
new mode 100755
diff --git a/bfd/po/rw.po b/bfd/po/rw.po
old mode 100644
new mode 100755
diff --git a/bfd/po/sr.po b/bfd/po/sr.po
old mode 100644
new mode 100755
diff --git a/bfd/po/sv.po b/bfd/po/sv.po
old mode 100644
new mode 100755
diff --git a/bfd/po/tr.po b/bfd/po/tr.po
old mode 100644
new mode 100755
diff --git a/bfd/po/uk.po b/bfd/po/uk.po
old mode 100644
new mode 100755
diff --git a/bfd/po/vi.po b/bfd/po/vi.po
old mode 100644
new mode 100755
diff --git a/bfd/po/zh_CN.po b/bfd/po/zh_CN.po
old mode 100644
new mode 100755
diff --git a/bfd/ppcboot.c b/bfd/ppcboot.c
old mode 100644
new mode 100755
diff --git a/bfd/ptrace-core.c b/bfd/ptrace-core.c
old mode 100644
new mode 100755
diff --git a/bfd/reloc.c b/bfd/reloc.c
old mode 100644
new mode 100755
index 6d920e1..8c8c039
--- a/bfd/reloc.c
+++ b/bfd/reloc.c
@@ -1,3 +1,6 @@
+#ifdef FRCOV
+extern short FIXREVERTER[];
+#endif
 /* BFD support for handling relocation entries.
    Copyright (C) 1990-2021 Free Software Foundation, Inc.
    Written by Cygnus Support.
@@ -723,8 +726,23 @@ bfd_perform_relocation (bfd *abfd,
     }
 
   /* PR 17512: file: 0f67f69d.  */
-  if (howto == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[8197]) {
+    if ((howto == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 8197\n");
+    else
+      fprintf(stderr, "reached bug index 8197\n");
+  }
+  if ((!FIXREVERTER[8197] && (howto == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     return bfd_reloc_undefined;
+    #ifdef FRCOV
+    }
+    #endif
 
   /* Is the address of the relocation really within the section?  */
   octets = reloc_entry->address * bfd_octets_per_byte (abfd, input_section);
@@ -8393,15 +8411,45 @@ bfd_generic_get_relocated_section_contents (bfd *abfd,
   if (!bfd_get_full_section_contents (input_bfd, input_section, &data))
     return NULL;
 
-  if (data == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[8199]) {
+    if ((data == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 8199\n");
+    else
+      fprintf(stderr, "reached bug index 8199\n");
+  }
+  if ((!FIXREVERTER[8199] && (data == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     return NULL;
+    #ifdef FRCOV
+    }
+    #endif
 
   if (reloc_size == 0)
     return data;
 
   reloc_vector = (arelent **) bfd_malloc (reloc_size);
-  if (reloc_vector == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[8201]) {
+    if ((reloc_vector == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 8201\n");
+    else
+      fprintf(stderr, "reached bug index 8201\n");
+  }
+  if ((!FIXREVERTER[8201] && (reloc_vector == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     return NULL;
+    #ifdef FRCOV
+    }
+    #endif
 
   reloc_count = bfd_canonicalize_reloc (input_bfd,
 					input_section,
@@ -8423,7 +8471,19 @@ bfd_generic_get_relocated_section_contents (bfd *abfd,
 	  symbol = *(*parent)->sym_ptr_ptr;
 	  /* PR ld/19628: A specially crafted input file
 	     can result in a NULL symbol pointer here.  */
-	  if (symbol == NULL)
+	  
+	  #ifdef FRCOV
+	  {if (FIXREVERTER[8203]) {
+	    if ((symbol == (void *) 0 ) && !(0))
+	      fprintf(stderr, "triggered bug index 8203\n");
+	    else
+	      fprintf(stderr, "reached bug index 8203\n");
+	  }
+	  if ((!FIXREVERTER[8203] && (symbol == (void *) 0 ))
+	  #else
+	  if (0
+	  #endif
+	  )
 	    {
 	      link_info->callbacks->einfo
 		/* xgettext:c-format */
@@ -8431,6 +8491,9 @@ bfd_generic_get_relocated_section_contents (bfd *abfd,
 		 abfd, input_section, (* parent)->address);
 	      goto error_return;
 	    }
+	    #ifdef FRCOV
+	    }
+	    #endif
 
 	  /* Zap reloc field when the symbol is from a discarded
 	     section, ignoring any addend.  Do the same when called
diff --git a/bfd/reloc16.c b/bfd/reloc16.c
old mode 100644
new mode 100755
diff --git a/bfd/rs6000-core.c b/bfd/rs6000-core.c
old mode 100644
new mode 100755
diff --git a/bfd/sco5-core.c b/bfd/sco5-core.c
old mode 100644
new mode 100755
diff --git a/bfd/section.c b/bfd/section.c
old mode 100644
new mode 100755
index a353488..438fdc2
--- a/bfd/section.c
+++ b/bfd/section.c
@@ -1,3 +1,6 @@
+#ifdef FRCOV
+extern short FIXREVERTER[];
+#endif
 /* Object file "section" support for the BFD library.
    Copyright (C) 1990-2021 Free Software Foundation, Inc.
    Written by Cygnus Support.
@@ -791,8 +794,23 @@ bfd_section_hash_newfunc (struct bfd_hash_entry *entry,
     {
       entry = (struct bfd_hash_entry *)
 	bfd_hash_allocate (table, sizeof (struct section_hash_entry));
-      if (entry == NULL)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[5129]) {
+        if ((entry == (void *) 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 5129\n");
+        else
+          fprintf(stderr, "reached bug index 5129\n");
+      }
+      if ((!FIXREVERTER[5129] && (entry == (void *) 0 ))
+      #else
+      if (0
+      #endif
+      )
 	return entry;
+	#ifdef FRCOV
+	}
+	#endif
     }
 
   /* Call the allocation method of the superclass.  */
@@ -1007,8 +1025,23 @@ bfd_get_section_by_name_if (bfd *abfd, const char *name,
   unsigned long hash;
 
   sh = section_hash_lookup (&abfd->section_htab, name, false, false);
-  if (sh == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[5130]) {
+    if ((sh == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 5130\n");
+    else
+      fprintf(stderr, "reached bug index 5130\n");
+  }
+  if ((!FIXREVERTER[5130] && (sh == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     return NULL;
+    #ifdef FRCOV
+    }
+    #endif
 
   hash = sh->root.hash;
   for (; sh != NULL; sh = (struct section_hash_entry *) sh->root.next)
@@ -1115,8 +1148,23 @@ bfd_make_section_old_way (bfd *abfd, const char *name)
       struct section_hash_entry *sh;
 
       sh = section_hash_lookup (&abfd->section_htab, name, true, false);
-      if (sh == NULL)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[5134]) {
+        if ((sh == (void *) 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 5134\n");
+        else
+          fprintf(stderr, "reached bug index 5134\n");
+      }
+      if ((!FIXREVERTER[5134] && (sh == (void *) 0 ))
+      #else
+      if (0
+      #endif
+      )
 	return NULL;
+	#ifdef FRCOV
+	}
+	#endif
 
       newsect = &sh->section;
       if (newsect->name != NULL)
@@ -1170,8 +1218,23 @@ bfd_make_section_anyway_with_flags (bfd *abfd, const char *name,
     }
 
   sh = section_hash_lookup (&abfd->section_htab, name, true, false);
-  if (sh == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[5135]) {
+    if ((sh == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 5135\n");
+    else
+      fprintf(stderr, "reached bug index 5135\n");
+  }
+  if ((!FIXREVERTER[5135] && (sh == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     return NULL;
+    #ifdef FRCOV
+    }
+    #endif
 
   newsect = &sh->section;
   if (newsect->name != NULL)
@@ -1183,8 +1246,23 @@ bfd_make_section_anyway_with_flags (bfd *abfd, const char *name,
       struct section_hash_entry *new_sh;
       new_sh = (struct section_hash_entry *)
 	bfd_section_hash_newfunc (NULL, &abfd->section_htab, name);
-      if (new_sh == NULL)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[5136]) {
+        if ((new_sh == (void *) 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 5136\n");
+        else
+          fprintf(stderr, "reached bug index 5136\n");
+      }
+      if ((!FIXREVERTER[5136] && (new_sh == (void *) 0 ))
+      #else
+      if (0
+      #endif
+      )
 	return NULL;
+	#ifdef FRCOV
+	}
+	#endif
 
       new_sh->root = sh->root;
       sh->root.next = &new_sh->root;
@@ -1255,8 +1333,23 @@ bfd_make_section_with_flags (bfd *abfd, const char *name,
     return NULL;
 
   sh = section_hash_lookup (&abfd->section_htab, name, true, false);
-  if (sh == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[5137]) {
+    if ((sh == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 5137\n");
+    else
+      fprintf(stderr, "reached bug index 5137\n");
+  }
+  if ((!FIXREVERTER[5137] && (sh == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     return NULL;
+    #ifdef FRCOV
+    }
+    #endif
 
   newsect = &sh->section;
   if (newsect->name != NULL)
diff --git a/bfd/simple.c b/bfd/simple.c
old mode 100644
new mode 100755
index 975d01f..26cc109
--- a/bfd/simple.c
+++ b/bfd/simple.c
@@ -1,3 +1,6 @@
+#ifdef FRCOV
+extern short FIXREVERTER[];
+#endif
 /* simple.c -- BFD simple client routines
    Copyright (C) 2002-2021 Free Software Foundation, Inc.
    Contributed by MontaVista Software, Inc.
@@ -172,8 +175,23 @@ simple_restore_output_info (bfd *abfd ATTRIBUTE_UNUSED,
   struct saved_offsets *saved_offsets = (struct saved_offsets *) ptr;
   struct saved_output_info *output_info;
 
-  if (section->index >= saved_offsets->section_count)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[5629]) {
+    if ((section -> index >= saved_offsets -> section_count ) && !(0))
+      fprintf(stderr, "triggered bug index 5629\n");
+    else
+      fprintf(stderr, "reached bug index 5629\n");
+  }
+  if ((!FIXREVERTER[5629] && (section -> index >= saved_offsets -> section_count ))
+  #else
+  if (0
+  #endif
+  )
     return;
+    #ifdef FRCOV
+    }
+    #endif
 
   output_info = &saved_offsets->sections[section->index];
   section->output_offset = output_info->offset;
diff --git a/bfd/som.c b/bfd/som.c
old mode 100644
new mode 100755
index 42ecc76..6283fd1
--- a/bfd/som.c
+++ b/bfd/som.c
@@ -1,3 +1,6 @@
+#ifdef FRCOV
+extern short FIXREVERTER[];
+#endif
 /* bfd back-end for HP PA-RISC SOM objects.
    Copyright (C) 1990-2021 Free Software Foundation, Inc.
 
@@ -2091,8 +2094,23 @@ setup_sections (bfd *abfd,
 		SEEK_SET) != 0)
     goto error_return;
   space_strings = (char *) _bfd_malloc_and_read (abfd, amt + 1, amt);
-  if (space_strings == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[1523]) {
+    if ((space_strings == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 1523\n");
+    else
+      fprintf(stderr, "reached bug index 1523\n");
+  }
+  if ((!FIXREVERTER[1523] && (space_strings == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     goto error_return;
+    #ifdef FRCOV
+    }
+    #endif
   /* Make sure that the string table is NUL terminated.  */
   space_strings[amt] = 0;
 
@@ -2122,8 +2140,23 @@ setup_sections (bfd *abfd,
       som_swap_space_dictionary_in (&ext_space, &space);
 
       /* Setup the space name string.  */
-      if (space.name >= file_hdr->space_strings_size)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[1524]) {
+        if ((space . name >= file_hdr -> space_strings_size ) && !(0))
+          fprintf(stderr, "triggered bug index 1524\n");
+        else
+          fprintf(stderr, "reached bug index 1524\n");
+      }
+      if ((!FIXREVERTER[1524] && (space . name >= file_hdr -> space_strings_size ))
+      #else
+      if (0
+      #endif
+      )
 	goto error_return;
+	#ifdef FRCOV
+	}
+	#endif
 
       space_name = space.name + space_strings;
 
@@ -2148,8 +2181,23 @@ setup_sections (bfd *abfd,
 	goto error_return;
 
       /* If the space has no subspaces, then we're done.  */
-      if (space.subspace_quantity == 0)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[1525]) {
+        if ((space . subspace_quantity == 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 1525\n");
+        else
+          fprintf(stderr, "reached bug index 1525\n");
+      }
+      if ((!FIXREVERTER[1525] && (space . subspace_quantity == 0 ))
+      #else
+      if (0
+      #endif
+      )
 	continue;
+	#ifdef FRCOV
+	}
+	#endif
 
       /* Now, read in the first subspace for this space.  */
       if (bfd_seek (abfd,
@@ -2196,8 +2244,23 @@ setup_sections (bfd *abfd,
 	  som_swap_subspace_dictionary_in (&ext_subspace, &subspace);
 
 	  /* Setup the subspace name string.  */
-	  if (subspace.name >= file_hdr->space_strings_size)
+	  
+	  #ifdef FRCOV
+	  {if (FIXREVERTER[1526]) {
+	    if ((subspace . name >= file_hdr -> space_strings_size ) && !(0))
+	      fprintf(stderr, "triggered bug index 1526\n");
+	    else
+	      fprintf(stderr, "reached bug index 1526\n");
+	  }
+	  if ((!FIXREVERTER[1526] && (subspace . name >= file_hdr -> space_strings_size ))
+	  #else
+	  if (0
+	  #endif
+	  )
 	    goto error_return;
+	    #ifdef FRCOV
+	    }
+	    #endif
 
 	  subspace_name = subspace.name + space_strings;
 
@@ -2349,8 +2412,23 @@ setup_sections (bfd *abfd,
       goto error_return;
     }
   subspace_sections = bfd_malloc (amt);
-  if (subspace_sections == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[1528]) {
+    if ((subspace_sections == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 1528\n");
+    else
+      fprintf(stderr, "reached bug index 1528\n");
+  }
+  if ((!FIXREVERTER[1528] && (subspace_sections == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     goto error_return;
+    #ifdef FRCOV
+    }
+    #endif
 
   for (i = 0, section = abfd->sections; section; section = section->next)
     {
@@ -2501,8 +2579,23 @@ som_object_p (bfd *abfd)
 
       aux_hdr_ptr = bfd_zalloc (abfd,
 				(bfd_size_type) sizeof (*aux_hdr_ptr));
-      if (aux_hdr_ptr == NULL)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[1529]) {
+        if ((aux_hdr_ptr == (void *) 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 1529\n");
+        else
+          fprintf(stderr, "reached bug index 1529\n");
+      }
+      if ((!FIXREVERTER[1529] && (aux_hdr_ptr == (void *) 0 ))
+      #else
+      if (0
+      #endif
+      )
 	return NULL;
+	#ifdef FRCOV
+	}
+	#endif
       amt = sizeof (struct som_external_exec_auxhdr);
       if (bfd_bread (&ext_exec_auxhdr, amt, abfd) != amt)
 	{
@@ -2549,8 +2642,23 @@ som_prep_headers (bfd *abfd)
 
   /* Make and attach a file header to the BFD.  */
   file_hdr = bfd_zalloc (abfd, amt);
-  if (file_hdr == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[1530]) {
+    if ((file_hdr == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 1530\n");
+    else
+      fprintf(stderr, "reached bug index 1530\n");
+  }
+  if ((!FIXREVERTER[1530] && (file_hdr == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     return false;
+    #ifdef FRCOV
+    }
+    #endif
   obj_som_file_hdr (abfd) = file_hdr;
 
   if (abfd->flags & (EXEC_P | DYNAMIC))
@@ -2803,8 +2911,23 @@ som_prep_for_fixups (bfd *abfd, asymbol **syms, unsigned long num_syms)
   asymbol **sorted_syms;
   size_t amt;
 
-  if (num_syms == 0)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[1532]) {
+    if ((num_syms == 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 1532\n");
+    else
+      fprintf(stderr, "reached bug index 1532\n");
+  }
+  if ((!FIXREVERTER[1532] && (num_syms == 0 ))
+  #else
+  if (0
+  #endif
+  )
     return true;
+    #ifdef FRCOV
+    }
+    #endif
 
   /* Most SOM relocations involving a symbol have a length which is
      dependent on the index of the symbol.  So symbols which are
@@ -2882,8 +3005,23 @@ som_prep_for_fixups (bfd *abfd, asymbol **syms, unsigned long num_syms)
       return false;
     }
   sorted_syms = bfd_zalloc (abfd, amt);
-  if (sorted_syms == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[1533]) {
+    if ((sorted_syms == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 1533\n");
+    else
+      fprintf(stderr, "reached bug index 1533\n");
+  }
+  if ((!FIXREVERTER[1533] && (sorted_syms == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     return false;
+    #ifdef FRCOV
+    }
+    #endif
   memcpy (sorted_syms, syms, num_syms * sizeof (asymbol *));
   qsort (sorted_syms, num_syms, sizeof (asymbol *), compare_syms);
   obj_som_sorted_syms (abfd) = sorted_syms;
@@ -3325,8 +3463,23 @@ som_write_space_strings (bfd *abfd,
   size_t amt;
   bfd_size_type res;
 
-  if (tmp_space == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[1535]) {
+    if ((tmp_space == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 1535\n");
+    else
+      fprintf(stderr, "reached bug index 1535\n");
+  }
+  if ((!FIXREVERTER[1535] && (tmp_space == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     return false;
+    #ifdef FRCOV
+    }
+    #endif
 
   /* Seek to the start of the space strings in preparation for writing
      them out.  */
@@ -3411,8 +3564,23 @@ som_write_space_strings (bfd *abfd,
   amt = p - tmp_space;
   res = bfd_bwrite ((void *) &tmp_space[0], amt, abfd);
   free (tmp_space);
-  if (res != amt)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[1536]) {
+    if ((res != amt ) && !(0))
+      fprintf(stderr, "triggered bug index 1536\n");
+    else
+      fprintf(stderr, "reached bug index 1536\n");
+  }
+  if ((!FIXREVERTER[1536] && (res != amt ))
+  #else
+  if (0
+  #endif
+  )
     return false;
+    #ifdef FRCOV
+    }
+    #endif
   *string_sizep = strings_size;
   return true;
 }
@@ -3437,8 +3605,23 @@ som_write_symbol_strings (bfd *abfd,
   size_t amt;
   bfd_size_type res;
 
-  if (tmp_space == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[1537]) {
+    if ((tmp_space == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 1537\n");
+    else
+      fprintf(stderr, "reached bug index 1537\n");
+  }
+  if ((!FIXREVERTER[1537] && (tmp_space == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     return false;
+    #ifdef FRCOV
+    }
+    #endif
 
   /* This gets a bit gruesome because of the compilation unit.  The
      strings within the compilation unit are part of the symbol
@@ -3587,8 +3770,23 @@ som_write_symbol_strings (bfd *abfd,
   amt = p - tmp_space;
   res = bfd_bwrite ((void *) &tmp_space[0], amt, abfd);
   free (tmp_space);
-  if (res != amt)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[1538]) {
+    if ((res != amt ) && !(0))
+      fprintf(stderr, "triggered bug index 1538\n");
+    else
+      fprintf(stderr, "reached bug index 1538\n");
+  }
+  if ((!FIXREVERTER[1538] && (res != amt ))
+  #else
+  if (0
+  #endif
+  )
     return false;
+    #ifdef FRCOV
+    }
+    #endif
 
   *string_sizep = strings_size;
   return true;
@@ -4254,19 +4452,48 @@ som_finish_writing (bfd *abfd)
       tmp = exec_header->exec_dsize;
       tmp = SOM_ALIGN (tmp, PA_PAGESIZE);
       exec_header->exec_bsize -= (tmp - exec_header->exec_dsize);
-      if (exec_header->exec_bsize < 0)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[1539]) {
+        if ((exec_header -> exec_bsize < 0  ) && !(0))
+          fprintf(stderr, "triggered bug index 1539\n");
+        else
+          fprintf(stderr, "reached bug index 1539\n");
+      }
+      if ((!FIXREVERTER[1539] && (exec_header -> exec_bsize < 0  ))
+      #else
+      if (0
+      #endif
+      )
 	exec_header->exec_bsize = 0;
+	#ifdef FRCOV
+	}
+	#endif
       exec_header->exec_dsize = tmp;
 
       /* Now perform some sanity checks.  The idea is to catch bogons now and
 	 inform the user, instead of silently generating a bogus file.  */
       som_length = obj_som_file_hdr (abfd)->som_length;
-      if (exec_header->exec_tfile + exec_header->exec_tsize > som_length
-	  || exec_header->exec_dfile + exec_header->exec_dsize > som_length)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[1540]) {
+        if ((exec_header -> exec_tfile + exec_header -> exec_tsize > som_length || exec_header -> exec_dfile + exec_header -> exec_dsize > som_length ) && !(0))
+          fprintf(stderr, "triggered bug index 1540\n");
+        else
+          fprintf(stderr, "reached bug index 1540\n");
+      }
+      if ((!FIXREVERTER[1540] && (exec_header -> exec_tfile + exec_header -> exec_tsize > som_length || exec_header -> exec_dfile + exec_header -> exec_dsize > som_length ))
+      #else
+      if (0
+      #endif
+      )
 	{
 	  bfd_set_error (bfd_error_bad_value);
 	  return false;
 	}
+	#ifdef FRCOV
+	}
+	#endif
 
       som_swap_exec_auxhdr_out (exec_header, &ext_exec_header);
 
@@ -4577,8 +4804,23 @@ som_slurp_string_table (bfd *abfd)
     return false;
   amt = obj_som_stringtab_size (abfd);
   stringtab = (char *) _bfd_malloc_and_read (abfd, amt + 1, amt);
-  if (stringtab == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[1541]) {
+    if ((stringtab == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 1541\n");
+    else
+      fprintf(stderr, "reached bug index 1541\n");
+  }
+  if ((!FIXREVERTER[1541] && (stringtab == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     return false;
+    #ifdef FRCOV
+    }
+    #endif
   /* Make sure that the strings are zero-terminated.  */
   stringtab[amt] = 0;
 
@@ -4660,8 +4902,23 @@ som_slurp_symbol_table (bfd *abfd)
     goto successful_return;
 
   /* Special case.  This is *not* an error.  */
-  if (symbol_count == 0)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[1542]) {
+    if ((symbol_count == 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 1542\n");
+    else
+      fprintf(stderr, "reached bug index 1542\n");
+  }
+  if ((!FIXREVERTER[1542] && (symbol_count == 0 ))
+  #else
+  if (0
+  #endif
+  )
     goto successful_return;
+    #ifdef FRCOV
+    }
+    #endif
 
   if (!som_slurp_string_table (abfd))
     goto error_return;
@@ -4678,8 +4935,23 @@ som_slurp_symbol_table (bfd *abfd)
     goto error_return;
   buf = (struct som_external_symbol_dictionary_record *)
     _bfd_malloc_and_read (abfd, amt, amt);
-  if (buf == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[1543]) {
+    if ((buf == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 1543\n");
+    else
+      fprintf(stderr, "reached bug index 1543\n");
+  }
+  if ((!FIXREVERTER[1543] && (buf == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     goto error_return;
+    #ifdef FRCOV
+    }
+    #endif
 
   if (_bfd_mul_overflow (symbol_count, sizeof (som_symbol_type), &amt))
     {
@@ -4687,8 +4959,23 @@ som_slurp_symbol_table (bfd *abfd)
       goto error_return;
     }
   symbase = bfd_zmalloc (amt);
-  if (symbase == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[1544]) {
+    if ((symbase == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 1544\n");
+    else
+      fprintf(stderr, "reached bug index 1544\n");
+  }
+  if ((!FIXREVERTER[1544] && (symbase == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     goto error_return;
+    #ifdef FRCOV
+    }
+    #endif
 
   /* Iterate over all the symbols and internalize them.  */
   endbufp = buf + symbol_count;
@@ -4874,8 +5161,23 @@ som_make_empty_symbol (bfd *abfd)
   size_t amt = sizeof (som_symbol_type);
   som_symbol_type *new_symbol_type = bfd_zalloc (abfd, amt);
 
-  if (new_symbol_type == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[1546]) {
+    if ((new_symbol_type == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 1546\n");
+    else
+      fprintf(stderr, "reached bug index 1546\n");
+  }
+  if ((!FIXREVERTER[1546] && (new_symbol_type == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     return NULL;
+    #ifdef FRCOV
+    }
+    #endif
   new_symbol_type->symbol.the_bfd = abfd;
 
   return &new_symbol_type->symbol;
@@ -5240,10 +5542,25 @@ som_set_reloc_info (unsigned char *fixup,
 		      section->contents = contents;
 		      deallocate_contents = 1;
 		    }
-		  else if (rptr->addend == 0)
+		  else 
+		  #ifdef FRCOV
+		  {if (FIXREVERTER[1548]) {
+		    if ((rptr -> addend == 0  ) && !(0))
+		      fprintf(stderr, "triggered bug index 1548\n");
+		    else
+		      fprintf(stderr, "reached bug index 1548\n");
+		  }
+		  if ((!FIXREVERTER[1548] && (rptr -> addend == 0  ))
+		  #else
+		  if (0
+		  #endif
+		  )
 		    rptr->addend = bfd_get_32 (section->owner,
 					       (section->contents
 						+ offset - var ('L')));
+						#ifdef FRCOV
+						}
+						#endif
 
 		}
 	      else
@@ -5288,8 +5605,23 @@ som_slurp_reloc_table (bfd *abfd,
 
   fixup_stream_size = som_section_data (section)->reloc_size;
   /* If there were no relocations, then there is nothing to do.  */
-  if (section->reloc_count == 0)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[1549]) {
+    if ((section -> reloc_count == 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 1549\n");
+    else
+      fprintf(stderr, "reached bug index 1549\n");
+  }
+  if ((!FIXREVERTER[1549] && (section -> reloc_count == 0 ))
+  #else
+  if (0
+  #endif
+  )
     return true;
+    #ifdef FRCOV
+    }
+    #endif
 
   /* If reloc_count is -1, then the relocation stream has not been
      parsed.  We must do so now to know how many relocations exist.  */
@@ -5301,8 +5633,23 @@ som_slurp_reloc_table (bfd *abfd,
 	return false;
       amt = fixup_stream_size;
       external_relocs = _bfd_malloc_and_read (abfd, amt, amt);
-      if (external_relocs == NULL)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[1550]) {
+        if ((external_relocs == (void *) 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 1550\n");
+        else
+          fprintf(stderr, "reached bug index 1550\n");
+      }
+      if ((!FIXREVERTER[1550] && (external_relocs == (void *) 0 ))
+      #else
+      if (0
+      #endif
+      )
 	return false;
+	#ifdef FRCOV
+	}
+	#endif
 
       /* Let callers know how many relocations found.
 	 also save the relocation stream as we will
@@ -5330,8 +5677,23 @@ som_slurp_reloc_table (bfd *abfd,
       return false;
     }
   internal_relocs = bfd_zalloc (abfd, amt);
-  if (internal_relocs == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[1551]) {
+    if ((internal_relocs == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 1551\n");
+    else
+      fprintf(stderr, "reached bug index 1551\n");
+  }
+  if ((!FIXREVERTER[1551] && (internal_relocs == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     return false;
+    #ifdef FRCOV
+    }
+    #endif
 
   /* Process and internalize the relocations.  */
   som_set_reloc_info (external_relocs, fixup_stream_size,
@@ -5854,8 +6216,23 @@ som_decode_symclass (asymbol *symbol)
 
   /* If the symbol did not have a scope specified,
      then it will not have associated section.  */
-  if (symbol == NULL || symbol->section == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[1554]) {
+    if ((symbol == (void *) 0 || symbol -> section == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 1554\n");
+    else
+      fprintf(stderr, "reached bug index 1554\n");
+  }
+  if ((!FIXREVERTER[1554] && (symbol == (void *) 0 || symbol -> section == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     return '?';
+    #ifdef FRCOV
+    }
+    #endif
 
   if (bfd_is_com_section (symbol->section))
     return 'C';
@@ -5952,8 +6329,23 @@ som_bfd_count_ar_symbols (bfd *abfd,
       unsigned int hash_val = bfd_getb32 (hash_table + 4 * i);
 
       /* An empty chain has zero as it's file offset.  */
-      if (hash_val == 0)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[1555]) {
+        if ((hash_val == 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 1555\n");
+        else
+          fprintf(stderr, "reached bug index 1555\n");
+      }
+      if ((!FIXREVERTER[1555] && (hash_val == 0 ))
+      #else
+      if (0
+      #endif
+      )
 	continue;
+	#ifdef FRCOV
+	}
+	#endif
 
       /* Seek to the first symbol in this hash chain.  */
       if (bfd_seek (abfd, lst_filepos + hash_val, SEEK_SET) != 0)
@@ -5971,16 +6363,46 @@ som_bfd_count_ar_symbols (bfd *abfd,
 	{
 	  unsigned int next_entry = bfd_getb32 (ext_lst_symbol.next_entry);
 
-	  if (next_entry == 0)
+	  
+	  #ifdef FRCOV
+	  {if (FIXREVERTER[1556]) {
+	    if ((next_entry == 0 ) && !(0))
+	      fprintf(stderr, "triggered bug index 1556\n");
+	    else
+	      fprintf(stderr, "reached bug index 1556\n");
+	  }
+	  if ((!FIXREVERTER[1556] && (next_entry == 0 ))
+	  #else
+	  if (0
+	  #endif
+	  )
 	    break;
+	    #ifdef FRCOV
+	    }
+	    #endif
 
 	  /* Assume symbols on a chain are in increasing file offset
 	     order.  Otherwise we can loop here with fuzzed input.  */
-	  if (next_entry < hash_val + sizeof (ext_lst_symbol))
+	  
+	  #ifdef FRCOV
+	  {if (FIXREVERTER[1557]) {
+	    if ((next_entry < hash_val + sizeof ( ext_lst_symbol ) ) && !(0))
+	      fprintf(stderr, "triggered bug index 1557\n");
+	    else
+	      fprintf(stderr, "reached bug index 1557\n");
+	  }
+	  if ((!FIXREVERTER[1557] && (next_entry < hash_val + sizeof ( ext_lst_symbol ) ))
+	  #else
+	  if (0
+	  #endif
+	  )
 	    {
 	      bfd_set_error (bfd_error_bad_value);
 	      goto error_return;
 	    }
+	    #ifdef FRCOV
+	    }
+	    #endif
 	  hash_val = next_entry;
 
 	  /* Seek to the next symbol.  */
@@ -6062,8 +6484,23 @@ som_bfd_fill_in_ar_symbols (bfd *abfd,
 
       /* An empty chain has zero as it's file offset.  */
       hash_val = bfd_getb32 (hash_table + 4 * i);
-      if (hash_val == 0)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[1559]) {
+        if ((hash_val == 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 1559\n");
+        else
+          fprintf(stderr, "reached bug index 1559\n");
+      }
+      if ((!FIXREVERTER[1559] && (hash_val == 0 ))
+      #else
+      if (0
+      #endif
+      )
 	continue;
+	#ifdef FRCOV
+	}
+	#endif
 
       /* Seek to and read the first symbol on the chain.  */
       if (bfd_seek (abfd, lst_filepos + hash_val, SEEK_SET) != 0)
@@ -6103,11 +6540,26 @@ som_bfd_fill_in_ar_symbols (bfd *abfd,
       /* Fill in the file offset.  Note that the "location" field points
 	 to the SOM itself, not the ar_hdr in front of it.  */
       ndx = bfd_getb32 (lst_symbol.som_index);
-      if (ndx >= lst_header->module_count)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[1560]) {
+        if ((ndx >= lst_header -> module_count ) && !(0))
+          fprintf(stderr, "triggered bug index 1560\n");
+        else
+          fprintf(stderr, "reached bug index 1560\n");
+      }
+      if ((!FIXREVERTER[1560] && (ndx >= lst_header -> module_count ))
+      #else
+      if (0
+      #endif
+      )
 	{
 	  bfd_set_error (bfd_error_bad_value);
 	  goto error_return;
 	}
+	#ifdef FRCOV
+	}
+	#endif
       set->file_offset
 	= bfd_getb32 (som_dict[ndx].location) - sizeof (struct ar_hdr);
 
@@ -6119,8 +6571,23 @@ som_bfd_fill_in_ar_symbols (bfd *abfd,
 	{
 	  unsigned int next_entry = bfd_getb32 (lst_symbol.next_entry);
 
-	  if (next_entry == 0)
+	  
+	  #ifdef FRCOV
+	  {if (FIXREVERTER[1561]) {
+	    if ((next_entry == 0 ) && !(0))
+	      fprintf(stderr, "triggered bug index 1561\n");
+	    else
+	      fprintf(stderr, "reached bug index 1561\n");
+	  }
+	  if ((!FIXREVERTER[1561] && (next_entry == 0 ))
+	  #else
+	  if (0
+	  #endif
+	  )
 	    break;
+	    #ifdef FRCOV
+	    }
+	    #endif
 
 	  /* Seek to the next symbol and read it in.  */
 	  if (bfd_seek (abfd, lst_filepos + next_entry, SEEK_SET) != 0)
@@ -6154,11 +6621,26 @@ som_bfd_fill_in_ar_symbols (bfd *abfd,
 	  /* Fill in the file offset.  Note that the "location" field points
 	     to the SOM itself, not the ar_hdr in front of it.  */
 	  ndx = bfd_getb32 (lst_symbol.som_index);
-	  if (ndx >= lst_header->module_count)
+	  
+	  #ifdef FRCOV
+	  {if (FIXREVERTER[1562]) {
+	    if ((ndx >= lst_header -> module_count ) && !(0))
+	      fprintf(stderr, "triggered bug index 1562\n");
+	    else
+	      fprintf(stderr, "reached bug index 1562\n");
+	  }
+	  if ((!FIXREVERTER[1562] && (ndx >= lst_header -> module_count ))
+	  #else
+	  if (0
+	  #endif
+	  )
 	    {
 	      bfd_set_error (bfd_error_bad_value);
 	      goto error_return;
 	    }
+	    #ifdef FRCOV
+	    }
+	    #endif
 	  set->file_offset
 	    = bfd_getb32 (som_dict[ndx].location) - sizeof (struct ar_hdr);
 
@@ -6330,10 +6812,23 @@ som_bfd_prep_for_ar_write (bfd *abfd,
 	  som_bfd_derive_misc_symbol_info (curr_bfd, &sym->symbol, &info);
 
 	  /* Should we include this symbol?  */
-	  if (info.symbol_type == ST_NULL
-	      || info.symbol_type == ST_SYM_EXT
-	      || info.symbol_type == ST_ARG_EXT)
+	  
+	  #ifdef FRCOV
+	  {if (FIXREVERTER[1567]) {
+	    if ((info . symbol_type == 0 || info . symbol_type == 10 || info . symbol_type == 11 ) && !(0))
+	      fprintf(stderr, "triggered bug index 1567\n");
+	    else
+	      fprintf(stderr, "reached bug index 1567\n");
+	  }
+	  if ((!FIXREVERTER[1567] && (info . symbol_type == 0 || info . symbol_type == 10 || info . symbol_type == 11 ))
+	  #else
+	  if (0
+	  #endif
+	  )
 	    continue;
+	    #ifdef FRCOV
+	    }
+	    #endif
 
 	  /* Only global symbols and unsatisfied commons.  */
 	  if (info.symbol_scope != SS_UNIVERSAL
@@ -6366,8 +6861,23 @@ som_bfd_ar_symbol_hash (asymbol *symbol)
   unsigned int len = strlen (symbol->name);
 
   /* Names with length 1 are special.  */
-  if (len == 1)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[1568]) {
+    if ((len == 1 ) && !(0))
+      fprintf(stderr, "triggered bug index 1568\n");
+    else
+      fprintf(stderr, "reached bug index 1568\n");
+  }
+  if ((!FIXREVERTER[1568] && (len == 1 ))
+  #else
+  if (0
+  #endif
+  )
     return 0x1000100 | (symbol->name[0] << 16) | symbol->name[0];
+    #ifdef FRCOV
+    }
+    #endif
 
   return ((len & 0x7f) << 24) | (symbol->name[1] << 16)
 	  | (symbol->name[len - 2] << 8) | symbol->name[len - 1];
@@ -6502,10 +7012,23 @@ som_bfd_ar_write_symbol_stuff (bfd *abfd,
 	  som_bfd_derive_misc_symbol_info (curr_bfd, &sym->symbol, &info);
 
 	  /* Should we include this symbol?  */
-	  if (info.symbol_type == ST_NULL
-	      || info.symbol_type == ST_SYM_EXT
-	      || info.symbol_type == ST_ARG_EXT)
+	  
+	  #ifdef FRCOV
+	  {if (FIXREVERTER[1569]) {
+	    if ((info . symbol_type == 0 || info . symbol_type == 10 || info . symbol_type == 11 ) && !(0))
+	      fprintf(stderr, "triggered bug index 1569\n");
+	    else
+	      fprintf(stderr, "reached bug index 1569\n");
+	  }
+	  if ((!FIXREVERTER[1569] && (info . symbol_type == 0 || info . symbol_type == 10 || info . symbol_type == 11 ))
+	  #else
+	  if (0
+	  #endif
+	  )
 	    continue;
+	    #ifdef FRCOV
+	    }
+	    #endif
 
 	  /* Only global symbols and unsatisfied commons.  */
 	  if (info.symbol_scope != SS_UNIVERSAL
diff --git a/bfd/som.h b/bfd/som.h
old mode 100644
new mode 100755
diff --git a/bfd/srec.c b/bfd/srec.c
old mode 100644
new mode 100755
diff --git a/bfd/stab-syms.c b/bfd/stab-syms.c
old mode 100644
new mode 100755
diff --git a/bfd/stabs.c b/bfd/stabs.c
old mode 100644
new mode 100755
index c5e64a4..2291719
--- a/bfd/stabs.c
+++ b/bfd/stabs.c
@@ -1,3 +1,6 @@
+#ifdef FRCOV
+extern short FIXREVERTER[];
+#endif
 /* Stabs in sections linking support.
    Copyright (C) 1996-2021 Free Software Foundation, Inc.
    Written by Ian Lance Taylor, Cygnus Support.
@@ -125,11 +128,41 @@ stab_link_includes_newfunc (struct bfd_hash_entry *entry,
 
   /* Allocate the structure if it has not already been allocated by a
      subclass.  */
-  if (ret == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[10590]) {
+    if ((ret == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 10590\n");
+    else
+      fprintf(stderr, "reached bug index 10590\n");
+  }
+  if ((!FIXREVERTER[10590] && (ret == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     ret = (struct stab_link_includes_entry *)
 	bfd_hash_allocate (table, sizeof (struct stab_link_includes_entry));
-  if (ret == NULL)
+	#ifdef FRCOV
+	}
+	#endif
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[10591]) {
+    if ((ret == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 10591\n");
+    else
+      fprintf(stderr, "reached bug index 10591\n");
+  }
+  if ((!FIXREVERTER[10591] && (ret == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     return NULL;
+    #ifdef FRCOV
+    }
+    #endif
 
   /* Call the allocation method of the superclass.  */
   ret = ((struct stab_link_includes_entry *)
diff --git a/bfd/stamp-h.in b/bfd/stamp-h.in
old mode 100644
new mode 100755
diff --git a/bfd/syms.c b/bfd/syms.c
old mode 100644
new mode 100755
index 7daf741..802ae5a
--- a/bfd/syms.c
+++ b/bfd/syms.c
@@ -1,3 +1,6 @@
+#ifdef FRCOV
+extern short FIXREVERTER[];
+#endif
 /* Generic symbol-table support for the BFD library.
    Copyright (C) 1990-2021 Free Software Foundation, Inc.
    Written by Cygnus Support.
@@ -655,8 +658,23 @@ bfd_decode_symclass (asymbol *symbol)
   char c;
 
   /* Paranoia...  */
-  if (symbol == NULL || symbol->section == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[11244]) {
+    if ((symbol == (void *) 0 || symbol -> section == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 11244\n");
+    else
+      fprintf(stderr, "reached bug index 11244\n");
+  }
+  if ((!FIXREVERTER[11244] && (symbol == (void *) 0 || symbol -> section == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     return '?';
+    #ifdef FRCOV
+    }
+    #endif
 
   if (symbol->section && bfd_is_com_section (symbol->section))
     {
@@ -890,10 +908,40 @@ cmpindexentry (const void *a, const void *b)
   const struct indexentry *contestantA = (const struct indexentry *) a;
   const struct indexentry *contestantB = (const struct indexentry *) b;
 
-  if (contestantA->val < contestantB->val)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[11249]) {
+    if ((contestantA -> val < contestantB -> val ) && !(0))
+      fprintf(stderr, "triggered bug index 11249\n");
+    else
+      fprintf(stderr, "reached bug index 11249\n");
+  }
+  if ((!FIXREVERTER[11249] && (contestantA -> val < contestantB -> val ))
+  #else
+  if (0
+  #endif
+  )
     return -1;
-  if (contestantA->val > contestantB->val)
+    #ifdef FRCOV
+    }
+    #endif
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[11250]) {
+    if ((contestantA -> val > contestantB -> val ) && !(0))
+      fprintf(stderr, "triggered bug index 11250\n");
+    else
+      fprintf(stderr, "reached bug index 11250\n");
+  }
+  if ((!FIXREVERTER[11250] && (contestantA -> val > contestantB -> val ))
+  #else
+  if (0
+  #endif
+  )
     return 1;
+    #ifdef FRCOV
+    }
+    #endif
   return contestantA->idx - contestantB->idx;
 }
 
diff --git a/bfd/sysdep.h b/bfd/sysdep.h
old mode 100644
new mode 100755
diff --git a/bfd/targets.c b/bfd/targets.c
old mode 100644
new mode 100755
index 89b49e7..1f8d427
--- a/bfd/targets.c
+++ b/bfd/targets.c
@@ -1,3 +1,6 @@
+#ifdef FRCOV
+extern short FIXREVERTER[];
+#endif
 /* Generic target-file-type support for the BFD library.
    Copyright (C) 1990-2021 Free Software Foundation, Inc.
    Written by Cygnus Support.
@@ -1571,8 +1574,23 @@ bfd_find_target (const char *target_name, bfd *abfd)
     abfd->target_defaulted = false;
 
   target = find_target (targname);
-  if (target == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[3226]) {
+    if ((target == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 3226\n");
+    else
+      fprintf(stderr, "reached bug index 3226\n");
+  }
+  if ((!FIXREVERTER[3226] && (target == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     return NULL;
+    #ifdef FRCOV
+    }
+    #endif
 
   if (abfd)
     abfd->xvec = target;
diff --git a/bfd/targmatch.sed b/bfd/targmatch.sed
old mode 100644
new mode 100755
diff --git a/bfd/tekhex.c b/bfd/tekhex.c
old mode 100644
new mode 100755
diff --git a/bfd/trad-core.c b/bfd/trad-core.c
old mode 100644
new mode 100755
diff --git a/bfd/vax1knetbsd.c b/bfd/vax1knetbsd.c
old mode 100644
new mode 100755
diff --git a/bfd/vaxnetbsd.c b/bfd/vaxnetbsd.c
old mode 100644
new mode 100755
diff --git a/bfd/verilog.c b/bfd/verilog.c
old mode 100644
new mode 100755
diff --git a/bfd/version.h b/bfd/version.h
old mode 100644
new mode 100755
diff --git a/bfd/version.m4 b/bfd/version.m4
old mode 100644
new mode 100755
diff --git a/bfd/vms-alpha.c b/bfd/vms-alpha.c
old mode 100644
new mode 100755
index 41cc944..d91d42e
--- a/bfd/vms-alpha.c
+++ b/bfd/vms-alpha.c
@@ -1,3 +1,6 @@
+#ifdef FRCOV
+extern short FIXREVERTER[];
+#endif
 /* vms.c -- BFD back-end for EVAX (openVMS/Alpha) files.
    Copyright (C) 1996-2021 Free Software Foundation, Inc.
 
@@ -536,15 +539,45 @@ _bfd_vms_slurp_eisd (bfd *abfd, unsigned int offset)
 	return false;
       eisd = (struct vms_eisd *) (PRIV (recrd.rec) + offset);
       rec_size = bfd_getl32 (eisd->eisdsize);
-      if (rec_size == 0)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[1756]) {
+        if ((rec_size == 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 1756\n");
+        else
+          fprintf(stderr, "reached bug index 1756\n");
+      }
+      if ((!FIXREVERTER[1756] && (rec_size == 0 ))
+      #else
+      if (0
+      #endif
+      )
 	break;
+	#ifdef FRCOV
+	}
+	#endif
 
       /* Skip to next block if pad.  */
-      if (rec_size == 0xffffffff)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[1757]) {
+        if ((rec_size == -1 ) && !(0))
+          fprintf(stderr, "triggered bug index 1757\n");
+        else
+          fprintf(stderr, "reached bug index 1757\n");
+      }
+      if ((!FIXREVERTER[1757] && (rec_size == -1 ))
+      #else
+      if (0
+      #endif
+      )
 	{
 	  offset = (offset + VMS_BLOCK_SIZE) & ~(VMS_BLOCK_SIZE - 1);
 	  continue;
 	}
+	#ifdef FRCOV
+	}
+	#endif
 
       /* Make sure that there is enough data present in the record.  */
       if (rec_size < offsetof (struct vms_eisd, type) + 1)
@@ -613,8 +646,23 @@ _bfd_vms_slurp_eisd (bfd *abfd, unsigned int offset)
 	  const char *pfx;
 
 	  name = (char *) bfd_alloc (abfd, 32);
-	  if (name == NULL)
+	  
+	  #ifdef FRCOV
+	  {if (FIXREVERTER[1758]) {
+	    if ((name == (void *) 0 ) && !(0))
+	      fprintf(stderr, "triggered bug index 1758\n");
+	    else
+	      fprintf(stderr, "reached bug index 1758\n");
+	  }
+	  if ((!FIXREVERTER[1758] && (name == (void *) 0 ))
+	  #else
+	  if (0
+	  #endif
+	  )
 	    return false;
+	    #ifdef FRCOV
+	    }
+	    #endif
 	  if (flags & EISD__M_DZRO)
 	    pfx = "BSS";
 	  else if (flags & EISD__M_EXE)
@@ -871,8 +919,23 @@ vms_get_remaining_object_record (bfd *abfd, unsigned int read_so_far)
       PRIV (recrd.buf_size) = to_read;
     }
   /* PR 17512: file: 025-1974-0.004.  */
-  else if (to_read <= read_so_far)
+  else 
+  #ifdef FRCOV
+  {if (FIXREVERTER[1759]) {
+    if ((to_read <= read_so_far ) && !(0))
+      fprintf(stderr, "triggered bug index 1759\n");
+    else
+      fprintf(stderr, "reached bug index 1759\n");
+  }
+  if ((!FIXREVERTER[1759] && (to_read <= read_so_far ))
+  #else
+  if (0
+  #endif
+  )
     return 0;
+    #ifdef FRCOV
+    }
+    #endif
 
   /* Read the remaining record.  */
   to_read -= read_so_far;
@@ -920,8 +983,23 @@ _bfd_vms_slurp_ehdr (bfd *abfd)
     {
     case EMH__C_MHD:
       /* Module header.  */
-      if (vms_rec + 21 >= end)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[1760]) {
+        if ((vms_rec + 21 >= end ) && !(0))
+          fprintf(stderr, "triggered bug index 1760\n");
+        else
+          fprintf(stderr, "reached bug index 1760\n");
+      }
+      if ((!FIXREVERTER[1760] && (vms_rec + 21 >= end ))
+      #else
+      if (0
+      #endif
+      )
 	goto fail;
+	#ifdef FRCOV
+	}
+	#endif
       PRIV (hdr_data).hdr_b_strlvl = vms_rec[6];
       PRIV (hdr_data).hdr_l_arch1  = bfd_getl32 (vms_rec + 8);
       PRIV (hdr_data).hdr_l_arch2  = bfd_getl32 (vms_rec + 12);
@@ -936,8 +1014,23 @@ _bfd_vms_slurp_ehdr (bfd *abfd)
       PRIV (hdr_data).hdr_t_version
 	= _bfd_vms_save_counted_string (abfd, ptr, *ptr);
       ptr += *ptr + 1;
-      if (ptr + 17 >= end)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[1761]) {
+        if ((ptr + 17 >= end ) && !(0))
+          fprintf(stderr, "triggered bug index 1761\n");
+        else
+          fprintf(stderr, "reached bug index 1761\n");
+      }
+      if ((!FIXREVERTER[1761] && (ptr + 17 >= end ))
+      #else
+      if (0
+      #endif
+      )
 	goto fail;
+	#ifdef FRCOV
+	}
+	#endif
       PRIV (hdr_data).hdr_t_date
 	= _bfd_vms_save_sized_string (abfd, ptr, 17);
       break;
@@ -1151,16 +1244,46 @@ add_symbol (bfd *abfd, const unsigned char *ascic, unsigned int max)
 
   len = *ascic++;
   max -= 1;
-  if (len > max)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[1763]) {
+    if ((len > max ) && !(0))
+      fprintf(stderr, "triggered bug index 1763\n");
+    else
+      fprintf(stderr, "reached bug index 1763\n");
+  }
+  if ((!FIXREVERTER[1763] && (len > max ))
+  #else
+  if (0
+  #endif
+  )
     {
       _bfd_error_handler (_("record is too small for symbol name length"));
       bfd_set_error (bfd_error_bad_value);
       return NULL;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
   entry = (struct vms_symbol_entry *)bfd_zalloc (abfd, sizeof (*entry) + len);
-  if (entry == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[1764]) {
+    if ((entry == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 1764\n");
+    else
+      fprintf(stderr, "reached bug index 1764\n");
+  }
+  if ((!FIXREVERTER[1764] && (entry == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     return NULL;
+    #ifdef FRCOV
+    }
+    #endif
   entry->namelen = len;
   memcpy (entry->name, ascic, len);
   entry->name[len] = 0;
@@ -1217,7 +1340,19 @@ _bfd_vms_slurp_egsd (bfd *abfd)
 	  return false;
 	}
 
-      if (gsd_size < 4)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[1766]) {
+        if ((gsd_size < 4 ) && !(0))
+          fprintf(stderr, "triggered bug index 1766\n");
+        else
+          fprintf(stderr, "reached bug index 1766\n");
+      }
+      if ((!FIXREVERTER[1766] && (gsd_size < 4 ))
+      #else
+      if (0
+      #endif
+      )
 	{
 	too_small:
 	  _bfd_error_handler (_("corrupt EGSD record type %d: size (%#x) "
@@ -1226,6 +1361,9 @@ _bfd_vms_slurp_egsd (bfd *abfd)
 	  bfd_set_error (bfd_error_bad_value);
 	  return false;
 	}
+	#ifdef FRCOV
+	}
+	#endif
 
       switch (gsd_type)
 	{
@@ -1332,11 +1470,41 @@ _bfd_vms_slurp_egsd (bfd *abfd)
 	    else
 	      nameoff = ESRF__B_NAMLNG;
 
-	    if (nameoff >= gsd_size)
+	    
+	    #ifdef FRCOV
+	    {if (FIXREVERTER[1767]) {
+	      if ((nameoff >= gsd_size ) && !(0))
+	        fprintf(stderr, "triggered bug index 1767\n");
+	      else
+	        fprintf(stderr, "reached bug index 1767\n");
+	    }
+	    if ((!FIXREVERTER[1767] && (nameoff >= gsd_size ))
+	    #else
+	    if (0
+	    #endif
+	    )
 	      goto too_small;
+	      #ifdef FRCOV
+	      }
+	      #endif
 	    entry = add_symbol (abfd, vms_rec + nameoff, gsd_size - nameoff);
-	    if (entry == NULL)
+	    
+	    #ifdef FRCOV
+	    {if (FIXREVERTER[1768]) {
+	      if ((entry == (void *) 0 ) && !(0))
+	        fprintf(stderr, "triggered bug index 1768\n");
+	      else
+	        fprintf(stderr, "reached bug index 1768\n");
+	    }
+	    if ((!FIXREVERTER[1768] && (entry == (void *) 0 ))
+	    #else
+	    if (0
+	    #endif
+	    )
 	      return false;
+	      #ifdef FRCOV
+	      }
+	      #endif
 
 	    /* Allow only duplicate reference.  */
 	    if ((entry->flags & EGSY__V_DEF) && (old_flags & EGSY__V_DEF))
@@ -1392,11 +1560,41 @@ _bfd_vms_slurp_egsd (bfd *abfd)
 	    flagword old_flags;
 	    unsigned int nameoff = offsetof (struct vms_egst, namlng);
 
-	    if (nameoff >= gsd_size)
+	    
+	    #ifdef FRCOV
+	    {if (FIXREVERTER[1769]) {
+	      if ((nameoff >= gsd_size ) && !(0))
+	        fprintf(stderr, "triggered bug index 1769\n");
+	      else
+	        fprintf(stderr, "reached bug index 1769\n");
+	    }
+	    if ((!FIXREVERTER[1769] && (nameoff >= gsd_size ))
+	    #else
+	    if (0
+	    #endif
+	    )
 	      goto too_small;
+	      #ifdef FRCOV
+	      }
+	      #endif
 	    entry = add_symbol (abfd, &egst->namlng, gsd_size - nameoff);
-	    if (entry == NULL)
+	    
+	    #ifdef FRCOV
+	    {if (FIXREVERTER[1770]) {
+	      if ((entry == (void *) 0 ) && !(0))
+	        fprintf(stderr, "triggered bug index 1770\n");
+	      else
+	        fprintf(stderr, "reached bug index 1770\n");
+	    }
+	    if ((!FIXREVERTER[1770] && (entry == (void *) 0 ))
+	    #else
+	    if (0
+	    #endif
+	    )
 	      return false;
+	      #ifdef FRCOV
+	      }
+	      #endif
 
 	    old_flags = bfd_getl16 (egst->header.flags);
 	    entry->typ = gsd_type;
@@ -1616,12 +1814,26 @@ image_write (bfd *abfd, unsigned char *ptr, unsigned int size)
   size_t off = PRIV (image_offset);
 
   /* Check bounds.  */
-  if (off > sec->size
-      || size > sec->size - off)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[1771]) {
+    if ((size > sec -> size - off ) && !(off > sec -> size ))
+      fprintf(stderr, "triggered bug index 1771\n");
+    else
+      fprintf(stderr, "reached bug index 1771\n");
+  }
+  if ((FIXREVERTER[1771] && (off > sec -> size )) || (!FIXREVERTER[1771] && (off > sec -> size || size > sec -> size - off ))
+  #else
+  if (off > sec -> size 
+  #endif
+  )
     {
       bfd_set_error (bfd_error_bad_value);
       return false;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
 #if VMS_DEBUG
   _bfd_vms_debug (8, "image_write from (%p, %d) to (%ld)\n", ptr, size,
@@ -1780,12 +1992,27 @@ _bfd_vms_get_value (bfd *abfd,
   struct alpha_vms_link_hash_entry *h;
 
   /* Not linking.  Do not try to resolve the symbol.  */
-  if (info == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[1778]) {
+    if ((info == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 1778\n");
+    else
+      fprintf(stderr, "reached bug index 1778\n");
+  }
+  if ((!FIXREVERTER[1778] && (info == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     {
       *vma = 0;
       *hp = NULL;
       return;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
   len = *ascic;
   if (ascic + len >= max_ascic)
@@ -1831,8 +2058,23 @@ static unsigned int
 alpha_vms_sym_to_ctxt (struct alpha_vms_link_hash_entry *h)
 {
   /* Handle undefined symbols.  */
-  if (h == NULL || h->sym == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[1779]) {
+    if ((h == (void *) 0 || h -> sym == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 1779\n");
+    else
+      fprintf(stderr, "reached bug index 1779\n");
+  }
+  if ((!FIXREVERTER[1779] && (h == (void *) 0 || h -> sym == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     return RELC_NONE;
+    #ifdef FRCOV
+    }
+    #endif
 
   if (h->sym->typ == EGSD__C_SYMG)
     {
@@ -1911,20 +2153,50 @@ _bfd_vms_slurp_etir (bfd *abfd, struct bfd_link_info *info)
     {
       int cmd, cmd_length;
 
-      if (ptr + 4 > maxptr)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[1780]) {
+        if ((ptr + 4 > maxptr ) && !(0))
+          fprintf(stderr, "triggered bug index 1780\n");
+        else
+          fprintf(stderr, "reached bug index 1780\n");
+      }
+      if ((!FIXREVERTER[1780] && (ptr + 4 > maxptr ))
+      #else
+      if (0
+      #endif
+      )
 	goto corrupt_etir;
+	#ifdef FRCOV
+	}
+	#endif
 
       cmd = bfd_getl16 (ptr);
       cmd_length = bfd_getl16 (ptr + 2);
 
       /* PR 21589 and 21579: Check for a corrupt ETIR record.  */
-      if (cmd_length < 4 || ptr + cmd_length > maxptr)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[1781]) {
+        if ((cmd_length < 4 || ptr + cmd_length > maxptr ) && !(0))
+          fprintf(stderr, "triggered bug index 1781\n");
+        else
+          fprintf(stderr, "reached bug index 1781\n");
+      }
+      if ((!FIXREVERTER[1781] && (cmd_length < 4 || ptr + cmd_length > maxptr ))
+      #else
+      if (0
+      #endif
+      )
 	{
 	corrupt_etir:
 	  _bfd_error_handler (_("corrupt ETIR record encountered"));
 	  bfd_set_error (bfd_error_bad_value);
 	  return false;
 	}
+	#ifdef FRCOV
+	}
+	#endif
       ptr += 4;
       cmd_length -= 4;
 
@@ -1951,8 +2223,23 @@ _bfd_vms_slurp_etir (bfd *abfd, struct bfd_link_info *info)
 
 	     stack 32 bit value, sign extend to 64 bit.  */
 	case ETIR__C_STA_LW:
-	  if (cmd_length < 4)
+	  
+	  #ifdef FRCOV
+	  {if (FIXREVERTER[1782]) {
+	    if ((cmd_length < 4 ) && !(0))
+	      fprintf(stderr, "triggered bug index 1782\n");
+	    else
+	      fprintf(stderr, "reached bug index 1782\n");
+	  }
+	  if ((!FIXREVERTER[1782] && (cmd_length < 4 ))
+	  #else
+	  if (0
+	  #endif
+	  )
 	    goto corrupt_etir;
+	    #ifdef FRCOV
+	    }
+	    #endif
 	  if (!_bfd_vms_push (abfd, bfd_getl32 (ptr), RELC_NONE))
 	    return false;
 	  break;
@@ -1962,8 +2249,23 @@ _bfd_vms_slurp_etir (bfd *abfd, struct bfd_link_info *info)
 
 	     stack 64 bit value of symbol.  */
 	case ETIR__C_STA_QW:
-	  if (cmd_length < 8)
+	  
+	  #ifdef FRCOV
+	  {if (FIXREVERTER[1783]) {
+	    if ((cmd_length < 8 ) && !(0))
+	      fprintf(stderr, "triggered bug index 1783\n");
+	    else
+	      fprintf(stderr, "reached bug index 1783\n");
+	  }
+	  if ((!FIXREVERTER[1783] && (cmd_length < 8 ))
+	  #else
+	  if (0
+	  #endif
+	  )
 	    goto corrupt_etir;
+	    #ifdef FRCOV
+	    }
+	    #endif
 	  if (!_bfd_vms_push (abfd, bfd_getl64 (ptr), RELC_NONE))
 	    return false;
 	  break;
@@ -1978,8 +2280,23 @@ _bfd_vms_slurp_etir (bfd *abfd, struct bfd_link_info *info)
 	  {
 	    int psect;
 
-	    if (cmd_length < 12)
+	    
+	    #ifdef FRCOV
+	    {if (FIXREVERTER[1784]) {
+	      if ((cmd_length < 12 ) && !(0))
+	        fprintf(stderr, "triggered bug index 1784\n");
+	      else
+	        fprintf(stderr, "reached bug index 1784\n");
+	    }
+	    if ((!FIXREVERTER[1784] && (cmd_length < 12 ))
+	    #else
+	    if (0
+	    #endif
+	    )
 	      goto corrupt_etir;
+	      #ifdef FRCOV
+	      }
+	      #endif
 	    psect = bfd_getl32 (ptr);
 	    if ((unsigned int) psect >= PRIV (section_count))
 	      {
@@ -2007,8 +2324,23 @@ _bfd_vms_slurp_etir (bfd *abfd, struct bfd_link_info *info)
 	case ETIR__C_STO_B:
 	  if (!_bfd_vms_pop (abfd, &op1, &rel1))
 	    return false;
-	  if (rel1 != RELC_NONE)
+	  
+	  #ifdef FRCOV
+	  {if (FIXREVERTER[1785]) {
+	    if ((rel1 != 0 ) && !(0))
+	      fprintf(stderr, "triggered bug index 1785\n");
+	    else
+	      fprintf(stderr, "reached bug index 1785\n");
+	  }
+	  if ((!FIXREVERTER[1785] && (rel1 != 0 ))
+	  #else
+	  if (0
+	  #endif
+	  )
 	    goto bad_context;
+	    #ifdef FRCOV
+	    }
+	    #endif
 	  if (!image_write_b (abfd, (unsigned int) op1 & 0xff))
 	    return false;
 	  break;
@@ -2018,8 +2350,23 @@ _bfd_vms_slurp_etir (bfd *abfd, struct bfd_link_info *info)
 	case ETIR__C_STO_W:
 	  if (!_bfd_vms_pop (abfd, &op1, &rel1))
 	    return false;
-	  if (rel1 != RELC_NONE)
+	  
+	  #ifdef FRCOV
+	  {if (FIXREVERTER[1786]) {
+	    if ((rel1 != 0 ) && !(0))
+	      fprintf(stderr, "triggered bug index 1786\n");
+	    else
+	      fprintf(stderr, "reached bug index 1786\n");
+	  }
+	  if ((!FIXREVERTER[1786] && (rel1 != 0 ))
+	  #else
+	  if (0
+	  #endif
+	  )
 	    goto bad_context;
+	    #ifdef FRCOV
+	    }
+	    #endif
 	  if (!image_write_w (abfd, (unsigned int) op1 & 0xffff))
 	    return false;
 	  break;
@@ -2081,17 +2428,77 @@ _bfd_vms_slurp_etir (bfd *abfd, struct bfd_link_info *info)
 	  {
 	    int size;
 
-	    if (cmd_length < 4)
+	    
+	    #ifdef FRCOV
+	    {if (FIXREVERTER[1787]) {
+	      if ((cmd_length < 4 ) && !(0))
+	        fprintf(stderr, "triggered bug index 1787\n");
+	      else
+	        fprintf(stderr, "reached bug index 1787\n");
+	    }
+	    if ((!FIXREVERTER[1787] && (cmd_length < 4 ))
+	    #else
+	    if (0
+	    #endif
+	    )
 	      goto corrupt_etir;
+	      #ifdef FRCOV
+	      }
+	      #endif
 	    size = bfd_getl32 (ptr);
-	    if (size > cmd_length - 4)
+	    
+	    #ifdef FRCOV
+	    {if (FIXREVERTER[1788]) {
+	      if ((size > cmd_length - 4 ) && !(0))
+	        fprintf(stderr, "triggered bug index 1788\n");
+	      else
+	        fprintf(stderr, "reached bug index 1788\n");
+	    }
+	    if ((!FIXREVERTER[1788] && (size > cmd_length - 4 ))
+	    #else
+	    if (0
+	    #endif
+	    )
 	      goto corrupt_etir;
+	      #ifdef FRCOV
+	      }
+	      #endif
 	    if (!_bfd_vms_pop (abfd, &op1, &rel1))
 	      return false;
-	    if (rel1 != RELC_NONE)
+	    
+	    #ifdef FRCOV
+	    {if (FIXREVERTER[1789]) {
+	      if ((rel1 != 0 ) && !(0))
+	        fprintf(stderr, "triggered bug index 1789\n");
+	      else
+	        fprintf(stderr, "reached bug index 1789\n");
+	    }
+	    if ((!FIXREVERTER[1789] && (rel1 != 0 ))
+	    #else
+	    if (0
+	    #endif
+	    )
 	      goto bad_context;
-	    if (size == 0)
+	      #ifdef FRCOV
+	      }
+	      #endif
+	    
+	    #ifdef FRCOV
+	    {if (FIXREVERTER[1790]) {
+	      if ((size == 0 ) && !(0))
+	        fprintf(stderr, "triggered bug index 1790\n");
+	      else
+	        fprintf(stderr, "reached bug index 1790\n");
+	    }
+	    if ((!FIXREVERTER[1790] && (size == 0 ))
+	    #else
+	    if (0
+	    #endif
+	    )
 	      break;
+	      #ifdef FRCOV
+	      }
+	      #endif
 	    op1 &= 0xffffffff;
 	    while (op1-- > 0)
 	      if (!image_write (abfd, ptr + 4, size))
@@ -2179,8 +2586,23 @@ _bfd_vms_slurp_etir (bfd *abfd, struct bfd_link_info *info)
 	  {
 	    unsigned int size;
 
-	    if (cmd_length < 4)
+	    
+	    #ifdef FRCOV
+	    {if (FIXREVERTER[1791]) {
+	      if ((cmd_length < 4 ) && !(0))
+	        fprintf(stderr, "triggered bug index 1791\n");
+	      else
+	        fprintf(stderr, "reached bug index 1791\n");
+	    }
+	    if ((!FIXREVERTER[1791] && (cmd_length < 4 ))
+	    #else
+	    if (0
+	    #endif
+	    )
 	      goto corrupt_etir;
+	      #ifdef FRCOV
+	      }
+	      #endif
 	    size = bfd_getl32 (ptr);
 	    if (!image_write (abfd, ptr + 4, size))
 	      return false;
@@ -2248,8 +2670,23 @@ _bfd_vms_slurp_etir (bfd *abfd, struct bfd_link_info *info)
 	     da	signature.  */
 
 	case ETIR__C_STC_LP_PSB:
-	  if (cmd_length < 4)
+	  
+	  #ifdef FRCOV
+	  {if (FIXREVERTER[1792]) {
+	    if ((cmd_length < 4 ) && !(0))
+	      fprintf(stderr, "triggered bug index 1792\n");
+	    else
+	      fprintf(stderr, "reached bug index 1792\n");
+	  }
+	  if ((!FIXREVERTER[1792] && (cmd_length < 4 ))
+	  #else
+	  if (0
+	  #endif
+	  )
 	    goto corrupt_etir;
+	    #ifdef FRCOV
+	    }
+	    #endif
 	  _bfd_vms_get_value (abfd, ptr + 4, ptr + cmd_length, info, &op1, &h);
 	  if (h && h->sym)
 	    {
@@ -2349,8 +2786,23 @@ _bfd_vms_slurp_etir (bfd *abfd, struct bfd_link_info *info)
 	  /* Augment relocation base: increment image location counter by offset
 	     arg: lw	offset value.  */
 	case ETIR__C_CTL_AUGRB:
-	  if (cmd_length < 4)
+	  
+	  #ifdef FRCOV
+	  {if (FIXREVERTER[1793]) {
+	    if ((cmd_length < 4 ) && !(0))
+	      fprintf(stderr, "triggered bug index 1793\n");
+	    else
+	      fprintf(stderr, "reached bug index 1793\n");
+	  }
+	  if ((!FIXREVERTER[1793] && (cmd_length < 4 ))
+	  #else
+	  if (0
+	  #endif
+	  )
 	    goto corrupt_etir;
+	    #ifdef FRCOV
+	    }
+	    #endif
 	  op1 = bfd_getl32 (ptr);
 	  image_inc_ptr (abfd, op1);
 	  break;
@@ -2360,8 +2812,23 @@ _bfd_vms_slurp_etir (bfd *abfd, struct bfd_link_info *info)
 	case ETIR__C_CTL_DFLOC:
 	  if (!_bfd_vms_pop (abfd, &op1, &rel1))
 	    return false;
-	  if (rel1 != RELC_NONE)
+	  
+	  #ifdef FRCOV
+	  {if (FIXREVERTER[1794]) {
+	    if ((rel1 != 0 ) && !(0))
+	      fprintf(stderr, "triggered bug index 1794\n");
+	    else
+	      fprintf(stderr, "reached bug index 1794\n");
+	  }
+	  if ((!FIXREVERTER[1794] && (rel1 != 0 ))
+	  #else
+	  if (0
+	  #endif
+	  )
 	    goto bad_context;
+	    #ifdef FRCOV
+	    }
+	    #endif
 	  if (!dst_define_location (abfd, op1))
 	    return false;
 	  break;
@@ -2371,8 +2838,23 @@ _bfd_vms_slurp_etir (bfd *abfd, struct bfd_link_info *info)
 	case ETIR__C_CTL_STLOC:
 	  if (!_bfd_vms_pop (abfd, &op1, &rel1))
 	    return false;
-	  if (rel1 != RELC_NONE)
+	  
+	  #ifdef FRCOV
+	  {if (FIXREVERTER[1795]) {
+	    if ((rel1 != 0 ) && !(0))
+	      fprintf(stderr, "triggered bug index 1795\n");
+	    else
+	      fprintf(stderr, "reached bug index 1795\n");
+	  }
+	  if ((!FIXREVERTER[1795] && (rel1 != 0 ))
+	  #else
+	  if (0
+	  #endif
+	  )
 	    goto bad_context;
+	    #ifdef FRCOV
+	    }
+	    #endif
 	  if (!dst_restore_location (abfd, op1))
 	    {
 	      bfd_set_error (bfd_error_bad_value);
@@ -2386,8 +2868,23 @@ _bfd_vms_slurp_etir (bfd *abfd, struct bfd_link_info *info)
 	case ETIR__C_CTL_STKDL:
 	  if (!_bfd_vms_pop (abfd, &op1, &rel1))
 	    return false;
-	  if (rel1 != RELC_NONE)
+	  
+	  #ifdef FRCOV
+	  {if (FIXREVERTER[1796]) {
+	    if ((rel1 != 0 ) && !(0))
+	      fprintf(stderr, "triggered bug index 1796\n");
+	    else
+	      fprintf(stderr, "reached bug index 1796\n");
+	  }
+	  if ((!FIXREVERTER[1796] && (rel1 != 0 ))
+	  #else
+	  if (0
+	  #endif
+	  )
 	    goto bad_context;
+	    #ifdef FRCOV
+	    }
+	    #endif
 	  if (!dst_retrieve_location (abfd, &op1))
 	    {
 	      bfd_set_error (bfd_error_bad_value);
@@ -2435,8 +2932,23 @@ _bfd_vms_slurp_etir (bfd *abfd, struct bfd_link_info *info)
 	  if (!_bfd_vms_pop (abfd, &op1, &rel1)
 	      || !_bfd_vms_pop (abfd, &op2, &rel2))
 	    return false;
-	  if (rel1 != RELC_NONE || rel2 != RELC_NONE)
+	  
+	  #ifdef FRCOV
+	  {if (FIXREVERTER[1797]) {
+	    if ((rel1 != 0 || rel2 != 0 ) && !(0))
+	      fprintf(stderr, "triggered bug index 1797\n");
+	    else
+	      fprintf(stderr, "reached bug index 1797\n");
+	  }
+	  if ((!FIXREVERTER[1797] && (rel1 != 0 || rel2 != 0 ))
+	  #else
+	  if (0
+	  #endif
+	  )
 	    goto bad_context;
+	    #ifdef FRCOV
+	    }
+	    #endif
 	  if (!_bfd_vms_push (abfd, op1 * op2, RELC_NONE))
 	    return false;
 	  break;
@@ -2445,8 +2957,23 @@ _bfd_vms_slurp_etir (bfd *abfd, struct bfd_link_info *info)
 	  if (!_bfd_vms_pop (abfd, &op1, &rel1)
 	      || !_bfd_vms_pop (abfd, &op2, &rel2))
 	    return false;
-	  if (rel1 != RELC_NONE || rel2 != RELC_NONE)
+	  
+	  #ifdef FRCOV
+	  {if (FIXREVERTER[1798]) {
+	    if ((rel1 != 0 || rel2 != 0 ) && !(0))
+	      fprintf(stderr, "triggered bug index 1798\n");
+	    else
+	      fprintf(stderr, "reached bug index 1798\n");
+	  }
+	  if ((!FIXREVERTER[1798] && (rel1 != 0 || rel2 != 0 ))
+	  #else
+	  if (0
+	  #endif
+	  )
 	    goto bad_context;
+	    #ifdef FRCOV
+	    }
+	    #endif
 	  if (op1 == 0)
 	    {
 	      /* Divide by zero is supposed to give a result of zero,
@@ -2466,8 +2993,23 @@ _bfd_vms_slurp_etir (bfd *abfd, struct bfd_link_info *info)
 	  if (!_bfd_vms_pop (abfd, &op1, &rel1)
 	      || !_bfd_vms_pop (abfd, &op2, &rel2))
 	    return false;
-	  if (rel1 != RELC_NONE || rel2 != RELC_NONE)
+	  
+	  #ifdef FRCOV
+	  {if (FIXREVERTER[1799]) {
+	    if ((rel1 != 0 || rel2 != 0 ) && !(0))
+	      fprintf(stderr, "triggered bug index 1799\n");
+	    else
+	      fprintf(stderr, "reached bug index 1799\n");
+	  }
+	  if ((!FIXREVERTER[1799] && (rel1 != 0 || rel2 != 0 ))
+	  #else
+	  if (0
+	  #endif
+	  )
 	    goto bad_context;
+	    #ifdef FRCOV
+	    }
+	    #endif
 	  if (!_bfd_vms_push (abfd, op1 & op2, RELC_NONE))
 	    return false;
 	  break;
@@ -2476,8 +3018,23 @@ _bfd_vms_slurp_etir (bfd *abfd, struct bfd_link_info *info)
 	  if (!_bfd_vms_pop (abfd, &op1, &rel1)
 	      || !_bfd_vms_pop (abfd, &op2, &rel2))
 	    return false;
-	  if (rel1 != RELC_NONE || rel2 != RELC_NONE)
+	  
+	  #ifdef FRCOV
+	  {if (FIXREVERTER[1800]) {
+	    if ((rel1 != 0 || rel2 != 0 ) && !(0))
+	      fprintf(stderr, "triggered bug index 1800\n");
+	    else
+	      fprintf(stderr, "reached bug index 1800\n");
+	  }
+	  if ((!FIXREVERTER[1800] && (rel1 != 0 || rel2 != 0 ))
+	  #else
+	  if (0
+	  #endif
+	  )
 	    goto bad_context;
+	    #ifdef FRCOV
+	    }
+	    #endif
 	  if (!_bfd_vms_push (abfd, op1 | op2, RELC_NONE))
 	    return false;
 	  break;
@@ -2486,8 +3043,23 @@ _bfd_vms_slurp_etir (bfd *abfd, struct bfd_link_info *info)
 	  if (!_bfd_vms_pop (abfd, &op1, &rel1)
 	      || !_bfd_vms_pop (abfd, &op2, &rel2))
 	    return false;
-	  if (rel1 != RELC_NONE || rel2 != RELC_NONE)
+	  
+	  #ifdef FRCOV
+	  {if (FIXREVERTER[1801]) {
+	    if ((rel1 != 0 || rel2 != 0 ) && !(0))
+	      fprintf(stderr, "triggered bug index 1801\n");
+	    else
+	      fprintf(stderr, "reached bug index 1801\n");
+	  }
+	  if ((!FIXREVERTER[1801] && (rel1 != 0 || rel2 != 0 ))
+	  #else
+	  if (0
+	  #endif
+	  )
 	    goto bad_context;
+	    #ifdef FRCOV
+	    }
+	    #endif
 	  if (!_bfd_vms_push (abfd, op1 ^ op2, RELC_NONE))
 	    return false;
 	  break;
@@ -2495,8 +3067,23 @@ _bfd_vms_slurp_etir (bfd *abfd, struct bfd_link_info *info)
 	case ETIR__C_OPR_NEG:      /* Negate.  */
 	  if (!_bfd_vms_pop (abfd, &op1, &rel1))
 	    return false;
-	  if (rel1 != RELC_NONE)
+	  
+	  #ifdef FRCOV
+	  {if (FIXREVERTER[1802]) {
+	    if ((rel1 != 0 ) && !(0))
+	      fprintf(stderr, "triggered bug index 1802\n");
+	    else
+	      fprintf(stderr, "reached bug index 1802\n");
+	  }
+	  if ((!FIXREVERTER[1802] && (rel1 != 0 ))
+	  #else
+	  if (0
+	  #endif
+	  )
 	    goto bad_context;
+	    #ifdef FRCOV
+	    }
+	    #endif
 	  if (!_bfd_vms_push (abfd, -op1, RELC_NONE))
 	    return false;
 	  break;
@@ -2504,8 +3091,23 @@ _bfd_vms_slurp_etir (bfd *abfd, struct bfd_link_info *info)
 	case ETIR__C_OPR_COM:      /* Complement.  */
 	  if (!_bfd_vms_pop (abfd, &op1, &rel1))
 	    return false;
-	  if (rel1 != RELC_NONE)
+	  
+	  #ifdef FRCOV
+	  {if (FIXREVERTER[1803]) {
+	    if ((rel1 != 0 ) && !(0))
+	      fprintf(stderr, "triggered bug index 1803\n");
+	    else
+	      fprintf(stderr, "reached bug index 1803\n");
+	  }
+	  if ((!FIXREVERTER[1803] && (rel1 != 0 ))
+	  #else
+	  if (0
+	  #endif
+	  )
 	    goto bad_context;
+	    #ifdef FRCOV
+	    }
+	    #endif
 	  if (!_bfd_vms_push (abfd, ~op1, RELC_NONE))
 	    return false;
 	  break;
@@ -2514,20 +3116,50 @@ _bfd_vms_slurp_etir (bfd *abfd, struct bfd_link_info *info)
 	  if (!_bfd_vms_pop (abfd, &op1, &rel1)
 	      || !_bfd_vms_pop (abfd, &op2, &rel2))
 	    return false;
-	  if (rel1 != RELC_NONE || rel2 != RELC_NONE)
+	  
+	  #ifdef FRCOV
+	  {if (FIXREVERTER[1804]) {
+	    if ((rel1 != 0 || rel2 != 0 ) && !(0))
+	      fprintf(stderr, "triggered bug index 1804\n");
+	    else
+	      fprintf(stderr, "reached bug index 1804\n");
+	  }
+	  if ((!FIXREVERTER[1804] && (rel1 != 0 || rel2 != 0 ))
+	  #else
+	  if (0
+	  #endif
+	  )
 	    {
 	    bad_context:
 	      _bfd_error_handler (_("invalid use of %s with contexts"),
 				  _bfd_vms_etir_name (cmd));
 	      return false;
 	    }
+	    #ifdef FRCOV
+	    }
+	    #endif
 	  if ((bfd_signed_vma) op2 < 0)
 	    {
 	      /* Shift right.  */
 	      bfd_vma sign;
 	      op2 = -op2;
-	      if (op2 >= CHAR_BIT * sizeof (op1))
+	      
+	      #ifdef FRCOV
+	      {if (FIXREVERTER[1805]) {
+	        if ((op2 >= 8 * sizeof ( op1 ) ) && !(0))
+	          fprintf(stderr, "triggered bug index 1805\n");
+	        else
+	          fprintf(stderr, "reached bug index 1805\n");
+	      }
+	      if ((!FIXREVERTER[1805] && (op2 >= 8 * sizeof ( op1 ) ))
+	      #else
+	      if (0
+	      #endif
+	      )
 		op2 = CHAR_BIT * sizeof (op1) - 1;
+		#ifdef FRCOV
+		}
+		#endif
 	      /* op1 = (bfd_signed_vma) op1 >> op2; */
 	      sign = op1 & ((bfd_vma) 1 << (CHAR_BIT * sizeof (op1) - 1));
 	      op1 >>= op2;
@@ -2821,8 +3453,23 @@ alpha_vms_object_p (bfd *abfd)
      4 bytes minor id, 4 bytes length).  */
   test_len = 12;
   buf = _bfd_malloc_and_read (abfd, test_len, test_len);
-  if (buf == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[1807]) {
+    if ((buf == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 1807\n");
+    else
+      fprintf(stderr, "reached bug index 1807\n");
+  }
+  if ((!FIXREVERTER[1807] && (buf == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     goto error_ret;
+    #ifdef FRCOV
+    }
+    #endif
   PRIV (recrd.buf) = buf;
   PRIV (recrd.buf_size) = test_len;
   PRIV (recrd.rec) = buf;
@@ -2852,8 +3499,23 @@ alpha_vms_object_p (bfd *abfd)
       PRIV (recrd.buf) = NULL;
       buf = _bfd_malloc_and_read (abfd, PRIV (recrd.rec_size),
 				  PRIV (recrd.rec_size));
-      if (buf == NULL)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[1808]) {
+        if ((buf == (void *) 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 1808\n");
+        else
+          fprintf(stderr, "reached bug index 1808\n");
+      }
+      if ((!FIXREVERTER[1808] && (buf == (void *) 0 ))
+      #else
+      if (0
+      #endif
+      )
 	goto error_ret;
+	#ifdef FRCOV
+	}
+	#endif
 
       PRIV (recrd.buf) = buf;
       PRIV (recrd.buf_size) = PRIV (recrd.rec_size);
@@ -2993,11 +3655,26 @@ _bfd_vms_write_eeom (bfd *abfd)
       asection *section;
 
       section = bfd_get_section_by_name (abfd, ".link");
-      if (section == 0)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[1811]) {
+        if ((section == 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 1811\n");
+        else
+          fprintf(stderr, "reached bug index 1811\n");
+      }
+      if ((!FIXREVERTER[1811] && (section == 0 ))
+      #else
+      if (0
+      #endif
+      )
 	{
 	  bfd_set_error (bfd_error_nonrepresentable_section);
 	  return false;
 	}
+	#ifdef FRCOV
+	}
+	#endif
       _bfd_vms_output_short (recwr, 0);
       _bfd_vms_output_long (recwr, (unsigned long) section->target_index);
       _bfd_vms_output_long (recwr,
@@ -3036,8 +3713,23 @@ vector_grow1 (struct vector_type *vec, size_t elsz)
 	  vec->els = bfd_realloc_or_free (vec->els, amt);
 	}
     }
-  if (vec->els == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[1812]) {
+    if ((vec -> els == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 1812\n");
+    else
+      fprintf(stderr, "reached bug index 1812\n");
+  }
+  if ((!FIXREVERTER[1812] && (vec -> els == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     return NULL;
+    #ifdef FRCOV
+    }
+    #endif
   return (char *) vec->els + elsz * vec->nbr_el++;
 }
 
@@ -3101,15 +3793,45 @@ alpha_vms_create_eisd_for_shared (bfd *abfd, bfd *shrimg)
   int namlen;
 
   namlen = strlen (PRIV2 (shrimg, hdr_data.hdr_t_name));
-  if (namlen + 5 > EISD__K_GBLNAMLEN)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[1813]) {
+    if ((namlen + 5 > 44 ) && !(0))
+      fprintf(stderr, "triggered bug index 1813\n");
+    else
+      fprintf(stderr, "reached bug index 1813\n");
+  }
+  if ((!FIXREVERTER[1813] && (namlen + 5 > 44 ))
+  #else
+  if (0
+  #endif
+  )
     {
       /* Won't fit.  */
       return false;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
   eisd = bfd_alloc (abfd, sizeof (*eisd));
-  if (eisd == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[1814]) {
+    if ((eisd == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 1814\n");
+    else
+      fprintf(stderr, "reached bug index 1814\n");
+  }
+  if ((!FIXREVERTER[1814] && (eisd == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     return false;
+    #ifdef FRCOV
+    }
+    #endif
 
   /* Fill the fields.  */
   eisd->u.gbl_eisd.common.majorid = EISD__K_MAJORID;
@@ -3149,8 +3871,23 @@ alpha_vms_create_eisd_for_section (bfd *abfd, asection *sec)
 
   BFD_ASSERT (vms_section_data (sec)->eisd == NULL);
   eisd = bfd_alloc (abfd, sizeof (*eisd));
-  if (eisd == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[1815]) {
+    if ((eisd == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 1815\n");
+    else
+      fprintf(stderr, "reached bug index 1815\n");
+  }
+  if ((!FIXREVERTER[1815] && (eisd == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     return false;
+    #ifdef FRCOV
+    }
+    #endif
   vms_section_data (sec)->eisd = eisd;
 
   /* Fill the fields.  */
@@ -3338,8 +4075,23 @@ alpha_vms_write_exec (bfd *abfd)
   if (first_eisd)
     {
       eisd = bfd_zalloc (abfd, sizeof (*eisd));
-      if (eisd == NULL)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[1817]) {
+        if ((eisd == (void *) 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 1817\n");
+        else
+          fprintf(stderr, "reached bug index 1817\n");
+      }
+      if ((!FIXREVERTER[1817] && (eisd == (void *) 0 ))
+      #else
+      if (0
+      #endif
+      )
 	return false;
+	#ifdef FRCOV
+	}
+	#endif
       eisd->u.eisd.majorid = 0;
       eisd->u.eisd.minorid = 0;
       eisd->u.eisd.eisdsize = 0;
@@ -3905,8 +4657,23 @@ sto_imm (bfd *abfd, asection *section,
 	  start_etir_or_etbt_record (abfd, section, vaddr);
 
 	  size = _bfd_vms_output_check (recwr, 0);	/* get max size */
-	  if (size > ssize)			/* more than what's left ? */
+	  
+	  #ifdef FRCOV
+	  {if (FIXREVERTER[1820]) {
+	    if ((size > ssize ) && !(0))
+	      fprintf(stderr, "triggered bug index 1820\n");
+	    else
+	      fprintf(stderr, "reached bug index 1820\n");
+	  }
+	  if ((!FIXREVERTER[1820] && (size > ssize ))
+	  #else
+	  if (0
+	  #endif
+	  )			/* more than what's left ? */
 	    size = ssize;
+	    #ifdef FRCOV
+	    }
+	    #endif
 	}
 
       _bfd_vms_output_begin_subrec (recwr, ETIR__C_STO_IMM);
@@ -4261,11 +5028,26 @@ _bfd_vms_write_etir (bfd * abfd, int objtype ATTRIBUTE_UNUSED)
 	  if (!pass2_in_progress)
 	    {
 	      /* Output rest of section.  */
-	      if (curr_addr > section->size)
+	      
+	      #ifdef FRCOV
+	      {if (FIXREVERTER[1821]) {
+	        if ((curr_addr > section -> size ) && !(0))
+	          fprintf(stderr, "triggered bug index 1821\n");
+	        else
+	          fprintf(stderr, "reached bug index 1821\n");
+	      }
+	      if ((!FIXREVERTER[1821] && (curr_addr > section -> size ))
+	      #else
+	      if (0
+	      #endif
+	      )
 		{
 		  _bfd_error_handler (_("size error in section %pA"), section);
 		  return false;
 		}
+		#ifdef FRCOV
+		}
+		#endif
 	      size = section->size - curr_addr;
 	      sto_imm (abfd, section, size, curr_data, curr_addr);
 	      curr_data += size;
@@ -5179,7 +5961,19 @@ alpha_vms_slurp_relocs (bfd *abfd)
 	      continue;
 
 	    case ETIR__C_CTL_SETRB:
-	      if (prev_cmd != ETIR__C_STA_PQ)
+	      
+	      #ifdef FRCOV
+	      {if (FIXREVERTER[1826]) {
+	        if ((prev_cmd != 3 ) && !(0))
+	          fprintf(stderr, "triggered bug index 1826\n");
+	        else
+	          fprintf(stderr, "reached bug index 1826\n");
+	      }
+	      if ((!FIXREVERTER[1826] && (prev_cmd != 3 ))
+	      #else
+	      if (0
+	      #endif
+	      )
 		{
 		  _bfd_error_handler
 		    /* xgettext:c-format */
@@ -5187,6 +5981,9 @@ alpha_vms_slurp_relocs (bfd *abfd)
 		     _bfd_vms_etir_name (cmd));
 		  return false;
 		}
+		#ifdef FRCOV
+		}
+		#endif
 	      cur_psect = cur_psidx;
 	      vaddr = cur_addend;
 	      cur_psidx = -1;
@@ -5197,7 +5994,19 @@ alpha_vms_slurp_relocs (bfd *abfd)
 				 /* ALPHA_R_REFLONG und_section, step 2 */
 	      if (prev_cmd != -1)
 		{
-		  if (prev_cmd != ETIR__C_STA_GBL)
+		  
+		  #ifdef FRCOV
+		  {if (FIXREVERTER[1827]) {
+		    if ((prev_cmd != 0 ) && !(0))
+		      fprintf(stderr, "triggered bug index 1827\n");
+		    else
+		      fprintf(stderr, "reached bug index 1827\n");
+		  }
+		  if ((!FIXREVERTER[1827] && (prev_cmd != 0 ))
+		  #else
+		  if (0
+		  #endif
+		  )
 		    {
 		      _bfd_error_handler
 			/* xgettext:c-format */
@@ -5205,6 +6014,9 @@ alpha_vms_slurp_relocs (bfd *abfd)
 			 _bfd_vms_etir_name (ETIR__C_STA_LW));
 		      return false;
 		    }
+		    #ifdef FRCOV
+		    }
+		    #endif
 		}
 	      cur_addend = bfd_getl32 (ptr + 4);
 	      prev_cmd = cmd;
@@ -5254,7 +6066,19 @@ alpha_vms_slurp_relocs (bfd *abfd)
 	      break;
 
 	    case ETIR__C_STO_OFF: /* ALPHA_R_REFQUAD others, step 2 */
-	      if (prev_cmd != ETIR__C_STA_PQ)
+	      
+	      #ifdef FRCOV
+	      {if (FIXREVERTER[1828]) {
+	        if ((prev_cmd != 3 ) && !(0))
+	          fprintf(stderr, "triggered bug index 1828\n");
+	        else
+	          fprintf(stderr, "reached bug index 1828\n");
+	      }
+	      if ((!FIXREVERTER[1828] && (prev_cmd != 3 ))
+	      #else
+	      if (0
+	      #endif
+	      )
 		{
 		  /* xgettext:c-format */
 		  _bfd_error_handler (_("unknown reloc %s + %s"),
@@ -5262,6 +6086,9 @@ alpha_vms_slurp_relocs (bfd *abfd)
 				      _bfd_vms_etir_name (ETIR__C_STO_OFF));
 		  return false;
 		}
+		#ifdef FRCOV
+		}
+		#endif
 	      reloc_code = BFD_RELOC_64;
 	      break;
 
@@ -5368,8 +6195,23 @@ alpha_vms_slurp_relocs (bfd *abfd)
 		    vms_sec->reloc_max *= 2;
 		    sec->relocation = bfd_realloc_or_free
 		      (sec->relocation, vms_sec->reloc_max * sizeof (arelent));
-		    if (sec->relocation == NULL)
+		    
+		    #ifdef FRCOV
+		    {if (FIXREVERTER[1829]) {
+		      if ((sec -> relocation == (void *) 0 ) && !(0))
+		        fprintf(stderr, "triggered bug index 1829\n");
+		      else
+		        fprintf(stderr, "reached bug index 1829\n");
+		    }
+		    if ((!FIXREVERTER[1829] && (sec -> relocation == (void *) 0 ))
+		    #else
+		    if (0
+		    #endif
+		    )
 		      return false;
+		      #ifdef FRCOV
+		      }
+		      #endif
 		  }
 	      }
 	    reloc = &sec->relocation[sec->reloc_count];
@@ -5958,30 +6800,90 @@ evax_bfd_print_emh (FILE *file, unsigned char *rec, unsigned int rec_len)
 		 (unsigned) bfd_getl32 (mhd->recsiz));
 	name = (char *)(mhd + 1);
 	maxname = (char *) rec + rec_len;
-	if (name > maxname - 2)
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[1834]) {
+	  if ((name > maxname - 2 ) && !(0))
+	    fprintf(stderr, "triggered bug index 1834\n");
+	  else
+	    fprintf(stderr, "reached bug index 1834\n");
+	}
+	if ((!FIXREVERTER[1834] && (name > maxname - 2 ))
+	#else
+	if (0
+	#endif
+	)
 	  {
 	    fprintf (file, _("   Error: The module name is missing\n"));
 	    return;
 	  }
+	  #ifdef FRCOV
+	  }
+	  #endif
 	nextname = name + name[0] + 1;
-	if (nextname >= maxname)
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[1835]) {
+	  if ((nextname >= maxname ) && !(0))
+	    fprintf(stderr, "triggered bug index 1835\n");
+	  else
+	    fprintf(stderr, "reached bug index 1835\n");
+	}
+	if ((!FIXREVERTER[1835] && (nextname >= maxname ))
+	#else
+	if (0
+	#endif
+	)
 	  {
 	    fprintf (file, _("   Error: The module name is too long\n"));
 	    return;
 	  }
+	  #ifdef FRCOV
+	  }
+	  #endif
 	fprintf (file, _("   module name    : %.*s\n"), name[0], name + 1);
 	name = nextname;
-	if (name > maxname - 2)
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[1836]) {
+	  if ((name > maxname - 2 ) && !(0))
+	    fprintf(stderr, "triggered bug index 1836\n");
+	  else
+	    fprintf(stderr, "reached bug index 1836\n");
+	}
+	if ((!FIXREVERTER[1836] && (name > maxname - 2 ))
+	#else
+	if (0
+	#endif
+	)
 	  {
 	    fprintf (file, _("   Error: The module version is missing\n"));
 	    return;
 	  }
+	  #ifdef FRCOV
+	  }
+	  #endif
 	nextname = name + name[0] + 1;
-	if (nextname >= maxname)
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[1837]) {
+	  if ((nextname >= maxname ) && !(0))
+	    fprintf(stderr, "triggered bug index 1837\n");
+	  else
+	    fprintf(stderr, "reached bug index 1837\n");
+	}
+	if ((!FIXREVERTER[1837] && (nextname >= maxname ))
+	#else
+	if (0
+	#endif
+	)
 	  {
 	    fprintf (file, _("   Error: The module version is too long\n"));
 	    return;
 	  }
+	  #ifdef FRCOV
+	  }
+	  #endif
 	fprintf (file, _("   module version : %.*s\n"), name[0], name + 1);
 	name = nextname;
 	if ((maxname - name) < 17 && maxname[-1] != 0)
@@ -6120,11 +7022,26 @@ evax_bfd_print_egsd (FILE *file, unsigned char *rec, unsigned int rec_len)
 	       n, type, len);
       n++;
 
-      if (off + len > rec_len || off + len < off)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[1838]) {
+        if ((off + len > rec_len || off + len < off ) && !(0))
+          fprintf(stderr, "triggered bug index 1838\n");
+        else
+          fprintf(stderr, "reached bug index 1838\n");
+      }
+      if ((!FIXREVERTER[1838] && (off + len > rec_len || off + len < off ))
+      #else
+      if (0
+      #endif
+      )
 	{
 	  fprintf (file, _("   Error: length larger than remaining space in record\n"));
 	  return;
 	}
+	#ifdef FRCOV
+	}
+	#endif
 
       switch (type)
 	{
@@ -6371,11 +7288,26 @@ evax_bfd_print_etir (FILE *file, const char *name,
       size = bfd_getl16 (etir->size);
       buf = rec + off + sizeof (struct vms_etir);
 
-      if (off + size > rec_len || off + size < off)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[1839]) {
+        if ((off + size > rec_len || off + size < off ) && !(0))
+          fprintf(stderr, "triggered bug index 1839\n");
+        else
+          fprintf(stderr, "reached bug index 1839\n");
+      }
+      if ((!FIXREVERTER[1839] && (off + size > rec_len || off + size < off ))
+      #else
+      if (0
+      #endif
+      )
 	{
 	  fprintf (file, _("   Error: length larger than remaining space in record\n"));
 	  return;
 	}
+	#ifdef FRCOV
+	}
+	#endif
 
       /* xgettext:c-format */
       fprintf (file, _("   (type: %3u, size: 4+%3u): "), type, size - 4);
@@ -7202,21 +8134,51 @@ evax_bfd_print_dst (struct bfd *abfd, unsigned int dst_size, FILE *file)
       /* xgettext:c-format */
       fprintf (file, _(" type: %3u, len: %3u (at 0x%08x): "),
 	       type, len, off);
-      if (len == 0)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[1848]) {
+        if ((len == 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 1848\n");
+        else
+          fprintf(stderr, "reached bug index 1848\n");
+      }
+      if ((!FIXREVERTER[1848] && (len == 0 ))
+      #else
+      if (0
+      #endif
+      )
 	{
 	  fputc ('\n', file);
 	  break;
 	}
+	#ifdef FRCOV
+	}
+	#endif
       len++;
       dst_size -= len;
       off += len;
       len -= sizeof (dsth);
       buf = _bfd_malloc_and_read (abfd, len, len);
-      if (buf == NULL)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[1849]) {
+        if ((buf == (void *) 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 1849\n");
+        else
+          fprintf(stderr, "reached bug index 1849\n");
+      }
+      if ((!FIXREVERTER[1849] && (buf == (void *) 0 ))
+      #else
+      if (0
+      #endif
+      )
 	{
 	  fprintf (file, _("cannot read DST symbol\n"));
 	  return;
 	}
+	#ifdef FRCOV
+	}
+	#endif
       switch (type)
 	{
 	case DSC__K_DTYPE_V:
@@ -7965,8 +8927,23 @@ evax_bfd_print_image (bfd *abfd, FILE *file)
 	       (unsigned)bfd_getl32 (eisd.majorid),
 	       (unsigned)bfd_getl32 (eisd.minorid),
 	       len, eisd_off);
-      if (len == 0)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[1850]) {
+        if ((len == 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 1850\n");
+        else
+          fprintf(stderr, "reached bug index 1850\n");
+      }
+      if ((!FIXREVERTER[1850] && (len == 0 ))
+      #else
+      if (0
+      #endif
+      )
 	break;
+	#ifdef FRCOV
+	}
+	#endif
       /* xgettext:c-format */
       fprintf (file, _(" section: base: 0x%08x%08x size: 0x%08x\n"),
 	       (unsigned)bfd_getl32 (eisd.virt_addr + 4),
@@ -8380,8 +9357,23 @@ alpha_vms_read_sections_content (bfd *abfd, struct bfd_link_info *info)
 	  break;
 	case EOBJ__C_EDBG:
 	case EOBJ__C_ETBT:
-	  if (dst_section == NULL)
+	  
+	  #ifdef FRCOV
+	  {if (FIXREVERTER[1852]) {
+	    if ((dst_section == (void *) 0 ) && !(0))
+	      fprintf(stderr, "triggered bug index 1852\n");
+	    else
+	      fprintf(stderr, "reached bug index 1852\n");
+	  }
+	  if ((!FIXREVERTER[1852] && (dst_section == (void *) 0 ))
+	  #else
+	  if (0
+	  #endif
+	  )
 	    continue;
+	    #ifdef FRCOV
+	    }
+	    #endif
 	  PRIV (image_section) = dst_section;
 	  PRIV (image_offset) = dst_offset;
 	  res = _bfd_vms_slurp_etir (abfd, info);
@@ -8421,8 +9413,23 @@ alpha_vms_add_fixup_lp (struct bfd_link_info *info, bfd *src, bfd *shlib)
 		struct alpha_vms_shlib_el, PRIV2 (shlib, shr_index));
   sl->has_fixups = true;
   p = VEC_APPEND (sl->lp, bfd_vma);
-  if (p == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[1853]) {
+    if ((p == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 1853\n");
+    else
+      fprintf(stderr, "reached bug index 1853\n");
+  }
+  if ((!FIXREVERTER[1853] && (p == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     return false;
+    #ifdef FRCOV
+    }
+    #endif
   *p = sect->output_section->vma + sect->output_offset + offset;
   sect->output_section->flags |= SEC_RELOC;
   return true;
@@ -8442,8 +9449,23 @@ alpha_vms_add_fixup_ca (struct bfd_link_info *info, bfd *src, bfd *shlib)
 		struct alpha_vms_shlib_el, PRIV2 (shlib, shr_index));
   sl->has_fixups = true;
   p = VEC_APPEND (sl->ca, bfd_vma);
-  if (p == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[1854]) {
+    if ((p == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 1854\n");
+    else
+      fprintf(stderr, "reached bug index 1854\n");
+  }
+  if ((!FIXREVERTER[1854] && (p == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     return false;
+    #ifdef FRCOV
+    }
+    #endif
   *p = sect->output_section->vma + sect->output_offset + offset;
   sect->output_section->flags |= SEC_RELOC;
   return true;
@@ -8464,8 +9486,23 @@ alpha_vms_add_fixup_qr (struct bfd_link_info *info, bfd *src,
 		struct alpha_vms_shlib_el, PRIV2 (shlib, shr_index));
   sl->has_fixups = true;
   r = VEC_APPEND (sl->qr, struct alpha_vms_vma_ref);
-  if (r == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[1855]) {
+    if ((r == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 1855\n");
+    else
+      fprintf(stderr, "reached bug index 1855\n");
+  }
+  if ((!FIXREVERTER[1855] && (r == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     return false;
+    #ifdef FRCOV
+    }
+    #endif
   r->vma = sect->output_section->vma + sect->output_offset + offset;
   r->ref = vec;
   sect->output_section->flags |= SEC_RELOC;
@@ -8619,8 +9656,23 @@ alpha_vms_link_add_object_symbols (bfd *abfd, struct bfd_link_info *info)
 
       shlib = VEC_APPEND (alpha_vms_link_hash (info)->shrlibs,
 			  struct alpha_vms_shlib_el);
-      if (shlib == NULL)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[1859]) {
+        if ((shlib == (void *) 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 1859\n");
+        else
+          fprintf(stderr, "reached bug index 1859\n");
+      }
+      if ((!FIXREVERTER[1859] && (shlib == (void *) 0 ))
+      #else
+      if (0
+      #endif
+      )
 	return false;
+	#ifdef FRCOV
+	}
+	#endif
       shlib->abfd = abfd;
       VEC_INIT (shlib->ca);
       VEC_INIT (shlib->lp);
@@ -8688,8 +9740,23 @@ alpha_vms_link_add_archive_symbols (bfd *abfd, struct bfd_link_info *info)
 	}
 
       element = bfd_get_elt_at_index (abfd, symidx);
-      if (element == NULL)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[1860]) {
+        if ((element == (void *) 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 1860\n");
+        else
+          fprintf(stderr, "reached bug index 1860\n");
+      }
+      if ((!FIXREVERTER[1860] && (element == (void *) 0 ))
+      #else
+      if (0
+      #endif
+      )
 	return false;
+	#ifdef FRCOV
+	}
+	#endif
 
       if (element->archive_pass == -1 || element->archive_pass == pass)
 	{
@@ -8826,8 +9893,23 @@ alpha_vms_build_fixups (struct bfd_link_info *info)
     + ca_sz + lp_sz + qr_sz + chgprt_sz;
   sz = (sz + VMS_BLOCK_SIZE - 1) & ~(VMS_BLOCK_SIZE - 1);
   content = bfd_zalloc (info->output_bfd, sz);
-  if (content == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[1861]) {
+    if ((content == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 1861\n");
+    else
+      fprintf(stderr, "reached bug index 1861\n");
+  }
+  if ((!FIXREVERTER[1861] && (content == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     return false;
+    #ifdef FRCOV
+    }
+    #endif
 
   sec = alpha_vms_link_hash (info)->fixup;
   sec->contents = content;
@@ -9234,15 +10316,60 @@ alpha_vms_bfd_final_link (bfd *abfd, struct bfd_link_info *info)
       if (o->flags & SEC_HAS_CONTENTS)
 	{
 	  o->contents = bfd_alloc (abfd, o->size);
-	  if (o->contents == NULL)
+	  
+	  #ifdef FRCOV
+	  {if (FIXREVERTER[1862]) {
+	    if ((o -> contents == (void *) 0 ) && !(0))
+	      fprintf(stderr, "triggered bug index 1862\n");
+	    else
+	      fprintf(stderr, "reached bug index 1862\n");
+	  }
+	  if ((!FIXREVERTER[1862] && (o -> contents == (void *) 0 ))
+	  #else
+	  if (0
+	  #endif
+	  )
 	    return false;
+	    #ifdef FRCOV
+	    }
+	    #endif
 	}
       if (o->flags & SEC_LOAD)
 	{
-	  if (o->vma < base_addr)
+	  
+	  #ifdef FRCOV
+	  {if (FIXREVERTER[1863]) {
+	    if ((o -> vma < base_addr ) && !(0))
+	      fprintf(stderr, "triggered bug index 1863\n");
+	    else
+	      fprintf(stderr, "reached bug index 1863\n");
+	  }
+	  if ((!FIXREVERTER[1863] && (o -> vma < base_addr ))
+	  #else
+	  if (0
+	  #endif
+	  )
 	    base_addr = o->vma;
-	  if (o->vma + o->size > last_addr)
+	    #ifdef FRCOV
+	    }
+	    #endif
+	  
+	  #ifdef FRCOV
+	  {if (FIXREVERTER[1864]) {
+	    if ((o -> vma + o -> size > last_addr ) && !(0))
+	      fprintf(stderr, "triggered bug index 1864\n");
+	    else
+	      fprintf(stderr, "reached bug index 1864\n");
+	  }
+	  if ((!FIXREVERTER[1864] && (o -> vma + o -> size > last_addr ))
+	  #else
+	  if (0
+	  #endif
+	  )
 	    last_addr = o->vma + o->size;
+	    #ifdef FRCOV
+	    }
+	    #endif
 	}
       /* Clear the RELOC flags.  Currently we don't support incremental
 	 linking.  We use the RELOC flag for computing the eicp entries.  */
@@ -9253,8 +10380,23 @@ alpha_vms_bfd_final_link (bfd *abfd, struct bfd_link_info *info)
   fixupsec = bfd_make_section_anyway_with_flags
     (info->output_bfd, "$FIXUP$",
      SEC_ALLOC | SEC_LOAD | SEC_HAS_CONTENTS | SEC_LINKER_CREATED);
-  if (fixupsec == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[1865]) {
+    if ((fixupsec == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 1865\n");
+    else
+      fprintf(stderr, "reached bug index 1865\n");
+  }
+  if ((!FIXREVERTER[1865] && (fixupsec == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     return false;
+    #ifdef FRCOV
+    }
+    #endif
   last_addr = (last_addr + 0xffff) & ~0xffff;
   fixupsec->vma = last_addr;
 
@@ -9272,8 +10414,23 @@ alpha_vms_bfd_final_link (bfd *abfd, struct bfd_link_info *info)
       dmt = bfd_make_section_anyway_with_flags
 	(info->output_bfd, "$DMT$",
 	 SEC_DEBUGGING | SEC_HAS_CONTENTS | SEC_LINKER_CREATED);
-      if (dmt == NULL)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[1866]) {
+        if ((dmt == (void *) 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 1866\n");
+        else
+          fprintf(stderr, "reached bug index 1866\n");
+      }
+      if ((!FIXREVERTER[1866] && (dmt == (void *) 0 ))
+      #else
+      if (0
+      #endif
+      )
 	return false;
+	#ifdef FRCOV
+	}
+	#endif
     }
   else
     dmt = NULL;
@@ -9338,8 +10495,23 @@ alpha_vms_bfd_final_link (bfd *abfd, struct bfd_link_info *info)
 
 	      /* Skip this module if it has no DST.  */
 	      sub_dst = PRIV2 (sub, dst_section);
-	      if (sub_dst == NULL || sub_dst->size == 0)
+	      
+	      #ifdef FRCOV
+	      {if (FIXREVERTER[1867]) {
+	        if ((sub_dst == (void *) 0 || sub_dst -> size == 0 ) && !(0))
+	          fprintf(stderr, "triggered bug index 1867\n");
+	        else
+	          fprintf(stderr, "reached bug index 1867\n");
+	      }
+	      if ((!FIXREVERTER[1867] && (sub_dst == (void *) 0 || sub_dst -> size == 0 ))
+	      #else
+	      if (0
+	      #endif
+	      )
 		continue;
+		#ifdef FRCOV
+		}
+		#endif
 
 	      if (pass == 1)
 		{
@@ -9381,8 +10553,23 @@ alpha_vms_bfd_final_link (bfd *abfd, struct bfd_link_info *info)
 	  if (pass == 0)
 	    {
 	      contents = bfd_zalloc (info->output_bfd, off);
-	      if (contents == NULL)
+	      
+	      #ifdef FRCOV
+	      {if (FIXREVERTER[1868]) {
+	        if ((contents == (void *) 0 ) && !(0))
+	          fprintf(stderr, "triggered bug index 1868\n");
+	        else
+	          fprintf(stderr, "reached bug index 1868\n");
+	      }
+	      if ((!FIXREVERTER[1868] && (contents == (void *) 0 ))
+	      #else
+	      if (0
+	      #endif
+	      )
 		return false;
+		#ifdef FRCOV
+		}
+		#endif
 	      dmt->contents = contents;
 	      dmt->size = off;
 	    }
@@ -9413,12 +10600,26 @@ alpha_vms_get_section_contents (bfd *abfd, asection *section,
 					      buf, offset, count);
 
   /* Safety check.  */
-  if (offset + count < count
-      || offset + count > section->size)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[1869]) {
+    if ((offset + count < count || offset + count > section -> size ) && !(0))
+      fprintf(stderr, "triggered bug index 1869\n");
+    else
+      fprintf(stderr, "reached bug index 1869\n");
+  }
+  if ((!FIXREVERTER[1869] && (offset + count < count || offset + count > section -> size ))
+  #else
+  if (0
+  #endif
+  )
     {
       bfd_set_error (bfd_error_invalid_operation);
       return false;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
   /* If the section is already in memory, just copy it.  */
   if (section->flags & SEC_IN_MEMORY)
@@ -9427,8 +10628,23 @@ alpha_vms_get_section_contents (bfd *abfd, asection *section,
       memcpy (buf, section->contents + offset, count);
       return true;
     }
-  if (section->size == 0)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[1871]) {
+    if ((section -> size == 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 1871\n");
+    else
+      fprintf(stderr, "reached bug index 1871\n");
+  }
+  if ((!FIXREVERTER[1871] && (section -> size == 0 ))
+  #else
+  if (0
+  #endif
+  )
     return true;
+    #ifdef FRCOV
+    }
+    #endif
 
   /* Alloc in memory and read ETIRs.  */
   for (sec = abfd->sections; sec; sec = sec->next)
@@ -9438,8 +10654,23 @@ alpha_vms_get_section_contents (bfd *abfd, asection *section,
       if (sec->size != 0 && (sec->flags & SEC_HAS_CONTENTS))
 	{
 	  sec->contents = bfd_alloc (abfd, sec->size);
-	  if (sec->contents == NULL)
+	  
+	  #ifdef FRCOV
+	  {if (FIXREVERTER[1872]) {
+	    if ((sec -> contents == (void *) 0 ) && !(0))
+	      fprintf(stderr, "triggered bug index 1872\n");
+	    else
+	      fprintf(stderr, "reached bug index 1872\n");
+	  }
+	  if ((!FIXREVERTER[1872] && (sec -> contents == (void *) 0 ))
+	  #else
+	  if (0
+	  #endif
+	  )
 	    return false;
+	    #ifdef FRCOV
+	    }
+	    #endif
 	}
     }
   if (!alpha_vms_read_sections_content (abfd, NULL))
@@ -9470,11 +10701,26 @@ alpha_vms_mkobject (bfd * abfd)
 
   arch = bfd_scan_arch ("alpha");
 
-  if (arch == 0)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[1874]) {
+    if ((arch == 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 1874\n");
+    else
+      fprintf(stderr, "reached bug index 1874\n");
+  }
+  if ((!FIXREVERTER[1874] && (arch == 0 ))
+  #else
+  if (0
+  #endif
+  )
     {
       bfd_set_error (bfd_error_wrong_format);
       return false;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
   abfd->arch_info = arch;
   return true;
@@ -9530,8 +10776,23 @@ vms_new_section_hook (bfd * abfd, asection *section)
 
   amt = sizeof (struct vms_section_data_struct);
   section->used_by_bfd = bfd_zalloc (abfd, amt);
-  if (section->used_by_bfd == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[1875]) {
+    if ((section -> used_by_bfd == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 1875\n");
+    else
+      fprintf(stderr, "reached bug index 1875\n");
+  }
+  if ((!FIXREVERTER[1875] && (section -> used_by_bfd == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     return false;
+    #ifdef FRCOV
+    }
+    #endif
 
   /* Create the section symbol.  */
   return _bfd_generic_new_section_hook (abfd, section);
@@ -9597,8 +10858,23 @@ vms_get_symbol_info (bfd * abfd ATTRIBUTE_UNUSED,
 
   sec = symbol->section;
 
-  if (ret == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[1876]) {
+    if ((ret == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 1876\n");
+    else
+      fprintf(stderr, "reached bug index 1876\n");
+  }
+  if ((!FIXREVERTER[1876] && (ret == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     return;
+    #ifdef FRCOV
+    }
+    #endif
 
   if (sec == NULL)
     ret->type = 'U';
@@ -9658,8 +10934,23 @@ _bfd_vms_set_section_contents (bfd * abfd,
   if (section->contents == NULL)
     {
       section->contents = bfd_alloc (abfd, section->size);
-      if (section->contents == NULL)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[1877]) {
+        if ((section -> contents == (void *) 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 1877\n");
+        else
+          fprintf(stderr, "reached bug index 1877\n");
+      }
+      if ((!FIXREVERTER[1877] && (section -> contents == (void *) 0 ))
+      #else
+      if (0
+      #endif
+      )
 	return false;
+	#ifdef FRCOV
+	}
+	#endif
 
       memcpy (section->contents + offset, location, (size_t) count);
     }
diff --git a/bfd/vms-lib.c b/bfd/vms-lib.c
old mode 100644
new mode 100755
index 55e6130..9899bd4
--- a/bfd/vms-lib.c
+++ b/bfd/vms-lib.c
@@ -1,3 +1,6 @@
+#ifdef FRCOV
+extern short FIXREVERTER[];
+#endif
 /* BFD back-end for VMS archive files.
 
    Copyright (C) 2010-2021 Free Software Foundation, Inc.
@@ -145,8 +148,23 @@ vms_add_index (struct carsym_mem *cs, char *name,
 	  return false;
 	}
       cs->max = 2 * cs->max + 32;
-      if (cs->max > cs->limit)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[2028]) {
+        if ((cs -> max > cs -> limit  ) && !(0))
+          fprintf(stderr, "triggered bug index 2028\n");
+        else
+          fprintf(stderr, "reached bug index 2028\n");
+      }
+      if ((!FIXREVERTER[2028] && (cs -> max > cs -> limit  ))
+      #else
+      if (0
+      #endif
+      )
 	cs->max = cs->limit;
+	#ifdef FRCOV
+	}
+	#endif
       if (_bfd_mul_overflow (cs->max, sizeof (struct carsym), &amt))
 	{
 	  bfd_set_error (bfd_error_file_too_big);
@@ -156,16 +174,46 @@ vms_add_index (struct carsym_mem *cs, char *name,
       if (!cs->realloced)
 	{
 	  n = bfd_malloc (amt);
-	  if (n == NULL)
+	  
+	  #ifdef FRCOV
+	  {if (FIXREVERTER[2029]) {
+	    if ((n == (void *) 0 ) && !(0))
+	      fprintf(stderr, "triggered bug index 2029\n");
+	    else
+	      fprintf(stderr, "reached bug index 2029\n");
+	  }
+	  if ((!FIXREVERTER[2029] && (n == (void *) 0 ))
+	  #else
+	  if (0
+	  #endif
+	  )
 	    return false;
+	    #ifdef FRCOV
+	    }
+	    #endif
 	  memcpy (n, cs->idx, cs->nbr * sizeof (struct carsym));
 	  /* And unfortunately we can't free cs->idx.  */
 	}
       else
 	{
 	  n = bfd_realloc_or_free (cs->idx, amt);
-	  if (n == NULL)
+	  
+	  #ifdef FRCOV
+	  {if (FIXREVERTER[2030]) {
+	    if ((n == (void *) 0 ) && !(0))
+	      fprintf(stderr, "triggered bug index 2030\n");
+	    else
+	      fprintf(stderr, "reached bug index 2030\n");
+	  }
+	  if ((!FIXREVERTER[2030] && (n == (void *) 0 ))
+	  #else
+	  if (0
+	  #endif
+	  )
 	    return false;
+	    #ifdef FRCOV
+	    }
+	    #endif
 	}
       cs->idx = n;
       cs->realloced = true;
@@ -190,8 +238,23 @@ vms_add_indexes_from_list (bfd *abfd, struct carsym_mem *cs, char *name,
   while (1)
     {
       vbn = bfd_getl32 (rfa->vbn);
-      if (vbn == 0)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[2031]) {
+        if ((vbn == 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 2031\n");
+        else
+          fprintf(stderr, "reached bug index 2031\n");
+      }
+      if ((!FIXREVERTER[2031] && (vbn == 0 ))
+      #else
+      if (0
+      #endif
+      )
 	return true;
+	#ifdef FRCOV
+	}
+	#endif
 
       /* Read the LHS.  */
       off = (vbn - 1) * VMS_BLOCK_SIZE + bfd_getl16 (rfa->offset);
@@ -305,13 +368,43 @@ vms_traverse_index (bfd *abfd, unsigned int vbn, struct carsym_mem *cs,
 	return false;
 
       /* Illegal value.  */
-      if (idx_vbn == 0)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[2033]) {
+        if ((idx_vbn == 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 2033\n");
+        else
+          fprintf(stderr, "reached bug index 2033\n");
+      }
+      if ((!FIXREVERTER[2033] && (idx_vbn == 0 ))
+      #else
+      if (0
+      #endif
+      )
 	return false;
+	#ifdef FRCOV
+	}
+	#endif
 
       /* Point to the next index entry.  */
       p = keyname + keylen;
-      if (p > endp)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[2034]) {
+        if ((p > endp ) && !(0))
+          fprintf(stderr, "triggered bug index 2034\n");
+        else
+          fprintf(stderr, "reached bug index 2034\n");
+      }
+      if ((!FIXREVERTER[2034] && (p > endp ))
+      #else
+      if (0
+      #endif
+      )
 	return false;
+	#ifdef FRCOV
+	}
+	#endif
 
       if (idx_off == RFADEF__C_INDEX)
 	{
@@ -341,8 +434,23 @@ vms_traverse_index (bfd *abfd, unsigned int vbn, struct carsym_mem *cs,
 	      keylen = bfd_getl16 (kbn->keylen);
 
 	      name = bfd_alloc (abfd, keylen + 1);
-	      if (name == NULL)
+	      
+	      #ifdef FRCOV
+	      {if (FIXREVERTER[2036]) {
+	        if ((name == (void *) 0 ) && !(0))
+	          fprintf(stderr, "triggered bug index 2036\n");
+	        else
+	          fprintf(stderr, "reached bug index 2036\n");
+	      }
+	      if ((!FIXREVERTER[2036] && (name == (void *) 0 ))
+	      #else
+	      if (0
+	      #endif
+	      )
 		return false;
+		#ifdef FRCOV
+		}
+		#endif
 	      kvbn = bfd_getl32 (kbn->rfa.vbn);
 	      koff = bfd_getl16 (kbn->rfa.offset);
 
@@ -362,23 +470,68 @@ vms_traverse_index (bfd *abfd, unsigned int vbn, struct carsym_mem *cs,
 		  kvbn = bfd_getl32 (kbn->rfa.vbn);
 		  koff = bfd_getl16 (kbn->rfa.offset);
 
-		  if (noff + klen > keylen)
+		  
+		  #ifdef FRCOV
+		  {if (FIXREVERTER[2037]) {
+		    if ((noff + klen > keylen ) && !(0))
+		      fprintf(stderr, "triggered bug index 2037\n");
+		    else
+		      fprintf(stderr, "reached bug index 2037\n");
+		  }
+		  if ((!FIXREVERTER[2037] && (noff + klen > keylen ))
+		  #else
+		  if (0
+		  #endif
+		  )
 		    return false;
+		    #ifdef FRCOV
+		    }
+		    #endif
 		  memcpy (name + noff, kbn + 1, klen);
 		  noff += klen;
 		}
 	      while (kvbn != 0);
 
 	      /* Sanity check.  */
-	      if (noff != keylen)
+	      
+	      #ifdef FRCOV
+	      {if (FIXREVERTER[2039]) {
+	        if ((noff != keylen ) && !(0))
+	          fprintf(stderr, "triggered bug index 2039\n");
+	        else
+	          fprintf(stderr, "reached bug index 2039\n");
+	      }
+	      if ((!FIXREVERTER[2039] && (noff != keylen ))
+	      #else
+	      if (0
+	      #endif
+	      )
 		return false;
+		#ifdef FRCOV
+		}
+		#endif
 	    }
 	  else
 	    {
 	      /* Usual key name.  */
 	      name = bfd_alloc (abfd, keylen + 1);
-	      if (name == NULL)
+	      
+	      #ifdef FRCOV
+	      {if (FIXREVERTER[2040]) {
+	        if ((name == (void *) 0 ) && !(0))
+	          fprintf(stderr, "triggered bug index 2040\n");
+	        else
+	          fprintf(stderr, "reached bug index 2040\n");
+	      }
+	      if ((!FIXREVERTER[2040] && (name == (void *) 0 ))
+	      #else
+	      if (0
+	      #endif
+	      )
 		return false;
+		#ifdef FRCOV
+		}
+		#endif
 
 	      memcpy (name, keyname, keylen);
 	    }
@@ -453,13 +606,43 @@ vms_lib_read_index (bfd *abfd, int idx, unsigned int *nbrel)
       if (filesize / (sizeof (struct vms_rfa) + 2) <= -1u)
 	csm.limit = filesize / (sizeof (struct vms_rfa) + 2);
     }
-  if (csm.max > csm.limit)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[2042]) {
+    if ((csm . max > csm . limit  ) && !(0))
+      fprintf(stderr, "triggered bug index 2042\n");
+    else
+      fprintf(stderr, "reached bug index 2042\n");
+  }
+  if ((!FIXREVERTER[2042] && (csm . max > csm . limit  ))
+  #else
+  if (0
+  #endif
+  )
     csm.max = csm.limit;
+    #ifdef FRCOV
+    }
+    #endif
   if (_bfd_mul_overflow (csm.max, sizeof (struct carsym), &amt))
     return NULL;
   csm.idx = csbuf = bfd_alloc (abfd, amt);
-  if (csm.idx == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[2043]) {
+    if ((csm . idx == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 2043\n");
+    else
+      fprintf(stderr, "reached bug index 2043\n");
+  }
+  if ((!FIXREVERTER[2043] && (csm . idx == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     return NULL;
+    #ifdef FRCOV
+    }
+    #endif
 
   /* Note: if the index is empty, there is no block to traverse.  */
   vbn = bfd_getl32 (idd.vbn);
@@ -479,8 +662,23 @@ vms_lib_read_index (bfd *abfd, int idx, unsigned int *nbrel)
       /* There are more entries than the first estimate.  Allocate on
 	 the BFD's objalloc.  */
       csbuf = bfd_alloc (abfd, csm.nbr * sizeof (struct carsym));
-      if (csbuf == NULL)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[2044]) {
+        if ((csbuf == (void *) 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 2044\n");
+        else
+          fprintf(stderr, "reached bug index 2044\n");
+      }
+      if ((!FIXREVERTER[2044] && (csbuf == (void *) 0 ))
+      #else
+      if (0
+      #endif
+      )
 	return NULL;
+	#ifdef FRCOV
+	}
+	#endif
       memcpy (csbuf, csm.idx, csm.nbr * sizeof (struct carsym));
       free (csm.idx);
       csm.idx = csbuf;
@@ -560,8 +758,23 @@ _bfd_vms_lib_archive_p (bfd *abfd, enum vms_lib_kind kind)
   /* Allocate and initialize private data.  */
   tdata_hold = bfd_libdata (abfd);
   tdata = (struct lib_tdata *) bfd_zalloc (abfd, sizeof (struct lib_tdata));
-  if (tdata == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[2045]) {
+    if ((tdata == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 2045\n");
+    else
+      fprintf(stderr, "reached bug index 2045\n");
+  }
+  if ((!FIXREVERTER[2045] && (tdata == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     return NULL;
+    #ifdef FRCOV
+    }
+    #endif
   abfd->tdata.any = (void *)tdata;
   tdata->ver = majorid;
   tdata->mhd_size = MHD__C_USRDAT + lhd.mhdusz;
@@ -575,8 +788,23 @@ _bfd_vms_lib_archive_p (bfd *abfd, enum vms_lib_kind kind)
   tdata->artdata.symdef_count = bfd_getl32 (lhd.idxcnt) - tdata->nbr_modules;
   nbr_ent = tdata->nbr_modules;
   tdata->modules = vms_lib_read_index (abfd, 0, &nbr_ent);
-  if (tdata->modules == NULL || nbr_ent != tdata->nbr_modules)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[2046]) {
+    if ((tdata -> modules == (void *) 0 || nbr_ent != tdata -> nbr_modules ) && !(0))
+      fprintf(stderr, "triggered bug index 2046\n");
+    else
+      fprintf(stderr, "reached bug index 2046\n");
+  }
+  if ((!FIXREVERTER[2046] && (tdata -> modules == (void *) 0 || nbr_ent != tdata -> nbr_modules ))
+  #else
+  if (0
+  #endif
+  )
     goto err;
+    #ifdef FRCOV
+    }
+    #endif
   if (lhd.nindex == 2)
     {
       nbr_ent = tdata->artdata.symdef_count;
@@ -591,8 +819,23 @@ _bfd_vms_lib_archive_p (bfd *abfd, enum vms_lib_kind kind)
       tdata->artdata.symdef_count = nbr_ent;
     }
   tdata->cache = bfd_zalloc (abfd, sizeof (bfd *) * tdata->nbr_modules);
-  if (tdata->cache == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[2047]) {
+    if ((tdata -> cache == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 2047\n");
+    else
+      fprintf(stderr, "reached bug index 2047\n");
+  }
+  if ((!FIXREVERTER[2047] && (tdata -> cache == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     goto err;
+    #ifdef FRCOV
+    }
+    #endif
 
   /* Read DCX submaps.  */
   dcxvbn = bfd_getl32 (lhd.dcxmapvbn);
@@ -613,8 +856,23 @@ _bfd_vms_lib_archive_p (bfd *abfd, enum vms_lib_kind kind)
       if (reclen < sizeof (struct vms_dcxmap))
 	goto err;
       buf = _bfd_malloc_and_read (abfd, reclen, reclen);
-      if (buf == NULL)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[2049]) {
+        if ((buf == (void *) 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 2049\n");
+        else
+          fprintf(stderr, "reached bug index 2049\n");
+      }
+      if ((!FIXREVERTER[2049] && (buf == (void *) 0 ))
+      #else
+      if (0
+      #endif
+      )
 	goto err;
+	#ifdef FRCOV
+	}
+	#endif
       map = (struct vms_dcxmap *)buf;
       tdata->nbr_dcxsbm = bfd_getl16 (map->nsubs);
       sbm_off = bfd_getl16 (map->sub0);
@@ -640,8 +898,23 @@ _bfd_vms_lib_archive_p (bfd *abfd, enum vms_lib_kind kind)
 	  sbm = (struct vms_dcxsbm *) (buf + sbm_off);
 	  sbm_sz = bfd_getl16 (sbm->size);
 	  sbm_off += sbm_sz;
-	  if (sbm_off > reclen)
+	  
+	  #ifdef FRCOV
+	  {if (FIXREVERTER[2050]) {
+	    if ((sbm_off > reclen ) && !(0))
+	      fprintf(stderr, "triggered bug index 2050\n");
+	    else
+	      fprintf(stderr, "reached bug index 2050\n");
+	  }
+	  if ((!FIXREVERTER[2050] && (sbm_off > reclen ))
+	  #else
+	  if (0
+	  #endif
+	  )
 	    goto err_free_buf;
+	    #ifdef FRCOV
+	    }
+	    #endif
 
 	  sbmdesc->min_char = sbm->min_char;
 	  BFD_ASSERT (sbmdesc->min_char == 0);
@@ -654,22 +927,64 @@ _bfd_vms_lib_archive_p (bfd *abfd, enum vms_lib_kind kind)
 	    goto err_free_buf;
 	  sbmdesc->flags = (unsigned char *)bfd_alloc (abfd, l);
 	  off = bfd_getl16 (sbm->flags);
-	  if (off > sbm_sz
-	      || sbm_sz - off < l)
+	  
+	  #ifdef FRCOV
+	  {if (FIXREVERTER[2051]) {
+	    if ((off > sbm_sz || sbm_sz - off < l ) && !(0))
+	      fprintf(stderr, "triggered bug index 2051\n");
+	    else
+	      fprintf(stderr, "reached bug index 2051\n");
+	  }
+	  if ((!FIXREVERTER[2051] && (off > sbm_sz || sbm_sz - off < l ))
+	  #else
+	  if (0
+	  #endif
+	  )
 	    goto err_free_buf;
+	    #ifdef FRCOV
+	    }
+	    #endif
 	  memcpy (sbmdesc->flags, (bfd_byte *) sbm + off, l);
 	  sbmdesc->nodes = (unsigned char *)bfd_alloc (abfd, 2 * sbm_len);
 	  off = bfd_getl16 (sbm->nodes);
-	  if (off > sbm_sz
-	      || sbm_sz - off < 2 * sbm_len)
+	  
+	  #ifdef FRCOV
+	  {if (FIXREVERTER[2052]) {
+	    if ((off > sbm_sz || sbm_sz - off < 2 * sbm_len ) && !(0))
+	      fprintf(stderr, "triggered bug index 2052\n");
+	    else
+	      fprintf(stderr, "reached bug index 2052\n");
+	  }
+	  if ((!FIXREVERTER[2052] && (off > sbm_sz || sbm_sz - off < 2 * sbm_len ))
+	  #else
+	  if (0
+	  #endif
+	  )
 	    goto err_free_buf;
+	    #ifdef FRCOV
+	    }
+	    #endif
 	  memcpy (sbmdesc->nodes, (bfd_byte *) sbm + off, 2 * sbm_len);
 	  off = bfd_getl16 (sbm->next);
 	  if (off != 0)
 	    {
-	      if (off > sbm_sz
-		  || sbm_sz - off < 2 * sbm_len)
+	      
+	      #ifdef FRCOV
+	      {if (FIXREVERTER[2053]) {
+	        if ((off > sbm_sz || sbm_sz - off < 2 * sbm_len ) && !(0))
+	          fprintf(stderr, "triggered bug index 2053\n");
+	        else
+	          fprintf(stderr, "reached bug index 2053\n");
+	      }
+	      if ((!FIXREVERTER[2053] && (off > sbm_sz || sbm_sz - off < 2 * sbm_len ))
+	      #else
+	      if (0
+	      #endif
+	      )
 		goto err_free_buf;
+		#ifdef FRCOV
+		}
+		#endif
 	      /* Read the 'next' array.  */
 	      sbmdesc->next = (unsigned short *) bfd_alloc (abfd, 2 * sbm_len);
 	      buf1 = (bfd_byte *) sbm + off;
@@ -735,8 +1050,23 @@ _bfd_vms_lib_mkarchive (bfd *abfd, enum vms_lib_kind kind)
   struct lib_tdata *tdata;
 
   tdata = (struct lib_tdata *) bfd_zalloc (abfd, sizeof (struct lib_tdata));
-  if (tdata == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[2054]) {
+    if ((tdata == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 2054\n");
+    else
+      fprintf(stderr, "reached bug index 2054\n");
+  }
+  if ((!FIXREVERTER[2054] && (tdata == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     return false;
+    #ifdef FRCOV
+    }
+    #endif
 
   abfd->tdata.any = (void *)tdata;
   vms_get_time (&tdata->credat_hi, &tdata->credat_lo);
@@ -919,10 +1249,40 @@ vms_lib_bread_raw (struct bfd *abfd, unsigned char *buf, file_ptr nbytes)
 
       /* Do not read past the data block, do not read more than requested.  */
       l = DATA__LENGTH - vec->blk_off;
-      if (l > nbytes)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[2057]) {
+        if ((l > nbytes ) && !(0))
+          fprintf(stderr, "triggered bug index 2057\n");
+        else
+          fprintf(stderr, "reached bug index 2057\n");
+      }
+      if ((!FIXREVERTER[2057] && (l > nbytes ))
+      #else
+      if (0
+      #endif
+      )
 	l = nbytes;
-      if (l == 0)
+	#ifdef FRCOV
+	}
+	#endif
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[2058]) {
+        if ((l == 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 2058\n");
+        else
+          fprintf(stderr, "reached bug index 2058\n");
+      }
+      if ((!FIXREVERTER[2058] && (l == 0 ))
+      #else
+      if (0
+      #endif
+      )
 	return 0;
+	#ifdef FRCOV
+	}
+	#endif
       if (buf != NULL)
 	{
 	  /* Really read into BUF.  */
@@ -992,8 +1352,23 @@ vms_lib_dcx (struct vms_lib_iovec *vec, unsigned char *buf, file_ptr nbytes)
 	    {
 	      unsigned char v = sbm->nodes[offset];
 
-	      if (sbm->next != NULL)
+	      
+	      #ifdef FRCOV
+	      {if (FIXREVERTER[2060]) {
+	        if ((sbm -> next != (void *) 0 ) && !(0))
+	          fprintf(stderr, "triggered bug index 2060\n");
+	        else
+	          fprintf(stderr, "reached bug index 2060\n");
+	      }
+	      if ((!FIXREVERTER[2060] && (sbm -> next != (void *) 0 ))
+	      #else
+	      if (0
+	      #endif
+	      )
 		sbm = vec->dcxsbms + sbm->next[v];
+		#ifdef FRCOV
+		}
+		#endif
 	      offset = 0;
 	      res++;
 
@@ -1029,8 +1404,23 @@ vms_lib_bread (struct bfd *abfd, void *vbuf, file_ptr nbytes)
   unsigned char *buf = (unsigned char *)vbuf;
 
   /* Do not read past the end.  */
-  if (vec->where >= vec->file_len)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[2061]) {
+    if ((vec -> where >= vec -> file_len ) && !(0))
+      fprintf(stderr, "triggered bug index 2061\n");
+    else
+      fprintf(stderr, "reached bug index 2061\n");
+  }
+  if ((!FIXREVERTER[2061] && (vec -> where >= vec -> file_len ))
+  #else
+  if (0
+  #endif
+  )
     return 0;
+    #ifdef FRCOV
+    }
+    #endif
 
   res = 0;
   while (nbytes > 0)
@@ -1082,8 +1472,23 @@ vms_lib_bread (struct bfd *abfd, void *vbuf, file_ptr nbytes)
 		  while (len > vec->dcx_max)
 		    vec->dcx_max *= 2;
 		  vec->dcx_buf = bfd_alloc (abfd, vec->dcx_max);
-		  if (vec->dcx_buf == NULL)
+		  
+		  #ifdef FRCOV
+		  {if (FIXREVERTER[2063]) {
+		    if ((vec -> dcx_buf == (void *) 0 ) && !(0))
+		      fprintf(stderr, "triggered bug index 2063\n");
+		    else
+		      fprintf(stderr, "reached bug index 2063\n");
+		  }
+		  if ((!FIXREVERTER[2063] && (vec -> dcx_buf == (void *) 0 ))
+		  #else
+		  if (0
+		  #endif
+		  )
 		    return -1;
+		    #ifdef FRCOV
+		    }
+		    #endif
 		}
 
 	      /* Read the compressed record.  */
@@ -1096,8 +1501,23 @@ vms_lib_bread (struct bfd *abfd, void *vbuf, file_ptr nbytes)
 	      else
 		{
 		  elen = vms_lib_bread_raw (abfd, vec->dcx_buf, len);
-		  if (elen != len)
+		  
+		  #ifdef FRCOV
+		  {if (FIXREVERTER[2065]) {
+		    if ((elen != len ) && !(0))
+		      fprintf(stderr, "triggered bug index 2065\n");
+		    else
+		      fprintf(stderr, "reached bug index 2065\n");
+		  }
+		  if ((!FIXREVERTER[2065] && (elen != len ))
+		  #else
+		  if (0
+		  #endif
+		  )
 		    return -1;
+		    #ifdef FRCOV
+		    }
+		    #endif
 		}
 
 	      /* Dummy expansion to get the expanded length.  */
@@ -1105,8 +1525,23 @@ vms_lib_bread (struct bfd *abfd, void *vbuf, file_ptr nbytes)
 	      vec->dcx_sbm = vec->dcxsbms;
 	      vec->dcx_pos = 0;
 	      elen = vms_lib_dcx (vec, NULL, 0x10000);
-	      if (elen < 0)
+	      
+	      #ifdef FRCOV
+	      {if (FIXREVERTER[2066]) {
+	        if ((elen < 0 ) && !(0))
+	          fprintf(stderr, "triggered bug index 2066\n");
+	        else
+	          fprintf(stderr, "reached bug index 2066\n");
+	      }
+	      if ((!FIXREVERTER[2066] && (elen < 0 ))
+	      #else
+	      if (0
+	      #endif
+	      )
 		return -1;
+		#ifdef FRCOV
+		}
+		#endif
 	      vec->rec_len = elen;
 	      vec->rec_rem = elen;
 
@@ -1172,8 +1607,23 @@ vms_lib_bread (struct bfd *abfd, void *vbuf, file_ptr nbytes)
 	  else
 	    chunk = vms_lib_bread_raw (abfd, buf, chunk);
 	}
-      if (chunk < 0)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[2067]) {
+        if ((chunk < 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 2067\n");
+        else
+          fprintf(stderr, "reached bug index 2067\n");
+      }
+      if ((!FIXREVERTER[2067] && (chunk < 0 ))
+      #else
+      if (0
+      #endif
+      )
 	return -1;
+	#ifdef FRCOV
+	}
+	#endif
       res += chunk;
       if (buf != NULL)
 	buf += chunk;
@@ -1295,8 +1745,23 @@ vms_lib_bopen (bfd *el, file_ptr filepos)
 
   /* Allocate and initialized the iovec.  */
   vec = bfd_zalloc (el, sizeof (*vec));
-  if (vec == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[2069]) {
+    if ((vec == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 2069\n");
+    else
+      fprintf(stderr, "reached bug index 2069\n");
+  }
+  if ((!FIXREVERTER[2069] && (vec == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     return false;
+    #ifdef FRCOV
+    }
+    #endif
 
   el->iostream = vec;
   el->iovec = &vms_lib_iovec;
@@ -1320,8 +1785,23 @@ vms_lib_bopen (bfd *el, file_ptr filepos)
   len = tdata->mhd_size;
   if (vms_lib_bread_raw (el, buf, 2) != 2)
     return false;
-  if (bfd_getl16 (buf) != len)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[2070]) {
+    if ((bfd_getl16 ( buf ) != len ) && !(0))
+      fprintf(stderr, "triggered bug index 2070\n");
+    else
+      fprintf(stderr, "reached bug index 2070\n");
+  }
+  if ((!FIXREVERTER[2070] && (bfd_getl16 ( buf ) != len ))
+  #else
+  if (0
+  #endif
+  )
     return false;
+    #ifdef FRCOV
+    }
+    #endif
   len = (len + 1) & ~1;
   BFD_ASSERT (len <= sizeof (buf));
   if (vms_lib_bread_raw (el, buf, len) != len)
@@ -1332,8 +1812,23 @@ vms_lib_bopen (bfd *el, file_ptr filepos)
   /* Check id.  */
   if (mhd->id != MHD__C_MHDID)
     return false;
-  if (len >= MHD__C_MHDLEN + 1)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[2071]) {
+    if ((len >= 16 + 1  ) && !(0))
+      fprintf(stderr, "triggered bug index 2071\n");
+    else
+      fprintf(stderr, "reached bug index 2071\n");
+  }
+  if ((!FIXREVERTER[2071] && (len >= 16 + 1  ))
+  #else
+  if (0
+  #endif
+  )
     el->selective_search = (mhd->objstat & MHD__M_SELSRC) ? 1 : 0;
+    #ifdef FRCOV
+    }
+    #endif
   el->mtime = vms_rawtime_to_time_t (mhd->datim);
   el->mtime_set = true;
 
@@ -1351,8 +1846,23 @@ vms_lib_bopen (bfd *el, file_ptr filepos)
       vec->dcx_max = 10 * 1024;
       vec->dcx_buf = bfd_alloc (el, vec->dcx_max);
       vec->dcx_pos = -1;
-      if (vec->dcx_buf == NULL)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[2072]) {
+        if ((vec -> dcx_buf == (void *) 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 2072\n");
+        else
+          fprintf(stderr, "reached bug index 2072\n");
+      }
+      if ((!FIXREVERTER[2072] && (vec -> dcx_buf == (void *) 0 ))
+      #else
+      if (0
+      #endif
+      )
 	return -1;
+	#ifdef FRCOV
+	}
+	#endif
     }
   return true;
 }
@@ -1370,8 +1880,23 @@ _bfd_vms_lib_get_module (bfd *abfd, unsigned int modidx)
   size_t namelen;
 
   /* Sanity check.  */
-  if (modidx >= tdata->nbr_modules)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[2073]) {
+    if ((modidx >= tdata -> nbr_modules ) && !(0))
+      fprintf(stderr, "triggered bug index 2073\n");
+    else
+      fprintf(stderr, "reached bug index 2073\n");
+  }
+  if ((!FIXREVERTER[2073] && (modidx >= tdata -> nbr_modules ))
+  #else
+  if (0
+  #endif
+  )
     return NULL;
+    #ifdef FRCOV
+    }
+    #endif
 
   /* Already loaded.  */
   if (tdata->cache[modidx])
@@ -1382,8 +1907,23 @@ _bfd_vms_lib_get_module (bfd *abfd, unsigned int modidx)
   if (tdata->type != LBR__C_TYP_IOBJ)
     {
       res = _bfd_create_empty_archive_element_shell (abfd);
-      if (res == NULL)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[2074]) {
+        if ((res == (void *) 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 2074\n");
+        else
+          fprintf(stderr, "reached bug index 2074\n");
+      }
+      if ((!FIXREVERTER[2074] && (res == (void *) 0 ))
+      #else
+      if (0
+      #endif
+      )
 	return NULL;
+	#ifdef FRCOV
+	}
+	#endif
 
       /* Special reader to deal with data blocks.  */
       if (!vms_lib_bopen (res, file_off))
@@ -1410,14 +1950,44 @@ _bfd_vms_lib_get_module (bfd *abfd, unsigned int modidx)
 	return NULL;
 
       res = _bfd_create_empty_archive_element_shell (abfd);
-      if (res == NULL)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[2076]) {
+        if ((res == (void *) 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 2076\n");
+        else
+          fprintf(stderr, "reached bug index 2076\n");
+      }
+      if ((!FIXREVERTER[2076] && (res == (void *) 0 ))
+      #else
+      if (0
+      #endif
+      )
 	return NULL;
+	#ifdef FRCOV
+	}
+	#endif
       arelt = bfd_zmalloc (sizeof (*arelt));
-      if (arelt == NULL)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[2077]) {
+        if ((arelt == (void *) 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 2077\n");
+        else
+          fprintf(stderr, "reached bug index 2077\n");
+      }
+      if ((!FIXREVERTER[2077] && (arelt == (void *) 0 ))
+      #else
+      if (0
+      #endif
+      )
 	{
 	  bfd_close (res);
 	  return NULL;
 	}
+	#ifdef FRCOV
+	}
+	#endif
       res->arelt_data = arelt;
 
       /* Get info from mhd.  */
@@ -1437,11 +2007,26 @@ _bfd_vms_lib_get_module (bfd *abfd, unsigned int modidx)
   name = tdata->modules[modidx].name;
   namelen = strlen (name);
   newname = bfd_malloc (namelen + 4 + 1);
-  if (newname == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[2078]) {
+    if ((newname == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 2078\n");
+    else
+      fprintf(stderr, "reached bug index 2078\n");
+  }
+  if ((!FIXREVERTER[2078] && (newname == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     {
       bfd_close (res);
       return NULL;
     }
+    #ifdef FRCOV
+    }
+    #endif
   strcpy (newname, name);
   switch (tdata->type)
     {
@@ -1486,8 +2071,23 @@ _bfd_vms_lib_get_elt_at_index (bfd *abfd, symindex symidx)
       if (tdata->modules[modidx].file_offset == file_off)
 	break;
     }
-  if (modidx >= tdata->nbr_modules)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[2079]) {
+    if ((modidx >= tdata -> nbr_modules ) && !(0))
+      fprintf(stderr, "triggered bug index 2079\n");
+    else
+      fprintf(stderr, "reached bug index 2079\n");
+  }
+  if ((!FIXREVERTER[2079] && (modidx >= tdata -> nbr_modules ))
+  #else
+  if (0
+  #endif
+  )
     return NULL;
+    #ifdef FRCOV
+    }
+    #endif
 
   return _bfd_vms_lib_get_module (abfd, modidx);
 }
@@ -1507,8 +2107,23 @@ _bfd_vms_lib_get_imagelib_file (bfd *el)
 
   /* Convert module name to lower case and append '.exe'.  */
   filename = bfd_alloc (el, modlen + 5);
-  if (filename == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[2080]) {
+    if ((filename == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 2080\n");
+    else
+      fprintf(stderr, "reached bug index 2080\n");
+  }
+  if ((!FIXREVERTER[2080] && (filename == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     return NULL;
+    #ifdef FRCOV
+    }
+    #endif
   for (j = 0; j < modlen; j++)
     if (ISALPHA (modname[j]))
       filename[j] = TOLOWER (modname[j]);
@@ -1517,11 +2132,38 @@ _bfd_vms_lib_get_imagelib_file (bfd *el)
   memcpy (filename + modlen, ".exe", 5);
 
   filename = _bfd_append_relative_path (archive, filename);
-  if (filename == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[2081]) {
+    if ((filename == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 2081\n");
+    else
+      fprintf(stderr, "reached bug index 2081\n");
+  }
+  if ((!FIXREVERTER[2081] && (filename == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     return NULL;
+    #ifdef FRCOV
+    }
+    #endif
   res = bfd_openr (filename, NULL);
 
-  if (res == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[2082]) {
+    if ((res == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 2082\n");
+    else
+      fprintf(stderr, "reached bug index 2082\n");
+  }
+  if ((!FIXREVERTER[2082] && (res == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     {
       /* xgettext:c-format */
       _bfd_error_handler(_("could not open shared image '%s' from '%s'"),
@@ -1529,6 +2171,9 @@ _bfd_vms_lib_get_imagelib_file (bfd *el)
       bfd_release (archive, filename);
       return NULL;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
   /* FIXME: put it in a cache ?  */
   return res;
@@ -1569,11 +2214,26 @@ _bfd_vms_lib_generic_stat_arch_elt (bfd *abfd, struct stat *st)
   struct lib_tdata *tdata;
 
   /* Sanity check.  */
-  if (abfd->my_archive == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[2084]) {
+    if ((abfd -> my_archive == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 2084\n");
+    else
+      fprintf(stderr, "reached bug index 2084\n");
+  }
+  if ((!FIXREVERTER[2084] && (abfd -> my_archive == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     {
       bfd_set_error (bfd_error_invalid_operation);
       return -1;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
   tdata = bfd_libdata (abfd->my_archive);
   if (tdata->type != LBR__C_TYP_IOBJ)
@@ -1750,8 +2410,23 @@ vms_write_index (bfd *abfd,
 		      else
 			{
 			  kbn_blk = bfd_malloc (VMS_BLOCK_SIZE);
-			  if (kbn_blk == NULL)
+			  
+			  #ifdef FRCOV
+			  {if (FIXREVERTER[2087]) {
+			    if ((kbn_blk == (void *) 0 ) && !(0))
+			      fprintf(stderr, "triggered bug index 2087\n");
+			    else
+			      fprintf(stderr, "reached bug index 2087\n");
+			  }
+			  if ((!FIXREVERTER[2087] && (kbn_blk == (void *) 0 ))
+			  #else
+			  if (0
+			  #endif
+			  )
 			    return false;
+			    #ifdef FRCOV
+			    }
+			    #endif
 			}
 		      *(unsigned short *)kbn_blk = 0;
 		    }
@@ -1931,8 +2606,23 @@ vms_write_index (bfd *abfd,
   if (topvbn != NULL)
     *topvbn = blk[level - 1].vbn;
 
-  if (abfd == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[2090]) {
+    if ((abfd == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 2090\n");
+    else
+      fprintf(stderr, "reached bug index 2090\n");
+  }
+  if ((!FIXREVERTER[2090] && (abfd == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     return true;
+    #ifdef FRCOV
+    }
+    #endif
 
   /* Flush.  */
   for (j = 1; j < level; j++)
@@ -2025,8 +2715,23 @@ _bfd_vms_lib_build_map (unsigned int nbr_modules,
   unsigned int map_count = 0;
 
   map = (struct lib_index *) bfd_malloc (map_max * sizeof (struct lib_index));
-  if (map == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[2093]) {
+    if ((map == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 2093\n");
+    else
+      fprintf(stderr, "reached bug index 2093\n");
+  }
+  if ((!FIXREVERTER[2093] && (map == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     goto error_return;
+    #ifdef FRCOV
+    }
+    #endif
 
   /* Gather symbols.  */
   for (i = 0; i < nbr_modules; i++)
@@ -2050,8 +2755,23 @@ _bfd_vms_lib_build_map (unsigned int nbr_modules,
 	      free (syms);
 	      syms_max = storage;
 	      syms = (asymbol **) bfd_malloc (syms_max);
-	      if (syms == NULL)
+	      
+	      #ifdef FRCOV
+	      {if (FIXREVERTER[2095]) {
+	        if ((syms == (void *) 0 ) && !(0))
+	          fprintf(stderr, "triggered bug index 2095\n");
+	        else
+	          fprintf(stderr, "reached bug index 2095\n");
+	      }
+	      if ((!FIXREVERTER[2095] && (syms == (void *) 0 ))
+	      #else
+	      if (0
+	      #endif
+	      )
 		goto error_return;
+		#ifdef FRCOV
+		}
+		#endif
 	    }
 	  symcount = bfd_canonicalize_symtab (current, syms);
 	  if (symcount < 0)
@@ -2078,8 +2798,23 @@ _bfd_vms_lib_build_map (unsigned int nbr_modules,
 		      map_max *= 2;
 		      new_map = (struct lib_index *)
 			bfd_realloc (map, map_max * sizeof (struct lib_index));
-		      if (new_map == NULL)
+		      
+		      #ifdef FRCOV
+		      {if (FIXREVERTER[2097]) {
+		        if ((new_map == (void *) 0 ) && !(0))
+		          fprintf(stderr, "triggered bug index 2097\n");
+		        else
+		          fprintf(stderr, "reached bug index 2097\n");
+		      }
+		      if ((!FIXREVERTER[2097] && (new_map == (void *) 0 ))
+		      #else
+		      if (0
+		      #endif
+		      )
 			goto error_return;
+			#ifdef FRCOV
+			}
+			#endif
 		      map = new_map;
 		    }
 
diff --git a/bfd/vms-misc.c b/bfd/vms-misc.c
old mode 100644
new mode 100755
index 3fd974c..564ad3c
--- a/bfd/vms-misc.c
+++ b/bfd/vms-misc.c
@@ -1,3 +1,6 @@
+#ifdef FRCOV
+extern short FIXREVERTER[];
+#endif
 /* vms-misc.c -- BFD back-end for VMS/VAX (openVMS/VAX) and
    EVAX (openVMS/Alpha) files.
    Copyright (C) 1996-2021 Free Software Foundation, Inc.
@@ -149,8 +152,23 @@ _bfd_vms_save_sized_string (bfd *abfd, unsigned char *str, size_t size)
       return NULL;
     }
   newstr = bfd_alloc (abfd, size + 1);
-  if (newstr == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[4951]) {
+    if ((newstr == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 4951\n");
+    else
+      fprintf(stderr, "reached bug index 4951\n");
+  }
+  if ((!FIXREVERTER[4951] && (newstr == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     return NULL;
+    #ifdef FRCOV
+    }
+    #endif
   memcpy (newstr, str, size);
   newstr[size] = 0;
 
@@ -168,8 +186,23 @@ _bfd_vms_save_counted_string (bfd *abfd, unsigned char *ptr, size_t maxlen)
   if (maxlen == 0)
     return NULL;
   len = *ptr++;
-  if (len >  maxlen - 1)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[4954]) {
+    if ((len > maxlen - 1 ) && !(0))
+      fprintf(stderr, "triggered bug index 4954\n");
+    else
+      fprintf(stderr, "reached bug index 4954\n");
+  }
+  if ((!FIXREVERTER[4954] && (len > maxlen - 1 ))
+  #else
+  if (0
+  #endif
+  )
     return NULL;
+    #ifdef FRCOV
+    }
+    #endif
   return _bfd_vms_save_sized_string (abfd, ptr, len);
 }
 
@@ -277,8 +310,23 @@ _bfd_vms_output_end (bfd *abfd, struct vms_rec_wr *recwr)
   /* Subrecord must have been closed.  */
   BFD_ASSERT (recwr->subrec_offset == 0);
 
-  if (recwr->size == 0)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[4956]) {
+    if ((recwr -> size == 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 4956\n");
+    else
+      fprintf(stderr, "reached bug index 4956\n");
+  }
+  if ((!FIXREVERTER[4956] && (recwr -> size == 0 ))
+  #else
+  if (0
+  #endif
+  )
     return;
+    #ifdef FRCOV
+    }
+    #endif
 
   _bfd_vms_output_align (recwr, recwr->size);
 
@@ -365,16 +413,46 @@ _bfd_vms_output_counted (struct vms_rec_wr *recwr, const char *value)
   vms_debug2 ((6, "_bfd_vms_output_counted (%s)\n", value));
 
   len = strlen (value);
-  if (len == 0)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[4957]) {
+    if ((len == 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 4957\n");
+    else
+      fprintf(stderr, "reached bug index 4957\n");
+  }
+  if ((!FIXREVERTER[4957] && (len == 0 ))
+  #else
+  if (0
+  #endif
+  )
     {
       _bfd_error_handler (_("_bfd_vms_output_counted called with zero bytes"));
       return;
     }
-  if (len > 255)
+    #ifdef FRCOV
+    }
+    #endif
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[4958]) {
+    if ((len > 255 ) && !(0))
+      fprintf(stderr, "triggered bug index 4958\n");
+    else
+      fprintf(stderr, "reached bug index 4958\n");
+  }
+  if ((!FIXREVERTER[4958] && (len > 255 ))
+  #else
+  if (0
+  #endif
+  )
     {
       _bfd_error_handler (_("_bfd_vms_output_counted called with too many bytes"));
       return;
     }
+    #ifdef FRCOV
+    }
+    #endif
   _bfd_vms_output_byte (recwr, (unsigned int) len & 0xff);
   _bfd_vms_output_dump (recwr, (const unsigned char *)value, len);
 }
@@ -386,8 +464,23 @@ _bfd_vms_output_dump (struct vms_rec_wr *recwr, const unsigned char *data, int l
 {
   vms_debug2 ((6, "_bfd_vms_output_dump (%d)\n", len));
 
-  if (len == 0)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[4959]) {
+    if ((len == 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 4959\n");
+    else
+      fprintf(stderr, "reached bug index 4959\n");
+  }
+  if ((!FIXREVERTER[4959] && (len == 0 ))
+  #else
+  if (0
+  #endif
+  )
     return;
+    #ifdef FRCOV
+    }
+    #endif
 
   memcpy (recwr->buf + recwr->size, data, (size_t) len);
   recwr->size += len;
@@ -400,8 +493,23 @@ _bfd_vms_output_fill (struct vms_rec_wr *recwr, int value, int count)
 {
   vms_debug2 ((6, "_bfd_vms_output_fill (val %02x times %d)\n", value, count));
 
-  if (count == 0)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[4960]) {
+    if ((count == 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 4960\n");
+    else
+      fprintf(stderr, "reached bug index 4960\n");
+  }
+  if ((!FIXREVERTER[4960] && (count == 0 ))
+  #else
+  if (0
+  #endif
+  )
     return;
+    #ifdef FRCOV
+    }
+    #endif
   memset (recwr->buf + recwr->size, value, (size_t) count);
   recwr->size += count;
 }
@@ -499,8 +607,23 @@ vms_get_module_name (const char *filename, bool upcase)
 
   /* Strip VMS path.  */
   fout = strrchr (filename, ']');
-  if (fout == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[4961]) {
+    if ((fout == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 4961\n");
+    else
+      fprintf(stderr, "reached bug index 4961\n");
+  }
+  if ((!FIXREVERTER[4961] && (fout == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     fout = strchr (filename, ':');
+    #ifdef FRCOV
+    }
+    #endif
   if (fout != NULL)
     fout++;
   else
@@ -508,8 +631,23 @@ vms_get_module_name (const char *filename, bool upcase)
 
   /* Strip UNIX path.  */
   fptr = strrchr (fout, '/');
-  if (fptr != NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[4962]) {
+    if ((fptr != (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 4962\n");
+    else
+      fprintf(stderr, "reached bug index 4962\n");
+  }
+  if ((!FIXREVERTER[4962] && (fptr != (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     fout = fptr + 1;
+    #ifdef FRCOV
+    }
+    #endif
 
   fname = strdup (fout);
 
@@ -584,8 +722,23 @@ vms_time_to_time_t (unsigned int hi, unsigned int lo)
     return 0;
 
   res = lo - VMS_TIME_OFFSET;
-  if (res <= 0)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[4963]) {
+    if ((res <= 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 4963\n");
+    else
+      fprintf(stderr, "reached bug index 4963\n");
+  }
+  if ((!FIXREVERTER[4963] && (res <= 0 ))
+  #else
+  if (0
+  #endif
+  )
     return 0;
+    #ifdef FRCOV
+    }
+    #endif
   return res;
 }
 
diff --git a/bfd/vms.h b/bfd/vms.h
old mode 100644
new mode 100755
diff --git a/bfd/warning.m4 b/bfd/warning.m4
old mode 100644
new mode 100755
diff --git a/bfd/wasm-module.c b/bfd/wasm-module.c
old mode 100644
new mode 100755
diff --git a/bfd/wasm-module.h b/bfd/wasm-module.h
old mode 100644
new mode 100755
diff --git a/bfd/xcofflink.c b/bfd/xcofflink.c
old mode 100644
new mode 100755
index e18efd4..9b054f5
--- a/bfd/xcofflink.c
+++ b/bfd/xcofflink.c
@@ -1,3 +1,6 @@
+#ifdef FRCOV
+extern short FIXREVERTER[];
+#endif
 /* POWER/PowerPC XCOFF linker support.
    Copyright (C) 1995-2021 Free Software Foundation, Inc.
    Written by Ian Lance Taylor <ian@cygnus.com>, Cygnus Support.
@@ -217,8 +220,23 @@ xcoff_get_section_contents (bfd *abfd, asection *sec)
       size_t amt = sizeof (struct coff_section_tdata);
 
       sec->used_by_bfd = bfd_zalloc (abfd, amt);
-      if (sec->used_by_bfd == NULL)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[12058]) {
+        if ((sec -> used_by_bfd == (void *) 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 12058\n");
+        else
+          fprintf(stderr, "reached bug index 12058\n");
+      }
+      if ((!FIXREVERTER[12058] && (sec -> used_by_bfd == (void *) 0 ))
+      #else
+      if (0
+      #endif
+      )
 	return false;
+	#ifdef FRCOV
+	}
+	#endif
     }
 
   if (coff_section_data (abfd, sec)->contents == NULL)
@@ -252,11 +270,26 @@ _bfd_xcoff_get_dynamic_symtab_upper_bound (bfd *abfd)
     }
 
   lsec = bfd_get_section_by_name (abfd, ".loader");
-  if (lsec == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[12059]) {
+    if ((lsec == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 12059\n");
+    else
+      fprintf(stderr, "reached bug index 12059\n");
+  }
+  if ((!FIXREVERTER[12059] && (lsec == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     {
       bfd_set_error (bfd_error_no_symbols);
       return -1;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
   if (! xcoff_get_section_contents (abfd, lsec))
     return -1;
@@ -286,11 +319,26 @@ _bfd_xcoff_canonicalize_dynamic_symtab (bfd *abfd, asymbol **psyms)
     }
 
   lsec = bfd_get_section_by_name (abfd, ".loader");
-  if (lsec == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[12060]) {
+    if ((lsec == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 12060\n");
+    else
+      fprintf(stderr, "reached bug index 12060\n");
+  }
+  if ((!FIXREVERTER[12060] && (lsec == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     {
       bfd_set_error (bfd_error_no_symbols);
       return -1;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
   if (! xcoff_get_section_contents (abfd, lsec))
     return -1;
@@ -303,8 +351,23 @@ _bfd_xcoff_canonicalize_dynamic_symtab (bfd *abfd, asymbol **psyms)
   strings = (char *) contents + ldhdr.l_stoff;
 
   symbuf = bfd_zalloc (abfd, ldhdr.l_nsyms * sizeof (* symbuf));
-  if (symbuf == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[12061]) {
+    if ((symbuf == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 12061\n");
+    else
+      fprintf(stderr, "reached bug index 12061\n");
+  }
+  if ((!FIXREVERTER[12061] && (symbuf == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     return -1;
+    #ifdef FRCOV
+    }
+    #endif
 
   elsym = contents + bfd_xcoff_loader_symbol_offset(abfd, &ldhdr);
 
@@ -324,8 +387,23 @@ _bfd_xcoff_canonicalize_dynamic_symtab (bfd *abfd, asymbol **psyms)
 	  char *c;
 
 	  c = bfd_alloc (abfd, (bfd_size_type) SYMNMLEN + 1);
-	  if (c == NULL)
+	  
+	  #ifdef FRCOV
+	  {if (FIXREVERTER[12062]) {
+	    if ((c == (void *) 0 ) && !(0))
+	      fprintf(stderr, "triggered bug index 12062\n");
+	    else
+	      fprintf(stderr, "reached bug index 12062\n");
+	  }
+	  if ((!FIXREVERTER[12062] && (c == (void *) 0 ))
+	  #else
+	  if (0
+	  #endif
+	  )
 	    return -1;
+	    #ifdef FRCOV
+	    }
+	    #endif
 	  memcpy (c, ldsym._l._l_name, SYMNMLEN);
 	  c[SYMNMLEN] = '\0';
 	  symbuf->symbol.name = c;
@@ -373,11 +451,26 @@ _bfd_xcoff_get_dynamic_reloc_upper_bound (bfd *abfd)
     }
 
   lsec = bfd_get_section_by_name (abfd, ".loader");
-  if (lsec == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[12063]) {
+    if ((lsec == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 12063\n");
+    else
+      fprintf(stderr, "reached bug index 12063\n");
+  }
+  if ((!FIXREVERTER[12063] && (lsec == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     {
       bfd_set_error (bfd_error_no_symbols);
       return -1;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
   if (! xcoff_get_section_contents (abfd, lsec))
     return -1;
@@ -850,7 +943,19 @@ xcoff_link_add_dynamic_symbols (bfd *abfd, struct bfd_link_info *info)
      o_snloader field in the a.out header, rather than grabbing the
      section by name.  */
   lsec = bfd_get_section_by_name (abfd, ".loader");
-  if (lsec == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[12071]) {
+    if ((lsec == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 12071\n");
+    else
+      fprintf(stderr, "reached bug index 12071\n");
+  }
+  if ((!FIXREVERTER[12071] && (lsec == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     {
       _bfd_error_handler
 	(_("%pB: dynamic object with no .loader section"),
@@ -858,6 +963,9 @@ xcoff_link_add_dynamic_symbols (bfd *abfd, struct bfd_link_info *info)
       bfd_set_error (bfd_error_no_symbols);
       return false;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
   if (! xcoff_get_section_contents (abfd, lsec))
     return false;
@@ -904,8 +1012,23 @@ xcoff_link_add_dynamic_symbols (bfd *abfd, struct bfd_link_info *info)
 
       h = xcoff_link_hash_lookup (xcoff_hash_table (info), name, true,
 				  true, true);
-      if (h == NULL)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[12073]) {
+        if ((h == (void *) 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 12073\n");
+        else
+          fprintf(stderr, "reached bug index 12073\n");
+      }
+      if ((!FIXREVERTER[12073] && (h == (void *) 0 ))
+      #else
+      if (0
+      #endif
+      )
 	return false;
+	#ifdef FRCOV
+	}
+	#endif
 
       if (!xcoff_dynamic_definition_p (h, &ldsym))
 	continue;
@@ -950,15 +1073,45 @@ xcoff_link_add_dynamic_symbols (bfd *abfd, struct bfd_link_info *info)
 	      char *dsnm;
 
 	      dsnm = bfd_malloc ((bfd_size_type) strlen (name) + 2);
-	      if (dsnm == NULL)
+	      
+	      #ifdef FRCOV
+	      {if (FIXREVERTER[12074]) {
+	        if ((dsnm == (void *) 0 ) && !(0))
+	          fprintf(stderr, "triggered bug index 12074\n");
+	        else
+	          fprintf(stderr, "reached bug index 12074\n");
+	      }
+	      if ((!FIXREVERTER[12074] && (dsnm == (void *) 0 ))
+	      #else
+	      if (0
+	      #endif
+	      )
 		return false;
+		#ifdef FRCOV
+		}
+		#endif
 	      dsnm[0] = '.';
 	      strcpy (dsnm + 1, name);
 	      hds = xcoff_link_hash_lookup (xcoff_hash_table (info), dsnm,
 					    true, true, true);
 	      free (dsnm);
-	      if (hds == NULL)
+	      
+	      #ifdef FRCOV
+	      {if (FIXREVERTER[12075]) {
+	        if ((hds == (void *) 0 ) && !(0))
+	          fprintf(stderr, "triggered bug index 12075\n");
+	        else
+	          fprintf(stderr, "reached bug index 12075\n");
+	      }
+	      if ((!FIXREVERTER[12075] && (hds == (void *) 0 ))
+	      #else
+	      if (0
+	      #endif
+	      )
 		return false;
+		#ifdef FRCOV
+		}
+		#endif
 
 	      hds->descriptor = h;
 	      h->descriptor = hds;
@@ -996,8 +1149,23 @@ xcoff_link_add_dynamic_symbols (bfd *abfd, struct bfd_link_info *info)
 
   /* Record this file in the import files.  */
   n = bfd_alloc (abfd, (bfd_size_type) sizeof (struct xcoff_import_file));
-  if (n == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[12076]) {
+    if ((n == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 12076\n");
+    else
+      fprintf(stderr, "reached bug index 12076\n");
+  }
+  if ((!FIXREVERTER[12076] && (n == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     return false;
+    #ifdef FRCOV
+    }
+    #endif
   n->next = NULL;
 
   if (abfd->my_archive == NULL || bfd_is_thin_archive (abfd->my_archive))
@@ -1061,8 +1229,23 @@ xcoff_link_create_extra_sections (bfd * abfd, struct bfd_link_info *info)
 	  flagword flags = SEC_HAS_CONTENTS | SEC_IN_MEMORY;
 
 	  lsec = bfd_make_section_anyway_with_flags (abfd, ".loader", flags);
-	  if (lsec == NULL)
+	  
+	  #ifdef FRCOV
+	  {if (FIXREVERTER[12077]) {
+	    if ((lsec == (void *) 0 ) && !(0))
+	      fprintf(stderr, "triggered bug index 12077\n");
+	    else
+	      fprintf(stderr, "reached bug index 12077\n");
+	  }
+	  if ((!FIXREVERTER[12077] && (lsec == (void *) 0 ))
+	  #else
+	  if (0
+	  #endif
+	  )
 	    goto end_return;
+	    #ifdef FRCOV
+	    }
+	    #endif
 
 	  xcoff_hash_table (info)->loader_section = lsec;
 	}
@@ -1075,8 +1258,23 @@ xcoff_link_create_extra_sections (bfd * abfd, struct bfd_link_info *info)
 			    | SEC_IN_MEMORY);
 
 	  lsec = bfd_make_section_anyway_with_flags (abfd, ".gl", flags);
-	  if (lsec == NULL)
+	  
+	  #ifdef FRCOV
+	  {if (FIXREVERTER[12078]) {
+	    if ((lsec == (void *) 0 ) && !(0))
+	      fprintf(stderr, "triggered bug index 12078\n");
+	    else
+	      fprintf(stderr, "reached bug index 12078\n");
+	  }
+	  if ((!FIXREVERTER[12078] && (lsec == (void *) 0 ))
+	  #else
+	  if (0
+	  #endif
+	  )
 	    goto end_return;
+	    #ifdef FRCOV
+	    }
+	    #endif
 
 	  xcoff_hash_table (info)->linkage_section = lsec;
 	  lsec->alignment_power = 2;
@@ -1090,8 +1288,23 @@ xcoff_link_create_extra_sections (bfd * abfd, struct bfd_link_info *info)
 			    | SEC_IN_MEMORY);
 
 	  tsec = bfd_make_section_anyway_with_flags (abfd, ".tc", flags);
-	  if (tsec == NULL)
+	  
+	  #ifdef FRCOV
+	  {if (FIXREVERTER[12079]) {
+	    if ((tsec == (void *) 0 ) && !(0))
+	      fprintf(stderr, "triggered bug index 12079\n");
+	    else
+	      fprintf(stderr, "reached bug index 12079\n");
+	  }
+	  if ((!FIXREVERTER[12079] && (tsec == (void *) 0 ))
+	  #else
+	  if (0
+	  #endif
+	  )
 	    goto end_return;
+	    #ifdef FRCOV
+	    }
+	    #endif
 
 	  xcoff_hash_table (info)->toc_section = tsec;
 	  tsec->alignment_power = 2;
@@ -1105,8 +1318,23 @@ xcoff_link_create_extra_sections (bfd * abfd, struct bfd_link_info *info)
 			    | SEC_IN_MEMORY);
 
 	  dsec = bfd_make_section_anyway_with_flags (abfd, ".ds", flags);
-	  if (dsec == NULL)
+	  
+	  #ifdef FRCOV
+	  {if (FIXREVERTER[12080]) {
+	    if ((dsec == (void *) 0 ) && !(0))
+	      fprintf(stderr, "triggered bug index 12080\n");
+	    else
+	      fprintf(stderr, "reached bug index 12080\n");
+	  }
+	  if ((!FIXREVERTER[12080] && (dsec == (void *) 0 ))
+	  #else
+	  if (0
+	  #endif
+	  )
 	    goto end_return;
+	    #ifdef FRCOV
+	    }
+	    #endif
 
 	  xcoff_hash_table (info)->descriptor_section = dsec;
 	  dsec->alignment_power = 2;
@@ -1120,8 +1348,23 @@ xcoff_link_create_extra_sections (bfd * abfd, struct bfd_link_info *info)
 	  flagword flags = SEC_HAS_CONTENTS | SEC_IN_MEMORY;
 
 	  dsec = bfd_make_section_anyway_with_flags (abfd, ".debug", flags);
-	  if (dsec == NULL)
+	  
+	  #ifdef FRCOV
+	  {if (FIXREVERTER[12081]) {
+	    if ((dsec == (void *) 0 ) && !(0))
+	      fprintf(stderr, "triggered bug index 12081\n");
+	    else
+	      fprintf(stderr, "reached bug index 12081\n");
+	  }
+	  if ((!FIXREVERTER[12081] && (dsec == (void *) 0 ))
+	  #else
+	  if (0
+	  #endif
+	  )
 	    goto end_return;
+	    #ifdef FRCOV
+	    }
+	    #endif
 
 	  xcoff_hash_table (info)->debug_section = dsec;
 	}
@@ -1294,8 +1537,23 @@ xcoff_link_add_symbols (bfd *abfd, struct bfd_link_info *info)
   amt = abfd->section_count + 1;
   amt *= sizeof (struct reloc_info_struct);
   reloc_info = bfd_zmalloc (amt);
-  if (reloc_info == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[12082]) {
+    if ((reloc_info == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 12082\n");
+    else
+      fprintf(stderr, "reached bug index 12082\n");
+  }
+  if ((!FIXREVERTER[12082] && (reloc_info == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     goto error_return;
+    #ifdef FRCOV
+    }
+    #endif
 
   /* Read in the relocs and line numbers for each section.  */
   linesz = bfd_coff_linesz (abfd);
@@ -1328,8 +1586,23 @@ xcoff_link_add_symbols (bfd *abfd, struct bfd_link_info *info)
 	      goto error_return;
 	    }
 	  linenos = _bfd_malloc_and_read (abfd, amt, amt);
-	  if (linenos == NULL)
+	  
+	  #ifdef FRCOV
+	  {if (FIXREVERTER[12083]) {
+	    if ((linenos == (void *) 0 ) && !(0))
+	      fprintf(stderr, "triggered bug index 12083\n");
+	    else
+	      fprintf(stderr, "reached bug index 12083\n");
+	  }
+	  if ((!FIXREVERTER[12083] && (linenos == (void *) 0 ))
+	  #else
+	  if (0
+	  #endif
+	  )
 	    goto error_return;
+	    #ifdef FRCOV
+	    }
+	    #endif
 	  reloc_info[o->target_index].linenos = linenos;
 	}
     }
@@ -1387,8 +1660,23 @@ xcoff_link_add_symbols (bfd *abfd, struct bfd_link_info *info)
 
       name = _bfd_coff_internal_syment_name (abfd, &sym, buf);
 
-      if (name == NULL)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[12085]) {
+        if ((name == (void *) 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 12085\n");
+        else
+          fprintf(stderr, "reached bug index 12085\n");
+      }
+      if ((!FIXREVERTER[12085] && (name == (void *) 0 ))
+      #else
+      if (0
+      #endif
+      )
 	goto error_return;
+	#ifdef FRCOV
+	}
+	#endif
 
       /* If this symbol has line number information attached to it,
 	 and we're not stripping it, count the number of entries and
@@ -1413,7 +1701,19 @@ xcoff_link_add_symbols (bfd *abfd, struct bfd_link_info *info)
 	      bfd_signed_vma linoff;
 
 	      enclosing = xcoff_section_data (abfd, csect)->enclosing;
-	      if (enclosing == NULL)
+	      
+	      #ifdef FRCOV
+	      {if (FIXREVERTER[12086]) {
+	        if ((enclosing == (void *) 0 ) && !(0))
+	          fprintf(stderr, "triggered bug index 12086\n");
+	        else
+	          fprintf(stderr, "reached bug index 12086\n");
+	      }
+	      if ((!FIXREVERTER[12086] && (enclosing == (void *) 0 ))
+	      #else
+	      if (0
+	      #endif
+	      )
 		{
 		  _bfd_error_handler
 		    /* xgettext:c-format */
@@ -1422,6 +1722,9 @@ xcoff_link_add_symbols (bfd *abfd, struct bfd_link_info *info)
 		  bfd_set_error (bfd_error_bad_value);
 		  goto error_return;
 		}
+		#ifdef FRCOV
+		}
+		#endif
 	      linoff = (auxlin.x_sym.x_fcnary.x_fcn.x_lnnoptr
 			- enclosing->line_filepos);
 	      /* Explicit cast to bfd_signed_vma for compiler.  */
@@ -1457,9 +1760,24 @@ xcoff_link_add_symbols (bfd *abfd, struct bfd_link_info *info)
 			 useful if all the line number entries for a
 			 csect are contiguous; this only matters for
 			 error reporting.  */
-		      if (csect->line_filepos == 0)
+		      
+		      #ifdef FRCOV
+		      {if (FIXREVERTER[12088]) {
+		        if ((csect -> line_filepos == 0  ) && !(0))
+		          fprintf(stderr, "triggered bug index 12088\n");
+		        else
+		          fprintf(stderr, "reached bug index 12088\n");
+		      }
+		      if ((!FIXREVERTER[12088] && (csect -> line_filepos == 0  ))
+		      #else
+		      if (0
+		      #endif
+		      )
 			csect->line_filepos =
 			  auxlin.x_sym.x_fcnary.x_fcn.x_lnnoptr;
+			  #ifdef FRCOV
+			  }
+			  #endif
 		    }
 		}
 	    }
@@ -1573,8 +1891,23 @@ xcoff_link_add_symbols (bfd *abfd, struct bfd_link_info *info)
 	      struct internal_reloc *rel;
 
 	      enclosing = coff_section_from_bfd_index (abfd, sym.n_scnum);
-	      if (enclosing == NULL)
+	      
+	      #ifdef FRCOV
+	      {if (FIXREVERTER[12089]) {
+	        if ((enclosing == (void *) 0 ) && !(0))
+	          fprintf(stderr, "triggered bug index 12089\n");
+	        else
+	          fprintf(stderr, "reached bug index 12089\n");
+	      }
+	      if ((!FIXREVERTER[12089] && (enclosing == (void *) 0 ))
+	      #else
+	      if (0
+	      #endif
+	      )
 		goto error_return;
+		#ifdef FRCOV
+		}
+		#endif
 
 	      relocs = reloc_info[enclosing->target_index].relocs;
 	      amt = enclosing->reloc_count;
@@ -1609,8 +1942,23 @@ xcoff_link_add_symbols (bfd *abfd, struct bfd_link_info *info)
 			 for an externally visible symbol.  */
 		      relname = _bfd_coff_internal_syment_name (abfd, &relsym,
 								relbuf);
-		      if (relname == NULL)
+		      
+		      #ifdef FRCOV
+		      {if (FIXREVERTER[12091]) {
+		        if ((relname == (void *) 0 ) && !(0))
+		          fprintf(stderr, "triggered bug index 12091\n");
+		        else
+		          fprintf(stderr, "reached bug index 12091\n");
+		      }
+		      if ((!FIXREVERTER[12091] && (relname == (void *) 0 ))
+		      #else
+		      if (0
+		      #endif
+		      )
 			goto error_return;
+			#ifdef FRCOV
+			}
+			#endif
 
 		      /* We only merge TOC entries if the TC name is
 			 the same as the symbol name.  This handles
@@ -1625,8 +1973,23 @@ xcoff_link_add_symbols (bfd *abfd, struct bfd_link_info *info)
 			  h = xcoff_link_hash_lookup (xcoff_hash_table (info),
 						      relname, true, copy,
 						      false);
-			  if (h == NULL)
+			  
+			  #ifdef FRCOV
+			  {if (FIXREVERTER[12092]) {
+			    if ((h == (void *) 0 ) && !(0))
+			      fprintf(stderr, "triggered bug index 12092\n");
+			    else
+			      fprintf(stderr, "reached bug index 12092\n");
+			  }
+			  if ((!FIXREVERTER[12092] && (h == (void *) 0 ))
+			  #else
+			  if (0
+			  #endif
+			  )
 			    goto error_return;
+			    #ifdef FRCOV
+			    }
+			    #endif
 
 			  /* At this point h->root.type could be
 			     bfd_link_hash_new.  That should be OK,
@@ -1668,14 +2031,44 @@ xcoff_link_add_symbols (bfd *abfd, struct bfd_link_info *info)
 	       accumulate similar csects together.  */
 
 	    csect = bfd_xcoff_create_csect_from_smclas(abfd, &aux, name);
-	    if (NULL == csect)
+	    
+	    #ifdef FRCOV
+	    {if (FIXREVERTER[12093]) {
+	      if (((void *) 0 == csect ) && !(0))
+	        fprintf(stderr, "triggered bug index 12093\n");
+	      else
+	        fprintf(stderr, "reached bug index 12093\n");
+	    }
+	    if ((!FIXREVERTER[12093] && ((void *) 0 == csect ))
+	    #else
+	    if (0
+	    #endif
+	    )
 	      goto error_return;
+	      #ifdef FRCOV
+	      }
+	      #endif
 
 	    /* The enclosing section is the main section : .data, .text
 	       or .bss that the csect is coming from.  */
 	    enclosing = coff_section_from_bfd_index (abfd, sym.n_scnum);
-	    if (enclosing == NULL)
+	    
+	    #ifdef FRCOV
+	    {if (FIXREVERTER[12094]) {
+	      if ((enclosing == (void *) 0 ) && !(0))
+	        fprintf(stderr, "triggered bug index 12094\n");
+	      else
+	        fprintf(stderr, "reached bug index 12094\n");
+	    }
+	    if ((!FIXREVERTER[12094] && (enclosing == (void *) 0 ))
+	    #else
+	    if (0
+	    #endif
+	    )
 	      goto error_return;
+	      #ifdef FRCOV
+	      }
+	      #endif
 
 	    if (! bfd_is_abs_section (enclosing)
 		&& ((bfd_vma) sym.n_value < enclosing->vma
@@ -1701,8 +2094,23 @@ xcoff_link_add_symbols (bfd *abfd, struct bfd_link_info *info)
 	       section.  */
 	    amt = sizeof (struct coff_section_tdata);
 	    csect->used_by_bfd = bfd_zalloc (abfd, amt);
-	    if (csect->used_by_bfd == NULL)
+	    
+	    #ifdef FRCOV
+	    {if (FIXREVERTER[12095]) {
+	      if ((csect -> used_by_bfd == (void *) 0 ) && !(0))
+	        fprintf(stderr, "triggered bug index 12095\n");
+	      else
+	        fprintf(stderr, "reached bug index 12095\n");
+	    }
+	    if ((!FIXREVERTER[12095] && (csect -> used_by_bfd == (void *) 0 ))
+	    #else
+	    if (0
+	    #endif
+	    )
 	      goto error_return;
+	      #ifdef FRCOV
+	      }
+	      #endif
 	    amt = sizeof (struct xcoff_section_tdata);
 	    coff_section_data (abfd, csect)->tdata = bfd_zalloc (abfd, amt);
 	    if (coff_section_data (abfd, csect)->tdata == NULL)
@@ -1751,8 +2159,23 @@ xcoff_link_add_symbols (bfd *abfd, struct bfd_link_info *info)
 
 	    xcoff_section_data (abfd, csect)->first_symndx = csect_index;
 
-	    if (first_csect == NULL)
+	    
+	    #ifdef FRCOV
+	    {if (FIXREVERTER[12096]) {
+	      if ((first_csect == (void *) 0 ) && !(0))
+	        fprintf(stderr, "triggered bug index 12096\n");
+	      else
+	        fprintf(stderr, "reached bug index 12096\n");
+	    }
+	    if ((!FIXREVERTER[12096] && (first_csect == (void *) 0 ))
+	    #else
+	    if (0
+	    #endif
+	    )
 	      first_csect = csect;
+	      #ifdef FRCOV
+	      }
+	      #endif
 
 	    /* If this symbol is external, we treat it as starting at the
 	       beginning of the newly created section.  */
@@ -1763,8 +2186,23 @@ xcoff_link_add_symbols (bfd *abfd, struct bfd_link_info *info)
 	      }
 
 	    /* If this is a TOC section for a symbol, record it.  */
-	    if (set_toc != NULL)
+	    
+	    #ifdef FRCOV
+	    {if (FIXREVERTER[12097]) {
+	      if ((set_toc != (void *) 0  ) && !(0))
+	        fprintf(stderr, "triggered bug index 12097\n");
+	      else
+	        fprintf(stderr, "reached bug index 12097\n");
+	    }
+	    if ((!FIXREVERTER[12097] && (set_toc != (void *) 0  ))
+	    #else
+	    if (0
+	    #endif
+	    )
 	      set_toc->toc_section = csect;
+	      #ifdef FRCOV
+	      }
+	      #endif
 	  }
 	  break;
 
@@ -1827,8 +2265,23 @@ xcoff_link_add_symbols (bfd *abfd, struct bfd_link_info *info)
 	    csect = bfd_make_section_anyway_with_flags (abfd, ".bss",
 							SEC_ALLOC);
 
-	  if (csect == NULL)
+	  
+	  #ifdef FRCOV
+	  {if (FIXREVERTER[12098]) {
+	    if ((csect == (void *) 0 ) && !(0))
+	      fprintf(stderr, "triggered bug index 12098\n");
+	    else
+	      fprintf(stderr, "reached bug index 12098\n");
+	  }
+	  if ((!FIXREVERTER[12098] && (csect == (void *) 0 ))
+	  #else
+	  if (0
+	  #endif
+	  )
 	    goto error_return;
+	    #ifdef FRCOV
+	    }
+	    #endif
 	  csect->vma = sym.n_value;
 	  csect->size = aux.x_csect.x_scnlen.l;
 	  csect->alignment_power = SMTYP_ALIGN (aux.x_csect.x_smtyp);
@@ -1841,16 +2294,46 @@ xcoff_link_add_symbols (bfd *abfd, struct bfd_link_info *info)
 
 	  amt = sizeof (struct coff_section_tdata);
 	  csect->used_by_bfd = bfd_zalloc (abfd, amt);
-	  if (csect->used_by_bfd == NULL)
+	  
+	  #ifdef FRCOV
+	  {if (FIXREVERTER[12099]) {
+	    if ((csect -> used_by_bfd == (void *) 0 ) && !(0))
+	      fprintf(stderr, "triggered bug index 12099\n");
+	    else
+	      fprintf(stderr, "reached bug index 12099\n");
+	  }
+	  if ((!FIXREVERTER[12099] && (csect -> used_by_bfd == (void *) 0 ))
+	  #else
+	  if (0
+	  #endif
+	  )
 	    goto error_return;
+	    #ifdef FRCOV
+	    }
+	    #endif
 	  amt = sizeof (struct xcoff_section_tdata);
 	  coff_section_data (abfd, csect)->tdata = bfd_zalloc (abfd, amt);
 	  if (coff_section_data (abfd, csect)->tdata == NULL)
 	    goto error_return;
 	  xcoff_section_data (abfd, csect)->first_symndx = csect_index;
 
-	  if (first_csect == NULL)
+	  
+	  #ifdef FRCOV
+	  {if (FIXREVERTER[12100]) {
+	    if ((first_csect == (void *) 0 ) && !(0))
+	      fprintf(stderr, "triggered bug index 12100\n");
+	    else
+	      fprintf(stderr, "reached bug index 12100\n");
+	  }
+	  if ((!FIXREVERTER[12100] && (first_csect == (void *) 0 ))
+	  #else
+	  if (0
+	  #endif
+	  )
 	    first_csect = csect;
+	    #ifdef FRCOV
+	    }
+	    #endif
 
 	  if (EXTERN_SYM_P (sym.n_sclass))
 	    {
@@ -2153,8 +2636,23 @@ xcoff_link_add_symbols (bfd *abfd, struct bfd_link_info *info)
 		      hds = xcoff_link_hash_lookup (xcoff_hash_table (info),
 						    h->root.root.string + 1,
 						    true, false, true);
-		      if (hds == NULL)
+		      
+		      #ifdef FRCOV
+		      {if (FIXREVERTER[12101]) {
+		        if ((hds == (void *) 0 ) && !(0))
+		          fprintf(stderr, "triggered bug index 12101\n");
+		        else
+		          fprintf(stderr, "reached bug index 12101\n");
+		      }
+		      if ((!FIXREVERTER[12101] && (hds == (void *) 0 ))
+		      #else
+		      if (0
+		      #endif
+		      )
 			goto error_return;
+			#ifdef FRCOV
+			}
+			#endif
 		      if (hds->root.type == bfd_link_hash_new)
 			{
 			  bh = &hds->root;
@@ -2259,9 +2757,24 @@ xcoff_link_check_dynamic_ar_symbols (bfd *abfd,
   *pneeded = false;
 
   lsec = bfd_get_section_by_name (abfd, ".loader");
-  if (lsec == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[12102]) {
+    if ((lsec == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 12102\n");
+    else
+      fprintf(stderr, "reached bug index 12102\n");
+  }
+  if ((!FIXREVERTER[12102] && (lsec == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     /* There are no symbols, so don't try to include it.  */
     return true;
+    #ifdef FRCOV
+    }
+    #endif
 
   if (! xcoff_get_section_contents (abfd, lsec))
     return false;
@@ -2364,8 +2877,23 @@ xcoff_link_check_ar_symbols (bfd *abfd,
 	     object file.  */
 	  name = _bfd_coff_internal_syment_name (abfd, &sym, buf);
 
-	  if (name == NULL)
+	  
+	  #ifdef FRCOV
+	  {if (FIXREVERTER[12105]) {
+	    if ((name == (void *) 0 ) && !(0))
+	      fprintf(stderr, "triggered bug index 12105\n");
+	    else
+	      fprintf(stderr, "reached bug index 12105\n");
+	  }
+	  if ((!FIXREVERTER[12105] && (name == (void *) 0 ))
+	  #else
+	  if (0
+	  #endif
+	  )
 	    return false;
+	    #ifdef FRCOV
+	    }
+	    #endif
 	  h = bfd_link_hash_lookup (info->hash, name, false, false, true);
 
 	  /* We are only interested in symbols that are currently
@@ -4100,7 +4628,19 @@ xcoff_create_ldrel (bfd *output_bfd, struct xcoff_final_link_info *flinfo,
     }
   else if (h != NULL)
     {
-      if (h->ldindx < 0)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[12114]) {
+        if ((h -> ldindx < 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 12114\n");
+        else
+          fprintf(stderr, "reached bug index 12114\n");
+      }
+      if ((!FIXREVERTER[12114] && (h -> ldindx < 0 ))
+      #else
+      if (0
+      #endif
+      )
 	{
 	  _bfd_error_handler
 	    /* xgettext:c-format */
@@ -4109,6 +4649,9 @@ xcoff_create_ldrel (bfd *output_bfd, struct xcoff_final_link_info *flinfo,
 	  bfd_set_error (bfd_error_bad_value);
 	  return false;
 	}
+	#ifdef FRCOV
+	}
+	#endif
       ldrel.l_symndx = h->ldindx;
     }
   else
@@ -4401,8 +4944,23 @@ xcoff_link_input_bfd (struct xcoff_final_link_info *flinfo,
 
 		  name = _bfd_coff_internal_syment_name (input_bfd, &isym, NULL);
 
-		  if (name == NULL)
+		  
+		  #ifdef FRCOV
+		  {if (FIXREVERTER[12115]) {
+		    if ((name == (void *) 0 ) && !(0))
+		      fprintf(stderr, "triggered bug index 12115\n");
+		    else
+		      fprintf(stderr, "reached bug index 12115\n");
+		  }
+		  if ((!FIXREVERTER[12115] && (name == (void *) 0 ))
+		  #else
+		  if (0
+		  #endif
+		  )
 		    return false;
+		    #ifdef FRCOV
+		    }
+		    #endif
 		  indx = _bfd_stringtab_add (flinfo->strtab, name, hash, copy);
 		  if (indx == (bfd_size_type) -1)
 		    return false;
@@ -4533,8 +5091,23 @@ xcoff_link_input_bfd (struct xcoff_final_link_info *flinfo,
 		      if (strings == NULL)
 			{
 			  strings = _bfd_coff_read_string_table (input_bfd);
-			  if (strings == NULL)
+			  
+			  #ifdef FRCOV
+			  {if (FIXREVERTER[12116]) {
+			    if ((strings == (void *) 0 ) && !(0))
+			      fprintf(stderr, "triggered bug index 12116\n");
+			    else
+			      fprintf(stderr, "reached bug index 12116\n");
+			  }
+			  if ((!FIXREVERTER[12116] && (strings == (void *) 0 ))
+			  #else
+			  if (0
+			  #endif
+			  )
 			    return false;
+			    #ifdef FRCOV
+			    }
+			    #endif
 			}
 		      if ((bfd_size_type) aux.x_file.x_n.x_offset >= obj_coff_strings_len (input_bfd))
 			filename = _("<corrupt>");
@@ -4837,8 +5410,23 @@ xcoff_link_input_bfd (struct xcoff_final_link_info *flinfo,
 			      true,
 			      (flinfo->section_info[target_index].relocs
 			       + o->output_section->reloc_count)));
-	  if (internal_relocs == NULL)
+	  
+	  #ifdef FRCOV
+	  {if (FIXREVERTER[12117]) {
+	    if ((internal_relocs == (void *) 0 ) && !(0))
+	      fprintf(stderr, "triggered bug index 12117\n");
+	    else
+	      fprintf(stderr, "reached bug index 12117\n");
+	  }
+	  if ((!FIXREVERTER[12117] && (internal_relocs == (void *) 0 ))
+	  #else
+	  if (0
+	  #endif
+	  )
 	    goto err_out;
+	    #ifdef FRCOV
+	    }
+	    #endif
 
 	  /* Call processor specific code to relocate the section
 	     contents.  */
@@ -4899,8 +5487,23 @@ xcoff_link_input_bfd (struct xcoff_final_link_info *flinfo,
 
 			  amt = sizeof (* n);
 			  n = bfd_alloc (flinfo->output_bfd, amt);
-			  if (n == NULL)
+			  
+			  #ifdef FRCOV
+			  {if (FIXREVERTER[12118]) {
+			    if ((n == (void *) 0 ) && !(0))
+			      fprintf(stderr, "triggered bug index 12118\n");
+			    else
+			      fprintf(stderr, "reached bug index 12118\n");
+			  }
+			  if ((!FIXREVERTER[12118] && (n == (void *) 0 ))
+			  #else
+			  if (0
+			  #endif
+			  )
 			    goto err_out;
+			    #ifdef FRCOV
+			    }
+			    #endif
 			  si = flinfo->section_info + target_index;
 			  n->next = si->toc_rel_hashes;
 			  n->h = h;
@@ -4981,8 +5584,23 @@ xcoff_link_input_bfd (struct xcoff_final_link_info *flinfo,
 			      name = (_bfd_coff_internal_syment_name
 				      (input_bfd, is, buf));
 
-			      if (name == NULL)
+			      
+			      #ifdef FRCOV
+			      {if (FIXREVERTER[12120]) {
+			        if ((name == (void *) 0 ) && !(0))
+			          fprintf(stderr, "triggered bug index 12120\n");
+			        else
+			          fprintf(stderr, "reached bug index 12120\n");
+			      }
+			      if ((!FIXREVERTER[12120] && (name == (void *) 0 ))
+			      #else
+			      if (0
+			      #endif
+			      )
 				goto err_out;
+				#ifdef FRCOV
+				}
+				#endif
 
 			      (*flinfo->info->callbacks->unattached_reloc)
 				(flinfo->info, name,
@@ -5112,16 +5730,46 @@ xcoff_find_tc0 (bfd *output_bfd, struct xcoff_final_link_info *flinfo)
 	    }
 
 	  end = start + sec->size;
-	  if (toc_end < end)
+	  
+	  #ifdef FRCOV
+	  {if (FIXREVERTER[12121]) {
+	    if ((toc_end < end ) && !(0))
+	      fprintf(stderr, "triggered bug index 12121\n");
+	    else
+	      fprintf(stderr, "reached bug index 12121\n");
+	  }
+	  if ((!FIXREVERTER[12121] && (toc_end < end ))
+	  #else
+	  if (0
+	  #endif
+	  )
 	    toc_end = end;
+	    #ifdef FRCOV
+	    }
+	    #endif
 	}
 
   /* There's no need for a TC0 symbol if we don't have a TOC.  */
-  if (toc_end < toc_start)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[12122]) {
+    if ((toc_end < toc_start ) && !(0))
+      fprintf(stderr, "triggered bug index 12122\n");
+    else
+      fprintf(stderr, "reached bug index 12122\n");
+  }
+  if ((!FIXREVERTER[12122] && (toc_end < toc_start ))
+  #else
+  if (0
+  #endif
+  )
     {
       xcoff_data (output_bfd)->toc = toc_start;
       return true;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
   if (toc_end - toc_start < 0x8000)
     /* Every TOC csect can be accessed from TOC_START.  */
@@ -5146,7 +5794,19 @@ xcoff_find_tc0 (bfd *output_bfd, struct xcoff_final_link_info *flinfo)
 	    }
 
       /* Make sure that the start of the TOC is also within range.  */
-      if (best_address > toc_start + 0x8000)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[12124]) {
+        if ((best_address > toc_start + 32768 ) && !(0))
+          fprintf(stderr, "triggered bug index 12124\n");
+        else
+          fprintf(stderr, "reached bug index 12124\n");
+      }
+      if ((!FIXREVERTER[12124] && (best_address > toc_start + 32768 ))
+      #else
+      if (0
+      #endif
+      )
 	{
 	  _bfd_error_handler
 	    (_("TOC overflow: %#" PRIx64 " > 0x10000; try -mminimal-toc "
@@ -5155,6 +5815,9 @@ xcoff_find_tc0 (bfd *output_bfd, struct xcoff_final_link_info *flinfo)
 	  bfd_set_error (bfd_error_file_too_big);
 	  return false;
 	}
+	#ifdef FRCOV
+	}
+	#endif
     }
 
   /* Record the chosen TOC value.  */
@@ -5745,22 +6408,52 @@ xcoff_reloc_link_order (bfd *output_bfd,
     abort ();
 
   howto = bfd_reloc_type_lookup (output_bfd, link_order->u.reloc.p->reloc);
-  if (howto == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[12125]) {
+    if ((howto == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 12125\n");
+    else
+      fprintf(stderr, "reached bug index 12125\n");
+  }
+  if ((!FIXREVERTER[12125] && (howto == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     {
       bfd_set_error (bfd_error_bad_value);
       return false;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
   h = ((struct xcoff_link_hash_entry *)
        bfd_wrapped_link_hash_lookup (output_bfd, flinfo->info,
 				     link_order->u.reloc.p->u.name,
 				     false, false, true));
-  if (h == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[12126]) {
+    if ((h == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 12126\n");
+    else
+      fprintf(stderr, "reached bug index 12126\n");
+  }
+  if ((!FIXREVERTER[12126] && (h == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     {
       (*flinfo->info->callbacks->unattached_reloc)
 	(flinfo->info, link_order->u.reloc.p->u.name, NULL, NULL, (bfd_vma) 0);
       return true;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
   hsec = xcoff_symbol_section (h);
   if (h->root.type == bfd_link_hash_defined
diff --git a/bfd/xcofflink.h b/bfd/xcofflink.h
old mode 100644
new mode 100755
diff --git a/bfd/xsym.c b/bfd/xsym.c
old mode 100644
new mode 100755
diff --git a/bfd/xsym.h b/bfd/xsym.h
old mode 100644
new mode 100755
diff --git a/bfd/xtensa-isa.c b/bfd/xtensa-isa.c
old mode 100644
new mode 100755
diff --git a/bfd/xtensa-modules.c b/bfd/xtensa-modules.c
old mode 100644
new mode 100755
diff --git a/binutils/.gitignore b/binutils/.gitignore
old mode 100644
new mode 100755
diff --git a/binutils/BRANCHES b/binutils/BRANCHES
old mode 100644
new mode 100755
diff --git a/binutils/ChangeLog b/binutils/ChangeLog
old mode 100644
new mode 100755
diff --git a/binutils/ChangeLog-0001 b/binutils/ChangeLog-0001
old mode 100644
new mode 100755
diff --git a/binutils/ChangeLog-0203 b/binutils/ChangeLog-0203
old mode 100644
new mode 100755
diff --git a/binutils/ChangeLog-2004 b/binutils/ChangeLog-2004
old mode 100644
new mode 100755
diff --git a/binutils/ChangeLog-2005 b/binutils/ChangeLog-2005
old mode 100644
new mode 100755
diff --git a/binutils/ChangeLog-2006 b/binutils/ChangeLog-2006
old mode 100644
new mode 100755
diff --git a/binutils/ChangeLog-2007 b/binutils/ChangeLog-2007
old mode 100644
new mode 100755
diff --git a/binutils/ChangeLog-2008 b/binutils/ChangeLog-2008
old mode 100644
new mode 100755
diff --git a/binutils/ChangeLog-2009 b/binutils/ChangeLog-2009
old mode 100644
new mode 100755
diff --git a/binutils/ChangeLog-2010 b/binutils/ChangeLog-2010
old mode 100644
new mode 100755
diff --git a/binutils/ChangeLog-2011 b/binutils/ChangeLog-2011
old mode 100644
new mode 100755
diff --git a/binutils/ChangeLog-2012 b/binutils/ChangeLog-2012
old mode 100644
new mode 100755
diff --git a/binutils/ChangeLog-2013 b/binutils/ChangeLog-2013
old mode 100644
new mode 100755
diff --git a/binutils/ChangeLog-2014 b/binutils/ChangeLog-2014
old mode 100644
new mode 100755
diff --git a/binutils/ChangeLog-2015 b/binutils/ChangeLog-2015
old mode 100644
new mode 100755
diff --git a/binutils/ChangeLog-2016 b/binutils/ChangeLog-2016
old mode 100644
new mode 100755
diff --git a/binutils/ChangeLog-2017 b/binutils/ChangeLog-2017
old mode 100644
new mode 100755
diff --git a/binutils/ChangeLog-2018 b/binutils/ChangeLog-2018
old mode 100644
new mode 100755
diff --git a/binutils/ChangeLog-2019 b/binutils/ChangeLog-2019
old mode 100644
new mode 100755
diff --git a/binutils/ChangeLog-2020 b/binutils/ChangeLog-2020
old mode 100644
new mode 100755
diff --git a/binutils/ChangeLog-9197 b/binutils/ChangeLog-9197
old mode 100644
new mode 100755
diff --git a/binutils/ChangeLog-9899 b/binutils/ChangeLog-9899
old mode 100644
new mode 100755
diff --git a/binutils/MAINTAINERS b/binutils/MAINTAINERS
old mode 100644
new mode 100755
diff --git a/binutils/Makefile.am b/binutils/Makefile.am
old mode 100644
new mode 100755
diff --git a/binutils/Makefile.in b/binutils/Makefile.in
old mode 100644
new mode 100755
diff --git a/binutils/NEWS b/binutils/NEWS
old mode 100644
new mode 100755
diff --git a/binutils/README b/binutils/README
old mode 100644
new mode 100755
diff --git a/binutils/README-how-to-make-a-release b/binutils/README-how-to-make-a-release
old mode 100644
new mode 100755
diff --git a/binutils/aclocal.m4 b/binutils/aclocal.m4
old mode 100644
new mode 100755
diff --git a/binutils/addr2line.c b/binutils/addr2line.c
old mode 100644
new mode 100755
diff --git a/binutils/ar.c b/binutils/ar.c
old mode 100644
new mode 100755
diff --git a/binutils/arlex.l b/binutils/arlex.l
old mode 100644
new mode 100755
diff --git a/binutils/arparse.y b/binutils/arparse.y
old mode 100644
new mode 100755
diff --git a/binutils/arsup.c b/binutils/arsup.c
old mode 100644
new mode 100755
diff --git a/binutils/arsup.h b/binutils/arsup.h
old mode 100644
new mode 100755
diff --git a/binutils/bfdtest1.c b/binutils/bfdtest1.c
old mode 100644
new mode 100755
diff --git a/binutils/bfdtest2.c b/binutils/bfdtest2.c
old mode 100644
new mode 100755
diff --git a/binutils/bin2c.c b/binutils/bin2c.c
old mode 100644
new mode 100755
diff --git a/binutils/binemul.c b/binutils/binemul.c
old mode 100644
new mode 100755
diff --git a/binutils/binemul.h b/binutils/binemul.h
old mode 100644
new mode 100755
diff --git a/binutils/bucomm.c b/binutils/bucomm.c
old mode 100644
new mode 100755
diff --git a/binutils/bucomm.h b/binutils/bucomm.h
old mode 100644
new mode 100755
diff --git a/binutils/budbg.h b/binutils/budbg.h
old mode 100644
new mode 100755
diff --git a/binutils/coffdump.c b/binutils/coffdump.c
old mode 100644
new mode 100755
diff --git a/binutils/coffgrok.c b/binutils/coffgrok.c
old mode 100644
new mode 100755
diff --git a/binutils/coffgrok.h b/binutils/coffgrok.h
old mode 100644
new mode 100755
diff --git a/binutils/config.in b/binutils/config.in
old mode 100644
new mode 100755
diff --git a/binutils/configure.ac b/binutils/configure.ac
old mode 100644
new mode 100755
diff --git a/binutils/configure.com b/binutils/configure.com
old mode 100644
new mode 100755
diff --git a/binutils/configure.tgt b/binutils/configure.tgt
old mode 100644
new mode 100755
diff --git a/binutils/cxxfilt.c b/binutils/cxxfilt.c
old mode 100644
new mode 100755
diff --git a/binutils/debug.c b/binutils/debug.c
old mode 100644
new mode 100755
diff --git a/binutils/debug.h b/binutils/debug.h
old mode 100644
new mode 100755
diff --git a/binutils/deflex.l b/binutils/deflex.l
old mode 100644
new mode 100755
diff --git a/binutils/defparse.y b/binutils/defparse.y
old mode 100644
new mode 100755
diff --git a/binutils/dep-in.sed b/binutils/dep-in.sed
old mode 100644
new mode 100755
diff --git a/binutils/dlltool.c b/binutils/dlltool.c
old mode 100644
new mode 100755
diff --git a/binutils/dlltool.h b/binutils/dlltool.h
old mode 100644
new mode 100755
diff --git a/binutils/dllwrap.c b/binutils/dllwrap.c
old mode 100644
new mode 100755
diff --git a/binutils/doc/Makefile.am b/binutils/doc/Makefile.am
old mode 100644
new mode 100755
diff --git a/binutils/doc/Makefile.in b/binutils/doc/Makefile.in
old mode 100644
new mode 100755
diff --git a/binutils/doc/binutils.texi b/binutils/doc/binutils.texi
old mode 100644
new mode 100755
diff --git a/binutils/doc/ctf.options.texi b/binutils/doc/ctf.options.texi
old mode 100644
new mode 100755
diff --git a/binutils/doc/debug.options.texi b/binutils/doc/debug.options.texi
old mode 100644
new mode 100755
diff --git a/binutils/doc/fdl.texi b/binutils/doc/fdl.texi
old mode 100644
new mode 100755
diff --git a/binutils/dwarf-mode.el b/binutils/dwarf-mode.el
old mode 100644
new mode 100755
diff --git a/binutils/dwarf.c b/binutils/dwarf.c
old mode 100644
new mode 100755
diff --git a/binutils/dwarf.h b/binutils/dwarf.h
old mode 100644
new mode 100755
diff --git a/binutils/elfcomm.c b/binutils/elfcomm.c
old mode 100644
new mode 100755
index d4e446c..52bd12d
--- a/binutils/elfcomm.c
+++ b/binutils/elfcomm.c
@@ -44,8 +44,8 @@ error (const char *message, ...)
   fflush (stdout);
 
   va_start (args, message);
-  fprintf (stderr, _("%s: Error: "), program_name);
-  vfprintf (stderr, message, args);
+  //, _("%s: Error: "), program_name);
+  //, message, args);
   va_end (args);
 }
 
@@ -58,8 +58,8 @@ warn (const char *message, ...)
   fflush (stdout);
 
   va_start (args, message);
-  fprintf (stderr, _("%s: Warning: "), program_name);
-  vfprintf (stderr, message, args);
+  //, _("%s: Warning: "), program_name);
+  //, message, args);
   va_end (args);
 }
 
diff --git a/binutils/elfcomm.h b/binutils/elfcomm.h
old mode 100644
new mode 100755
diff --git a/binutils/elfedit.c b/binutils/elfedit.c
old mode 100644
new mode 100755
diff --git a/binutils/embedspu.sh b/binutils/embedspu.sh
old mode 100644
new mode 100755
diff --git a/binutils/emul_aix.c b/binutils/emul_aix.c
old mode 100644
new mode 100755
diff --git a/binutils/emul_vanilla.c b/binutils/emul_vanilla.c
old mode 100644
new mode 100755
diff --git a/binutils/filemode.c b/binutils/filemode.c
old mode 100644
new mode 100755
diff --git a/binutils/is-ranlib.c b/binutils/is-ranlib.c
old mode 100644
new mode 100755
diff --git a/binutils/is-strip.c b/binutils/is-strip.c
old mode 100644
new mode 100755
diff --git a/binutils/makefile.vms b/binutils/makefile.vms
old mode 100644
new mode 100755
diff --git a/binutils/maybe-ranlib.c b/binutils/maybe-ranlib.c
old mode 100644
new mode 100755
diff --git a/binutils/maybe-strip.c b/binutils/maybe-strip.c
old mode 100644
new mode 100755
diff --git a/binutils/mclex.c b/binutils/mclex.c
old mode 100644
new mode 100755
diff --git a/binutils/mcparse.y b/binutils/mcparse.y
old mode 100644
new mode 100755
diff --git a/binutils/nm.c b/binutils/nm.c
old mode 100644
new mode 100755
diff --git a/binutils/not-ranlib.c b/binutils/not-ranlib.c
old mode 100644
new mode 100755
diff --git a/binutils/not-strip.c b/binutils/not-strip.c
old mode 100644
new mode 100755
diff --git a/binutils/objcopy.c b/binutils/objcopy.c
old mode 100644
new mode 100755
diff --git a/binutils/objdump.c b/binutils/objdump.c
old mode 100644
new mode 100755
diff --git a/binutils/objdump.h b/binutils/objdump.h
old mode 100644
new mode 100755
diff --git a/binutils/od-elf32_avr.c b/binutils/od-elf32_avr.c
old mode 100644
new mode 100755
diff --git a/binutils/od-macho.c b/binutils/od-macho.c
old mode 100644
new mode 100755
diff --git a/binutils/od-xcoff.c b/binutils/od-xcoff.c
old mode 100644
new mode 100755
diff --git a/binutils/po/.cvsignore b/binutils/po/.cvsignore
old mode 100644
new mode 100755
diff --git a/binutils/po/Make-in b/binutils/po/Make-in
old mode 100644
new mode 100755
diff --git a/binutils/po/POTFILES.in b/binutils/po/POTFILES.in
old mode 100644
new mode 100755
diff --git a/binutils/po/bg.po b/binutils/po/bg.po
old mode 100644
new mode 100755
diff --git a/binutils/po/binutils.pot b/binutils/po/binutils.pot
old mode 100644
new mode 100755
diff --git a/binutils/po/ca.po b/binutils/po/ca.po
old mode 100644
new mode 100755
diff --git a/binutils/po/da.po b/binutils/po/da.po
old mode 100644
new mode 100755
diff --git a/binutils/po/es.po b/binutils/po/es.po
old mode 100644
new mode 100755
diff --git a/binutils/po/fi.po b/binutils/po/fi.po
old mode 100644
new mode 100755
diff --git a/binutils/po/fr.po b/binutils/po/fr.po
old mode 100644
new mode 100755
diff --git a/binutils/po/hr.po b/binutils/po/hr.po
old mode 100644
new mode 100755
diff --git a/binutils/po/id.po b/binutils/po/id.po
old mode 100644
new mode 100755
diff --git a/binutils/po/it.po b/binutils/po/it.po
old mode 100644
new mode 100755
diff --git a/binutils/po/ja.po b/binutils/po/ja.po
old mode 100644
new mode 100755
diff --git a/binutils/po/pt.po b/binutils/po/pt.po
old mode 100644
new mode 100755
diff --git a/binutils/po/ro.po b/binutils/po/ro.po
old mode 100644
new mode 100755
diff --git a/binutils/po/ru.po b/binutils/po/ru.po
old mode 100644
new mode 100755
diff --git a/binutils/po/rw.po b/binutils/po/rw.po
old mode 100644
new mode 100755
diff --git a/binutils/po/sk.po b/binutils/po/sk.po
old mode 100644
new mode 100755
diff --git a/binutils/po/sr.po b/binutils/po/sr.po
old mode 100644
new mode 100755
diff --git a/binutils/po/sv.po b/binutils/po/sv.po
old mode 100644
new mode 100755
diff --git a/binutils/po/tr.po b/binutils/po/tr.po
old mode 100644
new mode 100755
diff --git a/binutils/po/uk.po b/binutils/po/uk.po
old mode 100644
new mode 100755
diff --git a/binutils/po/vi.po b/binutils/po/vi.po
old mode 100644
new mode 100755
diff --git a/binutils/po/zh_CN.po b/binutils/po/zh_CN.po
old mode 100644
new mode 100755
diff --git a/binutils/po/zh_TW.po b/binutils/po/zh_TW.po
old mode 100644
new mode 100755
diff --git a/binutils/prdbg.c b/binutils/prdbg.c
old mode 100644
new mode 100755
diff --git a/binutils/rclex.c b/binutils/rclex.c
old mode 100644
new mode 100755
diff --git a/binutils/rcparse.y b/binutils/rcparse.y
old mode 100644
new mode 100755
diff --git a/binutils/rdcoff.c b/binutils/rdcoff.c
old mode 100644
new mode 100755
diff --git a/binutils/rddbg.c b/binutils/rddbg.c
old mode 100644
new mode 100755
diff --git a/binutils/readelf.c b/binutils/readelf.c
old mode 100644
new mode 100755
diff --git a/binutils/rename.c b/binutils/rename.c
old mode 100644
new mode 100755
diff --git a/binutils/resbin.c b/binutils/resbin.c
old mode 100644
new mode 100755
diff --git a/binutils/rescoff.c b/binutils/rescoff.c
old mode 100644
new mode 100755
diff --git a/binutils/resrc.c b/binutils/resrc.c
old mode 100644
new mode 100755
diff --git a/binutils/resres.c b/binutils/resres.c
old mode 100644
new mode 100755
diff --git a/binutils/size.c b/binutils/size.c
old mode 100644
new mode 100755
diff --git a/binutils/srconv.c b/binutils/srconv.c
old mode 100644
new mode 100755
diff --git a/binutils/stabs.c b/binutils/stabs.c
old mode 100644
new mode 100755
diff --git a/binutils/stamp-h.in b/binutils/stamp-h.in
old mode 100644
new mode 100755
diff --git a/binutils/strings.c b/binutils/strings.c
old mode 100644
new mode 100755
diff --git a/binutils/sysdep.h b/binutils/sysdep.h
old mode 100644
new mode 100755
diff --git a/binutils/sysdump.c b/binutils/sysdump.c
old mode 100644
new mode 100755
diff --git a/binutils/sysinfo.y b/binutils/sysinfo.y
old mode 100644
new mode 100755
index 3d09fc0..bf23810
--- a/binutils/sysinfo.y
+++ b/binutils/sysinfo.y
@@ -19,6 +19,9 @@
    MA 02110-1301, USA.  */
 
 %{
+#ifdef FRCOV
+short FIXREVERTER[12386];
+#endif
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
diff --git a/binutils/syslex.l b/binutils/syslex.l
old mode 100644
new mode 100755
diff --git a/binutils/syslex_wrap.c b/binutils/syslex_wrap.c
old mode 100644
new mode 100755
diff --git a/binutils/sysroff.info b/binutils/sysroff.info
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/ChangeLog-0411 b/binutils/testsuite/ChangeLog-0411
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/ChangeLog-1215 b/binutils/testsuite/ChangeLog-1215
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/ChangeLog-9303 b/binutils/testsuite/ChangeLog-9303
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/aarch64/aarch64.exp b/binutils/testsuite/binutils-all/aarch64/aarch64.exp
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/aarch64/illegal.d b/binutils/testsuite/binutils-all/aarch64/illegal.d
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/aarch64/illegal.s b/binutils/testsuite/binutils-all/aarch64/illegal.s
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/aarch64/in-order-all.d b/binutils/testsuite/binutils-all/aarch64/in-order-all.d
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/aarch64/in-order.d b/binutils/testsuite/binutils-all/aarch64/in-order.d
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/aarch64/objdump.d b/binutils/testsuite/binutils-all/aarch64/objdump.d
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/aarch64/objdump.s b/binutils/testsuite/binutils-all/aarch64/objdump.s
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/aarch64/out-of-order-all.d b/binutils/testsuite/binutils-all/aarch64/out-of-order-all.d
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/aarch64/out-of-order.T b/binutils/testsuite/binutils-all/aarch64/out-of-order.T
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/aarch64/out-of-order.d b/binutils/testsuite/binutils-all/aarch64/out-of-order.d
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/aarch64/out-of-order.s b/binutils/testsuite/binutils-all/aarch64/out-of-order.s
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/aarch64/sve-dwarf-registers.d b/binutils/testsuite/binutils-all/aarch64/sve-dwarf-registers.d
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/aarch64/sve-dwarf-registers.s b/binutils/testsuite/binutils-all/aarch64/sve-dwarf-registers.s
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/aarch64/unallocated-encoding.d b/binutils/testsuite/binutils-all/aarch64/unallocated-encoding.d
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/aarch64/unallocated-encoding.s b/binutils/testsuite/binutils-all/aarch64/unallocated-encoding.s
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/add-empty-section.d b/binutils/testsuite/binutils-all/add-empty-section.d
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/add-section.d b/binutils/testsuite/binutils-all/add-section.d
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/add-symbol.d b/binutils/testsuite/binutils-all/add-symbol.d
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/alias-2.def b/binutils/testsuite/binutils-all/alias-2.def
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/alias.def b/binutils/testsuite/binutils-all/alias.def
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/ar.exp b/binutils/testsuite/binutils-all/ar.exp
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/arc/double_regs.s b/binutils/testsuite/binutils-all/arc/double_regs.s
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/arc/double_store.s b/binutils/testsuite/binutils-all/arc/double_store.s
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/arc/dsp.s b/binutils/testsuite/binutils-all/arc/dsp.s
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/arc/hexprint.s b/binutils/testsuite/binutils-all/arc/hexprint.s
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/arc/objdump.exp b/binutils/testsuite/binutils-all/arc/objdump.exp
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/arm/in-order-all.d b/binutils/testsuite/binutils-all/arm/in-order-all.d
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/arm/in-order.d b/binutils/testsuite/binutils-all/arm/in-order.d
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/arm/objdump.exp b/binutils/testsuite/binutils-all/arm/objdump.exp
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/arm/out-of-order-all.d b/binutils/testsuite/binutils-all/arm/out-of-order-all.d
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/arm/out-of-order.T b/binutils/testsuite/binutils-all/arm/out-of-order.T
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/arm/out-of-order.d b/binutils/testsuite/binutils-all/arm/out-of-order.d
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/arm/out-of-order.s b/binutils/testsuite/binutils-all/arm/out-of-order.s
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/arm/rvct_symbol.s b/binutils/testsuite/binutils-all/arm/rvct_symbol.s
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/arm/simple.s b/binutils/testsuite/binutils-all/arm/simple.s
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/arm/thumb2-cond.s b/binutils/testsuite/binutils-all/arm/thumb2-cond.s
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/arm/vdup-cond.d b/binutils/testsuite/binutils-all/arm/vdup-cond.d
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/arm/vdup-cond.s b/binutils/testsuite/binutils-all/arm/vdup-cond.s
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/arm/vdup-thumb.d b/binutils/testsuite/binutils-all/arm/vdup-thumb.d
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/arm/vdup-thumb.s b/binutils/testsuite/binutils-all/arm/vdup-thumb.s
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/bfin/objdump.exp b/binutils/testsuite/binutils-all/bfin/objdump.exp
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/bfin/unknown-mode.s b/binutils/testsuite/binutils-all/bfin/unknown-mode.s
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/bintest.s b/binutils/testsuite/binutils-all/bintest.s
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/common-1.s b/binutils/testsuite/binutils-all/common-1.s
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/common-1a.d b/binutils/testsuite/binutils-all/common-1a.d
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/common-1b.d b/binutils/testsuite/binutils-all/common-1b.d
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/common-1c.d b/binutils/testsuite/binutils-all/common-1c.d
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/common-1d.d b/binutils/testsuite/binutils-all/common-1d.d
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/common-1e.d b/binutils/testsuite/binutils-all/common-1e.d
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/common-1f.d b/binutils/testsuite/binutils-all/common-1f.d
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/common-2.s b/binutils/testsuite/binutils-all/common-2.s
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/common-2a.d b/binutils/testsuite/binutils-all/common-2a.d
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/common-2b.d b/binutils/testsuite/binutils-all/common-2b.d
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/common-2c.d b/binutils/testsuite/binutils-all/common-2c.d
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/common-2d.d b/binutils/testsuite/binutils-all/common-2d.d
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/common-2e.d b/binutils/testsuite/binutils-all/common-2e.d
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/common-2f.d b/binutils/testsuite/binutils-all/common-2f.d
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/compress.exp b/binutils/testsuite/binutils-all/compress.exp
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/copy-1.d b/binutils/testsuite/binutils-all/copy-1.d
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/copy-1.s b/binutils/testsuite/binutils-all/copy-1.s
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/copy-2.d b/binutils/testsuite/binutils-all/copy-2.d
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/copy-3.d b/binutils/testsuite/binutils-all/copy-3.d
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/copy-4.d b/binutils/testsuite/binutils-all/copy-4.d
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/copy-5.d b/binutils/testsuite/binutils-all/copy-5.d
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/copy-6.d b/binutils/testsuite/binutils-all/copy-6.d
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/copytest.s b/binutils/testsuite/binutils-all/copytest.s
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/cxxfilt.exp b/binutils/testsuite/binutils-all/cxxfilt.exp
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/data-sections.s b/binutils/testsuite/binutils-all/data-sections.s
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/debug_str.d b/binutils/testsuite/binutils-all/debug_str.d
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/debug_str.s b/binutils/testsuite/binutils-all/debug_str.s
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/debuginfod.exp b/binutils/testsuite/binutils-all/debuginfod.exp
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/debuglink.s b/binutils/testsuite/binutils-all/debuglink.s
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/disasm.s b/binutils/testsuite/binutils-all/disasm.s
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/dlltool.exp b/binutils/testsuite/binutils-all/dlltool.exp
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/dumptest.s b/binutils/testsuite/binutils-all/dumptest.s
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/dw2-1.S b/binutils/testsuite/binutils-all/dw2-1.S
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/dw2-1.W b/binutils/testsuite/binutils-all/dw2-1.W
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/dw2-2.S b/binutils/testsuite/binutils-all/dw2-2.S
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/dw2-3.S b/binutils/testsuite/binutils-all/dw2-3.S
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/dw2-3.W b/binutils/testsuite/binutils-all/dw2-3.W
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/dw2-3.rS b/binutils/testsuite/binutils-all/dw2-3.rS
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/dw2-3.rt b/binutils/testsuite/binutils-all/dw2-3.rt
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/dw2-3gabi.W b/binutils/testsuite/binutils-all/dw2-3gabi.W
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/dw2-compressed.S b/binutils/testsuite/binutils-all/dw2-compressed.S
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/dw2-decodedline-1.S b/binutils/testsuite/binutils-all/dw2-decodedline-1.S
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/dw2-decodedline.S b/binutils/testsuite/binutils-all/dw2-decodedline.S
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/dw2-empty.S b/binutils/testsuite/binutils-all/dw2-empty.S
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/dw2-ranges.S b/binutils/testsuite/binutils-all/dw2-ranges.S
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/dw2-ranges.W b/binutils/testsuite/binutils-all/dw2-ranges.W
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/dw4.s b/binutils/testsuite/binutils-all/dw4.s
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/dw5.S b/binutils/testsuite/binutils-all/dw5.S
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/dw5.W b/binutils/testsuite/binutils-all/dw5.W
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/dwarf-attributes.S b/binutils/testsuite/binutils-all/dwarf-attributes.S
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/dwarf-attributes.W b/binutils/testsuite/binutils-all/dwarf-attributes.W
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/dwo.s b/binutils/testsuite/binutils-all/dwo.s
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/elfedit-1.d b/binutils/testsuite/binutils-all/elfedit-1.d
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/elfedit-2.d b/binutils/testsuite/binutils-all/elfedit-2.d
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/elfedit-3.d b/binutils/testsuite/binutils-all/elfedit-3.d
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/elfedit-4.d b/binutils/testsuite/binutils-all/elfedit-4.d
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/elfedit-5.d b/binutils/testsuite/binutils-all/elfedit-5.d
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/elfedit.exp b/binutils/testsuite/binutils-all/elfedit.exp
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/empty b/binutils/testsuite/binutils-all/empty
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/empty-file b/binutils/testsuite/binutils-all/empty-file
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/empty.s b/binutils/testsuite/binutils-all/empty.s
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/exclude-1.s b/binutils/testsuite/binutils-all/exclude-1.s
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/exclude-1a.d b/binutils/testsuite/binutils-all/exclude-1a.d
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/exclude-1b.d b/binutils/testsuite/binutils-all/exclude-1b.d
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/fastcall.def b/binutils/testsuite/binutils-all/fastcall.def
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/group-2.s b/binutils/testsuite/binutils-all/group-2.s
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/group-3.s b/binutils/testsuite/binutils-all/group-3.s
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/group-4.s b/binutils/testsuite/binutils-all/group-4.s
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/group-5.d b/binutils/testsuite/binutils-all/group-5.d
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/group-5.s b/binutils/testsuite/binutils-all/group-5.s
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/group-6.d b/binutils/testsuite/binutils-all/group-6.d
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/group-6.s b/binutils/testsuite/binutils-all/group-6.s
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/group-7.s b/binutils/testsuite/binutils-all/group-7.s
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/group-7a.d b/binutils/testsuite/binutils-all/group-7a.d
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/group-7b.d b/binutils/testsuite/binutils-all/group-7b.d
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/group-7c.d b/binutils/testsuite/binutils-all/group-7c.d
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/group.s b/binutils/testsuite/binutils-all/group.s
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/hppa/addendbug.s b/binutils/testsuite/binutils-all/hppa/addendbug.s
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/hppa/freg.s b/binutils/testsuite/binutils-all/hppa/freg.s
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/hppa/objdump.exp b/binutils/testsuite/binutils-all/hppa/objdump.exp
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/i386/compressed-1.s b/binutils/testsuite/binutils-all/i386/compressed-1.s
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/i386/compressed-1a.d b/binutils/testsuite/binutils-all/i386/compressed-1a.d
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/i386/compressed-1b.d b/binutils/testsuite/binutils-all/i386/compressed-1b.d
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/i386/compressed-1c.d b/binutils/testsuite/binutils-all/i386/compressed-1c.d
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/i386/empty.d b/binutils/testsuite/binutils-all/i386/empty.d
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/i386/empty.s b/binutils/testsuite/binutils-all/i386/empty.s
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/i386/i386.exp b/binutils/testsuite/binutils-all/i386/i386.exp
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/i386/ibt.d b/binutils/testsuite/binutils-all/i386/ibt.d
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/i386/ibt.s b/binutils/testsuite/binutils-all/i386/ibt.s
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/i386/pr21231a.d b/binutils/testsuite/binutils-all/i386/pr21231a.d
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/i386/pr21231a.s b/binutils/testsuite/binutils-all/i386/pr21231a.s
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/i386/pr21231b.d b/binutils/testsuite/binutils-all/i386/pr21231b.d
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/i386/pr21231b.s b/binutils/testsuite/binutils-all/i386/pr21231b.s
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/i386/shstk.d b/binutils/testsuite/binutils-all/i386/shstk.d
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/i386/shstk.s b/binutils/testsuite/binutils-all/i386/shstk.s
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/ifunc.s b/binutils/testsuite/binutils-all/ifunc.s
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/keep-section-1.d b/binutils/testsuite/binutils-all/keep-section-1.d
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/keep-section-2.d b/binutils/testsuite/binutils-all/keep-section-2.d
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/libdw2-compressed.out b/binutils/testsuite/binutils-all/libdw2-compressed.out
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/libdw2-compressedgabi.out b/binutils/testsuite/binutils-all/libdw2-compressedgabi.out
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/libdw2.out b/binutils/testsuite/binutils-all/libdw2.out
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/link-order.s b/binutils/testsuite/binutils-all/link-order.s
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/linkdebug.s b/binutils/testsuite/binutils-all/linkdebug.s
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/localize-hidden-1.d b/binutils/testsuite/binutils-all/localize-hidden-1.d
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/localize-hidden-1.s b/binutils/testsuite/binutils-all/localize-hidden-1.s
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/localize-hidden-2.d b/binutils/testsuite/binutils-all/localize-hidden-2.d
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/localize-hidden-2.s b/binutils/testsuite/binutils-all/localize-hidden-2.s
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/locview-1.s b/binutils/testsuite/binutils-all/locview-1.s
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/locview-2.s b/binutils/testsuite/binutils-all/locview-2.s
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/m68k/fnop.s b/binutils/testsuite/binutils-all/m68k/fnop.s
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/m68k/movem.s b/binutils/testsuite/binutils-all/m68k/movem.s
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/m68k/objdump.exp b/binutils/testsuite/binutils-all/m68k/objdump.exp
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/mangled.s b/binutils/testsuite/binutils-all/mangled.s
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/mbind1.s b/binutils/testsuite/binutils-all/mbind1.s
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/mips/global-local-symtab-final-n32.d b/binutils/testsuite/binutils-all/mips/global-local-symtab-final-n32.d
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/mips/global-local-symtab-final-n64.d b/binutils/testsuite/binutils-all/mips/global-local-symtab-final-n64.d
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/mips/global-local-symtab-final-o32.d b/binutils/testsuite/binutils-all/mips/global-local-symtab-final-o32.d
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/mips/global-local-symtab-n32.d b/binutils/testsuite/binutils-all/mips/global-local-symtab-n32.d
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/mips/global-local-symtab-n32t.d b/binutils/testsuite/binutils-all/mips/global-local-symtab-n32t.d
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/mips/global-local-symtab-n64.d b/binutils/testsuite/binutils-all/mips/global-local-symtab-n64.d
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/mips/global-local-symtab-o32.d b/binutils/testsuite/binutils-all/mips/global-local-symtab-o32.d
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/mips/global-local-symtab-o32t.d b/binutils/testsuite/binutils-all/mips/global-local-symtab-o32t.d
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/mips/global-local-symtab-sort-n32.d b/binutils/testsuite/binutils-all/mips/global-local-symtab-sort-n32.d
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/mips/global-local-symtab-sort-n32t.d b/binutils/testsuite/binutils-all/mips/global-local-symtab-sort-n32t.d
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/mips/global-local-symtab-sort-n64.d b/binutils/testsuite/binutils-all/mips/global-local-symtab-sort-n64.d
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/mips/global-local-symtab-sort-n64t.d b/binutils/testsuite/binutils-all/mips/global-local-symtab-sort-n64t.d
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/mips/global-local-symtab-sort-o32.d b/binutils/testsuite/binutils-all/mips/global-local-symtab-sort-o32.d
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/mips/global-local-symtab-sort-o32t.d b/binutils/testsuite/binutils-all/mips/global-local-symtab-sort-o32t.d
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/mips/mips-ase-1.d b/binutils/testsuite/binutils-all/mips/mips-ase-1.d
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/mips/mips-ase-1.s b/binutils/testsuite/binutils-all/mips/mips-ase-1.s
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/mips/mips-ase-2.d b/binutils/testsuite/binutils-all/mips/mips-ase-2.d
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/mips/mips-ase-2.s b/binutils/testsuite/binutils-all/mips/mips-ase-2.s
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/mips/mips-ase-3.d b/binutils/testsuite/binutils-all/mips/mips-ase-3.d
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/mips/mips-note-2-n32.d b/binutils/testsuite/binutils-all/mips/mips-note-2-n32.d
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/mips/mips-note-2-n64.d b/binutils/testsuite/binutils-all/mips/mips-note-2-n64.d
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/mips/mips-note-2.d b/binutils/testsuite/binutils-all/mips/mips-note-2.d
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/mips/mips-note-2r-n32.d b/binutils/testsuite/binutils-all/mips/mips-note-2r-n32.d
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/mips/mips-note-2r-n64.d b/binutils/testsuite/binutils-all/mips/mips-note-2r-n64.d
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/mips/mips-note-2r.d b/binutils/testsuite/binutils-all/mips/mips-note-2r.d
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/mips/mips-reginfo-n32.d b/binutils/testsuite/binutils-all/mips/mips-reginfo-n32.d
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/mips/mips-reginfo.d b/binutils/testsuite/binutils-all/mips/mips-reginfo.d
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/mips/mips-reginfo.s b/binutils/testsuite/binutils-all/mips/mips-reginfo.s
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/mips/mips-xpa-virt-1.d b/binutils/testsuite/binutils-all/mips/mips-xpa-virt-1.d
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/mips/mips-xpa-virt-2.d b/binutils/testsuite/binutils-all/mips/mips-xpa-virt-2.d
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/mips/mips-xpa-virt-3.d b/binutils/testsuite/binutils-all/mips/mips-xpa-virt-3.d
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/mips/mips-xpa-virt-4.d b/binutils/testsuite/binutils-all/mips/mips-xpa-virt-4.d
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/mips/mips-xpa-virt.s b/binutils/testsuite/binutils-all/mips/mips-xpa-virt.s
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/mips/mips.exp b/binutils/testsuite/binutils-all/mips/mips.exp
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/mips/mips16-alias.d b/binutils/testsuite/binutils-all/mips/mips16-alias.d
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/mips/mips16-alias.s b/binutils/testsuite/binutils-all/mips/mips16-alias.s
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/mips/mips16-extend-insn.d b/binutils/testsuite/binutils-all/mips/mips16-extend-insn.d
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/mips/mips16-extend-insn.s b/binutils/testsuite/binutils-all/mips/mips16-extend-insn.s
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/mips/mips16-extend-noinsn.d b/binutils/testsuite/binutils-all/mips/mips16-extend-noinsn.d
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/mips/mips16-extend-noinsn.s b/binutils/testsuite/binutils-all/mips/mips16-extend-noinsn.s
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/mips/mips16-noalias.d b/binutils/testsuite/binutils-all/mips/mips16-noalias.d
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/mips/mips16-pcrel.d b/binutils/testsuite/binutils-all/mips/mips16-pcrel.d
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/mips/mips16-pcrel.s b/binutils/testsuite/binutils-all/mips/mips16-pcrel.s
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/mips/mips16-undecoded.d b/binutils/testsuite/binutils-all/mips/mips16-undecoded.d
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/mips/mips16-undecoded.s b/binutils/testsuite/binutils-all/mips/mips16-undecoded.s
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/mips/mips16e2-extend-insn.d b/binutils/testsuite/binutils-all/mips/mips16e2-extend-insn.d
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/mips/mips16e2-undecoded.d b/binutils/testsuite/binutils-all/mips/mips16e2-undecoded.d
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/mips/mixed-micromips.d b/binutils/testsuite/binutils-all/mips/mixed-micromips.d
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/mips/mixed-micromips.s b/binutils/testsuite/binutils-all/mips/mixed-micromips.s
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/mips/mixed-mips16-micromips.d b/binutils/testsuite/binutils-all/mips/mixed-mips16-micromips.d
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/mips/mixed-mips16-micromips.s b/binutils/testsuite/binutils-all/mips/mixed-mips16-micromips.s
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/mips/mixed-mips16.d b/binutils/testsuite/binutils-all/mips/mixed-mips16.d
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/mips/mixed-mips16.s b/binutils/testsuite/binutils-all/mips/mixed-mips16.s
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/needed-by-reloc.s b/binutils/testsuite/binutils-all/needed-by-reloc.s
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/nfp/objdump.exp b/binutils/testsuite/binutils-all/nfp/objdump.exp
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/nfp/test1.d b/binutils/testsuite/binutils-all/nfp/test1.d
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/nfp/test1_nfp6000.nffw b/binutils/testsuite/binutils-all/nfp/test1_nfp6000.nffw
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/nfp/test2_ctx8.d b/binutils/testsuite/binutils-all/nfp/test2_ctx8.d
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/nfp/test2_nfp6000.nffw b/binutils/testsuite/binutils-all/nfp/test2_nfp6000.nffw
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/nfp/test2_no-pc_ctx4.d b/binutils/testsuite/binutils-all/nfp/test2_no-pc_ctx4.d
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/nm-1.s b/binutils/testsuite/binutils-all/nm-1.s
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/nm-elf-1.s b/binutils/testsuite/binutils-all/nm-elf-1.s
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/nm-ver.s b/binutils/testsuite/binutils-all/nm-ver.s
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/nm.exp b/binutils/testsuite/binutils-all/nm.exp
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/note-1.d b/binutils/testsuite/binutils-all/note-1.d
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/note-2-32.d b/binutils/testsuite/binutils-all/note-2-32.d
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/note-2-32.s b/binutils/testsuite/binutils-all/note-2-32.s
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/note-2-64.d b/binutils/testsuite/binutils-all/note-2-64.d
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/note-2-64.s b/binutils/testsuite/binutils-all/note-2-64.s
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/note-3-32.d b/binutils/testsuite/binutils-all/note-3-32.d
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/note-3-32.s b/binutils/testsuite/binutils-all/note-3-32.s
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/note-3-64.d b/binutils/testsuite/binutils-all/note-3-64.d
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/note-3-64.s b/binutils/testsuite/binutils-all/note-3-64.s
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/note-3.32.s b/binutils/testsuite/binutils-all/note-3.32.s
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/note-4-32.d b/binutils/testsuite/binutils-all/note-4-32.d
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/note-4-32.s b/binutils/testsuite/binutils-all/note-4-32.s
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/note-4-64.d b/binutils/testsuite/binutils-all/note-4-64.d
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/note-4-64.s b/binutils/testsuite/binutils-all/note-4-64.s
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/note-5.d b/binutils/testsuite/binutils-all/note-5.d
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/note-5.s b/binutils/testsuite/binutils-all/note-5.s
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/note-6-32.d b/binutils/testsuite/binutils-all/note-6-32.d
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/note-6-32.s b/binutils/testsuite/binutils-all/note-6-32.s
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/note-6-64.d b/binutils/testsuite/binutils-all/note-6-64.d
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/note-6-64.s b/binutils/testsuite/binutils-all/note-6-64.s
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/objcopy.exp b/binutils/testsuite/binutils-all/objcopy.exp
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/objdump.W b/binutils/testsuite/binutils-all/objdump.W
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/objdump.WK2 b/binutils/testsuite/binutils-all/objdump.WK2
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/objdump.WK3 b/binutils/testsuite/binutils-all/objdump.WK3
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/objdump.WL b/binutils/testsuite/binutils-all/objdump.WL
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/objdump.Wk b/binutils/testsuite/binutils-all/objdump.Wk
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/objdump.exp b/binutils/testsuite/binutils-all/objdump.exp
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/objdump.s b/binutils/testsuite/binutils-all/objdump.s
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/only-section-01.d b/binutils/testsuite/binutils-all/only-section-01.d
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/pr18374.s b/binutils/testsuite/binutils-all/pr18374.s
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/pr19020.in b/binutils/testsuite/binutils-all/pr19020.in
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/pr19020a.d b/binutils/testsuite/binutils-all/pr19020a.d
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/pr19020b.d b/binutils/testsuite/binutils-all/pr19020b.d
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/pr19547.c b/binutils/testsuite/binutils-all/pr19547.c
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/pr23633.d b/binutils/testsuite/binutils-all/pr23633.d
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/pr23633.list b/binutils/testsuite/binutils-all/pr23633.list
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/pr23633.s b/binutils/testsuite/binutils-all/pr23633.s
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/pr25543.d b/binutils/testsuite/binutils-all/pr25543.d
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/pr25543.s b/binutils/testsuite/binutils-all/pr25543.s
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/pr25662-pdp11.s b/binutils/testsuite/binutils-all/pr25662-pdp11.s
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/pr25662.ld b/binutils/testsuite/binutils-all/pr25662.ld
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/pr25662.s b/binutils/testsuite/binutils-all/pr25662.s
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/pr26112.o.bz2 b/binutils/testsuite/binutils-all/pr26112.o.bz2
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/pr26112.r b/binutils/testsuite/binutils-all/pr26112.r
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/pr26160.dwp.bz2 b/binutils/testsuite/binutils-all/pr26160.dwp.bz2
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/pr26160.r b/binutils/testsuite/binutils-all/pr26160.r
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/pr26548.d b/binutils/testsuite/binutils-all/pr26548.d
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/pr26548.s b/binutils/testsuite/binutils-all/pr26548.s
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/pr26548e.d b/binutils/testsuite/binutils-all/pr26548e.d
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/readelf-maskos-1a.d b/binutils/testsuite/binutils-all/readelf-maskos-1a.d
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/readelf-maskos-1b.d b/binutils/testsuite/binutils-all/readelf-maskos-1b.d
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/readelf-maskos-unknown.s b/binutils/testsuite/binutils-all/readelf-maskos-unknown.s
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/readelf-maskos.s b/binutils/testsuite/binutils-all/readelf-maskos.s
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/readelf.demangled b/binutils/testsuite/binutils-all/readelf.demangled
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/readelf.exp b/binutils/testsuite/binutils-all/readelf.exp
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/readelf.h b/binutils/testsuite/binutils-all/readelf.h
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/readelf.k b/binutils/testsuite/binutils-all/readelf.k
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/readelf.k2 b/binutils/testsuite/binutils-all/readelf.k2
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/readelf.locview-1 b/binutils/testsuite/binutils-all/readelf.locview-1
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/readelf.locview-2 b/binutils/testsuite/binutils-all/readelf.locview-2
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/readelf.n b/binutils/testsuite/binutils-all/readelf.n
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/readelf.pr18374 b/binutils/testsuite/binutils-all/readelf.pr18374
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/readelf.r b/binutils/testsuite/binutils-all/readelf.r
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/readelf.r-64 b/binutils/testsuite/binutils-all/readelf.r-64
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/readelf.s b/binutils/testsuite/binutils-all/readelf.s
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/readelf.s-64 b/binutils/testsuite/binutils-all/readelf.s-64
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/readelf.s-64-unused b/binutils/testsuite/binutils-all/readelf.s-64-unused
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/readelf.ss b/binutils/testsuite/binutils-all/readelf.ss
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/readelf.ss-64 b/binutils/testsuite/binutils-all/readelf.ss-64
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/readelf.ss-64-unused b/binutils/testsuite/binutils-all/readelf.ss-64-unused
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/readelf.ss-mips b/binutils/testsuite/binutils-all/readelf.ss-mips
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/readelf.ss-tmips b/binutils/testsuite/binutils-all/readelf.ss-tmips
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/readelf.ss-unused b/binutils/testsuite/binutils-all/readelf.ss-unused
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/readelf.wKis b/binutils/testsuite/binutils-all/readelf.wKis
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/readelf.wa b/binutils/testsuite/binutils-all/readelf.wa
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/readelf.z b/binutils/testsuite/binutils-all/readelf.z
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/remove-relocs-01.d b/binutils/testsuite/binutils-all/remove-relocs-01.d
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/remove-relocs-01.s b/binutils/testsuite/binutils-all/remove-relocs-01.s
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/remove-relocs-02.d b/binutils/testsuite/binutils-all/remove-relocs-02.d
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/remove-relocs-03.d b/binutils/testsuite/binutils-all/remove-relocs-03.d
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/remove-relocs-04.d b/binutils/testsuite/binutils-all/remove-relocs-04.d
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/remove-relocs-05.d b/binutils/testsuite/binutils-all/remove-relocs-05.d
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/remove-relocs-06.d b/binutils/testsuite/binutils-all/remove-relocs-06.d
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/remove-relocs-07.d b/binutils/testsuite/binutils-all/remove-relocs-07.d
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/remove-relocs-07.s b/binutils/testsuite/binutils-all/remove-relocs-07.s
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/remove-relocs-08.d b/binutils/testsuite/binutils-all/remove-relocs-08.d
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/remove-section-01.d b/binutils/testsuite/binutils-all/remove-section-01.d
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/retain1.s b/binutils/testsuite/binutils-all/retain1.s
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/retain1a.d b/binutils/testsuite/binutils-all/retain1a.d
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/retain1b.d b/binutils/testsuite/binutils-all/retain1b.d
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/set-section-alignment.d b/binutils/testsuite/binutils-all/set-section-alignment.d
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/size.exp b/binutils/testsuite/binutils-all/size.exp
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/strings.exp b/binutils/testsuite/binutils-all/strings.exp
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/strip-1.d b/binutils/testsuite/binutils-all/strip-1.d
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/strip-10.d b/binutils/testsuite/binutils-all/strip-10.d
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/strip-11.d b/binutils/testsuite/binutils-all/strip-11.d
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/strip-12.d b/binutils/testsuite/binutils-all/strip-12.d
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/strip-12.s b/binutils/testsuite/binutils-all/strip-12.s
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/strip-13.d b/binutils/testsuite/binutils-all/strip-13.d
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/strip-13mips64.s b/binutils/testsuite/binutils-all/strip-13mips64.s
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/strip-13rel.s b/binutils/testsuite/binutils-all/strip-13rel.s
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/strip-13rela.s b/binutils/testsuite/binutils-all/strip-13rela.s
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/strip-14.d b/binutils/testsuite/binutils-all/strip-14.d
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/strip-14mips64.s b/binutils/testsuite/binutils-all/strip-14mips64.s
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/strip-14rel.s b/binutils/testsuite/binutils-all/strip-14rel.s
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/strip-14rela.s b/binutils/testsuite/binutils-all/strip-14rela.s
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/strip-15.d b/binutils/testsuite/binutils-all/strip-15.d
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/strip-15mips64.s b/binutils/testsuite/binutils-all/strip-15mips64.s
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/strip-15rel.s b/binutils/testsuite/binutils-all/strip-15rel.s
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/strip-15rela.s b/binutils/testsuite/binutils-all/strip-15rela.s
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/strip-2.d b/binutils/testsuite/binutils-all/strip-2.d
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/strip-3.d b/binutils/testsuite/binutils-all/strip-3.d
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/strip-4.d b/binutils/testsuite/binutils-all/strip-4.d
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/strip-5.d b/binutils/testsuite/binutils-all/strip-5.d
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/strip-6.d b/binutils/testsuite/binutils-all/strip-6.d
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/strip-7.d b/binutils/testsuite/binutils-all/strip-7.d
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/strip-8.d b/binutils/testsuite/binutils-all/strip-8.d
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/strip-9.d b/binutils/testsuite/binutils-all/strip-9.d
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/symbols-1.d b/binutils/testsuite/binutils-all/symbols-1.d
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/symbols-2.d b/binutils/testsuite/binutils-all/symbols-2.d
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/symbols-3.d b/binutils/testsuite/binutils-all/symbols-3.d
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/symbols-4.d b/binutils/testsuite/binutils-all/symbols-4.d
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/symbols.s b/binutils/testsuite/binutils-all/symbols.s
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/testprog.c b/binutils/testsuite/binutils-all/testprog.c
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/testranges-ia64.d b/binutils/testsuite/binutils-all/testranges-ia64.d
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/testranges-ia64.s b/binutils/testsuite/binutils-all/testranges-ia64.s
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/testranges.d b/binutils/testsuite/binutils-all/testranges.d
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/testranges.s b/binutils/testsuite/binutils-all/testranges.s
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/unique.s b/binutils/testsuite/binutils-all/unique.s
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/unknown.s b/binutils/testsuite/binutils-all/unknown.s
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/update-1.s b/binutils/testsuite/binutils-all/update-1.s
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/update-2.s b/binutils/testsuite/binutils-all/update-2.s
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/update-3.s b/binutils/testsuite/binutils-all/update-3.s
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/update-4.s b/binutils/testsuite/binutils-all/update-4.s
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/update-section.exp b/binutils/testsuite/binutils-all/update-section.exp
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/vax/entrymask.s b/binutils/testsuite/binutils-all/vax/entrymask.s
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/vax/objdump.exp b/binutils/testsuite/binutils-all/vax/objdump.exp
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/verilog-1.hex b/binutils/testsuite/binutils-all/verilog-1.hex
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/verilog-2.hex b/binutils/testsuite/binutils-all/verilog-2.hex
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/verilog-4.hex b/binutils/testsuite/binutils-all/verilog-4.hex
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/verilog-8.hex b/binutils/testsuite/binutils-all/verilog-8.hex
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/verilogtest.s b/binutils/testsuite/binutils-all/verilogtest.s
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/version.def b/binutils/testsuite/binutils-all/version.def
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/version.s b/binutils/testsuite/binutils-all/version.s
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/wasm32/create-wasm.d b/binutils/testsuite/binutils-all/wasm32/create-wasm.d
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/wasm32/create-wasm.s b/binutils/testsuite/binutils-all/wasm32/create-wasm.s
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/wasm32/custom-section.d b/binutils/testsuite/binutils-all/wasm32/custom-section.d
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/wasm32/custom-section.s b/binutils/testsuite/binutils-all/wasm32/custom-section.s
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/wasm32/invalid-wasm-1.d b/binutils/testsuite/binutils-all/wasm32/invalid-wasm-1.d
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/wasm32/invalid-wasm-1.s b/binutils/testsuite/binutils-all/wasm32/invalid-wasm-1.s
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/wasm32/invalid-wasm-2.d b/binutils/testsuite/binutils-all/wasm32/invalid-wasm-2.d
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/wasm32/invalid-wasm-2.s b/binutils/testsuite/binutils-all/wasm32/invalid-wasm-2.s
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/wasm32/long-sections.d b/binutils/testsuite/binutils-all/wasm32/long-sections.d
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/wasm32/long-sections.s b/binutils/testsuite/binutils-all/wasm32/long-sections.s
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/wasm32/parse-wasm-2.d b/binutils/testsuite/binutils-all/wasm32/parse-wasm-2.d
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/wasm32/parse-wasm-2.s b/binutils/testsuite/binutils-all/wasm32/parse-wasm-2.s
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/wasm32/parse-wasm.d b/binutils/testsuite/binutils-all/wasm32/parse-wasm.d
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/wasm32/parse-wasm.s b/binutils/testsuite/binutils-all/wasm32/parse-wasm.s
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/wasm32/prepared-section.d b/binutils/testsuite/binutils-all/wasm32/prepared-section.d
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/wasm32/prepared-section.s b/binutils/testsuite/binutils-all/wasm32/prepared-section.s
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/wasm32/wasm32.exp b/binutils/testsuite/binutils-all/wasm32/wasm32.exp
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/windres/MSG00001.bin b/binutils/testsuite/binutils-all/windres/MSG00001.bin
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/windres/README b/binutils/testsuite/binutils-all/windres/README
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/windres/bmp1.bmp b/binutils/testsuite/binutils-all/windres/bmp1.bmp
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/windres/bmpalign.rc b/binutils/testsuite/binutils-all/windres/bmpalign.rc
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/windres/bmpalign.rsd b/binutils/testsuite/binutils-all/windres/bmpalign.rsd
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/windres/capstyle.rc b/binutils/testsuite/binutils-all/windres/capstyle.rc
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/windres/capstyle.rsd b/binutils/testsuite/binutils-all/windres/capstyle.rsd
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/windres/checkbox.rc b/binutils/testsuite/binutils-all/windres/checkbox.rc
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/windres/checkbox.rsd b/binutils/testsuite/binutils-all/windres/checkbox.rsd
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/windres/combobox.rc b/binutils/testsuite/binutils-all/windres/combobox.rc
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/windres/combobox.rsd b/binutils/testsuite/binutils-all/windres/combobox.rsd
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/windres/controldata.rc b/binutils/testsuite/binutils-all/windres/controldata.rc
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/windres/controldata.rsd b/binutils/testsuite/binutils-all/windres/controldata.rsd
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/windres/deflang.rc b/binutils/testsuite/binutils-all/windres/deflang.rc
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/windres/deflang.rsd b/binutils/testsuite/binutils-all/windres/deflang.rsd
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/windres/dialog0.rc b/binutils/testsuite/binutils-all/windres/dialog0.rc
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/windres/dialog0.rsd b/binutils/testsuite/binutils-all/windres/dialog0.rsd
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/windres/dialog1.rc b/binutils/testsuite/binutils-all/windres/dialog1.rc
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/windres/dialog1.rsd b/binutils/testsuite/binutils-all/windres/dialog1.rsd
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/windres/dialogid.rc b/binutils/testsuite/binutils-all/windres/dialogid.rc
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/windres/dialogid.rsd b/binutils/testsuite/binutils-all/windres/dialogid.rsd
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/windres/dialogsignature.rc b/binutils/testsuite/binutils-all/windres/dialogsignature.rc
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/windres/dialogsignature.rsd b/binutils/testsuite/binutils-all/windres/dialogsignature.rsd
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/windres/dlgfont.rc b/binutils/testsuite/binutils-all/windres/dlgfont.rc
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/windres/dlgfont.rsd b/binutils/testsuite/binutils-all/windres/dlgfont.rsd
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/windres/edittext.rc b/binutils/testsuite/binutils-all/windres/edittext.rc
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/windres/edittext.rsd b/binutils/testsuite/binutils-all/windres/edittext.rsd
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/windres/escapea.rc b/binutils/testsuite/binutils-all/windres/escapea.rc
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/windres/escapea.rsd b/binutils/testsuite/binutils-all/windres/escapea.rsd
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/windres/escapex-2.rc b/binutils/testsuite/binutils-all/windres/escapex-2.rc
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/windres/escapex-2.rsd b/binutils/testsuite/binutils-all/windres/escapex-2.rsd
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/windres/escapex.rc b/binutils/testsuite/binutils-all/windres/escapex.rc
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/windres/escapex.rsd b/binutils/testsuite/binutils-all/windres/escapex.rsd
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/windres/html.rc b/binutils/testsuite/binutils-all/windres/html.rc
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/windres/html.rsd b/binutils/testsuite/binutils-all/windres/html.rsd
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/windres/html1.hm b/binutils/testsuite/binutils-all/windres/html1.hm
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/windres/html2.hm b/binutils/testsuite/binutils-all/windres/html2.hm
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/windres/lang.rc b/binutils/testsuite/binutils-all/windres/lang.rc
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/windres/lang.rsd b/binutils/testsuite/binutils-all/windres/lang.rsd
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/windres/listbox.rc b/binutils/testsuite/binutils-all/windres/listbox.rc
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/windres/listbox.rsd b/binutils/testsuite/binutils-all/windres/listbox.rsd
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/windres/menuitem_flags.rc b/binutils/testsuite/binutils-all/windres/menuitem_flags.rc
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/windres/messagetable.rc b/binutils/testsuite/binutils-all/windres/messagetable.rc
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/windres/messagetable.rsd b/binutils/testsuite/binutils-all/windres/messagetable.rsd
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/windres/nocaption.rc b/binutils/testsuite/binutils-all/windres/nocaption.rc
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/windres/nocaption.rsd b/binutils/testsuite/binutils-all/windres/nocaption.rsd
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/windres/printstyle.rc b/binutils/testsuite/binutils-all/windres/printstyle.rc
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/windres/printstyle.rsd b/binutils/testsuite/binutils-all/windres/printstyle.rsd
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/windres/quoteclass.rc b/binutils/testsuite/binutils-all/windres/quoteclass.rc
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/windres/scrollbar.rc b/binutils/testsuite/binutils-all/windres/scrollbar.rc
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/windres/scrollbar.rsd b/binutils/testsuite/binutils-all/windres/scrollbar.rsd
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/windres/strtab1.rc b/binutils/testsuite/binutils-all/windres/strtab1.rc
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/windres/strtab1.rsd b/binutils/testsuite/binutils-all/windres/strtab1.rsd
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/windres/strtab2.rc b/binutils/testsuite/binutils-all/windres/strtab2.rc
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/windres/strtab2.rsd b/binutils/testsuite/binutils-all/windres/strtab2.rsd
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/windres/strtab3.rc b/binutils/testsuite/binutils-all/windres/strtab3.rc
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/windres/strtab3.rsd b/binutils/testsuite/binutils-all/windres/strtab3.rsd
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/windres/strtab4.rc b/binutils/testsuite/binutils-all/windres/strtab4.rc
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/windres/strtab4.rsd b/binutils/testsuite/binutils-all/windres/strtab4.rsd
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/windres/sublang.rc b/binutils/testsuite/binutils-all/windres/sublang.rc
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/windres/sublang.rsd b/binutils/testsuite/binutils-all/windres/sublang.rsd
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/windres/version.rc b/binutils/testsuite/binutils-all/windres/version.rc
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/windres/version.rsd b/binutils/testsuite/binutils-all/windres/version.rsd
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/windres/version_cat.rc b/binutils/testsuite/binutils-all/windres/version_cat.rc
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/windres/version_cat.rsd b/binutils/testsuite/binutils-all/windres/version_cat.rsd
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/windres/version_mlang.rc b/binutils/testsuite/binutils-all/windres/version_mlang.rc
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/windres/version_mlang.rsd b/binutils/testsuite/binutils-all/windres/version_mlang.rsd
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/windres/version_small.rc b/binutils/testsuite/binutils-all/windres/version_small.rc
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/windres/version_small.rsd b/binutils/testsuite/binutils-all/windres/version_small.rsd
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/windres/windres.exp b/binutils/testsuite/binutils-all/windres/windres.exp
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/x86-64/compressed-1.s b/binutils/testsuite/binutils-all/x86-64/compressed-1.s
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/x86-64/compressed-1a.d b/binutils/testsuite/binutils-all/x86-64/compressed-1a.d
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/x86-64/compressed-1b.d b/binutils/testsuite/binutils-all/x86-64/compressed-1b.d
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/x86-64/compressed-1c.d b/binutils/testsuite/binutils-all/x86-64/compressed-1c.d
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/x86-64/empty-x32.d b/binutils/testsuite/binutils-all/x86-64/empty-x32.d
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/x86-64/empty.d b/binutils/testsuite/binutils-all/x86-64/empty.d
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/x86-64/empty.s b/binutils/testsuite/binutils-all/x86-64/empty.s
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/x86-64/ibt-x32.d b/binutils/testsuite/binutils-all/x86-64/ibt-x32.d
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/x86-64/ibt.d b/binutils/testsuite/binutils-all/x86-64/ibt.d
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/x86-64/ibt.s b/binutils/testsuite/binutils-all/x86-64/ibt.s
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/x86-64/lam-u48.d b/binutils/testsuite/binutils-all/x86-64/lam-u48.d
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/x86-64/lam-u48.s b/binutils/testsuite/binutils-all/x86-64/lam-u48.s
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/x86-64/lam-u57.d b/binutils/testsuite/binutils-all/x86-64/lam-u57.d
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/x86-64/lam-u57.s b/binutils/testsuite/binutils-all/x86-64/lam-u57.s
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/x86-64/objects.exp b/binutils/testsuite/binutils-all/x86-64/objects.exp
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/x86-64/pr21231a.d b/binutils/testsuite/binutils-all/x86-64/pr21231a.d
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/x86-64/pr21231a.s b/binutils/testsuite/binutils-all/x86-64/pr21231a.s
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/x86-64/pr21231b.d b/binutils/testsuite/binutils-all/x86-64/pr21231b.d
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/x86-64/pr21231b.s b/binutils/testsuite/binutils-all/x86-64/pr21231b.s
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/x86-64/pr22451.o.bz2 b/binutils/testsuite/binutils-all/x86-64/pr22451.o.bz2
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/x86-64/pr23494a-x32.d b/binutils/testsuite/binutils-all/x86-64/pr23494a-x32.d
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/x86-64/pr23494a.d b/binutils/testsuite/binutils-all/x86-64/pr23494a.d
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/x86-64/pr23494a.s b/binutils/testsuite/binutils-all/x86-64/pr23494a.s
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/x86-64/pr23494b-x32.d b/binutils/testsuite/binutils-all/x86-64/pr23494b-x32.d
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/x86-64/pr23494b.d b/binutils/testsuite/binutils-all/x86-64/pr23494b.d
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/x86-64/pr23494b.s b/binutils/testsuite/binutils-all/x86-64/pr23494b.s
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/x86-64/pr23494c-x32.d b/binutils/testsuite/binutils-all/x86-64/pr23494c-x32.d
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/x86-64/pr23494c.d b/binutils/testsuite/binutils-all/x86-64/pr23494c.d
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/x86-64/pr23494c.s b/binutils/testsuite/binutils-all/x86-64/pr23494c.s
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/x86-64/pr23494d-x32.d b/binutils/testsuite/binutils-all/x86-64/pr23494d-x32.d
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/x86-64/pr23494d.d b/binutils/testsuite/binutils-all/x86-64/pr23494d.d
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/x86-64/pr23494e-x32.d b/binutils/testsuite/binutils-all/x86-64/pr23494e-x32.d
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/x86-64/pr23494e.d b/binutils/testsuite/binutils-all/x86-64/pr23494e.d
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/x86-64/pr26808.dump b/binutils/testsuite/binutils-all/x86-64/pr26808.dump
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/x86-64/pr26808.dwp.bz2 b/binutils/testsuite/binutils-all/x86-64/pr26808.dwp.bz2
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/x86-64/pr27708.dump b/binutils/testsuite/binutils-all/x86-64/pr27708.dump
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/x86-64/pr27708.exe.bz2 b/binutils/testsuite/binutils-all/x86-64/pr27708.exe.bz2
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/x86-64/shstk-x32.d b/binutils/testsuite/binutils-all/x86-64/shstk-x32.d
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/x86-64/shstk.d b/binutils/testsuite/binutils-all/x86-64/shstk.d
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/x86-64/shstk.s b/binutils/testsuite/binutils-all/x86-64/shstk.s
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/x86-64/x86-64.exp b/binutils/testsuite/binutils-all/x86-64/x86-64.exp
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/z.s b/binutils/testsuite/binutils-all/z.s
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/zero-sec.r b/binutils/testsuite/binutils-all/zero-sec.r
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/binutils-all/zero-sec.s b/binutils/testsuite/binutils-all/zero-sec.s
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/config/default.exp b/binutils/testsuite/config/default.exp
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/config/hppa.sed b/binutils/testsuite/config/hppa.sed
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/gentestdlls.c b/binutils/testsuite/gentestdlls.c
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/lib/binutils-common.exp b/binutils/testsuite/lib/binutils-common.exp
old mode 100644
new mode 100755
diff --git a/binutils/testsuite/lib/utils-lib.exp b/binutils/testsuite/lib/utils-lib.exp
old mode 100644
new mode 100755
diff --git a/binutils/unwind-ia64.c b/binutils/unwind-ia64.c
old mode 100644
new mode 100755
diff --git a/binutils/unwind-ia64.h b/binutils/unwind-ia64.h
old mode 100644
new mode 100755
diff --git a/binutils/version.c b/binutils/version.c
old mode 100644
new mode 100755
diff --git a/binutils/windint.h b/binutils/windint.h
old mode 100644
new mode 100755
diff --git a/binutils/windmc.c b/binutils/windmc.c
old mode 100644
new mode 100755
diff --git a/binutils/windmc.h b/binutils/windmc.h
old mode 100644
new mode 100755
diff --git a/binutils/windres.c b/binutils/windres.c
old mode 100644
new mode 100755
diff --git a/binutils/windres.h b/binutils/windres.h
old mode 100644
new mode 100755
diff --git a/binutils/winduni.c b/binutils/winduni.c
old mode 100644
new mode 100755
diff --git a/binutils/winduni.h b/binutils/winduni.h
old mode 100644
new mode 100755
diff --git a/binutils/wrstabs.c b/binutils/wrstabs.c
old mode 100644
new mode 100755
diff --git a/libiberty/cp-demangle.c b/libiberty/cp-demangle.c
index d3e7984..97e565c 100644
--- a/libiberty/cp-demangle.c
+++ b/libiberty/cp-demangle.c
@@ -1,3 +1,6 @@
+#ifdef FRCOV
+short FIXREVERTER[12386];
+#endif
 /* Demangler for g++ V3 ABI.
    Copyright (C) 2003-2021 Free Software Foundation, Inc.
    Written by Ian Lance Taylor <ian@wasabisystems.com>.
diff --git a/libiberty/hashtab.c b/libiberty/hashtab.c
index 7c424e8..feedcc7 100644
--- a/libiberty/hashtab.c
+++ b/libiberty/hashtab.c
@@ -1,3 +1,6 @@
+#ifdef FRCOV
+extern short FIXREVERTER[];
+#endif
 /* An expandable hash tables datatype.  
    Copyright (C) 1999-2021 Free Software Foundation, Inc.
    Contributed by Vladimir Makarov (vmakarov@cygnus.com).
@@ -355,15 +358,45 @@ htab_create_typed_alloc (size_t size, htab_hash hash_f, htab_eq eq_f,
   size = prime_tab[size_prime_index].prime;
 
   result = (htab_t) (*alloc_tab_f) (1, sizeof (struct htab));
-  if (result == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[4122]) {
+    if ((result == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 4122\n");
+    else
+      fprintf(stderr, "reached bug index 4122\n");
+  }
+  if ((!FIXREVERTER[4122] && (result == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     return NULL;
+    #ifdef FRCOV
+    }
+    #endif
   result->entries = (PTR *) (*alloc_f) (size, sizeof (PTR));
-  if (result->entries == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[4123]) {
+    if ((result -> entries == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 4123\n");
+    else
+      fprintf(stderr, "reached bug index 4123\n");
+  }
+  if ((!FIXREVERTER[4123] && (result -> entries == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     {
       if (free_f != NULL)
 	(*free_f) (result);
       return NULL;
     }
+    #ifdef FRCOV
+    }
+    #endif
   result->size = size;
   result->size_prime_index = size_prime_index;
   result->hash_f = hash_f;
@@ -547,8 +580,23 @@ htab_expand (htab_t htab)
 						  sizeof (PTR *));
   else
     nentries = (PTR *) (*htab->alloc_f) (nsize, sizeof (PTR *));
-  if (nentries == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[4124]) {
+    if ((nentries == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 4124\n");
+    else
+      fprintf(stderr, "reached bug index 4124\n");
+  }
+  if ((!FIXREVERTER[4124] && (nentries == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     return 0;
+    #ifdef FRCOV
+    }
+    #endif
   htab->entries = nentries;
   htab->size = nsize;
   htab->size_prime_index = nindex;
diff --git a/libiberty/lrealpath.c b/libiberty/lrealpath.c
index 83bdd17..137d105 100644
--- a/libiberty/lrealpath.c
+++ b/libiberty/lrealpath.c
@@ -1,3 +1,6 @@
+#ifdef FRCOV
+extern short FIXREVERTER[];
+#endif
 /* Libiberty realpath.  Like realpath, but more consistent behavior.
    Based on gdb_realpath from GDB.
 
@@ -83,8 +86,23 @@ lrealpath (const char *filename)
   {
     char buf[REALPATH_LIMIT];
     const char *rp = realpath (filename, buf);
-    if (rp == NULL)
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[5404]) {
+      if ((rp == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 5404\n");
+      else
+        fprintf(stderr, "reached bug index 5404\n");
+    }
+    if ((!FIXREVERTER[5404] && (rp == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    )
       rp = filename;
+      #ifdef FRCOV
+      }
+      #endif
     return strdup (rp);
   }
 #endif /* REALPATH_LIMIT */
diff --git a/libiberty/make-relative-prefix.c b/libiberty/make-relative-prefix.c
index ef932ff..4dfa41f 100644
--- a/libiberty/make-relative-prefix.c
+++ b/libiberty/make-relative-prefix.c
@@ -1,3 +1,6 @@
+#ifdef FRCOV
+extern short FIXREVERTER[];
+#endif
 /* Relative (relocatable) prefix support.
    Copyright (C) 1987-2021 Free Software Foundation, Inc.
 
@@ -147,8 +150,23 @@ split_directories (const char *name, int *ptr_num_dirs)
     }
 
   dirs = (char **) malloc (sizeof (char *) * (num_dirs + 2));
-  if (dirs == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[10524]) {
+    if ((dirs == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 10524\n");
+    else
+      fprintf(stderr, "reached bug index 10524\n");
+  }
+  if ((!FIXREVERTER[10524] && (dirs == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     return NULL;
+    #ifdef FRCOV
+    }
+    #endif
 
   /* Now copy the directory parts.  */
   num_dirs = 0;
@@ -237,8 +255,23 @@ make_relative_prefix_1 (const char *progname, const char *bin_prefix,
   char *ret = NULL, *ptr, *full_progname;
   char *alloc_ptr = NULL;
 
-  if (progname == NULL || bin_prefix == NULL || prefix == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[10525]) {
+    if ((progname == (void *) 0 || bin_prefix == (void *) 0 || prefix == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 10525\n");
+    else
+      fprintf(stderr, "reached bug index 10525\n");
+  }
+  if ((!FIXREVERTER[10525] && (progname == (void *) 0 || bin_prefix == (void *) 0 || prefix == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     return NULL;
+    #ifdef FRCOV
+    }
+    #endif
 
   /* If there is no full pathname, try to find the program by checking in each
      of the directories specified in the PATH environment variable.  */
@@ -317,17 +350,62 @@ make_relative_prefix_1 (const char *progname, const char *bin_prefix,
     full_progname = lrealpath (progname);
   else
     full_progname = strdup (progname);
-  if (full_progname == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[10527]) {
+    if ((full_progname == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 10527\n");
+    else
+      fprintf(stderr, "reached bug index 10527\n");
+  }
+  if ((!FIXREVERTER[10527] && (full_progname == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     goto bailout;
+    #ifdef FRCOV
+    }
+    #endif
 
   prog_dirs = split_directories (full_progname, &prog_num);
   free (full_progname);
-  if (prog_dirs == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[10528]) {
+    if ((prog_dirs == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 10528\n");
+    else
+      fprintf(stderr, "reached bug index 10528\n");
+  }
+  if ((!FIXREVERTER[10528] && (prog_dirs == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     goto bailout;
+    #ifdef FRCOV
+    }
+    #endif
 
   bin_dirs = split_directories (bin_prefix, &bin_num);
-  if (bin_dirs == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[10529]) {
+    if ((bin_dirs == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 10529\n");
+    else
+      fprintf(stderr, "reached bug index 10529\n");
+  }
+  if ((!FIXREVERTER[10529] && (bin_dirs == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     goto bailout;
+    #ifdef FRCOV
+    }
+    #endif
 
   /* Remove the program name from comparison of directory names.  */
   prog_num--;
@@ -344,13 +422,43 @@ make_relative_prefix_1 (const char *progname, const char *bin_prefix,
 	    break;
 	}
 
-      if (prog_num <= 0 || i == bin_num)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[10530]) {
+        if ((prog_num <= 0 || i == bin_num ) && !(0))
+          fprintf(stderr, "triggered bug index 10530\n");
+        else
+          fprintf(stderr, "reached bug index 10530\n");
+      }
+      if ((!FIXREVERTER[10530] && (prog_num <= 0 || i == bin_num ))
+      #else
+      if (0
+      #endif
+      )
 	goto bailout;
+	#ifdef FRCOV
+	}
+	#endif
     }
 
   prefix_dirs = split_directories (prefix, &prefix_num);
-  if (prefix_dirs == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[10531]) {
+    if ((prefix_dirs == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 10531\n");
+    else
+      fprintf(stderr, "reached bug index 10531\n");
+  }
+  if ((!FIXREVERTER[10531] && (prefix_dirs == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     goto bailout;
+    #ifdef FRCOV
+    }
+    #endif
 
   /* Find how many directories are in common between bin_prefix & prefix.  */
   n = (prefix_num < bin_num) ? prefix_num : bin_num;
@@ -361,8 +469,23 @@ make_relative_prefix_1 (const char *progname, const char *bin_prefix,
     }
 
   /* If there are no common directories, there can be no relative prefix.  */
-  if (common == 0)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[10532]) {
+    if ((common == 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 10532\n");
+    else
+      fprintf(stderr, "reached bug index 10532\n");
+  }
+  if ((!FIXREVERTER[10532] && (common == 0 ))
+  #else
+  if (0
+  #endif
+  )
     goto bailout;
+    #ifdef FRCOV
+    }
+    #endif
 
   /* Two passes: first figure out the size of the result string, and
      then construct it.  */
@@ -375,8 +498,23 @@ make_relative_prefix_1 (const char *progname, const char *bin_prefix,
   needed_len += 1; /* Trailing NUL.  */
 
   ret = (char *) malloc (needed_len);
-  if (ret == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[10533]) {
+    if ((ret == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 10533\n");
+    else
+      fprintf(stderr, "reached bug index 10533\n");
+  }
+  if ((!FIXREVERTER[10533] && (ret == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     goto bailout;
+    #ifdef FRCOV
+    }
+    #endif
 
   /* Build up the pathnames in argv[0].  */
   *ret = '\0';
diff --git a/libiberty/objalloc.c b/libiberty/objalloc.c
index cf51905..b979e20 100644
--- a/libiberty/objalloc.c
+++ b/libiberty/objalloc.c
@@ -1,3 +1,6 @@
+#ifdef FRCOV
+extern short FIXREVERTER[];
+#endif
 /* objalloc.c -- routines to allocate memory for objects
    Copyright (C) 1997-2021 Free Software Foundation, Inc.
    Written by Ian Lance Taylor, Cygnus Solutions.
@@ -89,15 +92,45 @@ objalloc_create (void)
   struct objalloc_chunk *chunk;
 
   ret = (struct objalloc *) malloc (sizeof *ret);
-  if (ret == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[3088]) {
+    if ((ret == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 3088\n");
+    else
+      fprintf(stderr, "reached bug index 3088\n");
+  }
+  if ((!FIXREVERTER[3088] && (ret == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     return NULL;
+    #ifdef FRCOV
+    }
+    #endif
 
   ret->chunks = (PTR) malloc (CHUNK_SIZE);
-  if (ret->chunks == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[3089]) {
+    if ((ret -> chunks == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 3089\n");
+    else
+      fprintf(stderr, "reached bug index 3089\n");
+  }
+  if ((!FIXREVERTER[3089] && (ret -> chunks == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     {
       free (ret);
       return NULL;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
   chunk = (struct objalloc_chunk *) ret->chunks;
   chunk->next = NULL;
@@ -243,20 +276,65 @@ objalloc_free_block (struct objalloc *o, PTR block)
 	  next = q->next;
 	  if (small != NULL)
 	    {
-	      if (small == q)
+	      
+	      #ifdef FRCOV
+	      {if (FIXREVERTER[3090]) {
+	        if ((small == q ) && !(0))
+	          fprintf(stderr, "triggered bug index 3090\n");
+	        else
+	          fprintf(stderr, "reached bug index 3090\n");
+	      }
+	      if ((!FIXREVERTER[3090] && (small == q ))
+	      #else
+	      if (0
+	      #endif
+	      )
 		small = NULL;
+		#ifdef FRCOV
+		}
+		#endif
 	      free (q);
 	    }
 	  else if (q->current_ptr > b)
 	    free (q);
-	  else if (first == NULL)
+	  else 
+	  #ifdef FRCOV
+	  {if (FIXREVERTER[3091]) {
+	    if ((first == (void *) 0 ) && !(0))
+	      fprintf(stderr, "triggered bug index 3091\n");
+	    else
+	      fprintf(stderr, "reached bug index 3091\n");
+	  }
+	  if ((!FIXREVERTER[3091] && (first == (void *) 0 ))
+	  #else
+	  if (0
+	  #endif
+	  )
 	    first = q;
+	    #ifdef FRCOV
+	    }
+	    #endif
 
 	  q = next;
 	}
 
-      if (first == NULL)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[3092]) {
+        if ((first == (void *) 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 3092\n");
+        else
+          fprintf(stderr, "reached bug index 3092\n");
+      }
+      if ((!FIXREVERTER[3092] && (first == (void *) 0 ))
+      #else
+      if (0
+      #endif
+      )
 	first = p;
+	#ifdef FRCOV
+	}
+	#endif
       o->chunks = (PTR) first;
 
       /* Now start allocating from this small block again.  */
diff --git a/libiberty/splay-tree.c b/libiberty/splay-tree.c
index 7c8973c..06e294b 100644
--- a/libiberty/splay-tree.c
+++ b/libiberty/splay-tree.c
@@ -1,3 +1,6 @@
+#ifdef FRCOV
+extern short FIXREVERTER[];
+#endif
 /* A splay-tree datatype.  
    Copyright (C) 1998-2021 Free Software Foundation, Inc.
    Contributed by Mark Mitchell (mark@markmitchell.com).
@@ -140,8 +143,23 @@ rotate_right (splay_tree_node *pp, splay_tree_node p, splay_tree_node n)
 static void
 splay_tree_splay (splay_tree sp, splay_tree_key key)
 {
-  if (sp->root == 0)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[2961]) {
+    if ((sp -> root == 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 2961\n");
+    else
+      fprintf(stderr, "reached bug index 2961\n");
+  }
+  if ((!FIXREVERTER[2961] && (sp -> root == 0 ))
+  #else
+  if (0
+  #endif
+  )
     return;
+    #ifdef FRCOV
+    }
+    #endif
 
   do {
     int cmp1, cmp2;
@@ -236,8 +254,23 @@ splay_tree_foreach_helper (splay_tree_node node,
 	  node = node->left;
 	}
 
-      if (stack_ptr == 0)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[2964]) {
+        if ((stack_ptr == 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 2964\n");
+        else
+          fprintf(stderr, "reached bug index 2964\n");
+      }
+      if ((!FIXREVERTER[2964] && (stack_ptr == 0 ))
+      #else
+      if (0
+      #endif
+      )
 	break;
+	#ifdef FRCOV
+	}
+	#endif
 
       node = stack[--stack_ptr];
 
diff --git a/opcodes/arc-dis.c b/opcodes/arc-dis.c
index 78e8e80..cc503ce 100644
--- a/opcodes/arc-dis.c
+++ b/opcodes/arc-dis.c
@@ -1,3 +1,6 @@
+#ifdef FRCOV
+extern short FIXREVERTER[];
+#endif
 /* Instruction printing code for the ARC.
    Copyright (C) 1994-2021 Free Software Foundation, Inc.
 
@@ -149,8 +152,23 @@ init_arc_disasm_info (struct disassemble_info *info)
   struct arc_disassemble_info *arc_infop
     = calloc (sizeof (*arc_infop), 1);
 
-  if (arc_infop == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[10256]) {
+    if ((arc_infop == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 10256\n");
+    else
+      fprintf(stderr, "reached bug index 10256\n");
+  }
+  if ((!FIXREVERTER[10256] && (arc_infop == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     return false;
+    #ifdef FRCOV
+    }
+    #endif
 
   info->private_data = arc_infop;
   return true;
@@ -853,8 +871,23 @@ parse_disassembler_options (const char *options)
 {
   const char *option;
 
-  if (options == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[10265]) {
+    if ((options == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 10265\n");
+    else
+      fprintf(stderr, "reached bug index 10265\n");
+  }
+  if ((!FIXREVERTER[10265] && (options == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     return;
+    #ifdef FRCOV
+    }
+    #endif
 
   /* Disassembler might be reused for difference CPU's, and cpu option set for
      the first one shouldn't be applied to second (which might not have
diff --git a/opcodes/bfin-dis.c b/opcodes/bfin-dis.c
index 599b9a0..6b1941f 100644
--- a/opcodes/bfin-dis.c
+++ b/opcodes/bfin-dis.c
@@ -1,3 +1,6 @@
+#ifdef FRCOV
+extern short FIXREVERTER[];
+#endif
 /* Disassemble ADI Blackfin Instructions.
    Copyright (C) 2005-2021 Free Software Foundation, Inc.
 
@@ -2575,8 +2578,23 @@ decode_LoopSetup_0 (TIword iw0, TIword iw1, bfd_vma pc, disassemble_info *outf)
   if (priv->parallel)
     return 0;
 
-  if (reg > 7)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[10402]) {
+    if ((reg > 7 ) && !(0))
+      fprintf(stderr, "triggered bug index 10402\n");
+    else
+      fprintf(stderr, "reached bug index 10402\n");
+  }
+  if ((!FIXREVERTER[10402] && (reg > 7 ))
+  #else
+  if (0
+  #endif
+  )
     return 0;
+    #ifdef FRCOV
+    }
+    #endif
 
   if (rop == 0)
     {
@@ -4816,8 +4834,23 @@ print_insn_bfin (bfd_vma pc, disassemble_info *outf)
   if (!priv.comment)
     OUTS (outf, ";");
 
-  if (count == 0)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[10407]) {
+    if ((count == 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 10407\n");
+    else
+      fprintf(stderr, "reached bug index 10407\n");
+  }
+  if ((!FIXREVERTER[10407] && (count == 0 ))
+  #else
+  if (0
+  #endif
+  )
     return 2;
+    #ifdef FRCOV
+    }
+    #endif
 
   return count;
 }
diff --git a/opcodes/bpf-desc.c b/opcodes/bpf-desc.c
index 35c6dcd..c6d2a1e 100644
--- a/opcodes/bpf-desc.c
+++ b/opcodes/bpf-desc.c
@@ -1,3 +1,6 @@
+#ifdef FRCOV
+extern short FIXREVERTER[];
+#endif
 /* DO NOT EDIT!  -*- buffer-read-only: t -*- vi:set ro:  */
 /* CPU data for bpf.
 
@@ -1746,10 +1749,40 @@ bpf_cgen_rebuild_tables (CGEN_CPU_TABLE *cd)
 	  cd->base_insn_bitsize = CGEN_SIZE_UNKNOWN;
 
 	/* Set min,max insn sizes.  */
-	if (isa->min_insn_bitsize < cd->min_insn_bitsize)
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[12381]) {
+	  if ((isa -> min_insn_bitsize < cd -> min_insn_bitsize  ) && !(0))
+	    fprintf(stderr, "triggered bug index 12381\n");
+	  else
+	    fprintf(stderr, "reached bug index 12381\n");
+	}
+	if ((!FIXREVERTER[12381] && (isa -> min_insn_bitsize < cd -> min_insn_bitsize  ))
+	#else
+	if (0
+	#endif
+	)
 	  cd->min_insn_bitsize = isa->min_insn_bitsize;
-	if (isa->max_insn_bitsize > cd->max_insn_bitsize)
+	  #ifdef FRCOV
+	  }
+	  #endif
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[12382]) {
+	  if ((isa -> max_insn_bitsize > cd -> max_insn_bitsize  ) && !(0))
+	    fprintf(stderr, "triggered bug index 12382\n");
+	  else
+	    fprintf(stderr, "reached bug index 12382\n");
+	}
+	if ((!FIXREVERTER[12382] && (isa -> max_insn_bitsize > cd -> max_insn_bitsize  ))
+	#else
+	if (0
+	#endif
+	)
 	  cd->max_insn_bitsize = isa->max_insn_bitsize;
+	  #ifdef FRCOV
+	  }
+	  #endif
       }
 
   /* Data derived from the mach spec.  */
@@ -1760,8 +1793,23 @@ bpf_cgen_rebuild_tables (CGEN_CPU_TABLE *cd)
 
 	if (mach->insn_chunk_bitsize != 0)
 	{
-	  if (cd->insn_chunk_bitsize != 0 && cd->insn_chunk_bitsize != mach->insn_chunk_bitsize)
+	  
+	  #ifdef FRCOV
+	  {if (FIXREVERTER[12383]) {
+	    fprintf(stderr, "reached bug index 12383\n");
+	  }
+	  if ((FIXREVERTER[12383] && (cd -> insn_chunk_bitsize != 0 )) || (!FIXREVERTER[12383] && (cd -> insn_chunk_bitsize != 0 && cd -> insn_chunk_bitsize != mach -> insn_chunk_bitsize ))
+	  #else
+	  if (cd -> insn_chunk_bitsize != 0 
+	  #endif
+	  )
 	    {
+	      
+	    #ifdef FRCOV
+	      if (!(cd -> insn_chunk_bitsize != mach -> insn_chunk_bitsize ))
+	        fprintf(stderr, "triggered bug index 12383\n");
+	      #endif
+	    
 	      opcodes_error_handler
 		(/* xgettext:c-format */
 		 _("internal error: bpf_cgen_rebuild_tables: "
@@ -1769,6 +1817,9 @@ bpf_cgen_rebuild_tables (CGEN_CPU_TABLE *cd)
 		 cd->insn_chunk_bitsize, mach->insn_chunk_bitsize);
 	      abort ();
 	    }
+	    #ifdef FRCOV
+	    }
+	    #endif
 
  	  cd->insn_chunk_bitsize = mach->insn_chunk_bitsize;
 	}
@@ -1862,8 +1913,23 @@ bpf_cgen_cpu_open (enum cgen_cpu_open_arg arg_type, ...)
   va_end (ap);
 
   /* Mach unspecified means "all".  */
-  if (machs == 0)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[12385]) {
+    if ((machs == 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 12385\n");
+    else
+      fprintf(stderr, "reached bug index 12385\n");
+  }
+  if ((!FIXREVERTER[12385] && (machs == 0 ))
+  #else
+  if (0
+  #endif
+  )
     machs = (1 << MAX_MACHS) - 1;
+    #ifdef FRCOV
+    }
+    #endif
   /* Base mach is always selected.  */
   machs |= 1;
   if (endian == CGEN_ENDIAN_UNKNOWN)
diff --git a/opcodes/bpf-dis.c b/opcodes/bpf-dis.c
index 8c460c7..2fdb158 100644
--- a/opcodes/bpf-dis.c
+++ b/opcodes/bpf-dis.c
@@ -1,3 +1,6 @@
+#ifdef FRCOV
+extern short FIXREVERTER[];
+#endif
 /* DO NOT EDIT!  -*- buffer-read-only: t -*- vi:set ro:  */
 /* Disassembler interface for targets using CGEN. -*- C -*-
    CGEN: Cpu tools GENerator
@@ -621,10 +624,40 @@ print_insn_bpf (bfd_vma pc, disassemble_info *info)
      but if not possible try to move this hook elsewhere rather than
      have two hooks.  */
   length = CGEN_PRINT_INSN (cd, pc, info);
-  if (length > 0)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[12351]) {
+    if ((length > 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 12351\n");
+    else
+      fprintf(stderr, "reached bug index 12351\n");
+  }
+  if ((!FIXREVERTER[12351] && (length > 0 ))
+  #else
+  if (0
+  #endif
+  )
     return length;
-  if (length < 0)
+    #ifdef FRCOV
+    }
+    #endif
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[12352]) {
+    if ((length < 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 12352\n");
+    else
+      fprintf(stderr, "reached bug index 12352\n");
+  }
+  if ((!FIXREVERTER[12352] && (length < 0 ))
+  #else
+  if (0
+  #endif
+  )
     return -1;
+    #ifdef FRCOV
+    }
+    #endif
 
   (*info->fprintf_func) (info->stream, UNKNOWN_INSN_MSG);
   return cd->default_insn_bitsize / 8;
diff --git a/opcodes/cgen-bitset.c b/opcodes/cgen-bitset.c
index bbaddb7..da500c4 100644
--- a/opcodes/cgen-bitset.c
+++ b/opcodes/cgen-bitset.c
@@ -1,3 +1,6 @@
+#ifdef FRCOV
+extern short FIXREVERTER[];
+#endif
 /* CGEN generic opcode support.
    Copyright (C) 2002-2021 Free Software Foundation, Inc.
 
@@ -114,8 +117,23 @@ cgen_bitset_compare (CGEN_BITSET * mask1, CGEN_BITSET * mask2)
     return 0;
   if (! mask1 || ! mask2)
     return 1;
-  if (mask1->length != mask2->length)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[7489]) {
+    if ((mask1 -> length != mask2 -> length ) && !(0))
+      fprintf(stderr, "triggered bug index 7489\n");
+    else
+      fprintf(stderr, "reached bug index 7489\n");
+  }
+  if ((!FIXREVERTER[7489] && (mask1 -> length != mask2 -> length ))
+  #else
+  if (0
+  #endif
+  )
     return 1;
+    #ifdef FRCOV
+    }
+    #endif
   return memcmp (mask1->bits, mask2->bits, mask1->length);
 }
 
diff --git a/opcodes/cr16-dis.c b/opcodes/cr16-dis.c
index ac85552..1dc6173 100644
--- a/opcodes/cr16-dis.c
+++ b/opcodes/cr16-dis.c
@@ -1,3 +1,6 @@
+#ifdef FRCOV
+extern short FIXREVERTER[];
+#endif
 /* Disassembler code for CR16.
    Copyright (C) 2007-2021 Free Software Foundation, Inc.
    Contributed by M R Swami Reddy (MR.Swami.Reddy@nsc.com).
@@ -183,8 +186,23 @@ gettrapstring (unsigned int trap_index)
   const trap_entry *trap;
 
   for (trap = cr16_traps; trap < cr16_traps + NUMTRAPS; trap++)
-    if (trap->entry == trap_index)
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[3240]) {
+      if ((trap -> entry == trap_index ) && !(0))
+        fprintf(stderr, "triggered bug index 3240\n");
+      else
+        fprintf(stderr, "reached bug index 3240\n");
+    }
+    if ((!FIXREVERTER[3240] && (trap -> entry == trap_index ))
+    #else
+    if (0
+    #endif
+    )
       return trap->name;
+      #ifdef FRCOV
+      }
+      #endif
 
   return ILLEGAL;
 }
diff --git a/opcodes/cris-dis.c b/opcodes/cris-dis.c
index 0385e58..9c147dc 100644
--- a/opcodes/cris-dis.c
+++ b/opcodes/cris-dis.c
@@ -1,3 +1,6 @@
+#ifdef FRCOV
+extern short FIXREVERTER[];
+#endif
 /* Disassembler code for CRIS.
    Copyright (C) 2000-2021 Free Software Foundation, Inc.
    Contributed by Axis Communications AB, Lund, Sweden.
@@ -107,8 +110,23 @@ cris_parse_disassembler_options (disassemble_info *info,
 
   info->private_data = calloc (1, sizeof (struct cris_disasm_data));
   disdata = (struct cris_disasm_data *) info->private_data;
-  if (disdata == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[2558]) {
+    if ((disdata == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 2558\n");
+    else
+      fprintf(stderr, "reached bug index 2558\n");
+  }
+  if ((!FIXREVERTER[2558] && (disdata == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     return false;
+    #ifdef FRCOV
+    }
+    #endif
 
   /* Default true.  */
   disdata->trace_case
@@ -189,43 +207,133 @@ get_opcode_entry (unsigned int insn,
   if (opc_table == NULL)
     {
       opc_table = malloc (65536 * sizeof (opc_table[0]));
-      if (opc_table == NULL)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[2559]) {
+        if ((opc_table == (void *) 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 2559\n");
+        else
+          fprintf(stderr, "reached bug index 2559\n");
+      }
+      if ((!FIXREVERTER[2559] && (opc_table == (void *) 0 ))
+      #else
+      if (0
+      #endif
+      )
 	return NULL;
+	#ifdef FRCOV
+	}
+	#endif
 
       memset (opc_table, 0, 65536 * sizeof (const struct cris_opcode *));
 
       dip_prefixes
 	= malloc (65536 * sizeof (const struct cris_opcode **));
-      if (dip_prefixes == NULL)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[2560]) {
+        if ((dip_prefixes == (void *) 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 2560\n");
+        else
+          fprintf(stderr, "reached bug index 2560\n");
+      }
+      if ((!FIXREVERTER[2560] && (dip_prefixes == (void *) 0 ))
+      #else
+      if (0
+      #endif
+      )
 	return NULL;
+	#ifdef FRCOV
+	}
+	#endif
 
       memset (dip_prefixes, 0, 65536 * sizeof (dip_prefixes[0]));
 
       bdapq_m1_prefixes
 	= malloc (65536 * sizeof (const struct cris_opcode **));
-      if (bdapq_m1_prefixes == NULL)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[2561]) {
+        if ((bdapq_m1_prefixes == (void *) 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 2561\n");
+        else
+          fprintf(stderr, "reached bug index 2561\n");
+      }
+      if ((!FIXREVERTER[2561] && (bdapq_m1_prefixes == (void *) 0 ))
+      #else
+      if (0
+      #endif
+      )
 	return NULL;
+	#ifdef FRCOV
+	}
+	#endif
 
       memset (bdapq_m1_prefixes, 0, 65536 * sizeof (bdapq_m1_prefixes[0]));
 
       bdapq_m2_prefixes
 	= malloc (65536 * sizeof (const struct cris_opcode **));
-      if (bdapq_m2_prefixes == NULL)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[2562]) {
+        if ((bdapq_m2_prefixes == (void *) 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 2562\n");
+        else
+          fprintf(stderr, "reached bug index 2562\n");
+      }
+      if ((!FIXREVERTER[2562] && (bdapq_m2_prefixes == (void *) 0 ))
+      #else
+      if (0
+      #endif
+      )
 	return NULL;
+	#ifdef FRCOV
+	}
+	#endif
 
       memset (bdapq_m2_prefixes, 0, 65536 * sizeof (bdapq_m2_prefixes[0]));
 
       bdapq_m4_prefixes
 	= malloc (65536 * sizeof (const struct cris_opcode **));
-      if (bdapq_m4_prefixes == NULL)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[2563]) {
+        if ((bdapq_m4_prefixes == (void *) 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 2563\n");
+        else
+          fprintf(stderr, "reached bug index 2563\n");
+      }
+      if ((!FIXREVERTER[2563] && (bdapq_m4_prefixes == (void *) 0 ))
+      #else
+      if (0
+      #endif
+      )
 	return NULL;
+	#ifdef FRCOV
+	}
+	#endif
 
       memset (bdapq_m4_prefixes, 0, 65536 * sizeof (bdapq_m4_prefixes[0]));
 
       rest_prefixes
 	= malloc (65536 * sizeof (const struct cris_opcode **));
-      if (rest_prefixes == NULL)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[2564]) {
+        if ((rest_prefixes == (void *) 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 2564\n");
+        else
+          fprintf(stderr, "reached bug index 2564\n");
+      }
+      if ((!FIXREVERTER[2564] && (rest_prefixes == (void *) 0 ))
+      #else
+      if (0
+      #endif
+      )
 	return NULL;
+	#ifdef FRCOV
+	}
+	#endif
 
       memset (rest_prefixes, 0, 65536 * sizeof (rest_prefixes[0]));
     }
@@ -243,8 +351,23 @@ get_opcode_entry (unsigned int insn,
 	   ? opc_table[prefix_insn]
 	   : get_opcode_entry (prefix_insn, NO_CRIS_PREFIX, disdata));
 
-      if (popcodep == NULL)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[2565]) {
+        if ((popcodep == (void *) 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 2565\n");
+        else
+          fprintf(stderr, "reached bug index 2565\n");
+      }
+      if ((!FIXREVERTER[2565] && (popcodep == (void *) 0 ))
+      #else
+      if (0
+      #endif
+      )
 	return NULL;
+	#ifdef FRCOV
+	}
+	#endif
 
       if (popcodep->match == BDAP_QUICK_OPCODE)
 	{
@@ -680,8 +803,23 @@ bytes_to_skip (unsigned int insn,
 
 	    /* FIXME: Improve error handling; should have been caught
 	       earlier.  */
-	    if (sregp == NULL)
+	    
+	    #ifdef FRCOV
+	    {if (FIXREVERTER[2567]) {
+	      if ((sregp == (void *) 0 ) && !(0))
+	        fprintf(stderr, "triggered bug index 2567\n");
+	      else
+	        fprintf(stderr, "reached bug index 2567\n");
+	    }
+	    if ((!FIXREVERTER[2567] && (sregp == (void *) 0 ))
+	    #else
+	    if (0
+	    #endif
+	    )
 	      return 2;
+	      #ifdef FRCOV
+	      }
+	      #endif
 
 	    /* PC is incremented by two, not one, for a byte.  Except on
 	       CRISv32, where constants are always DWORD-size for
@@ -1657,8 +1795,23 @@ cris_get_disassembler (bfd *abfd)
   /* If there's no bfd in sight, we return what is valid as input in all
      contexts if fed back to the assembler: disassembly *with* register
      prefix.  Unfortunately this will be totally wrong for v32.  */
-  if (abfd == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[2576]) {
+    if ((abfd == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 2576\n");
+    else
+      fprintf(stderr, "reached bug index 2576\n");
+  }
+  if ((!FIXREVERTER[2576] && (abfd == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     return print_insn_cris_with_register_prefix;
+    #ifdef FRCOV
+    }
+    #endif
 
   if (bfd_get_symbol_leading_char (abfd) == 0)
     {
diff --git a/opcodes/crx-dis.c b/opcodes/crx-dis.c
index 147133a..2a008b9 100644
--- a/opcodes/crx-dis.c
+++ b/opcodes/crx-dis.c
@@ -1,3 +1,6 @@
+#ifdef FRCOV
+extern short FIXREVERTER[];
+#endif
 /* Disassembler code for CRX.
    Copyright (C) 2004-2021 Free Software Foundation, Inc.
    Contributed by Tomer Levi, NSC, Israel.
@@ -142,8 +145,23 @@ gettrapstring (unsigned int trap_index)
   const trap_entry *trap;
 
   for (trap = crx_traps; trap < crx_traps + NUMTRAPS; trap++)
-    if (trap->entry == trap_index)
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[11492]) {
+      if ((trap -> entry == trap_index ) && !(0))
+        fprintf(stderr, "triggered bug index 11492\n");
+      else
+        fprintf(stderr, "reached bug index 11492\n");
+    }
+    if ((!FIXREVERTER[11492] && (trap -> entry == trap_index ))
+    #else
+    if (0
+    #endif
+    )
       return trap->name;
+      #ifdef FRCOV
+      }
+      #endif
 
   return ILLEGAL;
 }
@@ -157,8 +175,23 @@ getcinvstring (unsigned int num)
   const cinv_entry *cinv;
 
   for (cinv = crx_cinvs; cinv < (crx_cinvs + NUMCINVS); cinv++)
-    if (cinv->value == num)
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[11493]) {
+      if ((cinv -> value == num ) && !(0))
+        fprintf(stderr, "triggered bug index 11493\n");
+      else
+        fprintf(stderr, "reached bug index 11493\n");
+    }
+    if ((!FIXREVERTER[11493] && (cinv -> value == num ))
+    #else
+    if (0
+    #endif
+    )
       return cinv->str;
+      #ifdef FRCOV
+      }
+      #endif
 
   return ILLEGAL;
 }
diff --git a/opcodes/csky-dis.c b/opcodes/csky-dis.c
index cdd911b..b2713fa 100644
--- a/opcodes/csky-dis.c
+++ b/opcodes/csky-dis.c
@@ -1,3 +1,6 @@
+#ifdef FRCOV
+extern short FIXREVERTER[];
+#endif
 /* C-SKY disassembler.
    Copyright (C) 1988-2021 Free Software Foundation, Inc.
    Contributed by C-SKY Microsystems and Mentor Graphics.
@@ -1095,15 +1098,45 @@ print_insn_csky (bfd_vma memaddr, struct disassemble_info *info)
       /* Start scanning at the start of the function, or wherever
 	 we finished last time.  */
       n = 0;
-      if (n < last_map_sym)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[5755]) {
+        if ((n < last_map_sym ) && !(0))
+          fprintf(stderr, "triggered bug index 5755\n");
+        else
+          fprintf(stderr, "reached bug index 5755\n");
+      }
+      if ((!FIXREVERTER[5755] && (n < last_map_sym ))
+      #else
+      if (0
+      #endif
+      )
 	n = last_map_sym;
+	#ifdef FRCOV
+	}
+	#endif
 
       /* Scan up to the location being disassembled.  */
       for (; n < info->symtab_size; n++)
 	{
 	  addr = bfd_asymbol_value (info->symtab[n]);
-	  if (addr > memaddr)
+	  
+	  #ifdef FRCOV
+	  {if (FIXREVERTER[5756]) {
+	    if ((addr > memaddr ) && !(0))
+	      fprintf(stderr, "triggered bug index 5756\n");
+	    else
+	      fprintf(stderr, "reached bug index 5756\n");
+	  }
+	  if ((!FIXREVERTER[5756] && (addr > memaddr ))
+	  #else
+	  if (0
+	  #endif
+	  )
 	    break;
+	    #ifdef FRCOV
+	    }
+	    #endif
 	  if ((info->section == NULL
 	       || info->section == info->symtab[n]->section)
 	      && get_sym_code_type (info, n, &type))
@@ -1118,18 +1151,63 @@ print_insn_csky (bfd_vma memaddr, struct disassemble_info *info)
 	  for (n = last_sym + 1; n < info->symtab_size; n++)
 	    {
 	      addr = bfd_asymbol_value (info->symtab[n]);
-	      if (addr > memaddr)
+	      
+	      #ifdef FRCOV
+	      {if (FIXREVERTER[5758]) {
+	        if ((addr > memaddr ) && !(0))
+	          fprintf(stderr, "triggered bug index 5758\n");
+	        else
+	          fprintf(stderr, "reached bug index 5758\n");
+	      }
+	      if ((!FIXREVERTER[5758] && (addr > memaddr ))
+	      #else
+	      if (0
+	      #endif
+	      )
 		{
-		  if (addr - memaddr < size)
+		  
+		  #ifdef FRCOV
+		  {if (FIXREVERTER[5757]) {
+		    if ((addr - memaddr < size ) && !(0))
+		      fprintf(stderr, "triggered bug index 5757\n");
+		    else
+		      fprintf(stderr, "reached bug index 5757\n");
+		  }
+		  if ((!FIXREVERTER[5757] && (addr - memaddr < size ))
+		  #else
+		  if (0
+		  #endif
+		  )
 		    size = addr - memaddr;
+		    #ifdef FRCOV
+		    }
+		    #endif
 		  break;
 		}
+		#ifdef FRCOV
+		}
+		#endif
 	    }
 	  /* If the next symbol is after three bytes, we need to
 	     print only part of the data, so that we can use either
 	     .byte or .short.  */
-	  if (size == 3)
+	  
+	  #ifdef FRCOV
+	  {if (FIXREVERTER[5759]) {
+	    if ((size == 3 ) && !(0))
+	      fprintf(stderr, "triggered bug index 5759\n");
+	    else
+	      fprintf(stderr, "reached bug index 5759\n");
+	  }
+	  if ((!FIXREVERTER[5759] && (size == 3 ))
+	  #else
+	  if (0
+	  #endif
+	  )
 	    size = (memaddr & 1) ? 1 : 2;
+	    #ifdef FRCOV
+	    }
+	    #endif
 	}
     }
   info->bytes_per_line = 4;
diff --git a/opcodes/disassemble.c b/opcodes/disassemble.c
index 8590e94..606876d 100644
--- a/opcodes/disassemble.c
+++ b/opcodes/disassemble.c
@@ -1,3 +1,6 @@
+#ifdef FRCOV
+extern short FIXREVERTER[];
+#endif
 /* Select disassembly routine for specified architecture.
    Copyright (C) 1994-2021 Free Software Foundation, Inc.
 
@@ -598,8 +601,23 @@ disassembler_usage (FILE *stream ATTRIBUTE_UNUSED)
 void
 disassemble_init_for_target (struct disassemble_info * info)
 {
-  if (info == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[4976]) {
+    if ((info == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 4976\n");
+    else
+      fprintf(stderr, "reached bug index 4976\n");
+  }
+  if ((!FIXREVERTER[4976] && (info == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     return;
+    #ifdef FRCOV
+    }
+    #endif
 
   switch (info->arch)
     {
@@ -722,8 +740,23 @@ disassemble_init_for_target (struct disassemble_info * info)
 void
 disassemble_free_target (struct disassemble_info *info)
 {
-  if (info == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[4977]) {
+    if ((info == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 4977\n");
+    else
+      fprintf(stderr, "reached bug index 4977\n");
+  }
+  if ((!FIXREVERTER[4977] && (info == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     return;
+    #ifdef FRCOV
+    }
+    #endif
 
   switch (info->arch)
     {
diff --git a/opcodes/epiphany-desc.c b/opcodes/epiphany-desc.c
index b8f99aa..0d2d04c 100644
--- a/opcodes/epiphany-desc.c
+++ b/opcodes/epiphany-desc.c
@@ -1,3 +1,6 @@
+#ifdef FRCOV
+extern short FIXREVERTER[];
+#endif
 /* DO NOT EDIT!  -*- buffer-read-only: t -*- vi:set ro:  */
 /* CPU data for epiphany.
 
@@ -2088,10 +2091,40 @@ epiphany_cgen_rebuild_tables (CGEN_CPU_TABLE *cd)
 	  cd->base_insn_bitsize = CGEN_SIZE_UNKNOWN;
 
 	/* Set min,max insn sizes.  */
-	if (isa->min_insn_bitsize < cd->min_insn_bitsize)
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[5289]) {
+	  if ((isa -> min_insn_bitsize < cd -> min_insn_bitsize  ) && !(0))
+	    fprintf(stderr, "triggered bug index 5289\n");
+	  else
+	    fprintf(stderr, "reached bug index 5289\n");
+	}
+	if ((!FIXREVERTER[5289] && (isa -> min_insn_bitsize < cd -> min_insn_bitsize  ))
+	#else
+	if (0
+	#endif
+	)
 	  cd->min_insn_bitsize = isa->min_insn_bitsize;
-	if (isa->max_insn_bitsize > cd->max_insn_bitsize)
+	  #ifdef FRCOV
+	  }
+	  #endif
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[5290]) {
+	  if ((isa -> max_insn_bitsize > cd -> max_insn_bitsize  ) && !(0))
+	    fprintf(stderr, "triggered bug index 5290\n");
+	  else
+	    fprintf(stderr, "reached bug index 5290\n");
+	}
+	if ((!FIXREVERTER[5290] && (isa -> max_insn_bitsize > cd -> max_insn_bitsize  ))
+	#else
+	if (0
+	#endif
+	)
 	  cd->max_insn_bitsize = isa->max_insn_bitsize;
+	  #ifdef FRCOV
+	  }
+	  #endif
       }
 
   /* Data derived from the mach spec.  */
@@ -2102,8 +2135,23 @@ epiphany_cgen_rebuild_tables (CGEN_CPU_TABLE *cd)
 
 	if (mach->insn_chunk_bitsize != 0)
 	{
-	  if (cd->insn_chunk_bitsize != 0 && cd->insn_chunk_bitsize != mach->insn_chunk_bitsize)
+	  
+	  #ifdef FRCOV
+	  {if (FIXREVERTER[5291]) {
+	    fprintf(stderr, "reached bug index 5291\n");
+	  }
+	  if ((FIXREVERTER[5291] && (cd -> insn_chunk_bitsize != 0 )) || (!FIXREVERTER[5291] && (cd -> insn_chunk_bitsize != 0 && cd -> insn_chunk_bitsize != mach -> insn_chunk_bitsize ))
+	  #else
+	  if (cd -> insn_chunk_bitsize != 0 
+	  #endif
+	  )
 	    {
+	      
+	    #ifdef FRCOV
+	      if (!(cd -> insn_chunk_bitsize != mach -> insn_chunk_bitsize ))
+	        fprintf(stderr, "triggered bug index 5291\n");
+	      #endif
+	    
 	      opcodes_error_handler
 		(/* xgettext:c-format */
 		 _("internal error: epiphany_cgen_rebuild_tables: "
@@ -2111,6 +2159,9 @@ epiphany_cgen_rebuild_tables (CGEN_CPU_TABLE *cd)
 		 cd->insn_chunk_bitsize, mach->insn_chunk_bitsize);
 	      abort ();
 	    }
+	    #ifdef FRCOV
+	    }
+	    #endif
 
  	  cd->insn_chunk_bitsize = mach->insn_chunk_bitsize;
 	}
@@ -2204,8 +2255,23 @@ epiphany_cgen_cpu_open (enum cgen_cpu_open_arg arg_type, ...)
   va_end (ap);
 
   /* Mach unspecified means "all".  */
-  if (machs == 0)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[5293]) {
+    if ((machs == 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 5293\n");
+    else
+      fprintf(stderr, "reached bug index 5293\n");
+  }
+  if ((!FIXREVERTER[5293] && (machs == 0 ))
+  #else
+  if (0
+  #endif
+  )
     machs = (1 << MAX_MACHS) - 1;
+    #ifdef FRCOV
+    }
+    #endif
   /* Base mach is always selected.  */
   machs |= 1;
   if (endian == CGEN_ENDIAN_UNKNOWN)
diff --git a/opcodes/epiphany-dis.c b/opcodes/epiphany-dis.c
index a541377..94b48e3 100644
--- a/opcodes/epiphany-dis.c
+++ b/opcodes/epiphany-dis.c
@@ -1,3 +1,6 @@
+#ifdef FRCOV
+extern short FIXREVERTER[];
+#endif
 /* DO NOT EDIT!  -*- buffer-read-only: t -*- vi:set ro:  */
 /* Disassembler interface for targets using CGEN. -*- C -*-
    CGEN: Cpu tools GENerator
@@ -697,10 +700,40 @@ print_insn_epiphany (bfd_vma pc, disassemble_info *info)
      but if not possible try to move this hook elsewhere rather than
      have two hooks.  */
   length = CGEN_PRINT_INSN (cd, pc, info);
-  if (length > 0)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[11510]) {
+    if ((length > 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 11510\n");
+    else
+      fprintf(stderr, "reached bug index 11510\n");
+  }
+  if ((!FIXREVERTER[11510] && (length > 0 ))
+  #else
+  if (0
+  #endif
+  )
     return length;
-  if (length < 0)
+    #ifdef FRCOV
+    }
+    #endif
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[11511]) {
+    if ((length < 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 11511\n");
+    else
+      fprintf(stderr, "reached bug index 11511\n");
+  }
+  if ((!FIXREVERTER[11511] && (length < 0 ))
+  #else
+  if (0
+  #endif
+  )
     return -1;
+    #ifdef FRCOV
+    }
+    #endif
 
   (*info->fprintf_func) (info->stream, UNKNOWN_INSN_MSG);
   return cd->default_insn_bitsize / 8;
diff --git a/opcodes/fr30-desc.c b/opcodes/fr30-desc.c
index 1b062b3..13bc946 100644
--- a/opcodes/fr30-desc.c
+++ b/opcodes/fr30-desc.c
@@ -1,3 +1,6 @@
+#ifdef FRCOV
+extern short FIXREVERTER[];
+#endif
 /* DO NOT EDIT!  -*- buffer-read-only: t -*- vi:set ro:  */
 /* CPU data for fr30.
 
@@ -1565,10 +1568,40 @@ fr30_cgen_rebuild_tables (CGEN_CPU_TABLE *cd)
 	  cd->base_insn_bitsize = CGEN_SIZE_UNKNOWN;
 
 	/* Set min,max insn sizes.  */
-	if (isa->min_insn_bitsize < cd->min_insn_bitsize)
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[2653]) {
+	  if ((isa -> min_insn_bitsize < cd -> min_insn_bitsize  ) && !(0))
+	    fprintf(stderr, "triggered bug index 2653\n");
+	  else
+	    fprintf(stderr, "reached bug index 2653\n");
+	}
+	if ((!FIXREVERTER[2653] && (isa -> min_insn_bitsize < cd -> min_insn_bitsize  ))
+	#else
+	if (0
+	#endif
+	)
 	  cd->min_insn_bitsize = isa->min_insn_bitsize;
-	if (isa->max_insn_bitsize > cd->max_insn_bitsize)
+	  #ifdef FRCOV
+	  }
+	  #endif
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[2654]) {
+	  if ((isa -> max_insn_bitsize > cd -> max_insn_bitsize  ) && !(0))
+	    fprintf(stderr, "triggered bug index 2654\n");
+	  else
+	    fprintf(stderr, "reached bug index 2654\n");
+	}
+	if ((!FIXREVERTER[2654] && (isa -> max_insn_bitsize > cd -> max_insn_bitsize  ))
+	#else
+	if (0
+	#endif
+	)
 	  cd->max_insn_bitsize = isa->max_insn_bitsize;
+	  #ifdef FRCOV
+	  }
+	  #endif
       }
 
   /* Data derived from the mach spec.  */
@@ -1579,8 +1612,23 @@ fr30_cgen_rebuild_tables (CGEN_CPU_TABLE *cd)
 
 	if (mach->insn_chunk_bitsize != 0)
 	{
-	  if (cd->insn_chunk_bitsize != 0 && cd->insn_chunk_bitsize != mach->insn_chunk_bitsize)
+	  
+	  #ifdef FRCOV
+	  {if (FIXREVERTER[2655]) {
+	    fprintf(stderr, "reached bug index 2655\n");
+	  }
+	  if ((FIXREVERTER[2655] && (cd -> insn_chunk_bitsize != 0 )) || (!FIXREVERTER[2655] && (cd -> insn_chunk_bitsize != 0 && cd -> insn_chunk_bitsize != mach -> insn_chunk_bitsize ))
+	  #else
+	  if (cd -> insn_chunk_bitsize != 0 
+	  #endif
+	  )
 	    {
+	      
+	    #ifdef FRCOV
+	      if (!(cd -> insn_chunk_bitsize != mach -> insn_chunk_bitsize ))
+	        fprintf(stderr, "triggered bug index 2655\n");
+	      #endif
+	    
 	      opcodes_error_handler
 		(/* xgettext:c-format */
 		 _("internal error: fr30_cgen_rebuild_tables: "
@@ -1588,6 +1636,9 @@ fr30_cgen_rebuild_tables (CGEN_CPU_TABLE *cd)
 		 cd->insn_chunk_bitsize, mach->insn_chunk_bitsize);
 	      abort ();
 	    }
+	    #ifdef FRCOV
+	    }
+	    #endif
 
  	  cd->insn_chunk_bitsize = mach->insn_chunk_bitsize;
 	}
@@ -1681,8 +1732,23 @@ fr30_cgen_cpu_open (enum cgen_cpu_open_arg arg_type, ...)
   va_end (ap);
 
   /* Mach unspecified means "all".  */
-  if (machs == 0)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[2657]) {
+    if ((machs == 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 2657\n");
+    else
+      fprintf(stderr, "reached bug index 2657\n");
+  }
+  if ((!FIXREVERTER[2657] && (machs == 0 ))
+  #else
+  if (0
+  #endif
+  )
     machs = (1 << MAX_MACHS) - 1;
+    #ifdef FRCOV
+    }
+    #endif
   /* Base mach is always selected.  */
   machs |= 1;
   if (endian == CGEN_ENDIAN_UNKNOWN)
diff --git a/opcodes/fr30-dis.c b/opcodes/fr30-dis.c
index abf9073..dbcf132 100644
--- a/opcodes/fr30-dis.c
+++ b/opcodes/fr30-dis.c
@@ -1,3 +1,6 @@
+#ifdef FRCOV
+extern short FIXREVERTER[];
+#endif
 /* DO NOT EDIT!  -*- buffer-read-only: t -*- vi:set ro:  */
 /* Disassembler interface for targets using CGEN. -*- C -*-
    CGEN: Cpu tools GENerator
@@ -718,10 +721,40 @@ print_insn_fr30 (bfd_vma pc, disassemble_info *info)
      but if not possible try to move this hook elsewhere rather than
      have two hooks.  */
   length = CGEN_PRINT_INSN (cd, pc, info);
-  if (length > 0)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[5308]) {
+    if ((length > 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 5308\n");
+    else
+      fprintf(stderr, "reached bug index 5308\n");
+  }
+  if ((!FIXREVERTER[5308] && (length > 0 ))
+  #else
+  if (0
+  #endif
+  )
     return length;
-  if (length < 0)
+    #ifdef FRCOV
+    }
+    #endif
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[5309]) {
+    if ((length < 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 5309\n");
+    else
+      fprintf(stderr, "reached bug index 5309\n");
+  }
+  if ((!FIXREVERTER[5309] && (length < 0 ))
+  #else
+  if (0
+  #endif
+  )
     return -1;
+    #ifdef FRCOV
+    }
+    #endif
 
   (*info->fprintf_func) (info->stream, UNKNOWN_INSN_MSG);
   return cd->default_insn_bitsize / 8;
diff --git a/opcodes/frv-desc.c b/opcodes/frv-desc.c
index 82025aa..2ec426f 100644
--- a/opcodes/frv-desc.c
+++ b/opcodes/frv-desc.c
@@ -1,3 +1,6 @@
+#ifdef FRCOV
+extern short FIXREVERTER[];
+#endif
 /* DO NOT EDIT!  -*- buffer-read-only: t -*- vi:set ro:  */
 /* CPU data for frv.
 
@@ -6305,10 +6308,40 @@ frv_cgen_rebuild_tables (CGEN_CPU_TABLE *cd)
 	  cd->base_insn_bitsize = CGEN_SIZE_UNKNOWN;
 
 	/* Set min,max insn sizes.  */
-	if (isa->min_insn_bitsize < cd->min_insn_bitsize)
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[11804]) {
+	  if ((isa -> min_insn_bitsize < cd -> min_insn_bitsize  ) && !(0))
+	    fprintf(stderr, "triggered bug index 11804\n");
+	  else
+	    fprintf(stderr, "reached bug index 11804\n");
+	}
+	if ((!FIXREVERTER[11804] && (isa -> min_insn_bitsize < cd -> min_insn_bitsize  ))
+	#else
+	if (0
+	#endif
+	)
 	  cd->min_insn_bitsize = isa->min_insn_bitsize;
-	if (isa->max_insn_bitsize > cd->max_insn_bitsize)
+	  #ifdef FRCOV
+	  }
+	  #endif
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[11805]) {
+	  if ((isa -> max_insn_bitsize > cd -> max_insn_bitsize  ) && !(0))
+	    fprintf(stderr, "triggered bug index 11805\n");
+	  else
+	    fprintf(stderr, "reached bug index 11805\n");
+	}
+	if ((!FIXREVERTER[11805] && (isa -> max_insn_bitsize > cd -> max_insn_bitsize  ))
+	#else
+	if (0
+	#endif
+	)
 	  cd->max_insn_bitsize = isa->max_insn_bitsize;
+	  #ifdef FRCOV
+	  }
+	  #endif
       }
 
   /* Data derived from the mach spec.  */
@@ -6319,8 +6352,23 @@ frv_cgen_rebuild_tables (CGEN_CPU_TABLE *cd)
 
 	if (mach->insn_chunk_bitsize != 0)
 	{
-	  if (cd->insn_chunk_bitsize != 0 && cd->insn_chunk_bitsize != mach->insn_chunk_bitsize)
+	  
+	  #ifdef FRCOV
+	  {if (FIXREVERTER[11806]) {
+	    fprintf(stderr, "reached bug index 11806\n");
+	  }
+	  if ((FIXREVERTER[11806] && (cd -> insn_chunk_bitsize != 0 )) || (!FIXREVERTER[11806] && (cd -> insn_chunk_bitsize != 0 && cd -> insn_chunk_bitsize != mach -> insn_chunk_bitsize ))
+	  #else
+	  if (cd -> insn_chunk_bitsize != 0 
+	  #endif
+	  )
 	    {
+	      
+	    #ifdef FRCOV
+	      if (!(cd -> insn_chunk_bitsize != mach -> insn_chunk_bitsize ))
+	        fprintf(stderr, "triggered bug index 11806\n");
+	      #endif
+	    
 	      opcodes_error_handler
 		(/* xgettext:c-format */
 		 _("internal error: frv_cgen_rebuild_tables: "
@@ -6328,6 +6376,9 @@ frv_cgen_rebuild_tables (CGEN_CPU_TABLE *cd)
 		 cd->insn_chunk_bitsize, mach->insn_chunk_bitsize);
 	      abort ();
 	    }
+	    #ifdef FRCOV
+	    }
+	    #endif
 
  	  cd->insn_chunk_bitsize = mach->insn_chunk_bitsize;
 	}
@@ -6421,8 +6472,23 @@ frv_cgen_cpu_open (enum cgen_cpu_open_arg arg_type, ...)
   va_end (ap);
 
   /* Mach unspecified means "all".  */
-  if (machs == 0)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[11808]) {
+    if ((machs == 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 11808\n");
+    else
+      fprintf(stderr, "reached bug index 11808\n");
+  }
+  if ((!FIXREVERTER[11808] && (machs == 0 ))
+  #else
+  if (0
+  #endif
+  )
     machs = (1 << MAX_MACHS) - 1;
+    #ifdef FRCOV
+    }
+    #endif
   /* Base mach is always selected.  */
   machs |= 1;
   if (endian == CGEN_ENDIAN_UNKNOWN)
diff --git a/opcodes/frv-dis.c b/opcodes/frv-dis.c
index 9601ee7..c498304 100644
--- a/opcodes/frv-dis.c
+++ b/opcodes/frv-dis.c
@@ -1,3 +1,6 @@
+#ifdef FRCOV
+extern short FIXREVERTER[];
+#endif
 /* DO NOT EDIT!  -*- buffer-read-only: t -*- vi:set ro:  */
 /* Disassembler interface for targets using CGEN. -*- C -*-
    CGEN: Cpu tools GENerator
@@ -815,10 +818,40 @@ print_insn_frv (bfd_vma pc, disassemble_info *info)
      but if not possible try to move this hook elsewhere rather than
      have two hooks.  */
   length = CGEN_PRINT_INSN (cd, pc, info);
-  if (length > 0)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[1441]) {
+    if ((length > 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 1441\n");
+    else
+      fprintf(stderr, "reached bug index 1441\n");
+  }
+  if ((!FIXREVERTER[1441] && (length > 0 ))
+  #else
+  if (0
+  #endif
+  )
     return length;
-  if (length < 0)
+    #ifdef FRCOV
+    }
+    #endif
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[1442]) {
+    if ((length < 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 1442\n");
+    else
+      fprintf(stderr, "reached bug index 1442\n");
+  }
+  if ((!FIXREVERTER[1442] && (length < 0 ))
+  #else
+  if (0
+  #endif
+  )
     return -1;
+    #ifdef FRCOV
+    }
+    #endif
 
   (*info->fprintf_func) (info->stream, UNKNOWN_INSN_MSG);
   return cd->default_insn_bitsize / 8;
diff --git a/opcodes/i386-dis.c b/opcodes/i386-dis.c
index 21e4085..f11162d 100644
--- a/opcodes/i386-dis.c
+++ b/opcodes/i386-dis.c
@@ -1,3 +1,6 @@
+#ifdef FRCOV
+extern short FIXREVERTER[];
+#endif
 /* Print i386 instructions for GDB, the GNU debugger.
    Copyright (C) 1988-2021 Free Software Foundation, Inc.
 
@@ -9563,7 +9566,19 @@ print_insn (bfd_vma pc, disassemble_info *info)
       /* Getting here means we tried for data but didn't get it.  That
 	 means we have an incomplete instruction of some sort.  Just
 	 print the first byte as a prefix or a .byte pseudo-op.  */
-      if (codep > priv.the_buffer)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[68]) {
+        if ((codep > priv . the_buffer ) && !(0))
+          fprintf(stderr, "triggered bug index 68\n");
+        else
+          fprintf(stderr, "reached bug index 68\n");
+      }
+      if ((!FIXREVERTER[68] && (codep > priv . the_buffer ))
+      #else
+      if (0
+      #endif
+      )
 	{
 	  name = prefix_name (priv.the_buffer[0], priv.orig_sizeflag);
 	  if (name != NULL)
@@ -9577,6 +9592,9 @@ print_insn (bfd_vma pc, disassemble_info *info)
 
 	  return 1;
 	}
+	#ifdef FRCOV
+	}
+	#endif
 
       return -1;
     }
@@ -10326,13 +10344,28 @@ putop (const char *in_template, int sizeflag)
 
   for (p = in_template; *p; p++)
     {
-      if (len > l)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[72]) {
+        if ((len > l ) && !(0))
+          fprintf(stderr, "triggered bug index 72\n");
+        else
+          fprintf(stderr, "reached bug index 72\n");
+      }
+      if ((!FIXREVERTER[72] && (len > l ))
+      #else
+      if (0
+      #endif
+      )
 	{
 	  if (l >= sizeof (last) || !ISUPPER (*p))
 	    abort ();
 	  last[l++] = *p;
 	  continue;
 	}
+	#ifdef FRCOV
+	}
+	#endif
       switch (*p)
 	{
 	default:
@@ -10888,11 +10921,26 @@ print_operand_value (char *buf, int hex, bfd_vma disp)
 	      *(buf++) = '-';
 	      v = -disp;
 	      /* Check for possible overflow on 0x8000000000000000.  */
-	      if (v < 0)
+	      
+	      #ifdef FRCOV
+	      {if (FIXREVERTER[76]) {
+	        if ((v < 0 ) && !(0))
+	          fprintf(stderr, "triggered bug index 76\n");
+	        else
+	          fprintf(stderr, "reached bug index 76\n");
+	      }
+	      if ((!FIXREVERTER[76] && (v < 0 ))
+	      #else
+	      if (0
+	      #endif
+	      )
 		{
 		  strcpy (buf, "9223372036854775808");
 		  return;
 		}
+		#ifdef FRCOV
+		}
+		#endif
 	    }
 	  if (!v)
 	    {
@@ -11338,11 +11386,26 @@ OP_E_register (int bytemode, int sizeflag)
       break;
     case bnd_mode:
     case bnd_swap_mode:
-      if (reg > 0x3)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[79]) {
+        if ((reg > 3 ) && !(0))
+          fprintf(stderr, "triggered bug index 79\n");
+        else
+          fprintf(stderr, "reached bug index 79\n");
+      }
+      if ((!FIXREVERTER[79] && (reg > 3 ))
+      #else
+      if (0
+      #endif
+      )
 	{
 	  oappend ("(bad)");
 	  return;
 	}
+	#ifdef FRCOV
+	}
+	#endif
       names = names_bnd;
       break;
     case indir_v_mode:
@@ -11404,11 +11467,26 @@ OP_E_register (int bytemode, int sizeflag)
       break;
     case mask_bd_mode:
     case mask_mode:
-      if (reg > 0x7)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[80]) {
+        if ((reg > 7 ) && !(0))
+          fprintf(stderr, "triggered bug index 80\n");
+        else
+          fprintf(stderr, "reached bug index 80\n");
+      }
+      if ((!FIXREVERTER[80] && (reg > 7 ))
+      #else
+      if (0
+      #endif
+      )
 	{
 	  oappend ("(bad)");
 	  return;
 	}
+	#ifdef FRCOV
+	}
+	#endif
       names = names_mask;
       break;
     case 0:
@@ -12017,11 +12095,26 @@ OP_G (int bytemode, int sizeflag)
       break;
     case mask_bd_mode:
     case mask_mode:
-      if ((modrm.reg + add) > 0x7)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[84]) {
+        if ((modrm . reg + add > 7 ) && !(0))
+          fprintf(stderr, "triggered bug index 84\n");
+        else
+          fprintf(stderr, "reached bug index 84\n");
+      }
+      if ((!FIXREVERTER[84] && (modrm . reg + add > 7 ))
+      #else
+      if (0
+      #endif
+      )
 	{
 	  oappend ("(bad)");
 	  return;
 	}
+	#ifdef FRCOV
+	}
+	#endif
       oappend (names_mask[modrm.reg + add]);
       break;
     default:
@@ -12654,11 +12747,26 @@ OP_XMM (int bytemode, int sizeflag ATTRIBUTE_UNUSED)
   else if (bytemode == tmm_mode)
     {
       modrm.reg = reg;
-      if (reg >= 8)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[85]) {
+        if ((reg >= 8 ) && !(0))
+          fprintf(stderr, "triggered bug index 85\n");
+        else
+          fprintf(stderr, "reached bug index 85\n");
+      }
+      if ((!FIXREVERTER[85] && (reg >= 8 ))
+      #else
+      if (0
+      #endif
+      )
 	{
 	  oappend ("(bad)");
 	  return;
 	}
+	#ifdef FRCOV
+	}
+	#endif
       names = names_tmm;
     }
   else if (need_vex
@@ -12845,11 +12953,26 @@ OP_EX (int bytemode, int sizeflag)
   else if (bytemode == tmm_mode)
     {
       modrm.rm = reg;
-      if (reg >= 8)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[89]) {
+        if ((reg >= 8 ) && !(0))
+          fprintf(stderr, "triggered bug index 89\n");
+        else
+          fprintf(stderr, "reached bug index 89\n");
+      }
+      if ((!FIXREVERTER[89] && (reg >= 8 ))
+      #else
+      if (0
+      #endif
+      )
 	{
 	  oappend ("(bad)");
 	  return;
 	}
+	#ifdef FRCOV
+	}
+	#endif
       names = names_tmm;
     }
   else if (bytemode == ymm_mode)
@@ -13431,11 +13554,26 @@ OP_VEX (int bytemode, int sizeflag ATTRIBUTE_UNUSED)
 	  break;
 	case mask_bd_mode:
 	case mask_mode:
-	  if (reg > 0x7)
+	  
+	  #ifdef FRCOV
+	  {if (FIXREVERTER[94]) {
+	    if ((reg > 7 ) && !(0))
+	      fprintf(stderr, "triggered bug index 94\n");
+	    else
+	      fprintf(stderr, "reached bug index 94\n");
+	  }
+	  if ((!FIXREVERTER[94] && (reg > 7 ))
+	  #else
+	  if (0
+	  #endif
+	  )
 	    {
 	      oappend ("(bad)");
 	      return;
 	    }
+	    #ifdef FRCOV
+	    }
+	    #endif
 	  names = names_mask;
 	  break;
 	default:
@@ -13451,11 +13589,26 @@ OP_VEX (int bytemode, int sizeflag ATTRIBUTE_UNUSED)
 	  break;
 	case mask_bd_mode:
 	case mask_mode:
-	  if (reg > 0x7)
+	  
+	  #ifdef FRCOV
+	  {if (FIXREVERTER[95]) {
+	    if ((reg > 7 ) && !(0))
+	      fprintf(stderr, "triggered bug index 95\n");
+	    else
+	      fprintf(stderr, "reached bug index 95\n");
+	  }
+	  if ((!FIXREVERTER[95] && (reg > 7 ))
+	  #else
+	  if (0
+	  #endif
+	  )
 	    {
 	      oappend ("(bad)");
 	      return;
 	    }
+	    #ifdef FRCOV
+	    }
+	    #endif
 	  names = names_mask;
 	  break;
 	default:
diff --git a/opcodes/ia64-dis.c b/opcodes/ia64-dis.c
index d92912f..db64f45 100644
--- a/opcodes/ia64-dis.c
+++ b/opcodes/ia64-dis.c
@@ -1,3 +1,6 @@
+#ifdef FRCOV
+extern short FIXREVERTER[];
+#endif
 /* ia64-dis.c -- Disassemble ia64 instructions
    Copyright (C) 1998-2021 Free Software Foundation, Inc.
    Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
@@ -78,8 +81,23 @@ print_insn_ia64 (bfd_vma memaddr, struct disassemble_info *info)
   enum ia64_unit unit;
   char regname[16];
 
-  if (info->bytes_per_line == 0)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[6607]) {
+    if ((info -> bytes_per_line == 0  ) && !(0))
+      fprintf(stderr, "triggered bug index 6607\n");
+    else
+      fprintf(stderr, "reached bug index 6607\n");
+  }
+  if ((!FIXREVERTER[6607] && (info -> bytes_per_line == 0  ))
+  #else
+  if (0
+  #endif
+  )
     info->bytes_per_line = 6;
+    #ifdef FRCOV
+    }
+    #endif
   info->display_endian = info->endian;
 
   slot_multiplier = info->bytes_per_line;
@@ -126,8 +144,23 @@ print_insn_ia64 (bfd_vma memaddr, struct disassemble_info *info)
     goto decoding_failed;
 
   idesc = ia64_dis_opcode (insn, unit_to_type (insn, unit));
-  if (idesc == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[6611]) {
+    if ((idesc == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 6611\n");
+    else
+      fprintf(stderr, "reached bug index 6611\n");
+  }
+  if ((!FIXREVERTER[6611] && (idesc == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     goto decoding_failed;
+    #ifdef FRCOV
+    }
+    #endif
 
   /* print predicate, if any: */
 
diff --git a/opcodes/ip2k-desc.c b/opcodes/ip2k-desc.c
index 6592234..4529f85 100644
--- a/opcodes/ip2k-desc.c
+++ b/opcodes/ip2k-desc.c
@@ -1,3 +1,6 @@
+#ifdef FRCOV
+extern short FIXREVERTER[];
+#endif
 /* DO NOT EDIT!  -*- buffer-read-only: t -*- vi:set ro:  */
 /* CPU data for ip2k.
 
@@ -994,10 +997,40 @@ ip2k_cgen_rebuild_tables (CGEN_CPU_TABLE *cd)
 	  cd->base_insn_bitsize = CGEN_SIZE_UNKNOWN;
 
 	/* Set min,max insn sizes.  */
-	if (isa->min_insn_bitsize < cd->min_insn_bitsize)
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[1428]) {
+	  if ((isa -> min_insn_bitsize < cd -> min_insn_bitsize  ) && !(0))
+	    fprintf(stderr, "triggered bug index 1428\n");
+	  else
+	    fprintf(stderr, "reached bug index 1428\n");
+	}
+	if ((!FIXREVERTER[1428] && (isa -> min_insn_bitsize < cd -> min_insn_bitsize  ))
+	#else
+	if (0
+	#endif
+	)
 	  cd->min_insn_bitsize = isa->min_insn_bitsize;
-	if (isa->max_insn_bitsize > cd->max_insn_bitsize)
+	  #ifdef FRCOV
+	  }
+	  #endif
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[1429]) {
+	  if ((isa -> max_insn_bitsize > cd -> max_insn_bitsize  ) && !(0))
+	    fprintf(stderr, "triggered bug index 1429\n");
+	  else
+	    fprintf(stderr, "reached bug index 1429\n");
+	}
+	if ((!FIXREVERTER[1429] && (isa -> max_insn_bitsize > cd -> max_insn_bitsize  ))
+	#else
+	if (0
+	#endif
+	)
 	  cd->max_insn_bitsize = isa->max_insn_bitsize;
+	  #ifdef FRCOV
+	  }
+	  #endif
       }
 
   /* Data derived from the mach spec.  */
@@ -1008,8 +1041,23 @@ ip2k_cgen_rebuild_tables (CGEN_CPU_TABLE *cd)
 
 	if (mach->insn_chunk_bitsize != 0)
 	{
-	  if (cd->insn_chunk_bitsize != 0 && cd->insn_chunk_bitsize != mach->insn_chunk_bitsize)
+	  
+	  #ifdef FRCOV
+	  {if (FIXREVERTER[1430]) {
+	    fprintf(stderr, "reached bug index 1430\n");
+	  }
+	  if ((FIXREVERTER[1430] && (cd -> insn_chunk_bitsize != 0 )) || (!FIXREVERTER[1430] && (cd -> insn_chunk_bitsize != 0 && cd -> insn_chunk_bitsize != mach -> insn_chunk_bitsize ))
+	  #else
+	  if (cd -> insn_chunk_bitsize != 0 
+	  #endif
+	  )
 	    {
+	      
+	    #ifdef FRCOV
+	      if (!(cd -> insn_chunk_bitsize != mach -> insn_chunk_bitsize ))
+	        fprintf(stderr, "triggered bug index 1430\n");
+	      #endif
+	    
 	      opcodes_error_handler
 		(/* xgettext:c-format */
 		 _("internal error: ip2k_cgen_rebuild_tables: "
@@ -1017,6 +1065,9 @@ ip2k_cgen_rebuild_tables (CGEN_CPU_TABLE *cd)
 		 cd->insn_chunk_bitsize, mach->insn_chunk_bitsize);
 	      abort ();
 	    }
+	    #ifdef FRCOV
+	    }
+	    #endif
 
  	  cd->insn_chunk_bitsize = mach->insn_chunk_bitsize;
 	}
@@ -1110,8 +1161,23 @@ ip2k_cgen_cpu_open (enum cgen_cpu_open_arg arg_type, ...)
   va_end (ap);
 
   /* Mach unspecified means "all".  */
-  if (machs == 0)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[1432]) {
+    if ((machs == 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 1432\n");
+    else
+      fprintf(stderr, "reached bug index 1432\n");
+  }
+  if ((!FIXREVERTER[1432] && (machs == 0 ))
+  #else
+  if (0
+  #endif
+  )
     machs = (1 << MAX_MACHS) - 1;
+    #ifdef FRCOV
+    }
+    #endif
   /* Base mach is always selected.  */
   machs |= 1;
   if (endian == CGEN_ENDIAN_UNKNOWN)
diff --git a/opcodes/ip2k-dis.c b/opcodes/ip2k-dis.c
index fa40cde..2fc339f 100644
--- a/opcodes/ip2k-dis.c
+++ b/opcodes/ip2k-dis.c
@@ -1,3 +1,6 @@
+#ifdef FRCOV
+extern short FIXREVERTER[];
+#endif
 /* DO NOT EDIT!  -*- buffer-read-only: t -*- vi:set ro:  */
 /* Disassembler interface for targets using CGEN. -*- C -*-
    CGEN: Cpu tools GENerator
@@ -707,10 +710,40 @@ print_insn_ip2k (bfd_vma pc, disassemble_info *info)
      but if not possible try to move this hook elsewhere rather than
      have two hooks.  */
   length = CGEN_PRINT_INSN (cd, pc, info);
-  if (length > 0)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[12252]) {
+    if ((length > 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 12252\n");
+    else
+      fprintf(stderr, "reached bug index 12252\n");
+  }
+  if ((!FIXREVERTER[12252] && (length > 0 ))
+  #else
+  if (0
+  #endif
+  )
     return length;
-  if (length < 0)
+    #ifdef FRCOV
+    }
+    #endif
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[12253]) {
+    if ((length < 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 12253\n");
+    else
+      fprintf(stderr, "reached bug index 12253\n");
+  }
+  if ((!FIXREVERTER[12253] && (length < 0 ))
+  #else
+  if (0
+  #endif
+  )
     return -1;
+    #ifdef FRCOV
+    }
+    #endif
 
   (*info->fprintf_func) (info->stream, UNKNOWN_INSN_MSG);
   return cd->default_insn_bitsize / 8;
diff --git a/opcodes/iq2000-desc.c b/opcodes/iq2000-desc.c
index 704e20a..6c4c9be 100644
--- a/opcodes/iq2000-desc.c
+++ b/opcodes/iq2000-desc.c
@@ -1,3 +1,6 @@
+#ifdef FRCOV
+extern short FIXREVERTER[];
+#endif
 /* DO NOT EDIT!  -*- buffer-read-only: t -*- vi:set ro:  */
 /* CPU data for iq2000.
 
@@ -1999,10 +2002,40 @@ iq2000_cgen_rebuild_tables (CGEN_CPU_TABLE *cd)
 	  cd->base_insn_bitsize = CGEN_SIZE_UNKNOWN;
 
 	/* Set min,max insn sizes.  */
-	if (isa->min_insn_bitsize < cd->min_insn_bitsize)
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[7879]) {
+	  if ((isa -> min_insn_bitsize < cd -> min_insn_bitsize  ) && !(0))
+	    fprintf(stderr, "triggered bug index 7879\n");
+	  else
+	    fprintf(stderr, "reached bug index 7879\n");
+	}
+	if ((!FIXREVERTER[7879] && (isa -> min_insn_bitsize < cd -> min_insn_bitsize  ))
+	#else
+	if (0
+	#endif
+	)
 	  cd->min_insn_bitsize = isa->min_insn_bitsize;
-	if (isa->max_insn_bitsize > cd->max_insn_bitsize)
+	  #ifdef FRCOV
+	  }
+	  #endif
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[7880]) {
+	  if ((isa -> max_insn_bitsize > cd -> max_insn_bitsize  ) && !(0))
+	    fprintf(stderr, "triggered bug index 7880\n");
+	  else
+	    fprintf(stderr, "reached bug index 7880\n");
+	}
+	if ((!FIXREVERTER[7880] && (isa -> max_insn_bitsize > cd -> max_insn_bitsize  ))
+	#else
+	if (0
+	#endif
+	)
 	  cd->max_insn_bitsize = isa->max_insn_bitsize;
+	  #ifdef FRCOV
+	  }
+	  #endif
       }
 
   /* Data derived from the mach spec.  */
@@ -2013,8 +2046,23 @@ iq2000_cgen_rebuild_tables (CGEN_CPU_TABLE *cd)
 
 	if (mach->insn_chunk_bitsize != 0)
 	{
-	  if (cd->insn_chunk_bitsize != 0 && cd->insn_chunk_bitsize != mach->insn_chunk_bitsize)
+	  
+	  #ifdef FRCOV
+	  {if (FIXREVERTER[7881]) {
+	    fprintf(stderr, "reached bug index 7881\n");
+	  }
+	  if ((FIXREVERTER[7881] && (cd -> insn_chunk_bitsize != 0 )) || (!FIXREVERTER[7881] && (cd -> insn_chunk_bitsize != 0 && cd -> insn_chunk_bitsize != mach -> insn_chunk_bitsize ))
+	  #else
+	  if (cd -> insn_chunk_bitsize != 0 
+	  #endif
+	  )
 	    {
+	      
+	    #ifdef FRCOV
+	      if (!(cd -> insn_chunk_bitsize != mach -> insn_chunk_bitsize ))
+	        fprintf(stderr, "triggered bug index 7881\n");
+	      #endif
+	    
 	      opcodes_error_handler
 		(/* xgettext:c-format */
 		 _("internal error: iq2000_cgen_rebuild_tables: "
@@ -2022,6 +2070,9 @@ iq2000_cgen_rebuild_tables (CGEN_CPU_TABLE *cd)
 		 cd->insn_chunk_bitsize, mach->insn_chunk_bitsize);
 	      abort ();
 	    }
+	    #ifdef FRCOV
+	    }
+	    #endif
 
  	  cd->insn_chunk_bitsize = mach->insn_chunk_bitsize;
 	}
@@ -2115,8 +2166,23 @@ iq2000_cgen_cpu_open (enum cgen_cpu_open_arg arg_type, ...)
   va_end (ap);
 
   /* Mach unspecified means "all".  */
-  if (machs == 0)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[7883]) {
+    if ((machs == 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 7883\n");
+    else
+      fprintf(stderr, "reached bug index 7883\n");
+  }
+  if ((!FIXREVERTER[7883] && (machs == 0 ))
+  #else
+  if (0
+  #endif
+  )
     machs = (1 << MAX_MACHS) - 1;
+    #ifdef FRCOV
+    }
+    #endif
   /* Base mach is always selected.  */
   machs |= 1;
   if (endian == CGEN_ENDIAN_UNKNOWN)
diff --git a/opcodes/iq2000-dis.c b/opcodes/iq2000-dis.c
index e2f2af9..ee9345e 100644
--- a/opcodes/iq2000-dis.c
+++ b/opcodes/iq2000-dis.c
@@ -1,3 +1,6 @@
+#ifdef FRCOV
+extern short FIXREVERTER[];
+#endif
 /* DO NOT EDIT!  -*- buffer-read-only: t -*- vi:set ro:  */
 /* Disassembler interface for targets using CGEN. -*- C -*-
    CGEN: Cpu tools GENerator
@@ -608,10 +611,40 @@ print_insn_iq2000 (bfd_vma pc, disassemble_info *info)
      but if not possible try to move this hook elsewhere rather than
      have two hooks.  */
   length = CGEN_PRINT_INSN (cd, pc, info);
-  if (length > 0)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[500]) {
+    if ((length > 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 500\n");
+    else
+      fprintf(stderr, "reached bug index 500\n");
+  }
+  if ((!FIXREVERTER[500] && (length > 0 ))
+  #else
+  if (0
+  #endif
+  )
     return length;
-  if (length < 0)
+    #ifdef FRCOV
+    }
+    #endif
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[501]) {
+    if ((length < 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 501\n");
+    else
+      fprintf(stderr, "reached bug index 501\n");
+  }
+  if ((!FIXREVERTER[501] && (length < 0 ))
+  #else
+  if (0
+  #endif
+  )
     return -1;
+    #ifdef FRCOV
+    }
+    #endif
 
   (*info->fprintf_func) (info->stream, UNKNOWN_INSN_MSG);
   return cd->default_insn_bitsize / 8;
diff --git a/opcodes/lm32-desc.c b/opcodes/lm32-desc.c
index 02424f0..c0306d9 100644
--- a/opcodes/lm32-desc.c
+++ b/opcodes/lm32-desc.c
@@ -1,3 +1,6 @@
+#ifdef FRCOV
+extern short FIXREVERTER[];
+#endif
 /* DO NOT EDIT!  -*- buffer-read-only: t -*- vi:set ro:  */
 /* CPU data for lm32.
 
@@ -981,10 +984,40 @@ lm32_cgen_rebuild_tables (CGEN_CPU_TABLE *cd)
 	  cd->base_insn_bitsize = CGEN_SIZE_UNKNOWN;
 
 	/* Set min,max insn sizes.  */
-	if (isa->min_insn_bitsize < cd->min_insn_bitsize)
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[8500]) {
+	  if ((isa -> min_insn_bitsize < cd -> min_insn_bitsize  ) && !(0))
+	    fprintf(stderr, "triggered bug index 8500\n");
+	  else
+	    fprintf(stderr, "reached bug index 8500\n");
+	}
+	if ((!FIXREVERTER[8500] && (isa -> min_insn_bitsize < cd -> min_insn_bitsize  ))
+	#else
+	if (0
+	#endif
+	)
 	  cd->min_insn_bitsize = isa->min_insn_bitsize;
-	if (isa->max_insn_bitsize > cd->max_insn_bitsize)
+	  #ifdef FRCOV
+	  }
+	  #endif
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[8501]) {
+	  if ((isa -> max_insn_bitsize > cd -> max_insn_bitsize  ) && !(0))
+	    fprintf(stderr, "triggered bug index 8501\n");
+	  else
+	    fprintf(stderr, "reached bug index 8501\n");
+	}
+	if ((!FIXREVERTER[8501] && (isa -> max_insn_bitsize > cd -> max_insn_bitsize  ))
+	#else
+	if (0
+	#endif
+	)
 	  cd->max_insn_bitsize = isa->max_insn_bitsize;
+	  #ifdef FRCOV
+	  }
+	  #endif
       }
 
   /* Data derived from the mach spec.  */
@@ -995,8 +1028,23 @@ lm32_cgen_rebuild_tables (CGEN_CPU_TABLE *cd)
 
 	if (mach->insn_chunk_bitsize != 0)
 	{
-	  if (cd->insn_chunk_bitsize != 0 && cd->insn_chunk_bitsize != mach->insn_chunk_bitsize)
+	  
+	  #ifdef FRCOV
+	  {if (FIXREVERTER[8502]) {
+	    fprintf(stderr, "reached bug index 8502\n");
+	  }
+	  if ((FIXREVERTER[8502] && (cd -> insn_chunk_bitsize != 0 )) || (!FIXREVERTER[8502] && (cd -> insn_chunk_bitsize != 0 && cd -> insn_chunk_bitsize != mach -> insn_chunk_bitsize ))
+	  #else
+	  if (cd -> insn_chunk_bitsize != 0 
+	  #endif
+	  )
 	    {
+	      
+	    #ifdef FRCOV
+	      if (!(cd -> insn_chunk_bitsize != mach -> insn_chunk_bitsize ))
+	        fprintf(stderr, "triggered bug index 8502\n");
+	      #endif
+	    
 	      opcodes_error_handler
 		(/* xgettext:c-format */
 		 _("internal error: lm32_cgen_rebuild_tables: "
@@ -1004,6 +1052,9 @@ lm32_cgen_rebuild_tables (CGEN_CPU_TABLE *cd)
 		 cd->insn_chunk_bitsize, mach->insn_chunk_bitsize);
 	      abort ();
 	    }
+	    #ifdef FRCOV
+	    }
+	    #endif
 
  	  cd->insn_chunk_bitsize = mach->insn_chunk_bitsize;
 	}
@@ -1097,8 +1148,23 @@ lm32_cgen_cpu_open (enum cgen_cpu_open_arg arg_type, ...)
   va_end (ap);
 
   /* Mach unspecified means "all".  */
-  if (machs == 0)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[8504]) {
+    if ((machs == 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 8504\n");
+    else
+      fprintf(stderr, "reached bug index 8504\n");
+  }
+  if ((!FIXREVERTER[8504] && (machs == 0 ))
+  #else
+  if (0
+  #endif
+  )
     machs = (1 << MAX_MACHS) - 1;
+    #ifdef FRCOV
+    }
+    #endif
   /* Base mach is always selected.  */
   machs |= 1;
   if (endian == CGEN_ENDIAN_UNKNOWN)
diff --git a/opcodes/lm32-dis.c b/opcodes/lm32-dis.c
index 266079e..a7d8043 100644
--- a/opcodes/lm32-dis.c
+++ b/opcodes/lm32-dis.c
@@ -1,3 +1,6 @@
+#ifdef FRCOV
+extern short FIXREVERTER[];
+#endif
 /* DO NOT EDIT!  -*- buffer-read-only: t -*- vi:set ro:  */
 /* Disassembler interface for targets using CGEN. -*- C -*-
    CGEN: Cpu tools GENerator
@@ -566,10 +569,40 @@ print_insn_lm32 (bfd_vma pc, disassemble_info *info)
      but if not possible try to move this hook elsewhere rather than
      have two hooks.  */
   length = CGEN_PRINT_INSN (cd, pc, info);
-  if (length > 0)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[1223]) {
+    if ((length > 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 1223\n");
+    else
+      fprintf(stderr, "reached bug index 1223\n");
+  }
+  if ((!FIXREVERTER[1223] && (length > 0 ))
+  #else
+  if (0
+  #endif
+  )
     return length;
-  if (length < 0)
+    #ifdef FRCOV
+    }
+    #endif
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[1224]) {
+    if ((length < 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 1224\n");
+    else
+      fprintf(stderr, "reached bug index 1224\n");
+  }
+  if ((!FIXREVERTER[1224] && (length < 0 ))
+  #else
+  if (0
+  #endif
+  )
     return -1;
+    #ifdef FRCOV
+    }
+    #endif
 
   (*info->fprintf_func) (info->stream, UNKNOWN_INSN_MSG);
   return cd->default_insn_bitsize / 8;
diff --git a/opcodes/m32c-desc.c b/opcodes/m32c-desc.c
index 2764a82..47f2d33 100644
--- a/opcodes/m32c-desc.c
+++ b/opcodes/m32c-desc.c
@@ -1,3 +1,6 @@
+#ifdef FRCOV
+extern short FIXREVERTER[];
+#endif
 /* DO NOT EDIT!  -*- buffer-read-only: t -*- vi:set ro:  */
 /* CPU data for m32c.
 
@@ -63012,10 +63015,40 @@ m32c_cgen_rebuild_tables (CGEN_CPU_TABLE *cd)
 	  cd->base_insn_bitsize = CGEN_SIZE_UNKNOWN;
 
 	/* Set min,max insn sizes.  */
-	if (isa->min_insn_bitsize < cd->min_insn_bitsize)
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[8801]) {
+	  if ((isa -> min_insn_bitsize < cd -> min_insn_bitsize  ) && !(0))
+	    fprintf(stderr, "triggered bug index 8801\n");
+	  else
+	    fprintf(stderr, "reached bug index 8801\n");
+	}
+	if ((!FIXREVERTER[8801] && (isa -> min_insn_bitsize < cd -> min_insn_bitsize  ))
+	#else
+	if (0
+	#endif
+	)
 	  cd->min_insn_bitsize = isa->min_insn_bitsize;
-	if (isa->max_insn_bitsize > cd->max_insn_bitsize)
+	  #ifdef FRCOV
+	  }
+	  #endif
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[8802]) {
+	  if ((isa -> max_insn_bitsize > cd -> max_insn_bitsize  ) && !(0))
+	    fprintf(stderr, "triggered bug index 8802\n");
+	  else
+	    fprintf(stderr, "reached bug index 8802\n");
+	}
+	if ((!FIXREVERTER[8802] && (isa -> max_insn_bitsize > cd -> max_insn_bitsize  ))
+	#else
+	if (0
+	#endif
+	)
 	  cd->max_insn_bitsize = isa->max_insn_bitsize;
+	  #ifdef FRCOV
+	  }
+	  #endif
       }
 
   /* Data derived from the mach spec.  */
@@ -63026,8 +63059,23 @@ m32c_cgen_rebuild_tables (CGEN_CPU_TABLE *cd)
 
 	if (mach->insn_chunk_bitsize != 0)
 	{
-	  if (cd->insn_chunk_bitsize != 0 && cd->insn_chunk_bitsize != mach->insn_chunk_bitsize)
+	  
+	  #ifdef FRCOV
+	  {if (FIXREVERTER[8803]) {
+	    fprintf(stderr, "reached bug index 8803\n");
+	  }
+	  if ((FIXREVERTER[8803] && (cd -> insn_chunk_bitsize != 0 )) || (!FIXREVERTER[8803] && (cd -> insn_chunk_bitsize != 0 && cd -> insn_chunk_bitsize != mach -> insn_chunk_bitsize ))
+	  #else
+	  if (cd -> insn_chunk_bitsize != 0 
+	  #endif
+	  )
 	    {
+	      
+	    #ifdef FRCOV
+	      if (!(cd -> insn_chunk_bitsize != mach -> insn_chunk_bitsize ))
+	        fprintf(stderr, "triggered bug index 8803\n");
+	      #endif
+	    
 	      opcodes_error_handler
 		(/* xgettext:c-format */
 		 _("internal error: m32c_cgen_rebuild_tables: "
@@ -63035,6 +63083,9 @@ m32c_cgen_rebuild_tables (CGEN_CPU_TABLE *cd)
 		 cd->insn_chunk_bitsize, mach->insn_chunk_bitsize);
 	      abort ();
 	    }
+	    #ifdef FRCOV
+	    }
+	    #endif
 
  	  cd->insn_chunk_bitsize = mach->insn_chunk_bitsize;
 	}
@@ -63128,8 +63179,23 @@ m32c_cgen_cpu_open (enum cgen_cpu_open_arg arg_type, ...)
   va_end (ap);
 
   /* Mach unspecified means "all".  */
-  if (machs == 0)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[8805]) {
+    if ((machs == 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 8805\n");
+    else
+      fprintf(stderr, "reached bug index 8805\n");
+  }
+  if ((!FIXREVERTER[8805] && (machs == 0 ))
+  #else
+  if (0
+  #endif
+  )
     machs = (1 << MAX_MACHS) - 1;
+    #ifdef FRCOV
+    }
+    #endif
   /* Base mach is always selected.  */
   machs |= 1;
   if (endian == CGEN_ENDIAN_UNKNOWN)
diff --git a/opcodes/m32c-dis.c b/opcodes/m32c-dis.c
index 11ce775..397934f 100644
--- a/opcodes/m32c-dis.c
+++ b/opcodes/m32c-dis.c
@@ -1,3 +1,6 @@
+#ifdef FRCOV
+extern short FIXREVERTER[];
+#endif
 /* DO NOT EDIT!  -*- buffer-read-only: t -*- vi:set ro:  */
 /* Disassembler interface for targets using CGEN. -*- C -*-
    CGEN: Cpu tools GENerator
@@ -1310,10 +1313,40 @@ print_insn_m32c (bfd_vma pc, disassemble_info *info)
      but if not possible try to move this hook elsewhere rather than
      have two hooks.  */
   length = CGEN_PRINT_INSN (cd, pc, info);
-  if (length > 0)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[509]) {
+    if ((length > 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 509\n");
+    else
+      fprintf(stderr, "reached bug index 509\n");
+  }
+  if ((!FIXREVERTER[509] && (length > 0 ))
+  #else
+  if (0
+  #endif
+  )
     return length;
-  if (length < 0)
+    #ifdef FRCOV
+    }
+    #endif
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[510]) {
+    if ((length < 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 510\n");
+    else
+      fprintf(stderr, "reached bug index 510\n");
+  }
+  if ((!FIXREVERTER[510] && (length < 0 ))
+  #else
+  if (0
+  #endif
+  )
     return -1;
+    #ifdef FRCOV
+    }
+    #endif
 
   (*info->fprintf_func) (info->stream, UNKNOWN_INSN_MSG);
   return cd->default_insn_bitsize / 8;
diff --git a/opcodes/m32r-desc.c b/opcodes/m32r-desc.c
index 3ee7981..01f6d51 100644
--- a/opcodes/m32r-desc.c
+++ b/opcodes/m32r-desc.c
@@ -1,3 +1,6 @@
+#ifdef FRCOV
+extern short FIXREVERTER[];
+#endif
 /* DO NOT EDIT!  -*- buffer-read-only: t -*- vi:set ro:  */
 /* CPU data for m32r.
 
@@ -1344,10 +1347,40 @@ m32r_cgen_rebuild_tables (CGEN_CPU_TABLE *cd)
 	  cd->base_insn_bitsize = CGEN_SIZE_UNKNOWN;
 
 	/* Set min,max insn sizes.  */
-	if (isa->min_insn_bitsize < cd->min_insn_bitsize)
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[11481]) {
+	  if ((isa -> min_insn_bitsize < cd -> min_insn_bitsize  ) && !(0))
+	    fprintf(stderr, "triggered bug index 11481\n");
+	  else
+	    fprintf(stderr, "reached bug index 11481\n");
+	}
+	if ((!FIXREVERTER[11481] && (isa -> min_insn_bitsize < cd -> min_insn_bitsize  ))
+	#else
+	if (0
+	#endif
+	)
 	  cd->min_insn_bitsize = isa->min_insn_bitsize;
-	if (isa->max_insn_bitsize > cd->max_insn_bitsize)
+	  #ifdef FRCOV
+	  }
+	  #endif
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[11482]) {
+	  if ((isa -> max_insn_bitsize > cd -> max_insn_bitsize  ) && !(0))
+	    fprintf(stderr, "triggered bug index 11482\n");
+	  else
+	    fprintf(stderr, "reached bug index 11482\n");
+	}
+	if ((!FIXREVERTER[11482] && (isa -> max_insn_bitsize > cd -> max_insn_bitsize  ))
+	#else
+	if (0
+	#endif
+	)
 	  cd->max_insn_bitsize = isa->max_insn_bitsize;
+	  #ifdef FRCOV
+	  }
+	  #endif
       }
 
   /* Data derived from the mach spec.  */
@@ -1358,8 +1391,23 @@ m32r_cgen_rebuild_tables (CGEN_CPU_TABLE *cd)
 
 	if (mach->insn_chunk_bitsize != 0)
 	{
-	  if (cd->insn_chunk_bitsize != 0 && cd->insn_chunk_bitsize != mach->insn_chunk_bitsize)
+	  
+	  #ifdef FRCOV
+	  {if (FIXREVERTER[11483]) {
+	    fprintf(stderr, "reached bug index 11483\n");
+	  }
+	  if ((FIXREVERTER[11483] && (cd -> insn_chunk_bitsize != 0 )) || (!FIXREVERTER[11483] && (cd -> insn_chunk_bitsize != 0 && cd -> insn_chunk_bitsize != mach -> insn_chunk_bitsize ))
+	  #else
+	  if (cd -> insn_chunk_bitsize != 0 
+	  #endif
+	  )
 	    {
+	      
+	    #ifdef FRCOV
+	      if (!(cd -> insn_chunk_bitsize != mach -> insn_chunk_bitsize ))
+	        fprintf(stderr, "triggered bug index 11483\n");
+	      #endif
+	    
 	      opcodes_error_handler
 		(/* xgettext:c-format */
 		 _("internal error: m32r_cgen_rebuild_tables: "
@@ -1367,6 +1415,9 @@ m32r_cgen_rebuild_tables (CGEN_CPU_TABLE *cd)
 		 cd->insn_chunk_bitsize, mach->insn_chunk_bitsize);
 	      abort ();
 	    }
+	    #ifdef FRCOV
+	    }
+	    #endif
 
  	  cd->insn_chunk_bitsize = mach->insn_chunk_bitsize;
 	}
@@ -1460,8 +1511,23 @@ m32r_cgen_cpu_open (enum cgen_cpu_open_arg arg_type, ...)
   va_end (ap);
 
   /* Mach unspecified means "all".  */
-  if (machs == 0)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[11485]) {
+    if ((machs == 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 11485\n");
+    else
+      fprintf(stderr, "reached bug index 11485\n");
+  }
+  if ((!FIXREVERTER[11485] && (machs == 0 ))
+  #else
+  if (0
+  #endif
+  )
     machs = (1 << MAX_MACHS) - 1;
+    #ifdef FRCOV
+    }
+    #endif
   /* Base mach is always selected.  */
   machs |= 1;
   if (endian == CGEN_ENDIAN_UNKNOWN)
diff --git a/opcodes/m32r-dis.c b/opcodes/m32r-dis.c
index 233354e..1a079b2 100644
--- a/opcodes/m32r-dis.c
+++ b/opcodes/m32r-dis.c
@@ -1,3 +1,6 @@
+#ifdef FRCOV
+extern short FIXREVERTER[];
+#endif
 /* DO NOT EDIT!  -*- buffer-read-only: t -*- vi:set ro:  */
 /* Disassembler interface for targets using CGEN. -*- C -*-
    CGEN: Cpu tools GENerator
@@ -698,10 +701,40 @@ print_insn_m32r (bfd_vma pc, disassemble_info *info)
      but if not possible try to move this hook elsewhere rather than
      have two hooks.  */
   length = CGEN_PRINT_INSN (cd, pc, info);
-  if (length > 0)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[10568]) {
+    if ((length > 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 10568\n");
+    else
+      fprintf(stderr, "reached bug index 10568\n");
+  }
+  if ((!FIXREVERTER[10568] && (length > 0 ))
+  #else
+  if (0
+  #endif
+  )
     return length;
-  if (length < 0)
+    #ifdef FRCOV
+    }
+    #endif
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[10569]) {
+    if ((length < 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 10569\n");
+    else
+      fprintf(stderr, "reached bug index 10569\n");
+  }
+  if ((!FIXREVERTER[10569] && (length < 0 ))
+  #else
+  if (0
+  #endif
+  )
     return -1;
+    #ifdef FRCOV
+    }
+    #endif
 
   (*info->fprintf_func) (info->stream, UNKNOWN_INSN_MSG);
   return cd->default_insn_bitsize / 8;
diff --git a/opcodes/m32r-opc.c b/opcodes/m32r-opc.c
index 9b6e185..18db23b 100644
--- a/opcodes/m32r-opc.c
+++ b/opcodes/m32r-opc.c
@@ -1,3 +1,6 @@
+#ifdef FRCOV
+extern short FIXREVERTER[];
+#endif
 /* DO NOT EDIT!  -*- buffer-read-only: t -*- vi:set ro:  */
 /* Instruction opcode table for m32r.
 
@@ -41,11 +44,41 @@ m32r_cgen_dis_hash (const char * buf ATTRIBUTE_UNUSED, CGEN_INSN_INT value)
     value = (value >> 16) & 0xffff;
 
   x = (value >> 8) & 0xf0;
-  if (x == 0x40 || x == 0xe0 || x == 0x60 || x == 0x50)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[9630]) {
+    if ((x == 64 || x == 224 || x == 96 || x == 80 ) && !(0))
+      fprintf(stderr, "triggered bug index 9630\n");
+    else
+      fprintf(stderr, "reached bug index 9630\n");
+  }
+  if ((!FIXREVERTER[9630] && (x == 64 || x == 224 || x == 96 || x == 80 ))
+  #else
+  if (0
+  #endif
+  )
     return x;
-
-  if (x == 0x70 || x == 0xf0)
+    #ifdef FRCOV
+    }
+    #endif
+
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[9631]) {
+    if ((x == 112 || x == 240 ) && !(0))
+      fprintf(stderr, "triggered bug index 9631\n");
+    else
+      fprintf(stderr, "reached bug index 9631\n");
+  }
+  if ((!FIXREVERTER[9631] && (x == 112 || x == 240 ))
+  #else
+  if (0
+  #endif
+  )
     return x | ((value >> 8) & 0x0f);
+    #ifdef FRCOV
+    }
+    #endif
 
   if (x == 0x30)
     return x | ((value & 0x70) >> 4);
diff --git a/opcodes/m68hc11-dis.c b/opcodes/m68hc11-dis.c
index 0944da1..2dc4666 100644
--- a/opcodes/m68hc11-dis.c
+++ b/opcodes/m68hc11-dis.c
@@ -1,3 +1,6 @@
+#ifdef FRCOV
+extern short FIXREVERTER[];
+#endif
 /* m68hc11-dis.c -- Motorola 68HC11 & 68HC12 disassembly
    Copyright (C) 1999-2021 Free Software Foundation, Inc.
    Written by Stephane Carrez (stcarrez@nerim.fr)
@@ -81,10 +84,25 @@ print_indexed_operand (bfd_vma memaddr, struct disassemble_info* info,
     *indirect = 0;
 
   status = read_memory (memaddr, &buffer[0], 1, info);
-  if (status != 0)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[9996]) {
+    if ((status != 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 9996\n");
+    else
+      fprintf(stderr, "reached bug index 9996\n");
+  }
+  if ((!FIXREVERTER[9996] && (status != 0 ))
+  #else
+  if (0
+  #endif
+  )
     {
       return status;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
   /* n,r with 5-bits signed constant.  */
   if ((buffer[0] & 0x20) == 0)
@@ -142,8 +160,23 @@ print_indexed_operand (bfd_vma memaddr, struct disassemble_info* info,
 	}
       reg = (buffer[0] >> 3) & 0x03;
       status = read_memory (memaddr + pos, &buffer[0], 2, info);
-      if (status != 0)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[9997]) {
+        if ((status != 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 9997\n");
+        else
+          fprintf(stderr, "reached bug index 9997\n");
+      }
+      if ((!FIXREVERTER[9997] && (status != 0 ))
+      #else
+      if (0
+      #endif
+      )
 	return status;
+	#ifdef FRCOV
+	}
+	#endif
 
       pos += 2;
       val = (buffer[0] << 8) | buffer[1];
@@ -166,8 +199,23 @@ print_indexed_operand (bfd_vma memaddr, struct disassemble_info* info,
       reg = (buffer[0] >> 3) & 0x03;
       status = read_memory (memaddr + pos,
 			    &buffer[1], (buffer[0] & 0x2 ? 2 : 1), info);
-      if (status != 0)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[9998]) {
+        if ((status != 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 9998\n");
+        else
+          fprintf(stderr, "reached bug index 9998\n");
+      }
+      if ((!FIXREVERTER[9998] && (status != 0 ))
+      #else
+      if (0
+      #endif
+      )
 	return status;
+	#ifdef FRCOV
+	}
+	#endif
 
       if (buffer[0] & 2)
 	{
@@ -232,8 +280,23 @@ print_insn (bfd_vma memaddr, struct disassemble_info* info, int arch)
     {
       /* Get two bytes as all XGATE instructions are 16bit.  */
       status = read_memory (memaddr, buffer, 2, info);
-      if (status != 0)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[10000]) {
+        if ((status != 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 10000\n");
+        else
+          fprintf(stderr, "reached bug index 10000\n");
+      }
+      if ((!FIXREVERTER[10000] && (status != 0 ))
+      #else
+      if (0
+      #endif
+      )
 	return status;
+	#ifdef FRCOV
+	}
+	#endif
 
       format = 0;
       code = (buffer[0] << 8) + buffer[1];
@@ -325,8 +388,23 @@ print_insn (bfd_vma memaddr, struct disassemble_info* info, int arch)
   /* Get first byte.  Only one at a time because we don't know the
      size of the insn.  */
   status = read_memory (memaddr, buffer, 1, info);
-  if (status != 0)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[10001]) {
+    if ((status != 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 10001\n");
+    else
+      fprintf(stderr, "reached bug index 10001\n");
+  }
+  if ((!FIXREVERTER[10001] && (status != 0 ))
+  #else
+  if (0
+  #endif
+  )
     return status;
+    #ifdef FRCOV
+    }
+    #endif
 
   format = 0;
   code = buffer[0];
@@ -353,8 +431,23 @@ print_insn (bfd_vma memaddr, struct disassemble_info* info, int arch)
   if (pos == 1)
     {
       status = read_memory (memaddr + pos, &buffer[1], 1, info);
-      if (status != 0)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[10003]) {
+        if ((status != 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 10003\n");
+        else
+          fprintf(stderr, "reached bug index 10003\n");
+      }
+      if ((!FIXREVERTER[10003] && (status != 0 ))
+      #else
+      if (0
+      #endif
+      )
 	return status;
+	#ifdef FRCOV
+	}
+	#endif
 
       code = buffer[1];
     }
@@ -375,8 +468,23 @@ print_insn (bfd_vma memaddr, struct disassemble_info* info, int arch)
 		{
 		  status = read_memory (memaddr + pos + 1,
 					&buffer[1], 1, info);
-		  if (status != 0)
+		  
+		  #ifdef FRCOV
+		  {if (FIXREVERTER[10004]) {
+		    if ((status != 0 ) && !(0))
+		      fprintf(stderr, "triggered bug index 10004\n");
+		    else
+		      fprintf(stderr, "reached bug index 10004\n");
+		  }
+		  if ((!FIXREVERTER[10004] && (status != 0 ))
+		  #else
+		  if (0
+		  #endif
+		  )
 		    break;
+		    #ifdef FRCOV
+		    }
+		    #endif
 
 		  must_read = 1;
 		}
@@ -403,8 +511,23 @@ print_insn (bfd_vma memaddr, struct disassemble_info* info, int arch)
 
       if ((opcode->arch & arch) == 0)
 	continue;
-      if (opcode->opcode != code)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[10005]) {
+        if ((opcode -> opcode != code ) && !(0))
+          fprintf(stderr, "triggered bug index 10005\n");
+        else
+          fprintf(stderr, "reached bug index 10005\n");
+      }
+      if ((!FIXREVERTER[10005] && (opcode -> opcode != code ))
+      #else
+      if (0
+      #endif
+      )
 	continue;
+	#ifdef FRCOV
+	}
+	#endif
       if ((opcode->format & OP_PAGE_MASK) != format)
 	continue;
 
@@ -419,10 +542,25 @@ print_insn (bfd_vma memaddr, struct disassemble_info* info, int arch)
 	    is_jump = 0;
 
 	  status = read_memory (memaddr + pos, &buffer[0], 1, info);
-	  if (status != 0)
+	  
+	  #ifdef FRCOV
+	  {if (FIXREVERTER[10006]) {
+	    if ((status != 0 ) && !(0))
+	      fprintf(stderr, "triggered bug index 10006\n");
+	    else
+	      fprintf(stderr, "reached bug index 10006\n");
+	  }
+	  if ((!FIXREVERTER[10006] && (status != 0 ))
+	  #else
+	  if (0
+	  #endif
+	  )
 	    {
 	      return status;
 	    }
+	    #ifdef FRCOV
+	    }
+	    #endif
 	  for (j = 0; i + j < m68hc11_num_opcodes; j++)
 	    {
 	      if ((opcode[j].arch & arch) == 0)
@@ -515,10 +653,25 @@ print_insn (bfd_vma memaddr, struct disassemble_info* info, int arch)
 	{
 	  /* Check xb to see position of data.  */
 	  status = read_memory (memaddr + pos, &buffer[0], 1, info);
-	  if (status != 0)
+	  
+	  #ifdef FRCOV
+	  {if (FIXREVERTER[10007]) {
+	    if ((status != 0 ) && !(0))
+	      fprintf(stderr, "triggered bug index 10007\n");
+	    else
+	      fprintf(stderr, "reached bug index 10007\n");
+	  }
+	  if ((!FIXREVERTER[10007] && (status != 0 ))
+	  #else
+	  if (0
+	  #endif
+	  )
 	    {
 	      return status;
 	    }
+	    #ifdef FRCOV
+	    }
+	    #endif
 
 	  if (((buffer[0] & 0xe0) == 0xe0) && ((buffer[0] & 0x04) == 0))
 	    {
@@ -542,8 +695,23 @@ print_insn (bfd_vma memaddr, struct disassemble_info* info, int arch)
 	  (M6811_OP_IMM8 | M6811_OP_IX | M6811_OP_IY | M6811_OP_DIRECT))
 	{
 	  status = read_memory (memaddr + pos + offset, &buffer[0], 1, info);
-	  if (status != 0)
+	  
+	  #ifdef FRCOV
+	  {if (FIXREVERTER[10008]) {
+	    if ((status != 0 ) && !(0))
+	      fprintf(stderr, "triggered bug index 10008\n");
+	    else
+	      fprintf(stderr, "reached bug index 10008\n");
+	  }
+	  if ((!FIXREVERTER[10008] && (status != 0 ))
+	  #else
+	  if (0
+	  #endif
+	  )
 	    return status;
+	    #ifdef FRCOV
+	    }
+	    #endif
 
 	  /* This movb/movw is special (see above).  */
 	  if (offset < 2)
@@ -602,8 +770,23 @@ print_insn (bfd_vma memaddr, struct disassemble_info* info, int arch)
 	  status = print_indexed_operand (memaddr + pos, info, &indirect,
 					  (format & M6812_DST_MOVE),
 					  pc_src_offset, endaddr, arch);
-	  if (status < 0)
+	  
+	  #ifdef FRCOV
+	  {if (FIXREVERTER[10009]) {
+	    if ((status < 0 ) && !(0))
+	      fprintf(stderr, "triggered bug index 10009\n");
+	    else
+	      fprintf(stderr, "reached bug index 10009\n");
+	  }
+	  if ((!FIXREVERTER[10009] && (status < 0 ))
+	  #else
+	  if (0
+	  #endif
+	  )
 	    return status;
+	    #ifdef FRCOV
+	    }
+	    #endif
 
 	  pos += status;
 
@@ -617,8 +800,23 @@ print_insn (bfd_vma memaddr, struct disassemble_info* info, int arch)
       if ((format & M6812_OP_REG) && (format & M6811_OP_JUMP_REL))
 	{
 	  status = read_memory (memaddr + pos, &buffer[0], 2, info);
-	  if (status != 0)
+	  
+	  #ifdef FRCOV
+	  {if (FIXREVERTER[10010]) {
+	    if ((status != 0 ) && !(0))
+	      fprintf(stderr, "triggered bug index 10010\n");
+	    else
+	      fprintf(stderr, "reached bug index 10010\n");
+	  }
+	  if ((!FIXREVERTER[10010] && (status != 0 ))
+	  #else
+	  if (0
+	  #endif
+	  )
 	    return status;
+	    #ifdef FRCOV
+	    }
+	    #endif
 
 	  (*info->fprintf_func) (info->stream, "%s,",
 				 reg_src_table[buffer[0] & 0x07]);
@@ -632,8 +830,23 @@ print_insn (bfd_vma memaddr, struct disassemble_info* info, int arch)
       else if (format & (M6812_OP_REG | M6812_OP_REG_2))
 	{
 	  status = read_memory (memaddr + pos, &buffer[0], 1, info);
-	  if (status != 0)
+	  
+	  #ifdef FRCOV
+	  {if (FIXREVERTER[10011]) {
+	    if ((status != 0 ) && !(0))
+	      fprintf(stderr, "triggered bug index 10011\n");
+	    else
+	      fprintf(stderr, "reached bug index 10011\n");
+	  }
+	  if ((!FIXREVERTER[10011] && (status != 0 ))
+	  #else
+	  if (0
+	  #endif
+	  )
 	    return status;
+	    #ifdef FRCOV
+	    }
+	    #endif
 
 	  pos++;
 	  (*info->fprintf_func) (info->stream, "%s,%s",
@@ -647,8 +860,23 @@ print_insn (bfd_vma memaddr, struct disassemble_info* info, int arch)
 	  unsigned page = 0;
 
 	  status = read_memory (memaddr + pos + offset, &buffer[0], 2, info);
-	  if (status != 0)
+	  
+	  #ifdef FRCOV
+	  {if (FIXREVERTER[10012]) {
+	    if ((status != 0 ) && !(0))
+	      fprintf(stderr, "triggered bug index 10012\n");
+	    else
+	      fprintf(stderr, "reached bug index 10012\n");
+	  }
+	  if ((!FIXREVERTER[10012] && (status != 0 ))
+	  #else
+	  if (0
+	  #endif
+	  )
 	    return status;
+	    #ifdef FRCOV
+	    }
+	    #endif
 
 	  if (format & M6812_OP_IDX_P2)
 	    offset = -2;
@@ -661,8 +889,23 @@ print_insn (bfd_vma memaddr, struct disassemble_info* info, int arch)
 	  if (format & M6812_OP_PAGE)
 	    {
 	      status = read_memory (memaddr + pos + offset, buffer, 1, info);
-	      if (status != 0)
+	      
+	      #ifdef FRCOV
+	      {if (FIXREVERTER[10013]) {
+	        if ((status != 0 ) && !(0))
+	          fprintf(stderr, "triggered bug index 10013\n");
+	        else
+	          fprintf(stderr, "reached bug index 10013\n");
+	      }
+	      if ((!FIXREVERTER[10013] && (status != 0 ))
+	      #else
+	      if (0
+	      #endif
+	      )
 		return status;
+		#ifdef FRCOV
+		}
+		#endif
 
 	      page = buffer[0];
 	      if (addr >= M68HC12_BANK_BASE && addr < 0x0c000)
@@ -721,8 +964,23 @@ print_insn (bfd_vma memaddr, struct disassemble_info* info, int arch)
 	  status = print_indexed_operand (memaddr + pos + offset, info,
 					  0, 1, pc_dst_offset,
 					  memaddr + pos + offset + 1, arch);
-	  if (status < 0)
+	  
+	  #ifdef FRCOV
+	  {if (FIXREVERTER[10015]) {
+	    if ((status < 0 ) && !(0))
+	      fprintf(stderr, "triggered bug index 10015\n");
+	    else
+	      fprintf(stderr, "reached bug index 10015\n");
+	  }
+	  if ((!FIXREVERTER[10015] && (status < 0 ))
+	  #else
+	  if (0
+	  #endif
+	  )
 	    return status;
+	    #ifdef FRCOV
+	    }
+	    #endif
 	  pos += status;
 	}
 
@@ -731,8 +989,23 @@ print_insn (bfd_vma memaddr, struct disassemble_info* info, int arch)
 	  (*info->fprintf_func) (info->stream, ", ");
 
 	  status = read_memory (memaddr + pos + offset, &buffer[0], 2, info);
-	  if (status != 0)
+	  
+	  #ifdef FRCOV
+	  {if (FIXREVERTER[10016]) {
+	    if ((status != 0 ) && !(0))
+	      fprintf(stderr, "triggered bug index 10016\n");
+	    else
+	      fprintf(stderr, "reached bug index 10016\n");
+	  }
+	  if ((!FIXREVERTER[10016] && (status != 0 ))
+	  #else
+	  if (0
+	  #endif
+	  )
 	    return status;
+	    #ifdef FRCOV
+	    }
+	    #endif
 
 	  pos += 2;
 
@@ -749,8 +1022,23 @@ print_insn (bfd_vma memaddr, struct disassemble_info* info, int arch)
       if (format & M6811_OP_BITMASK)
 	{
 	  status = read_memory (memaddr + pos, &buffer[0], 1, info);
-	  if (status != 0)
+	  
+	  #ifdef FRCOV
+	  {if (FIXREVERTER[10017]) {
+	    if ((status != 0 ) && !(0))
+	      fprintf(stderr, "triggered bug index 10017\n");
+	    else
+	      fprintf(stderr, "reached bug index 10017\n");
+	  }
+	  if ((!FIXREVERTER[10017] && (status != 0 ))
+	  #else
+	  if (0
+	  #endif
+	  )
 	    return status;
+	    #ifdef FRCOV
+	    }
+	    #endif
 
 	  pos++;
 	  (*info->fprintf_func) (info->stream, ", #0x%02x%s",
@@ -761,8 +1049,23 @@ print_insn (bfd_vma memaddr, struct disassemble_info* info, int arch)
       if (format & M6811_OP_JUMP_REL)
 	{
 	  status = read_memory (memaddr + pos, &buffer[0], 1, info);
-	  if (status != 0)
+	  
+	  #ifdef FRCOV
+	  {if (FIXREVERTER[10018]) {
+	    if ((status != 0 ) && !(0))
+	      fprintf(stderr, "triggered bug index 10018\n");
+	    else
+	      fprintf(stderr, "reached bug index 10018\n");
+	  }
+	  if ((!FIXREVERTER[10018] && (status != 0 ))
+	  #else
+	  if (0
+	  #endif
+	  )
 	    return status;
+	    #ifdef FRCOV
+	    }
+	    #endif
 
 	  (*info->fprintf_func) (info->stream, "0x");
 	  pos++;
@@ -773,8 +1076,23 @@ print_insn (bfd_vma memaddr, struct disassemble_info* info, int arch)
       else if (format & M6812_OP_JUMP_REL16)
 	{
 	  status = read_memory (memaddr + pos, &buffer[0], 2, info);
-	  if (status != 0)
+	  
+	  #ifdef FRCOV
+	  {if (FIXREVERTER[10019]) {
+	    if ((status != 0 ) && !(0))
+	      fprintf(stderr, "triggered bug index 10019\n");
+	    else
+	      fprintf(stderr, "reached bug index 10019\n");
+	  }
+	  if ((!FIXREVERTER[10019] && (status != 0 ))
+	  #else
+	  if (0
+	  #endif
+	  )
 	    return status;
+	    #ifdef FRCOV
+	    }
+	    #endif
 
 	  pos += 2;
 	  val = (((buffer[0] << 8) | buffer[1]) ^ 0x8000) - 0x8000;
@@ -787,8 +1105,23 @@ print_insn (bfd_vma memaddr, struct disassemble_info* info, int arch)
       if (format & M6812_OP_PAGE)
 	{
 	  status = read_memory (memaddr + pos + offset, &buffer[0], 1, info);
-	  if (status != 0)
+	  
+	  #ifdef FRCOV
+	  {if (FIXREVERTER[10020]) {
+	    if ((status != 0 ) && !(0))
+	      fprintf(stderr, "triggered bug index 10020\n");
+	    else
+	      fprintf(stderr, "reached bug index 10020\n");
+	  }
+	  if ((!FIXREVERTER[10020] && (status != 0 ))
+	  #else
+	  if (0
+	  #endif
+	  )
 	    return status;
+	    #ifdef FRCOV
+	    }
+	    #endif
 
 	  pos += 1;
 
diff --git a/opcodes/m68k-dis.c b/opcodes/m68k-dis.c
index fe2536d..3ef28b0 100644
--- a/opcodes/m68k-dis.c
+++ b/opcodes/m68k-dis.c
@@ -1,3 +1,6 @@
+#ifdef FRCOV
+extern short FIXREVERTER[];
+#endif
 /* Print Motorola 68k instructions.
    Copyright (C) 1986-2021 Free Software Foundation, Inc.
 
@@ -758,8 +761,23 @@ print_insn_arg (const char *d,
 		  (*info->fprintf_func) (info->stream, "%s", names_v4e[regno].name);
 		  break;
 		}
-	    if (regno >= 0)
+	    
+	    #ifdef FRCOV
+	    {if (FIXREVERTER[7063]) {
+	      if ((regno >= 0 ) && !(0))
+	        fprintf(stderr, "triggered bug index 7063\n");
+	      else
+	        fprintf(stderr, "reached bug index 7063\n");
+	    }
+	    if ((!FIXREVERTER[7063] && (regno >= 0 ))
+	    #else
+	    if (0
+	    #endif
+	    )
 	      break;
+	      #ifdef FRCOV
+	      }
+	      #endif
 	  }
 	for (regno = ARRAY_SIZE (names) - 1; regno >= 0; regno--)
 	  if (names[regno].value == val)
@@ -783,8 +801,23 @@ print_insn_arg (const char *d,
     case 'x':
       FETCH_ARG (3, val);
       /* 0 means -1.  */
-      if (val == 0)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[7064]) {
+        if ((val == 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 7064\n");
+        else
+          fprintf(stderr, "reached bug index 7064\n");
+      }
+      if ((!FIXREVERTER[7064] && (val == 0 ))
+      #else
+      if (0
+      #endif
+      )
 	val = -1;
+	#ifdef FRCOV
+	}
+	#endif
       (*info->fprintf_func) (info->stream, "#%d", val);
       break;
 
@@ -974,8 +1007,23 @@ print_insn_arg (const char *d,
     case 'I':
       /* Get coprocessor ID... */
       val = fetch_arg (buffer, 'd', 3, info);
-      if (val < 0)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[7065]) {
+        if ((val < 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 7065\n");
+        else
+          fprintf(stderr, "reached bug index 7065\n");
+      }
+      if ((!FIXREVERTER[7065] && (val < 0 ))
+      #else
+      if (0
+      #endif
+      )
 	return PRINT_INSN_ARG_MEMORY_ERROR;
+	#ifdef FRCOV
+	}
+	#endif
       if (val != 1)				/* Unusual coprocessor ID?  */
 	(*info->fprintf_func) (info->stream, "(cpid=%d) ", val);
       break;
@@ -1007,15 +1055,45 @@ print_insn_arg (const char *d,
       if (place == 'd')
 	{
 	  val = fetch_arg (buffer, 'x', 6, info);
-	  if (val < 0)
+	  
+	  #ifdef FRCOV
+	  {if (FIXREVERTER[7066]) {
+	    if ((val < 0 ) && !(0))
+	      fprintf(stderr, "triggered bug index 7066\n");
+	    else
+	      fprintf(stderr, "reached bug index 7066\n");
+	  }
+	  if ((!FIXREVERTER[7066] && (val < 0 ))
+	  #else
+	  if (0
+	  #endif
+	  )
 	    return PRINT_INSN_ARG_MEMORY_ERROR;
+	    #ifdef FRCOV
+	    }
+	    #endif
 	  val = ((val & 7) << 3) + ((val >> 3) & 7);
 	}
       else
 	{
 	  val = fetch_arg (buffer, 's', 6, info);
-	  if (val < 0)
+	  
+	  #ifdef FRCOV
+	  {if (FIXREVERTER[7067]) {
+	    if ((val < 0 ) && !(0))
+	      fprintf(stderr, "triggered bug index 7067\n");
+	    else
+	      fprintf(stderr, "reached bug index 7067\n");
+	  }
+	  if ((!FIXREVERTER[7067] && (val < 0 ))
+	  #else
+	  if (0
+	  #endif
+	  )
 	    return PRINT_INSN_ARG_MEMORY_ERROR;
+	    #ifdef FRCOV
+	    }
+	    #endif
 	}
 
       /* If the <ea> is invalid for *d, then reject this match.  */
@@ -1054,8 +1132,23 @@ print_insn_arg (const char *d,
 
 	case 6:
 	  p = print_indexed (regno, p, addr, info);
-	  if (p == NULL)
+	  
+	  #ifdef FRCOV
+	  {if (FIXREVERTER[7068]) {
+	    if ((p == (void *) 0 ) && !(0))
+	      fprintf(stderr, "triggered bug index 7068\n");
+	    else
+	      fprintf(stderr, "reached bug index 7068\n");
+	  }
+	  if ((!FIXREVERTER[7068] && (p == (void *) 0 ))
+	  #else
+	  if (0
+	  #endif
+	  )
 	    return PRINT_INSN_ARG_MEMORY_ERROR;
+	    #ifdef FRCOV
+	    }
+	    #endif
 	  break;
 
 	case 7:
@@ -1080,8 +1173,23 @@ print_insn_arg (const char *d,
 
 	    case 3:
 	      p = print_indexed (-1, p, addr, info);
-	      if (p == NULL)
+	      
+	      #ifdef FRCOV
+	      {if (FIXREVERTER[7069]) {
+	        if ((p == (void *) 0 ) && !(0))
+	          fprintf(stderr, "triggered bug index 7069\n");
+	        else
+	          fprintf(stderr, "reached bug index 7069\n");
+	      }
+	      if ((!FIXREVERTER[7069] && (p == (void *) 0 ))
+	      #else
+	      if (0
+	      #endif
+	      )
 		return PRINT_INSN_ARG_MEMORY_ERROR;
+		#ifdef FRCOV
+		}
+		#endif
 	      break;
 
 	    case 4:
@@ -1154,11 +1262,26 @@ print_insn_arg (const char *d,
 	    /* Move the pointer ahead if this point is farther ahead
 	       than the last.  */
 	    p = p1 > p ? p1 : p;
-	    if (val == 0)
+	    
+	    #ifdef FRCOV
+	    {if (FIXREVERTER[7070]) {
+	      if ((val == 0 ) && !(0))
+	        fprintf(stderr, "triggered bug index 7070\n");
+	      else
+	        fprintf(stderr, "reached bug index 7070\n");
+	    }
+	    if ((!FIXREVERTER[7070] && (val == 0 ))
+	    #else
+	    if (0
+	    #endif
+	    )
 	      {
 		(*info->fprintf_func) (info->stream, "#0");
 		break;
 	      }
+	      #ifdef FRCOV
+	      }
+	      #endif
 	    if (*d == 'l')
 	      {
 		int newval = 0;
@@ -1193,11 +1316,26 @@ print_insn_arg (const char *d,
 	    char doneany;
 
 	    FETCH_ARG (8, val);
-	    if (val == 0)
+	    
+	    #ifdef FRCOV
+	    {if (FIXREVERTER[7071]) {
+	      if ((val == 0 ) && !(0))
+	        fprintf(stderr, "triggered bug index 7071\n");
+	      else
+	        fprintf(stderr, "reached bug index 7071\n");
+	    }
+	    if ((!FIXREVERTER[7071] && (val == 0 ))
+	    #else
+	    if (0
+	    #endif
+	    )
 	      {
 		(*info->fprintf_func) (info->stream, "#0");
 		break;
 	      }
+	      #ifdef FRCOV
+	      }
+	      #endif
 	    if (*d == 'l')
 	      {
 		int newval = 0;
diff --git a/opcodes/mep-desc.c b/opcodes/mep-desc.c
index c280979..76127fa 100644
--- a/opcodes/mep-desc.c
+++ b/opcodes/mep-desc.c
@@ -1,3 +1,6 @@
+#ifdef FRCOV
+extern short FIXREVERTER[];
+#endif
 /* DO NOT EDIT!  -*- buffer-read-only: t -*- vi:set ro:  */
 /* CPU data for mep.
 
@@ -6205,10 +6208,40 @@ mep_cgen_rebuild_tables (CGEN_CPU_TABLE *cd)
 	  cd->base_insn_bitsize = CGEN_SIZE_UNKNOWN;
 
 	/* Set min,max insn sizes.  */
-	if (isa->min_insn_bitsize < cd->min_insn_bitsize)
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[7042]) {
+	  if ((isa -> min_insn_bitsize < cd -> min_insn_bitsize  ) && !(0))
+	    fprintf(stderr, "triggered bug index 7042\n");
+	  else
+	    fprintf(stderr, "reached bug index 7042\n");
+	}
+	if ((!FIXREVERTER[7042] && (isa -> min_insn_bitsize < cd -> min_insn_bitsize  ))
+	#else
+	if (0
+	#endif
+	)
 	  cd->min_insn_bitsize = isa->min_insn_bitsize;
-	if (isa->max_insn_bitsize > cd->max_insn_bitsize)
+	  #ifdef FRCOV
+	  }
+	  #endif
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[7043]) {
+	  if ((isa -> max_insn_bitsize > cd -> max_insn_bitsize  ) && !(0))
+	    fprintf(stderr, "triggered bug index 7043\n");
+	  else
+	    fprintf(stderr, "reached bug index 7043\n");
+	}
+	if ((!FIXREVERTER[7043] && (isa -> max_insn_bitsize > cd -> max_insn_bitsize  ))
+	#else
+	if (0
+	#endif
+	)
 	  cd->max_insn_bitsize = isa->max_insn_bitsize;
+	  #ifdef FRCOV
+	  }
+	  #endif
       }
 
   /* Data derived from the mach spec.  */
@@ -6219,8 +6252,23 @@ mep_cgen_rebuild_tables (CGEN_CPU_TABLE *cd)
 
 	if (mach->insn_chunk_bitsize != 0)
 	{
-	  if (cd->insn_chunk_bitsize != 0 && cd->insn_chunk_bitsize != mach->insn_chunk_bitsize)
+	  
+	  #ifdef FRCOV
+	  {if (FIXREVERTER[7044]) {
+	    fprintf(stderr, "reached bug index 7044\n");
+	  }
+	  if ((FIXREVERTER[7044] && (cd -> insn_chunk_bitsize != 0 )) || (!FIXREVERTER[7044] && (cd -> insn_chunk_bitsize != 0 && cd -> insn_chunk_bitsize != mach -> insn_chunk_bitsize ))
+	  #else
+	  if (cd -> insn_chunk_bitsize != 0 
+	  #endif
+	  )
 	    {
+	      
+	    #ifdef FRCOV
+	      if (!(cd -> insn_chunk_bitsize != mach -> insn_chunk_bitsize ))
+	        fprintf(stderr, "triggered bug index 7044\n");
+	      #endif
+	    
 	      opcodes_error_handler
 		(/* xgettext:c-format */
 		 _("internal error: mep_cgen_rebuild_tables: "
@@ -6228,6 +6276,9 @@ mep_cgen_rebuild_tables (CGEN_CPU_TABLE *cd)
 		 cd->insn_chunk_bitsize, mach->insn_chunk_bitsize);
 	      abort ();
 	    }
+	    #ifdef FRCOV
+	    }
+	    #endif
 
  	  cd->insn_chunk_bitsize = mach->insn_chunk_bitsize;
 	}
@@ -6321,8 +6372,23 @@ mep_cgen_cpu_open (enum cgen_cpu_open_arg arg_type, ...)
   va_end (ap);
 
   /* Mach unspecified means "all".  */
-  if (machs == 0)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[7046]) {
+    if ((machs == 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 7046\n");
+    else
+      fprintf(stderr, "reached bug index 7046\n");
+  }
+  if ((!FIXREVERTER[7046] && (machs == 0 ))
+  #else
+  if (0
+  #endif
+  )
     machs = (1 << MAX_MACHS) - 1;
+    #ifdef FRCOV
+    }
+    #endif
   /* Base mach is always selected.  */
   machs |= 1;
   if (endian == CGEN_ENDIAN_UNKNOWN)
diff --git a/opcodes/mep-dis.c b/opcodes/mep-dis.c
index f8f429b..0914897 100644
--- a/opcodes/mep-dis.c
+++ b/opcodes/mep-dis.c
@@ -1,3 +1,6 @@
+#ifdef FRCOV
+extern short FIXREVERTER[];
+#endif
 /* DO NOT EDIT!  -*- buffer-read-only: t -*- vi:set ro:  */
 /* Disassembler interface for targets using CGEN. -*- C -*-
    CGEN: Cpu tools GENerator
@@ -1606,10 +1609,40 @@ print_insn_mep (bfd_vma pc, disassemble_info *info)
      but if not possible try to move this hook elsewhere rather than
      have two hooks.  */
   length = CGEN_PRINT_INSN (cd, pc, info);
-  if (length > 0)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[8375]) {
+    if ((length > 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 8375\n");
+    else
+      fprintf(stderr, "reached bug index 8375\n");
+  }
+  if ((!FIXREVERTER[8375] && (length > 0 ))
+  #else
+  if (0
+  #endif
+  )
     return length;
-  if (length < 0)
+    #ifdef FRCOV
+    }
+    #endif
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[8376]) {
+    if ((length < 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 8376\n");
+    else
+      fprintf(stderr, "reached bug index 8376\n");
+  }
+  if ((!FIXREVERTER[8376] && (length < 0 ))
+  #else
+  if (0
+  #endif
+  )
     return -1;
+    #ifdef FRCOV
+    }
+    #endif
 
   (*info->fprintf_func) (info->stream, UNKNOWN_INSN_MSG);
   return cd->default_insn_bitsize / 8;
diff --git a/opcodes/microblaze-dis.c b/opcodes/microblaze-dis.c
index aa75c4c..ef04cb9 100644
--- a/opcodes/microblaze-dis.c
+++ b/opcodes/microblaze-dis.c
@@ -1,3 +1,6 @@
+#ifdef FRCOV
+extern short FIXREVERTER[];
+#endif
 /* Disassemble Xilinx microblaze instructions.
 
    Copyright (C) 2009-2021 Free Software Foundation, Inc.
@@ -236,16 +239,46 @@ print_insn_microblaze (bfd_vma memaddr, struct disassemble_info * info)
   info->bytes_per_chunk = 4;
 
   inst = read_insn_microblaze (memaddr, info, &op);
-  if (inst == 0)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[2584]) {
+    if ((inst == 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 2584\n");
+    else
+      fprintf(stderr, "reached bug index 2584\n");
+  }
+  if ((!FIXREVERTER[2584] && (inst == 0 ))
+  #else
+  if (0
+  #endif
+  )
     return -1;
+    #ifdef FRCOV
+    }
+    #endif
 
   if (prev_insn_vma == curr_insn_vma)
     {
       if (memaddr-(info->bytes_per_chunk) == prev_insn_addr)
 	{
 	  prev_inst = read_insn_microblaze (prev_insn_addr, info, &pop);
-	  if (prev_inst == 0)
+	  
+	  #ifdef FRCOV
+	  {if (FIXREVERTER[2585]) {
+	    if ((prev_inst == 0 ) && !(0))
+	      fprintf(stderr, "triggered bug index 2585\n");
+	    else
+	      fprintf(stderr, "reached bug index 2585\n");
+	  }
+	  if ((!FIXREVERTER[2585] && (prev_inst == 0 ))
+	  #else
+	  if (0
+	  #endif
+	  )
 	    return -1;
+	    #ifdef FRCOV
+	    }
+	    #endif
 	  if (pop->instr == imm)
 	    {
 	      immval = (get_int_field_imm (prev_inst) << 16) & 0xffff0000;
diff --git a/opcodes/mips-dis.c b/opcodes/mips-dis.c
index d519420..1380ee8 100644
--- a/opcodes/mips-dis.c
+++ b/opcodes/mips-dis.c
@@ -1,3 +1,6 @@
+#ifdef FRCOV
+extern short FIXREVERTER[];
+#endif
 /* Print mips instructions for GDB, the GNU debugger, or for objdump.
    Copyright (C) 1989-2021 Free Software Foundation, Inc.
    Contributed by Nobuyuki Hikichi(hikichi@sra.co.jp).
@@ -714,10 +717,26 @@ choose_abi_by_name (const char *name, unsigned int namelen)
   const struct mips_abi_choice *c;
   unsigned int i;
 
-  for (i = 0, c = NULL; i < ARRAY_SIZE (mips_abi_choices) && c == NULL; i++)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[12016])
+    fprintf(stderr, "reached bug index 12016\n");
+  for (i = 0 , c = ((void *)0); (FIXREVERTER[12016] && (i < sizeof ( mips_abi_choices ) / sizeof ( mips_abi_choices [ 0 ] ) )) || (!FIXREVERTER[12016] && (i < sizeof ( mips_abi_choices ) / sizeof ( mips_abi_choices [ 0 ] ) && c == (void *) 0 ))
+  #else
+  for (i = 0 , c = ((void *)0); i < sizeof ( mips_abi_choices ) / sizeof ( mips_abi_choices [ 0 ] ) 
+  #endif
+  ; i++)
+    
+    #ifdef FRCOV
+    {if (!(c == (void *) 0 ))
+      fprintf(stderr, "triggered bug index 12016\n");
+    #endif
     if (strncmp (mips_abi_choices[i].name, name, namelen) == 0
 	&& strlen (mips_abi_choices[i].name) == namelen)
       c = &mips_abi_choices[i];
+      #ifdef FRCOV
+      }}
+      #endif
 
   return c;
 }
@@ -1011,12 +1030,57 @@ parse_mips_dis_option (const char *option, unsigned int len)
     if (option[i] == '=')
       break;
 
-  if (i == 0)		/* Invalid option: no name before '='.  */
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[12017]) {
+    if ((i == 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 12017\n");
+    else
+      fprintf(stderr, "reached bug index 12017\n");
+  }
+  if ((!FIXREVERTER[12017] && (i == 0 ))
+  #else
+  if (0
+  #endif
+  )		/* Invalid option: no name before '='.  */
     return;
-  if (i == len)		/* Invalid option: no '='.  */
+    #ifdef FRCOV
+    }
+    #endif
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[12018]) {
+    if ((i == len ) && !(0))
+      fprintf(stderr, "triggered bug index 12018\n");
+    else
+      fprintf(stderr, "reached bug index 12018\n");
+  }
+  if ((!FIXREVERTER[12018] && (i == len ))
+  #else
+  if (0
+  #endif
+  )		/* Invalid option: no '='.  */
     return;
-  if (i == (len - 1))	/* Invalid option: no value after '='.  */
+    #ifdef FRCOV
+    }
+    #endif
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[12019]) {
+    if ((i == len - 1 ) && !(0))
+      fprintf(stderr, "triggered bug index 12019\n");
+    else
+      fprintf(stderr, "reached bug index 12019\n");
+  }
+  if ((!FIXREVERTER[12019] && (i == len - 1 ))
+  #else
+  if (0
+  #endif
+  )	/* Invalid option: no value after '='.  */
     return;
+    #ifdef FRCOV
+    }
+    #endif
 
   optionlen = i;
   val = option + (optionlen + 1);
@@ -1104,8 +1168,23 @@ parse_mips_dis_options (const char *options)
 {
   const char *option_end;
 
-  if (options == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[12024]) {
+    if ((options == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 12024\n");
+    else
+      fprintf(stderr, "reached bug index 12024\n");
+  }
+  if ((!FIXREVERTER[12024] && (options == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     return;
+    #ifdef FRCOV
+    }
+    #endif
 
   while (*options != '\0')
     {
@@ -2544,10 +2623,40 @@ _print_insn_mips (bfd_vma memaddr,
   set_default_mips_dis_options (info);
   parse_mips_dis_options (info->disassembler_options);
 
-  if (info->mach == bfd_mach_mips16)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[12035]) {
+    if ((info -> mach == 16 ) && !(0))
+      fprintf(stderr, "triggered bug index 12035\n");
+    else
+      fprintf(stderr, "reached bug index 12035\n");
+  }
+  if ((!FIXREVERTER[12035] && (info -> mach == 16 ))
+  #else
+  if (0
+  #endif
+  )
     return print_insn_mips16 (memaddr, info);
-  if (info->mach == bfd_mach_mips_micromips)
+    #ifdef FRCOV
+    }
+    #endif
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[12036]) {
+    if ((info -> mach == 96 ) && !(0))
+      fprintf(stderr, "triggered bug index 12036\n");
+    else
+      fprintf(stderr, "reached bug index 12036\n");
+  }
+  if ((!FIXREVERTER[12036] && (info -> mach == 96 ))
+  #else
+  if (0
+  #endif
+  )
     return print_insn_micromips (memaddr, info);
+    #ifdef FRCOV
+    }
+    #endif
 
 #if 1
   /* FIXME: If odd address, this is CLEARLY a compressed instruction.  */
diff --git a/opcodes/mmix-dis.c b/opcodes/mmix-dis.c
index 16eb168..af29297 100644
--- a/opcodes/mmix-dis.c
+++ b/opcodes/mmix-dis.c
@@ -1,3 +1,6 @@
+#ifdef FRCOV
+extern short FIXREVERTER[];
+#endif
 /* mmix-dis.c -- Disassemble MMIX instructions.
    Copyright (C) 2000-2021 Free Software Foundation, Inc.
    Written by Hans-Peter Nilsson (hp@bitrange.com)
@@ -288,11 +291,26 @@ print_insn_mmix (bfd_vma memaddr, struct disassemble_info *info)
 
   opcodep = get_opcode (insn);
 
-  if (opcodep == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[9233]) {
+    if ((opcodep == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 9233\n");
+    else
+      fprintf(stderr, "reached bug index 9233\n");
+  }
+  if ((!FIXREVERTER[9233] && (opcodep == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     {
       (*info->fprintf_func) (info->stream, _("*unknown*"));
       return 4;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
   (*info->fprintf_func) (info->stream, "%s ", opcodep->name);
 
diff --git a/opcodes/msp430-dis.c b/opcodes/msp430-dis.c
index 1dac644..2cc85d5 100644
--- a/opcodes/msp430-dis.c
+++ b/opcodes/msp430-dis.c
@@ -1,3 +1,6 @@
+#ifdef FRCOV
+extern short FIXREVERTER[];
+#endif
 /* Disassemble MSP430 instructions.
    Copyright (C) 2002-2021 Free Software Foundation, Inc.
 
@@ -539,8 +542,23 @@ msp430_doubleoperand (disassemble_info *info,
 		     then this is not an rla instruction.  */
 		  if (msp430dis_opcode_signed (addr + 4, info, &src, comm2))
 		    {
-		      if (src != dst)
+		      
+		      #ifdef FRCOV
+		      {if (FIXREVERTER[5820]) {
+		        if ((src != dst ) && !(0))
+		          fprintf(stderr, "triggered bug index 5820\n");
+		        else
+		          fprintf(stderr, "reached bug index 5820\n");
+		      }
+		      if ((!FIXREVERTER[5820] && (src != dst ))
+		      #else
+		      if (0
+		      #endif
+		      )
 			return 0;
+			#ifdef FRCOV
+			}
+			#endif
 		    }
 		  else
 		    return -1;
@@ -1355,7 +1373,19 @@ print_insn_msp430 (bfd_vma addr, disassemble_info *info)
 	break;
     }
 
-  if (cmd_len < 1)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[5823]) {
+    if ((cmd_len < 1 ) && !(0))
+      fprintf(stderr, "triggered bug index 5823\n");
+    else
+      fprintf(stderr, "reached bug index 5823\n");
+  }
+  if ((!FIXREVERTER[5823] && (cmd_len < 1 ))
+  #else
+  if (0
+  #endif
+  )
     {
       /* Unknown opcode, or invalid combination of operands.  */
       if (extension_word)
@@ -1368,6 +1398,9 @@ print_insn_msp430 (bfd_vma addr, disassemble_info *info)
       (*prin) (stream, ".word	0x%04x;	????", PS (insn));
       return 2;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
   /* Display the repeat count (if set) for extended register mode.  */
   if (cmd_len == 2 && ((extension_word & 0xf) != 0))
diff --git a/opcodes/mt-desc.c b/opcodes/mt-desc.c
index 72a79f6..19ba0f8 100644
--- a/opcodes/mt-desc.c
+++ b/opcodes/mt-desc.c
@@ -1,3 +1,6 @@
+#ifdef FRCOV
+extern short FIXREVERTER[];
+#endif
 /* DO NOT EDIT!  -*- buffer-read-only: t -*- vi:set ro:  */
 /* CPU data for mt.
 
@@ -1125,10 +1128,40 @@ mt_cgen_rebuild_tables (CGEN_CPU_TABLE *cd)
 	  cd->base_insn_bitsize = CGEN_SIZE_UNKNOWN;
 
 	/* Set min,max insn sizes.  */
-	if (isa->min_insn_bitsize < cd->min_insn_bitsize)
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[7450]) {
+	  if ((isa -> min_insn_bitsize < cd -> min_insn_bitsize  ) && !(0))
+	    fprintf(stderr, "triggered bug index 7450\n");
+	  else
+	    fprintf(stderr, "reached bug index 7450\n");
+	}
+	if ((!FIXREVERTER[7450] && (isa -> min_insn_bitsize < cd -> min_insn_bitsize  ))
+	#else
+	if (0
+	#endif
+	)
 	  cd->min_insn_bitsize = isa->min_insn_bitsize;
-	if (isa->max_insn_bitsize > cd->max_insn_bitsize)
+	  #ifdef FRCOV
+	  }
+	  #endif
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[7451]) {
+	  if ((isa -> max_insn_bitsize > cd -> max_insn_bitsize  ) && !(0))
+	    fprintf(stderr, "triggered bug index 7451\n");
+	  else
+	    fprintf(stderr, "reached bug index 7451\n");
+	}
+	if ((!FIXREVERTER[7451] && (isa -> max_insn_bitsize > cd -> max_insn_bitsize  ))
+	#else
+	if (0
+	#endif
+	)
 	  cd->max_insn_bitsize = isa->max_insn_bitsize;
+	  #ifdef FRCOV
+	  }
+	  #endif
       }
 
   /* Data derived from the mach spec.  */
@@ -1139,8 +1172,23 @@ mt_cgen_rebuild_tables (CGEN_CPU_TABLE *cd)
 
 	if (mach->insn_chunk_bitsize != 0)
 	{
-	  if (cd->insn_chunk_bitsize != 0 && cd->insn_chunk_bitsize != mach->insn_chunk_bitsize)
+	  
+	  #ifdef FRCOV
+	  {if (FIXREVERTER[7452]) {
+	    fprintf(stderr, "reached bug index 7452\n");
+	  }
+	  if ((FIXREVERTER[7452] && (cd -> insn_chunk_bitsize != 0 )) || (!FIXREVERTER[7452] && (cd -> insn_chunk_bitsize != 0 && cd -> insn_chunk_bitsize != mach -> insn_chunk_bitsize ))
+	  #else
+	  if (cd -> insn_chunk_bitsize != 0 
+	  #endif
+	  )
 	    {
+	      
+	    #ifdef FRCOV
+	      if (!(cd -> insn_chunk_bitsize != mach -> insn_chunk_bitsize ))
+	        fprintf(stderr, "triggered bug index 7452\n");
+	      #endif
+	    
 	      opcodes_error_handler
 		(/* xgettext:c-format */
 		 _("internal error: mt_cgen_rebuild_tables: "
@@ -1148,6 +1196,9 @@ mt_cgen_rebuild_tables (CGEN_CPU_TABLE *cd)
 		 cd->insn_chunk_bitsize, mach->insn_chunk_bitsize);
 	      abort ();
 	    }
+	    #ifdef FRCOV
+	    }
+	    #endif
 
  	  cd->insn_chunk_bitsize = mach->insn_chunk_bitsize;
 	}
@@ -1241,8 +1292,23 @@ mt_cgen_cpu_open (enum cgen_cpu_open_arg arg_type, ...)
   va_end (ap);
 
   /* Mach unspecified means "all".  */
-  if (machs == 0)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[7454]) {
+    if ((machs == 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 7454\n");
+    else
+      fprintf(stderr, "reached bug index 7454\n");
+  }
+  if ((!FIXREVERTER[7454] && (machs == 0 ))
+  #else
+  if (0
+  #endif
+  )
     machs = (1 << MAX_MACHS) - 1;
+    #ifdef FRCOV
+    }
+    #endif
   /* Base mach is always selected.  */
   machs |= 1;
   if (endian == CGEN_ENDIAN_UNKNOWN)
diff --git a/opcodes/mt-dis.c b/opcodes/mt-dis.c
index 30de527..35326d6 100644
--- a/opcodes/mt-dis.c
+++ b/opcodes/mt-dis.c
@@ -1,3 +1,6 @@
+#ifdef FRCOV
+extern short FIXREVERTER[];
+#endif
 /* DO NOT EDIT!  -*- buffer-read-only: t -*- vi:set ro:  */
 /* Disassembler interface for targets using CGEN. -*- C -*-
    CGEN: Cpu tools GENerator
@@ -709,10 +712,40 @@ print_insn_mt (bfd_vma pc, disassemble_info *info)
      but if not possible try to move this hook elsewhere rather than
      have two hooks.  */
   length = CGEN_PRINT_INSN (cd, pc, info);
-  if (length > 0)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[12239]) {
+    if ((length > 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 12239\n");
+    else
+      fprintf(stderr, "reached bug index 12239\n");
+  }
+  if ((!FIXREVERTER[12239] && (length > 0 ))
+  #else
+  if (0
+  #endif
+  )
     return length;
-  if (length < 0)
+    #ifdef FRCOV
+    }
+    #endif
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[12240]) {
+    if ((length < 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 12240\n");
+    else
+      fprintf(stderr, "reached bug index 12240\n");
+  }
+  if ((!FIXREVERTER[12240] && (length < 0 ))
+  #else
+  if (0
+  #endif
+  )
     return -1;
+    #ifdef FRCOV
+    }
+    #endif
 
   (*info->fprintf_func) (info->stream, UNKNOWN_INSN_MSG);
   return cd->default_insn_bitsize / 8;
diff --git a/opcodes/nds32-dis.c b/opcodes/nds32-dis.c
index e501f2a..88d108f 100644
--- a/opcodes/nds32-dis.c
+++ b/opcodes/nds32-dis.c
@@ -1,3 +1,6 @@
+#ifdef FRCOV
+extern short FIXREVERTER[];
+#endif
 /* NDS32-specific support for 32-bit ELF.
    Copyright (C) 2012-2021 Free Software Foundation, Inc.
    Contributed by Andes Technology Corporation.
@@ -1007,12 +1010,42 @@ print_insn_nds32 (bfd_vma pc, disassemble_info *info)
       else
 	{
 	  start = info->symtab_pos;
-	  if (start < private_data->last_symbol_index)
+	  
+	  #ifdef FRCOV
+	  {if (FIXREVERTER[4282]) {
+	    if ((start < private_data -> last_symbol_index ) && !(0))
+	      fprintf(stderr, "triggered bug index 4282\n");
+	    else
+	      fprintf(stderr, "reached bug index 4282\n");
+	  }
+	  if ((!FIXREVERTER[4282] && (start < private_data -> last_symbol_index ))
+	  #else
+	  if (0
+	  #endif
+	  )
 	    start = private_data->last_symbol_index;
+	    #ifdef FRCOV
+	    }
+	    #endif
 	}
 
-      if (0 > start)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[4283]) {
+        if ((0 > start ) && !(0))
+          fprintf(stderr, "triggered bug index 4283\n");
+        else
+          fprintf(stderr, "reached bug index 4283\n");
+      }
+      if ((!FIXREVERTER[4283] && (0 > start ))
+      #else
+      if (0
+      #endif
+      )
 	start = 0;
+	#ifdef FRCOV
+	}
+	#endif
 
       if (private_data->has_mapping_symbols != 0
 	  && ((strncmp (".text", info->section->name, 5) == 0)))
@@ -1195,8 +1228,23 @@ nds32_symbol_is_valid (asymbol *sym,
 {
   const char *name;
 
-  if (sym == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[4287]) {
+    if ((sym == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 4287\n");
+    else
+      fprintf(stderr, "reached bug index 4287\n");
+  }
+  if ((!FIXREVERTER[4287] && (sym == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     return false;
+    #ifdef FRCOV
+    }
+    #endif
 
   name = bfd_asymbol_name (sym);
 
@@ -1212,8 +1260,23 @@ nds32_add_opcode_hash_table (unsigned indx)
   opcode_t *opc;
 
   opc = nds32_opcode_table[indx];
-  if (opc == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[4288]) {
+    if ((opc == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 4288\n");
+    else
+      fprintf(stderr, "reached bug index 4288\n");
+  }
+  if ((!FIXREVERTER[4288] && (opc == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     return;
+    #ifdef FRCOV
+    }
+    #endif
 
   while (opc->opcode != NULL)
     {
diff --git a/opcodes/nfp-dis.c b/opcodes/nfp-dis.c
index b74ccb3..4f75a3e 100644
--- a/opcodes/nfp-dis.c
+++ b/opcodes/nfp-dis.c
@@ -1,3 +1,6 @@
+#ifdef FRCOV
+extern short FIXREVERTER[];
+#endif
 /* Print NFP instructions for objdump.
    Copyright (C) 2017-2021 Free Software Foundation, Inc.
    Contributed by Francois H. Theron <francois.theron@netronome.com>
@@ -1907,11 +1910,41 @@ _nfp_cmp_mnmnc (const void *arg_a, const void *arg_b)
   const nfp_cmd_mnemonic *a = arg_a;
   const nfp_cmd_mnemonic *b = arg_b;
 
-  if (a->cpp_target != b->cpp_target)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[8327]) {
+    if ((a -> cpp_target != b -> cpp_target ) && !(0))
+      fprintf(stderr, "triggered bug index 8327\n");
+    else
+      fprintf(stderr, "reached bug index 8327\n");
+  }
+  if ((!FIXREVERTER[8327] && (a -> cpp_target != b -> cpp_target ))
+  #else
+  if (0
+  #endif
+  )
     return (a->cpp_target > b->cpp_target) - (a->cpp_target < b->cpp_target);
+    #ifdef FRCOV
+    }
+    #endif
 
-  if (a->cpp_action != b->cpp_action)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[8328]) {
+    if ((a -> cpp_action != b -> cpp_action ) && !(0))
+      fprintf(stderr, "triggered bug index 8328\n");
+    else
+      fprintf(stderr, "reached bug index 8328\n");
+  }
+  if ((!FIXREVERTER[8328] && (a -> cpp_action != b -> cpp_action ))
+  #else
+  if (0
+  #endif
+  )
     return (a->cpp_action > b->cpp_action) - (a->cpp_action < b->cpp_action);
+    #ifdef FRCOV
+    }
+    #endif
 
   return (a->cpp_token > b->cpp_token) - (a->cpp_token < b->cpp_token);
 }
@@ -2546,15 +2579,45 @@ init_nfp3200_priv (nfp_priv_data * priv, struct disassemble_info *dinfo)
     {
       sec = elf_elfsections (dinfo->section->owner)[sec_idx];
 
-      if (sec->sh_type == SHT_NFP_MECONFIG)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[8333]) {
+        if ((sec -> sh_type == 1879048192 + 1 ) && !(0))
+          fprintf(stderr, "triggered bug index 8333\n");
+        else
+          fprintf(stderr, "reached bug index 8333\n");
+      }
+      if ((!FIXREVERTER[8333] && (sec -> sh_type == 1879048192 + 1 ))
+      #else
+      if (0
+      #endif
+      )
 	break;
+	#ifdef FRCOV
+	}
+	#endif
     }
 
-  if (sec_idx == sec_cnt)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[8334]) {
+    if ((sec_idx == sec_cnt ) && !(0))
+      fprintf(stderr, "triggered bug index 8334\n");
+    else
+      fprintf(stderr, "reached bug index 8334\n");
+  }
+  if ((!FIXREVERTER[8334] && (sec_idx == sec_cnt ))
+  #else
+  if (0
+  #endif
+  )
     {
       dinfo->fprintf_func (dinfo->stream, _("File has no ME-Config section."));
       return false;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
   for (roff = 0; (bfd_size_type) roff < sec->sh_size;
        roff += sec->sh_entsize, menum_linear++)
@@ -2598,8 +2661,23 @@ init_nfp6000_mecsr_sec (nfp_priv_data * priv, Elf_Internal_Shdr * sec,
   file_ptr ireg_off = 0;
   size_t isl, menum;
 
-  if (sec->sh_entsize != sizeof (ireg))
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[8337]) {
+    if ((sec -> sh_entsize != sizeof ( ireg ) ) && !(0))
+      fprintf(stderr, "triggered bug index 8337\n");
+    else
+      fprintf(stderr, "reached bug index 8337\n");
+  }
+  if ((!FIXREVERTER[8337] && (sec -> sh_entsize != sizeof ( ireg ) ))
+  #else
+  if (0
+  #endif
+  )
     return false;
+    #ifdef FRCOV
+    }
+    #endif
 
   isl = SHI_NFP_IREG_ISLAND (sec->sh_info);
 
@@ -2693,8 +2771,23 @@ init_nfp6000_priv (nfp_priv_data * priv, struct disassemble_info *dinfo)
       if (sec->sh_flags & SHF_NFP_INIT2)
 	sec_order += SHI_NFP_IREG_ORDER (~0U) + 1;
 
-      if (sec->sh_type != SHT_NFP_INITREG)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[8339]) {
+        if ((sec -> sh_type != 1879048192 + 2 ) && !(0))
+          fprintf(stderr, "triggered bug index 8339\n");
+        else
+          fprintf(stderr, "reached bug index 8339\n");
+      }
+      if ((!FIXREVERTER[8339] && (sec -> sh_type != 1879048192 + 2 ))
+      #else
+      if (0
+      #endif
+      )
 	continue;
+	#ifdef FRCOV
+	}
+	#endif
       if (!SHI_NFP_6000_IS_IREG_MECSR (sec->sh_info))
 	continue;
 
@@ -2721,8 +2814,23 @@ parse_disassembler_options (nfp_opts * opts, struct disassemble_info *dinfo)
 {
   const char *option;
 
-  if (dinfo->disassembler_options == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[8340]) {
+    if ((dinfo -> disassembler_options == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 8340\n");
+    else
+      fprintf(stderr, "reached bug index 8340\n");
+  }
+  if ((!FIXREVERTER[8340] && (dinfo -> disassembler_options == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     return 0;
+    #ifdef FRCOV
+    }
+    #endif
 
   FOR_EACH_DISASSEMBLER_OPTION (option, dinfo->disassembler_options)
   {
@@ -2953,8 +3061,23 @@ print_insn_nfp (bfd_vma addr, struct disassemble_info *dinfo)
   opts.show_pc = 1;
   opts.ctx_mode = 0;
   err = parse_disassembler_options (&opts, dinfo);
-  if (err < 0)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[8343]) {
+    if ((err < 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 8343\n");
+    else
+      fprintf(stderr, "reached bug index 8343\n");
+  }
+  if ((!FIXREVERTER[8343] && (err < 0 ))
+  #else
+  if (0
+  #endif
+  )
     goto end;
+    #ifdef FRCOV
+    }
+    #endif
 
   err = _print_instrs (addr, dinfo, &opts);
 
diff --git a/opcodes/ns32k-dis.c b/opcodes/ns32k-dis.c
index 34ef3b0..df2c708 100644
--- a/opcodes/ns32k-dis.c
+++ b/opcodes/ns32k-dis.c
@@ -1,3 +1,6 @@
+#ifdef FRCOV
+extern short FIXREVERTER[];
+#endif
 /* Print National Semiconductor 32000 instructions.
    Copyright (C) 1986-2021 Free Software Foundation, Inc.
 
@@ -265,8 +268,23 @@ bit_extract (bfd_byte *buffer, int offset, int count)
   unsigned int result;
   unsigned int bit;
 
-  if (offset < 0 || count < 0)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[7853]) {
+    if ((offset < 0 ) && !(count < 0 ))
+      fprintf(stderr, "triggered bug index 7853\n");
+    else
+      fprintf(stderr, "reached bug index 7853\n");
+  }
+  if ((FIXREVERTER[7853] && (count < 0 )) || (!FIXREVERTER[7853] && (offset < 0 || count < 0 ))
+  #else
+  if (count < 0 
+  #endif
+  )
     return 0;
+    #ifdef FRCOV
+    }
+    #endif
   buffer += offset >> 3;
   offset &= 7;
   bit = 1;
@@ -294,8 +312,23 @@ bit_extract_simple (bfd_byte *buffer, int offset, int count)
   unsigned int result;
   unsigned int bit;
 
-  if (offset < 0 || count < 0)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[7854]) {
+    if ((offset < 0 ) && !(count < 0 ))
+      fprintf(stderr, "triggered bug index 7854\n");
+    else
+      fprintf(stderr, "reached bug index 7854\n");
+  }
+  if ((FIXREVERTER[7854] && (count < 0 )) || (!FIXREVERTER[7854] && (offset < 0 || count < 0 ))
+  #else
+  if (count < 0 
+  #endif
+  )
     return 0;
+    #ifdef FRCOV
+    }
+    #endif
   buffer += offset >> 3;
   offset &= 7;
   bit = 1;
@@ -317,8 +350,23 @@ bit_extract_simple (bfd_byte *buffer, int offset, int count)
 static void
 bit_copy (bfd_byte *buffer, int offset, int count, char *to)
 {
-  if (offset < 0 || count < 0)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[7855]) {
+    if ((offset < 0 ) && !(count < 0 ))
+      fprintf(stderr, "triggered bug index 7855\n");
+    else
+      fprintf(stderr, "reached bug index 7855\n");
+  }
+  if ((FIXREVERTER[7855] && (count < 0 )) || (!FIXREVERTER[7855] && (offset < 0 || count < 0 ))
+  #else
+  if (count < 0 
+  #endif
+  )
     return;
+    #ifdef FRCOV
+    }
+    #endif
   for (; count > 8; count -= 8, to++, offset += 8)
     *to = bit_extract (buffer, offset, 8);
   *to = bit_extract (buffer, offset, count);
diff --git a/opcodes/or1k-desc.c b/opcodes/or1k-desc.c
index 2de74d5..c073bc2 100644
--- a/opcodes/or1k-desc.c
+++ b/opcodes/or1k-desc.c
@@ -1,3 +1,6 @@
+#ifdef FRCOV
+extern short FIXREVERTER[];
+#endif
 /* DO NOT EDIT!  -*- buffer-read-only: t -*- vi:set ro:  */
 /* CPU data for or1k.
 
@@ -2019,10 +2022,40 @@ or1k_cgen_rebuild_tables (CGEN_CPU_TABLE *cd)
 	  cd->base_insn_bitsize = CGEN_SIZE_UNKNOWN;
 
 	/* Set min,max insn sizes.  */
-	if (isa->min_insn_bitsize < cd->min_insn_bitsize)
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[3457]) {
+	  if ((isa -> min_insn_bitsize < cd -> min_insn_bitsize  ) && !(0))
+	    fprintf(stderr, "triggered bug index 3457\n");
+	  else
+	    fprintf(stderr, "reached bug index 3457\n");
+	}
+	if ((!FIXREVERTER[3457] && (isa -> min_insn_bitsize < cd -> min_insn_bitsize  ))
+	#else
+	if (0
+	#endif
+	)
 	  cd->min_insn_bitsize = isa->min_insn_bitsize;
-	if (isa->max_insn_bitsize > cd->max_insn_bitsize)
+	  #ifdef FRCOV
+	  }
+	  #endif
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[3458]) {
+	  if ((isa -> max_insn_bitsize > cd -> max_insn_bitsize  ) && !(0))
+	    fprintf(stderr, "triggered bug index 3458\n");
+	  else
+	    fprintf(stderr, "reached bug index 3458\n");
+	}
+	if ((!FIXREVERTER[3458] && (isa -> max_insn_bitsize > cd -> max_insn_bitsize  ))
+	#else
+	if (0
+	#endif
+	)
 	  cd->max_insn_bitsize = isa->max_insn_bitsize;
+	  #ifdef FRCOV
+	  }
+	  #endif
       }
 
   /* Data derived from the mach spec.  */
@@ -2033,8 +2066,23 @@ or1k_cgen_rebuild_tables (CGEN_CPU_TABLE *cd)
 
 	if (mach->insn_chunk_bitsize != 0)
 	{
-	  if (cd->insn_chunk_bitsize != 0 && cd->insn_chunk_bitsize != mach->insn_chunk_bitsize)
+	  
+	  #ifdef FRCOV
+	  {if (FIXREVERTER[3459]) {
+	    fprintf(stderr, "reached bug index 3459\n");
+	  }
+	  if ((FIXREVERTER[3459] && (cd -> insn_chunk_bitsize != 0 )) || (!FIXREVERTER[3459] && (cd -> insn_chunk_bitsize != 0 && cd -> insn_chunk_bitsize != mach -> insn_chunk_bitsize ))
+	  #else
+	  if (cd -> insn_chunk_bitsize != 0 
+	  #endif
+	  )
 	    {
+	      
+	    #ifdef FRCOV
+	      if (!(cd -> insn_chunk_bitsize != mach -> insn_chunk_bitsize ))
+	        fprintf(stderr, "triggered bug index 3459\n");
+	      #endif
+	    
 	      opcodes_error_handler
 		(/* xgettext:c-format */
 		 _("internal error: or1k_cgen_rebuild_tables: "
@@ -2042,6 +2090,9 @@ or1k_cgen_rebuild_tables (CGEN_CPU_TABLE *cd)
 		 cd->insn_chunk_bitsize, mach->insn_chunk_bitsize);
 	      abort ();
 	    }
+	    #ifdef FRCOV
+	    }
+	    #endif
 
  	  cd->insn_chunk_bitsize = mach->insn_chunk_bitsize;
 	}
@@ -2135,8 +2186,23 @@ or1k_cgen_cpu_open (enum cgen_cpu_open_arg arg_type, ...)
   va_end (ap);
 
   /* Mach unspecified means "all".  */
-  if (machs == 0)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[3461]) {
+    if ((machs == 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 3461\n");
+    else
+      fprintf(stderr, "reached bug index 3461\n");
+  }
+  if ((!FIXREVERTER[3461] && (machs == 0 ))
+  #else
+  if (0
+  #endif
+  )
     machs = (1 << MAX_MACHS) - 1;
+    #ifdef FRCOV
+    }
+    #endif
   /* Base mach is always selected.  */
   machs |= 1;
   if (endian == CGEN_ENDIAN_UNKNOWN)
diff --git a/opcodes/or1k-dis.c b/opcodes/or1k-dis.c
index 6684404..7f4b5b8 100644
--- a/opcodes/or1k-dis.c
+++ b/opcodes/or1k-dis.c
@@ -1,3 +1,6 @@
+#ifdef FRCOV
+extern short FIXREVERTER[];
+#endif
 /* DO NOT EDIT!  -*- buffer-read-only: t -*- vi:set ro:  */
 /* Disassembler interface for targets using CGEN. -*- C -*-
    CGEN: Cpu tools GENerator
@@ -593,10 +596,40 @@ print_insn_or1k (bfd_vma pc, disassemble_info *info)
      but if not possible try to move this hook elsewhere rather than
      have two hooks.  */
   length = CGEN_PRINT_INSN (cd, pc, info);
-  if (length > 0)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[3715]) {
+    if ((length > 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 3715\n");
+    else
+      fprintf(stderr, "reached bug index 3715\n");
+  }
+  if ((!FIXREVERTER[3715] && (length > 0 ))
+  #else
+  if (0
+  #endif
+  )
     return length;
-  if (length < 0)
+    #ifdef FRCOV
+    }
+    #endif
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[3716]) {
+    if ((length < 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 3716\n");
+    else
+      fprintf(stderr, "reached bug index 3716\n");
+  }
+  if ((!FIXREVERTER[3716] && (length < 0 ))
+  #else
+  if (0
+  #endif
+  )
     return -1;
+    #ifdef FRCOV
+    }
+    #endif
 
   (*info->fprintf_func) (info->stream, UNKNOWN_INSN_MSG);
   return cd->default_insn_bitsize / 8;
diff --git a/opcodes/ppc-dis.c b/opcodes/ppc-dis.c
index 739195a..0e534fa 100644
--- a/opcodes/ppc-dis.c
+++ b/opcodes/ppc-dis.c
@@ -1,3 +1,6 @@
+#ifdef FRCOV
+extern short FIXREVERTER[];
+#endif
 /* ppc-dis.c -- Disassemble PowerPC instructions
    Copyright (C) 1994-2021 Free Software Foundation, Inc.
    Written by Ian Lance Taylor, Cygnus Support
@@ -312,8 +315,23 @@ ppc_parse_cpu (ppc_cpu_t ppc_cpu, ppc_cpu_t *sticky, const char *arg)
 	ppc_cpu = ppc_opts[i].cpu;
 	break;
       }
-  if (i >= ARRAY_SIZE (ppc_opts))
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[6160]) {
+    if ((i >= sizeof ( ppc_opts ) / sizeof ( ppc_opts [ 0 ] ) ) && !(0))
+      fprintf(stderr, "triggered bug index 6160\n");
+    else
+      fprintf(stderr, "reached bug index 6160\n");
+  }
+  if ((!FIXREVERTER[6160] && (i >= sizeof ( ppc_opts ) / sizeof ( ppc_opts [ 0 ] ) ))
+  #else
+  if (0
+  #endif
+  )
     return 0;
+    #ifdef FRCOV
+    }
+    #endif
 
   ppc_cpu |= *sticky;
   return ppc_cpu;
@@ -328,8 +346,23 @@ powerpc_init_dialect (struct disassemble_info *info)
   ppc_cpu_t sticky = 0;
   struct dis_private *priv = calloc (sizeof (*priv), 1);
 
-  if (priv == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[6161]) {
+    if ((priv == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 6161\n");
+    else
+      fprintf(stderr, "reached bug index 6161\n");
+  }
+  if ((!FIXREVERTER[6161] && (priv == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     return;
+    #ifdef FRCOV
+    }
+    #endif
 
   switch (info->mach)
     {
@@ -415,8 +448,23 @@ ppc_symbol_is_valid (asymbol *sym,
 {
   elf_symbol_type * est;
 
-  if (sym == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[6166]) {
+    if ((sym == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 6166\n");
+    else
+      fprintf(stderr, "reached bug index 6166\n");
+  }
+  if ((!FIXREVERTER[6166] && (sym == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     return false;
+    #ifdef FRCOV
+    }
+    #endif
 
   est = elf_symbol_from (sym);
 
@@ -928,8 +976,23 @@ print_insn_powerpc (bfd_vma memaddr,
     {
       if ((dialect & PPC_OPCODE_SPE2) != 0)
 	opcode = lookup_spe2 (insn);
-      if (opcode == NULL)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[6173]) {
+        if ((opcode == (void *) 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 6173\n");
+        else
+          fprintf(stderr, "reached bug index 6173\n");
+      }
+      if ((!FIXREVERTER[6173] && (opcode == (void *) 0 ))
+      #else
+      if (0
+      #endif
+      )
 	opcode = lookup_powerpc (insn, dialect & ~PPC_OPCODE_ANY);
+	#ifdef FRCOV
+	}
+	#endif
       if (opcode == NULL && (dialect & PPC_OPCODE_ANY) != 0)
 	opcode = lookup_powerpc (insn, dialect);
     }
diff --git a/opcodes/riscv-dis.c b/opcodes/riscv-dis.c
index 025d134..51170ec 100644
--- a/opcodes/riscv-dis.c
+++ b/opcodes/riscv-dis.c
@@ -1,3 +1,6 @@
+#ifdef FRCOV
+extern short FIXREVERTER[];
+#endif
 /* RISC-V disassembler
    Copyright (C) 2011-2021 Free Software Foundation, Inc.
 
@@ -79,12 +82,27 @@ parse_riscv_dis_option (const char *option)
     return;
 
   equal = strchr (option, '=');
-  if (equal == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[12275]) {
+    if ((equal == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 12275\n");
+    else
+      fprintf(stderr, "reached bug index 12275\n");
+  }
+  if ((!FIXREVERTER[12275] && (equal == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     {
       /* The option without '=' should be defined above.  */
       opcodes_error_handler (_("unrecognized disassembler option: %s"), option);
       return;
     }
+    #ifdef FRCOV
+    }
+    #endif
   if (equal == option
       || *(equal + 1) == '\0')
     {
diff --git a/opcodes/rx-dis.c b/opcodes/rx-dis.c
index ef04ff8..dea3311 100644
--- a/opcodes/rx-dis.c
+++ b/opcodes/rx-dis.c
@@ -1,3 +1,6 @@
+#ifdef FRCOV
+extern short FIXREVERTER[];
+#endif
 /* Disassembler code for Renesas RX.
    Copyright (C) 2008-2021 Free Software Foundation, Inc.
    Contributed by Red Hat.
@@ -134,80 +137,230 @@ static const char * double_condition_names[] =
 static inline const char *
 get_register_name (unsigned int reg)
 {
-  if (reg < ARRAY_SIZE (register_names))
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[12212]) {
+    if ((reg < sizeof ( register_names ) / sizeof ( register_names [ 0 ] ) ) && !(0))
+      fprintf(stderr, "triggered bug index 12212\n");
+    else
+      fprintf(stderr, "reached bug index 12212\n");
+  }
+  if ((!FIXREVERTER[12212] && (reg < sizeof ( register_names ) / sizeof ( register_names [ 0 ] ) ))
+  #else
+  if (0
+  #endif
+  )
     return register_names[reg];
+    #ifdef FRCOV
+    }
+    #endif
   return _("<invalid register number>");
 }
 
 static inline const char *
 get_condition_name (unsigned int cond)
 {
-  if (cond < ARRAY_SIZE (condition_names))
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[12213]) {
+    if ((cond < sizeof ( condition_names ) / sizeof ( condition_names [ 0 ] ) ) && !(0))
+      fprintf(stderr, "triggered bug index 12213\n");
+    else
+      fprintf(stderr, "reached bug index 12213\n");
+  }
+  if ((!FIXREVERTER[12213] && (cond < sizeof ( condition_names ) / sizeof ( condition_names [ 0 ] ) ))
+  #else
+  if (0
+  #endif
+  )
     return condition_names[cond];
+    #ifdef FRCOV
+    }
+    #endif
   return _("<invalid condition code>");
 }
 
 static inline const char *
 get_flag_name (unsigned int flag)
 {
-  if (flag < ARRAY_SIZE (flag_names))
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[12214]) {
+    if ((flag < sizeof ( flag_names ) / sizeof ( flag_names [ 0 ] ) ) && !(0))
+      fprintf(stderr, "triggered bug index 12214\n");
+    else
+      fprintf(stderr, "reached bug index 12214\n");
+  }
+  if ((!FIXREVERTER[12214] && (flag < sizeof ( flag_names ) / sizeof ( flag_names [ 0 ] ) ))
+  #else
+  if (0
+  #endif
+  )
     return flag_names[flag];
+    #ifdef FRCOV
+    }
+    #endif
   return _("<invalid flag>");
 }
 
 static inline const char *
 get_double_register_name (unsigned int reg)
 {
-  if (reg < ARRAY_SIZE (double_register_names))
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[12215]) {
+    if ((reg < sizeof ( double_register_names ) / sizeof ( double_register_names [ 0 ] ) ) && !(0))
+      fprintf(stderr, "triggered bug index 12215\n");
+    else
+      fprintf(stderr, "reached bug index 12215\n");
+  }
+  if ((!FIXREVERTER[12215] && (reg < sizeof ( double_register_names ) / sizeof ( double_register_names [ 0 ] ) ))
+  #else
+  if (0
+  #endif
+  )
     return double_register_names[reg];
+    #ifdef FRCOV
+    }
+    #endif
   return _("<invalid register number>");
 }
 
 static inline const char *
 get_double_register_high_name (unsigned int reg)
 {
-  if (reg < ARRAY_SIZE (double_register_high_names))
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[12216]) {
+    if ((reg < sizeof ( double_register_high_names ) / sizeof ( double_register_high_names [ 0 ] ) ) && !(0))
+      fprintf(stderr, "triggered bug index 12216\n");
+    else
+      fprintf(stderr, "reached bug index 12216\n");
+  }
+  if ((!FIXREVERTER[12216] && (reg < sizeof ( double_register_high_names ) / sizeof ( double_register_high_names [ 0 ] ) ))
+  #else
+  if (0
+  #endif
+  )
     return double_register_high_names[reg];
+    #ifdef FRCOV
+    }
+    #endif
   return _("<invalid register number>");
 }
 
 static inline const char *
 get_double_register_low_name (unsigned int reg)
 {
-  if (reg < ARRAY_SIZE (double_register_low_names))
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[12217]) {
+    if ((reg < sizeof ( double_register_low_names ) / sizeof ( double_register_low_names [ 0 ] ) ) && !(0))
+      fprintf(stderr, "triggered bug index 12217\n");
+    else
+      fprintf(stderr, "reached bug index 12217\n");
+  }
+  if ((!FIXREVERTER[12217] && (reg < sizeof ( double_register_low_names ) / sizeof ( double_register_low_names [ 0 ] ) ))
+  #else
+  if (0
+  #endif
+  )
     return double_register_low_names[reg];
+    #ifdef FRCOV
+    }
+    #endif
   return _("<invalid register number>");
 }
 
 static inline const char *
 get_double_control_register_name (unsigned int reg)
 {
-  if (reg < ARRAY_SIZE (double_control_register_names))
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[12218]) {
+    if ((reg < sizeof ( double_control_register_names ) / sizeof ( double_control_register_names [ 0 ] ) ) && !(0))
+      fprintf(stderr, "triggered bug index 12218\n");
+    else
+      fprintf(stderr, "reached bug index 12218\n");
+  }
+  if ((!FIXREVERTER[12218] && (reg < sizeof ( double_control_register_names ) / sizeof ( double_control_register_names [ 0 ] ) ))
+  #else
+  if (0
+  #endif
+  )
     return double_control_register_names[reg];
+    #ifdef FRCOV
+    }
+    #endif
   return _("<invalid register number>");
 }
 
 static inline const char *
 get_double_condition_name (unsigned int cond)
 {
-  if (cond < ARRAY_SIZE (double_condition_names))
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[12219]) {
+    if ((cond < sizeof ( double_condition_names ) / sizeof ( double_condition_names [ 0 ] ) ) && !(0))
+      fprintf(stderr, "triggered bug index 12219\n");
+    else
+      fprintf(stderr, "reached bug index 12219\n");
+  }
+  if ((!FIXREVERTER[12219] && (cond < sizeof ( double_condition_names ) / sizeof ( double_condition_names [ 0 ] ) ))
+  #else
+  if (0
+  #endif
+  )
     return double_condition_names[cond];
+    #ifdef FRCOV
+    }
+    #endif
   return _("<invalid condition code>");
 }
 
 static inline const char *
 get_opsize_name (unsigned int opsize)
 {
-  if (opsize < ARRAY_SIZE (opsize_names))
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[12220]) {
+    if ((opsize < sizeof ( opsize_names ) / sizeof ( opsize_names [ 0 ] ) ) && !(0))
+      fprintf(stderr, "triggered bug index 12220\n");
+    else
+      fprintf(stderr, "reached bug index 12220\n");
+  }
+  if ((!FIXREVERTER[12220] && (opsize < sizeof ( opsize_names ) / sizeof ( opsize_names [ 0 ] ) ))
+  #else
+  if (0
+  #endif
+  )
     return opsize_names[opsize];
+    #ifdef FRCOV
+    }
+    #endif
   return _("<invalid opsize>");
 }
 
 static inline const char *
 get_size_name (unsigned int size)
 {
-  if (size < ARRAY_SIZE (size_names))
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[12221]) {
+    if ((size < sizeof ( size_names ) / sizeof ( size_names [ 0 ] ) ) && !(0))
+      fprintf(stderr, "triggered bug index 12221\n");
+    else
+      fprintf(stderr, "reached bug index 12221\n");
+  }
+  if ((!FIXREVERTER[12221] && (size < sizeof ( size_names ) / sizeof ( size_names [ 0 ] ) ))
+  #else
+  if (0
+  #endif
+  )
     return size_names[size];
+    #ifdef FRCOV
+    }
+    #endif
   return _("<invalid size>");
 }
 
diff --git a/opcodes/s12z-opc.c b/opcodes/s12z-opc.c
index 5453305..150e334 100644
--- a/opcodes/s12z-opc.c
+++ b/opcodes/s12z-opc.c
@@ -1,3 +1,6 @@
+#ifdef FRCOV
+extern short FIXREVERTER[];
+#endif
 /* s12z-decode.c -- Freescale S12Z disassembly
    Copyright (C) 2018-2021 Free Software Foundation, Inc.
 
@@ -108,8 +111,23 @@ x_opr_n_bytes (struct mem_read_abstraction_base *mra, int offset)
 {
   bfd_byte xb;
   int status = mra->read (mra, offset, 1, &xb);
-  if (status < 0)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[2203]) {
+    if ((status < 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 2203\n");
+    else
+      fprintf(stderr, "reached bug index 2203\n");
+  }
+  if ((!FIXREVERTER[2203] && (status < 0 ))
+  #else
+  if (0
+  #endif
+  )
     return status;
+    #ifdef FRCOV
+    }
+    #endif
 
   size_t i;
   for (i = 0; i < sizeof (opr_pb) / sizeof (opr_pb[0]); ++i)
@@ -128,8 +146,23 @@ static int
 opr_n_bytes_p1 (struct mem_read_abstraction_base *mra)
 {
   int n = x_opr_n_bytes (mra, 0);
-  if (n < 0)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[2204]) {
+    if ((n < 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 2204\n");
+    else
+      fprintf(stderr, "reached bug index 2204\n");
+  }
+  if ((!FIXREVERTER[2204] && (n < 0 ))
+  #else
+  if (0
+  #endif
+  )
     return n;
+    #ifdef FRCOV
+    }
+    #endif
   return 1 + n;
 }
 
@@ -137,11 +170,41 @@ static int
 opr_n_bytes2 (struct mem_read_abstraction_base *mra)
 {
   int s = x_opr_n_bytes (mra, 0);
-  if (s < 0)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[2205]) {
+    if ((s < 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 2205\n");
+    else
+      fprintf(stderr, "reached bug index 2205\n");
+  }
+  if ((!FIXREVERTER[2205] && (s < 0 ))
+  #else
+  if (0
+  #endif
+  )
     return s;
+    #ifdef FRCOV
+    }
+    #endif
   int n = x_opr_n_bytes (mra, s);
-  if (n < 0)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[2206]) {
+    if ((n < 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 2206\n");
+    else
+      fprintf(stderr, "reached bug index 2206\n");
+  }
+  if ((!FIXREVERTER[2206] && (n < 0 ))
+  #else
+  if (0
+  #endif
+  )
     return n;
+    #ifdef FRCOV
+    }
+    #endif
   return s + n + 1;
 }
 
@@ -179,8 +242,23 @@ bfextins_n_bytes (struct mem_read_abstraction_base *mra)
 {
   bfd_byte bb;
   int status = mra->read (mra, 0, 1, &bb);
-  if (status < 0)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[2208]) {
+    if ((status < 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 2208\n");
+    else
+      fprintf(stderr, "reached bug index 2208\n");
+  }
+  if ((!FIXREVERTER[2208] && (status < 0 ))
+  #else
+  if (0
+  #endif
+  )
     return status;
+    #ifdef FRCOV
+    }
+    #endif
 
   size_t i;
   const struct opr_bb *bbs = 0;
@@ -197,8 +275,23 @@ bfextins_n_bytes (struct mem_read_abstraction_base *mra)
   if (bbs->opr)
     {
       int x = x_opr_n_bytes (mra, n - 1);
-      if (x < 0)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[2209]) {
+        if ((x < 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 2209\n");
+        else
+          fprintf(stderr, "reached bug index 2209\n");
+      }
+      if ((!FIXREVERTER[2209] && (x < 0 ))
+      #else
+      if (0
+      #endif
+      )
 	return x;
+	#ifdef FRCOV
+	}
+	#endif
       n += x;
     }
 
@@ -240,8 +333,23 @@ pcrel_15bit (struct mem_read_abstraction_base *mra)
 {
   bfd_byte byte;
   int status = mra->read (mra, 0, 1, &byte);
-  if (status < 0)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[2210]) {
+    if ((status < 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 2210\n");
+    else
+      fprintf(stderr, "reached bug index 2210\n");
+  }
+  if ((!FIXREVERTER[2210] && (status < 0 ))
+  #else
+  if (0
+  #endif
+  )
     return status;
+    #ifdef FRCOV
+    }
+    #endif
   return (byte & 0x80) ? 3 : 2;
 }
 
@@ -421,8 +529,23 @@ z_ext24_decode (struct mem_read_abstraction_base *mra, int *n_operands,
     }
 
   op = create_simple_memory_operand (addr, 0, false);
-  if (op == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[2213]) {
+    if ((op == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 2213\n");
+    else
+      fprintf(stderr, "reached bug index 2213\n");
+  }
+  if ((!FIXREVERTER[2213] && (op == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     return -1;
+    #ifdef FRCOV
+    }
+    #endif
   operand[(*n_operands)++] = op;
   return 0;
 }
@@ -472,8 +595,23 @@ x_imm1 (struct mem_read_abstraction_base *mra,
     return status;
 
   op = create_immediate_operand (byte);
-  if (op == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[2217]) {
+    if ((op == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 2217\n");
+    else
+      fprintf(stderr, "reached bug index 2217\n");
+  }
+  if ((!FIXREVERTER[2217] && (op == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     return -1;
+    #ifdef FRCOV
+    }
+    #endif
   operand[(*n_operands)++] = op;
   return 0;
 }
@@ -775,8 +913,23 @@ x_opr_decode_with_size (struct mem_read_abstraction_base *mra, int offset,
       abort ();
     }
 
-  if (operand != NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[2236]) {
+    if ((operand != (void *) 0  ) && !(0))
+      fprintf(stderr, "triggered bug index 2236\n");
+    else
+      fprintf(stderr, "reached bug index 2236\n");
+  }
+  if ((!FIXREVERTER[2236] && (operand != (void *) 0  ))
+  #else
+  if (0
+  #endif
+  )
     operand->osize = osize;
+    #ifdef FRCOV
+    }
+    #endif
 
   return operand;
 }
@@ -792,8 +945,23 @@ z_opr_decode (struct mem_read_abstraction_base *mra,
 	      int *n_operands, struct operand **operand)
 {
   struct operand *op = x_opr_decode (mra, 0);
-  if (op == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[2237]) {
+    if ((op == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 2237\n");
+    else
+      fprintf(stderr, "reached bug index 2237\n");
+  }
+  if ((!FIXREVERTER[2237] && (op == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     return -1;
+    #ifdef FRCOV
+    }
+    #endif
   operand[(*n_operands)++] = op;
   return 0;
 }
@@ -806,12 +974,42 @@ z_opr_decode2 (struct mem_read_abstraction_base *mra,
   if (n < 0)
     return n;
   struct operand *op = x_opr_decode (mra, 0);
-  if (op == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[2239]) {
+    if ((op == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 2239\n");
+    else
+      fprintf(stderr, "reached bug index 2239\n");
+  }
+  if ((!FIXREVERTER[2239] && (op == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     return -1;
+    #ifdef FRCOV
+    }
+    #endif
   operand[(*n_operands)++] = op;
   op = x_opr_decode (mra, n);
-  if (op == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[2240]) {
+    if ((op == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 2240\n");
+    else
+      fprintf(stderr, "reached bug index 2240\n");
+  }
+  if ((!FIXREVERTER[2240] && (op == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     return -1;
+    #ifdef FRCOV
+    }
+    #endif
   operand[(*n_operands)++] = op;
   return 0;
 }
@@ -835,8 +1033,23 @@ imm1234 (struct mem_read_abstraction_base *mra, int base,
     return -1;
 
   op = create_immediate_operand (imm);
-  if (op == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[2242]) {
+    if ((op == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 2242\n");
+    else
+      fprintf(stderr, "reached bug index 2242\n");
+  }
+  if ((!FIXREVERTER[2242] && (op == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     return -1;
+    #ifdef FRCOV
+    }
+    #endif
   operand[(*n_operands)++] = op;
   return 0;
 }
@@ -850,16 +1063,46 @@ reg_s_imm (struct mem_read_abstraction_base *mra, int *n_operands,
   struct operand *op;
 
   op = create_register_operand (REG_S);
-  if (op == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[2243]) {
+    if ((op == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 2243\n");
+    else
+      fprintf(stderr, "reached bug index 2243\n");
+  }
+  if ((!FIXREVERTER[2243] && (op == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     return -1;
+    #ifdef FRCOV
+    }
+    #endif
   operand[(*n_operands)++] = op;
 
   uint32_t imm;
   if (decode_signed_value (mra, 3, &imm) < 0)
     return -1;
   op = create_immediate_operand (imm);
-  if (op == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[2244]) {
+    if ((op == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 2244\n");
+    else
+      fprintf(stderr, "reached bug index 2244\n");
+  }
+  if ((!FIXREVERTER[2244] && (op == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     return -1;
+    #ifdef FRCOV
+    }
+    #endif
   operand[(*n_operands)++] = op;
   return 0;
 }
@@ -872,12 +1115,42 @@ reg_s_opr (struct mem_read_abstraction_base *mra, int *n_operands,
   struct operand *op;
 
   op = create_register_operand (REG_S);
-  if (op == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[2245]) {
+    if ((op == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 2245\n");
+    else
+      fprintf(stderr, "reached bug index 2245\n");
+  }
+  if ((!FIXREVERTER[2245] && (op == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     return -1;
+    #ifdef FRCOV
+    }
+    #endif
   operand[(*n_operands)++] = op;
   op = x_opr_decode (mra, 0);
-  if (op == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[2246]) {
+    if ((op == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 2246\n");
+    else
+      fprintf(stderr, "reached bug index 2246\n");
+  }
+  if ((!FIXREVERTER[2246] && (op == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     return -1;
+    #ifdef FRCOV
+    }
+    #endif
   operand[(*n_operands)++] = op;
   return 0;
 }
@@ -908,12 +1181,42 @@ z_tfr (struct mem_read_abstraction_base *mra, int *n_operands,
     return status;
 
   op = create_register_operand (byte >> 4);
-  if (op == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[2248]) {
+    if ((op == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 2248\n");
+    else
+      fprintf(stderr, "reached bug index 2248\n");
+  }
+  if ((!FIXREVERTER[2248] && (op == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     return -1;
+    #ifdef FRCOV
+    }
+    #endif
   operand[(*n_operands)++] = op;
   op = create_register_operand (byte & 0x0F);
-  if (op == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[2249]) {
+    if ((op == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 2249\n");
+    else
+      fprintf(stderr, "reached bug index 2249\n");
+  }
+  if ((!FIXREVERTER[2249] && (op == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     return -1;
+    #ifdef FRCOV
+    }
+    #endif
   operand[(*n_operands)++] = op;
   return 0;
 }
@@ -929,8 +1232,23 @@ z_reg (struct mem_read_abstraction_base *mra, int *n_operands,
     return status;
 
   op = create_register_operand (byte & 0x07);
-  if (op == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[2251]) {
+    if ((op == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 2251\n");
+    else
+      fprintf(stderr, "reached bug index 2251\n");
+  }
+  if ((!FIXREVERTER[2251] && (op == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     return -1;
+    #ifdef FRCOV
+    }
+    #endif
   operand[(*n_operands)++] = op;
   return 0;
 }
@@ -947,8 +1265,23 @@ reg_xy (struct mem_read_abstraction_base *mra,
     return status;
 
   op = create_register_operand ((byte & 0x01) ? REG_Y : REG_X);
-  if (op == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[2253]) {
+    if ((op == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 2253\n");
+    else
+      fprintf(stderr, "reached bug index 2253\n");
+  }
+  if ((!FIXREVERTER[2253] && (op == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     return -1;
+    #ifdef FRCOV
+    }
+    #endif
   operand[(*n_operands)++] = op;
   return 0;
 }
@@ -978,12 +1311,42 @@ lea_reg_xys_opr (struct mem_read_abstraction_base *mra,
     }
 
   op = create_register_operand (reg_xys);
-  if (op == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[2255]) {
+    if ((op == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 2255\n");
+    else
+      fprintf(stderr, "reached bug index 2255\n");
+  }
+  if ((!FIXREVERTER[2255] && (op == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     return -1;
+    #ifdef FRCOV
+    }
+    #endif
   operand[(*n_operands)++] = op;
   op = x_opr_decode (mra, 0);
-  if (op == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[2256]) {
+    if ((op == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 2256\n");
+    else
+      fprintf(stderr, "reached bug index 2256\n");
+  }
+  if ((!FIXREVERTER[2256] && (op == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     return -1;
+    #ifdef FRCOV
+    }
+    #endif
   operand[(*n_operands)++] = op;
   return 0;
 }
@@ -1017,12 +1380,42 @@ lea_reg_xys (struct mem_read_abstraction_base *mra,
     return status;
 
   op = create_register_operand (reg_n);
-  if (op == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[2259]) {
+    if ((op == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 2259\n");
+    else
+      fprintf(stderr, "reached bug index 2259\n");
+  }
+  if ((!FIXREVERTER[2259] && (op == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     return -1;
+    #ifdef FRCOV
+    }
+    #endif
   operand[(*n_operands)++] = op;
   op = create_memory_operand (false, (int8_t) byte, 1, reg_n, -1);
-  if (op == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[2260]) {
+    if ((op == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 2260\n");
+    else
+      fprintf(stderr, "reached bug index 2260\n");
+  }
+  if ((!FIXREVERTER[2260] && (op == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     return -1;
+    #ifdef FRCOV
+    }
+    #endif
   operand[(*n_operands)++] = op;
   return 0;
 }
@@ -1069,8 +1462,23 @@ rel_15_7 (struct mem_read_abstraction_base *mra, int offset,
     }
 
   op = create_simple_memory_operand (addr, mra->posn (mra) - 1, true);
-  if (op == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[2263]) {
+    if ((op == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 2263\n");
+    else
+      fprintf(stderr, "reached bug index 2263\n");
+  }
+  if ((!FIXREVERTER[2263] && (op == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     return -1;
+    #ifdef FRCOV
+    }
+    #endif
   operands[(*n_operands)++] = op;
   return 0;
 }
@@ -1117,12 +1525,42 @@ cmp_xy (struct mem_read_abstraction_base *mra ATTRIBUTE_UNUSED,
   struct operand *op;
 
   op = create_register_operand (REG_X);
-  if (op == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[2264]) {
+    if ((op == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 2264\n");
+    else
+      fprintf(stderr, "reached bug index 2264\n");
+  }
+  if ((!FIXREVERTER[2264] && (op == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     return -1;
+    #ifdef FRCOV
+    }
+    #endif
   operand[(*n_operands)++] = op;
   op = create_register_operand (REG_Y);
-  if (op == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[2265]) {
+    if ((op == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 2265\n");
+    else
+      fprintf(stderr, "reached bug index 2265\n");
+  }
+  if ((!FIXREVERTER[2265] && (op == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     return -1;
+    #ifdef FRCOV
+    }
+    #endif
   operand[(*n_operands)++] = op;
   return 0;
 }
@@ -1134,16 +1572,61 @@ sub_d6_x_y (struct mem_read_abstraction_base *mra ATTRIBUTE_UNUSED,
   struct operand *op;
 
   op = create_register_operand (REG_D6);
-  if (op == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[2266]) {
+    if ((op == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 2266\n");
+    else
+      fprintf(stderr, "reached bug index 2266\n");
+  }
+  if ((!FIXREVERTER[2266] && (op == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     return -1;
+    #ifdef FRCOV
+    }
+    #endif
   operand[(*n_operands)++] = op;
   op = create_register_operand (REG_X);
-  if (op == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[2267]) {
+    if ((op == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 2267\n");
+    else
+      fprintf(stderr, "reached bug index 2267\n");
+  }
+  if ((!FIXREVERTER[2267] && (op == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     return -1;
+    #ifdef FRCOV
+    }
+    #endif
   operand[(*n_operands)++] = op;
   op = create_register_operand (REG_Y);
-  if (op == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[2268]) {
+    if ((op == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 2268\n");
+    else
+      fprintf(stderr, "reached bug index 2268\n");
+  }
+  if ((!FIXREVERTER[2268] && (op == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     return -1;
+    #ifdef FRCOV
+    }
+    #endif
   operand[(*n_operands)++] = op;
   return 0;
 }
@@ -1155,16 +1638,61 @@ sub_d6_y_x (struct mem_read_abstraction_base *mra ATTRIBUTE_UNUSED,
   struct operand *op;
 
   op = create_register_operand (REG_D6);
-  if (op == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[2269]) {
+    if ((op == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 2269\n");
+    else
+      fprintf(stderr, "reached bug index 2269\n");
+  }
+  if ((!FIXREVERTER[2269] && (op == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     return -1;
+    #ifdef FRCOV
+    }
+    #endif
   operand[(*n_operands)++] = op;
   op = create_register_operand (REG_Y);
-  if (op == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[2270]) {
+    if ((op == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 2270\n");
+    else
+      fprintf(stderr, "reached bug index 2270\n");
+  }
+  if ((!FIXREVERTER[2270] && (op == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     return -1;
+    #ifdef FRCOV
+    }
+    #endif
   operand[(*n_operands)++] = op;
   op = create_register_operand (REG_X);
-  if (op == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[2271]) {
+    if ((op == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 2271\n");
+    else
+      fprintf(stderr, "reached bug index 2271\n");
+  }
+  if ((!FIXREVERTER[2271] && (op == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     return -1;
+    #ifdef FRCOV
+    }
+    #endif
   operand[(*n_operands)++] = op;
   return 0;
 }
@@ -1817,8 +2345,23 @@ mul_decode (struct mem_read_abstraction_base *mra,
 	}
     }
   op = create_register_operand (byte & 0x07);
-  if (op == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[2280]) {
+    if ((op == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 2280\n");
+    else
+      fprintf(stderr, "reached bug index 2280\n");
+  }
+  if ((!FIXREVERTER[2280] && (op == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     return -1;
+    #ifdef FRCOV
+    }
+    #endif
   operand[(*n_operands)++] = op;
 
   switch (mode)
@@ -1827,37 +2370,127 @@ mul_decode (struct mem_read_abstraction_base *mra,
       {
 	int size = (mb & 0x3);
 	op = create_register_operand_with_size ((mb & 0x38) >> 3, size);
-	if (op == NULL)
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[2281]) {
+	  if ((op == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 2281\n");
+	  else
+	    fprintf(stderr, "reached bug index 2281\n");
+	}
+	if ((!FIXREVERTER[2281] && (op == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	)
 	  return -1;
+	  #ifdef FRCOV
+	  }
+	  #endif
 	operand[(*n_operands)++] = op;
 
 	uint32_t imm;
 	if (z_decode_signed_value (mra, 1, size + 1, &imm) < 0)
 	  return -1;
 	op = create_immediate_operand (imm);
-	if (op == NULL)
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[2282]) {
+	  if ((op == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 2282\n");
+	  else
+	    fprintf(stderr, "reached bug index 2282\n");
+	}
+	if ((!FIXREVERTER[2282] && (op == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	)
 	  return -1;
+	  #ifdef FRCOV
+	  }
+	  #endif
 	operand[(*n_operands)++] = op;
       }
       break;
     case MUL_REG_REG:
       op = create_register_operand ((mb & 0x38) >> 3);
-      if (op == NULL)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[2283]) {
+        if ((op == (void *) 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 2283\n");
+        else
+          fprintf(stderr, "reached bug index 2283\n");
+      }
+      if ((!FIXREVERTER[2283] && (op == (void *) 0 ))
+      #else
+      if (0
+      #endif
+      )
 	return -1;
+	#ifdef FRCOV
+	}
+	#endif
       operand[(*n_operands)++] = op;
       op = create_register_operand (mb & 0x07);
-      if (op == NULL)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[2284]) {
+        if ((op == (void *) 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 2284\n");
+        else
+          fprintf(stderr, "reached bug index 2284\n");
+      }
+      if ((!FIXREVERTER[2284] && (op == (void *) 0 ))
+      #else
+      if (0
+      #endif
+      )
 	return -1;
+	#ifdef FRCOV
+	}
+	#endif
       operand[(*n_operands)++] = op;
       break;
     case MUL_REG_OPR:
       op = create_register_operand ((mb & 0x38) >> 3);
-      if (op == NULL)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[2285]) {
+        if ((op == (void *) 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 2285\n");
+        else
+          fprintf(stderr, "reached bug index 2285\n");
+      }
+      if ((!FIXREVERTER[2285] && (op == (void *) 0 ))
+      #else
+      if (0
+      #endif
+      )
 	return -1;
+	#ifdef FRCOV
+	}
+	#endif
       operand[(*n_operands)++] = op;
       op = x_opr_decode_with_size (mra, 1, mb & 0x3);
-      if (op == NULL)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[2286]) {
+        if ((op == (void *) 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 2286\n");
+        else
+          fprintf(stderr, "reached bug index 2286\n");
+      }
+      if ((!FIXREVERTER[2286] && (op == (void *) 0 ))
+      #else
+      if (0
+      #endif
+      )
 	return -1;
+	#ifdef FRCOV
+	}
+	#endif
       operand[(*n_operands)++] = op;
       break;
     case MUL_OPR_OPR:
@@ -1866,12 +2499,42 @@ mul_decode (struct mem_read_abstraction_base *mra,
 	if (first < 0)
 	  return first;
 	op = x_opr_decode_with_size (mra, 1, (mb & 0x30) >> 4);
-	if (op == NULL)
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[2288]) {
+	  if ((op == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 2288\n");
+	  else
+	    fprintf(stderr, "reached bug index 2288\n");
+	}
+	if ((!FIXREVERTER[2288] && (op == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	)
 	  return -1;
+	  #ifdef FRCOV
+	  }
+	  #endif
 	operand[(*n_operands)++] = op;
 	op = x_opr_decode_with_size (mra, first + 1, (mb & 0x0c) >> 2);
-	if (op == NULL)
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[2289]) {
+	  if ((op == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 2289\n");
+	  else
+	    fprintf(stderr, "reached bug index 2289\n");
+	}
+	if ((!FIXREVERTER[2289] && (op == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	)
 	  return -1;
+	  #ifdef FRCOV
+	  }
+	  #endif
 	operand[(*n_operands)++] = op;
 	break;
       }
@@ -1887,8 +2550,23 @@ mul_n_bytes (struct mem_read_abstraction_base *mra)
   int first, second;
   uint8_t mb;
   int status = mra->read (mra, 0, 1, &mb);
-  if (status < 0)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[2290]) {
+    if ((status < 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 2290\n");
+    else
+      fprintf(stderr, "reached bug index 2290\n");
+  }
+  if ((!FIXREVERTER[2290] && (status < 0 ))
+  #else
+  if (0
+  #endif
+  )
     return status;
+    #ifdef FRCOV
+    }
+    #endif
 
   enum MUL_MODE mode = -1;
   size_t i;
@@ -1913,18 +2591,63 @@ mul_n_bytes (struct mem_read_abstraction_base *mra)
       break;
     case MUL_REG_OPR:
       first = x_opr_n_bytes (mra, 1);
-      if (first < 0)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[2291]) {
+        if ((first < 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 2291\n");
+        else
+          fprintf(stderr, "reached bug index 2291\n");
+      }
+      if ((!FIXREVERTER[2291] && (first < 0 ))
+      #else
+      if (0
+      #endif
+      )
 	return first;
+	#ifdef FRCOV
+	}
+	#endif
       nx += first;
       break;
     case MUL_OPR_OPR:
       first = x_opr_n_bytes (mra, nx - 1);
-      if (first < 0)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[2292]) {
+        if ((first < 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 2292\n");
+        else
+          fprintf(stderr, "reached bug index 2292\n");
+      }
+      if ((!FIXREVERTER[2292] && (first < 0 ))
+      #else
+      if (0
+      #endif
+      )
 	return first;
+	#ifdef FRCOV
+	}
+	#endif
       nx += first;
       second = x_opr_n_bytes (mra, nx - 1);
-      if (second < 0)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[2293]) {
+        if ((second < 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 2293\n");
+        else
+          fprintf(stderr, "reached bug index 2293\n");
+      }
+      if ((!FIXREVERTER[2293] && (second < 0 ))
+      #else
+      if (0
+      #endif
+      )
 	return second;
+	#ifdef FRCOV
+	}
+	#endif
       nx += second;
       break;
     }
@@ -1998,26 +2721,86 @@ bm_decode (struct mem_read_abstraction_base *mra,
     case BM_REG_IMM:
     case BM_RESERVED0:
       op = create_register_operand (bm & 0x07);
-      if (op == NULL)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[2296]) {
+        if ((op == (void *) 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 2296\n");
+        else
+          fprintf(stderr, "reached bug index 2296\n");
+      }
+      if ((!FIXREVERTER[2296] && (op == (void *) 0 ))
+      #else
+      if (0
+      #endif
+      )
 	return -1;
+	#ifdef FRCOV
+	}
+	#endif
       operand[(*n_operands)++] = op;
       break;
     case BM_OPR_B:
       op = x_opr_decode_with_size (mra, 1, 0);
-      if (op == NULL)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[2297]) {
+        if ((op == (void *) 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 2297\n");
+        else
+          fprintf(stderr, "reached bug index 2297\n");
+      }
+      if ((!FIXREVERTER[2297] && (op == (void *) 0 ))
+      #else
+      if (0
+      #endif
+      )
 	return -1;
+	#ifdef FRCOV
+	}
+	#endif
       operand[(*n_operands)++] = op;
       break;
     case BM_OPR_W:
       op = x_opr_decode_with_size (mra, 1, 1);
-      if (op == NULL)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[2298]) {
+        if ((op == (void *) 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 2298\n");
+        else
+          fprintf(stderr, "reached bug index 2298\n");
+      }
+      if ((!FIXREVERTER[2298] && (op == (void *) 0 ))
+      #else
+      if (0
+      #endif
+      )
 	return -1;
+	#ifdef FRCOV
+	}
+	#endif
       operand[(*n_operands)++] = op;
       break;
     case BM_OPR_L:
       op = x_opr_decode_with_size (mra, 1, 3);
-      if (op == NULL)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[2299]) {
+        if ((op == (void *) 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 2299\n");
+        else
+          fprintf(stderr, "reached bug index 2299\n");
+      }
+      if ((!FIXREVERTER[2299] && (op == (void *) 0 ))
+      #else
+      if (0
+      #endif
+      )
 	return -1;
+	#ifdef FRCOV
+	}
+	#endif
       operand[(*n_operands)++] = op;
       break;
     case BM_OPR_REG:
@@ -2032,8 +2815,23 @@ bm_decode (struct mem_read_abstraction_base *mra,
 	  op = x_opr_decode_with_size (mra, 1, (bm & 0x0c) >> 2);
 	else
 	  op = x_opr_decode (mra, 1);
-	if (op == NULL)
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[2301]) {
+	  if ((op == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 2301\n");
+	  else
+	    fprintf(stderr, "reached bug index 2301\n");
+	}
+	if ((!FIXREVERTER[2301] && (op == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	)
 	  return -1;
+	  #ifdef FRCOV
+	  }
+	  #endif
 	operand[(*n_operands)++] = op;
       }
       break;
@@ -2046,8 +2844,23 @@ bm_decode (struct mem_read_abstraction_base *mra,
     case BM_RESERVED0:
       imm = (bm & 0x38) >> 3;
       op = create_immediate_operand (imm);
-      if (op == NULL)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[2302]) {
+        if ((op == (void *) 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 2302\n");
+        else
+          fprintf(stderr, "reached bug index 2302\n");
+      }
+      if ((!FIXREVERTER[2302] && (op == (void *) 0 ))
+      #else
+      if (0
+      #endif
+      )
 	return -1;
+	#ifdef FRCOV
+	}
+	#endif
       operand[(*n_operands)++] = op;
       break;
     case BM_OPR_L:
@@ -2059,15 +2872,45 @@ bm_decode (struct mem_read_abstraction_base *mra,
     case BM_OPR_B:
       imm |= (bm & 0x70) >> 4;
       op = create_immediate_operand (imm);
-      if (op == NULL)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[2303]) {
+        if ((op == (void *) 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 2303\n");
+        else
+          fprintf(stderr, "reached bug index 2303\n");
+      }
+      if ((!FIXREVERTER[2303] && (op == (void *) 0 ))
+      #else
+      if (0
+      #endif
+      )
 	return -1;
+	#ifdef FRCOV
+	}
+	#endif
       operand[(*n_operands)++] = op;
       break;
     case BM_OPR_REG:
     case BM_RESERVED1:
       op = create_register_operand ((bm & 0x70) >> 4);
-      if (op == NULL)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[2304]) {
+        if ((op == (void *) 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 2304\n");
+        else
+          fprintf(stderr, "reached bug index 2304\n");
+      }
+      if ((!FIXREVERTER[2304] && (op == (void *) 0 ))
+      #else
+      if (0
+      #endif
+      )
 	return -1;
+	#ifdef FRCOV
+	}
+	#endif
       operand[(*n_operands)++] = op;
       break;
     }
@@ -2103,14 +2946,44 @@ bm_rel_decode (struct mem_read_abstraction_base *mra,
     case BM_REG_IMM:
     case BM_RESERVED0:
       op = create_register_operand (bm & 0x07);
-      if (op == NULL)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[2306]) {
+        if ((op == (void *) 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 2306\n");
+        else
+          fprintf(stderr, "reached bug index 2306\n");
+      }
+      if ((!FIXREVERTER[2306] && (op == (void *) 0 ))
+      #else
+      if (0
+      #endif
+      )
 	return -1;
+	#ifdef FRCOV
+	}
+	#endif
       operand[(*n_operands)++] = op;
       break;
     case BM_OPR_B:
       op = x_opr_decode_with_size (mra, 1, 0);
-      if (op == NULL)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[2307]) {
+        if ((op == (void *) 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 2307\n");
+        else
+          fprintf(stderr, "reached bug index 2307\n");
+      }
+      if ((!FIXREVERTER[2307] && (op == (void *) 0 ))
+      #else
+      if (0
+      #endif
+      )
 	return -1;
+	#ifdef FRCOV
+	}
+	#endif
       operand[(*n_operands)++] = op;
       n = x_opr_n_bytes (mra, 1);
       if (n < 0)
@@ -2119,8 +2992,23 @@ bm_rel_decode (struct mem_read_abstraction_base *mra,
       break;
     case BM_OPR_W:
       op = x_opr_decode_with_size (mra, 1, 1);
-      if (op == NULL)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[2309]) {
+        if ((op == (void *) 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 2309\n");
+        else
+          fprintf(stderr, "reached bug index 2309\n");
+      }
+      if ((!FIXREVERTER[2309] && (op == (void *) 0 ))
+      #else
+      if (0
+      #endif
+      )
 	return -1;
+	#ifdef FRCOV
+	}
+	#endif
       operand[(*n_operands)++] = op;
       n = x_opr_n_bytes (mra, 1);
       if (n < 0)
@@ -2129,8 +3017,23 @@ bm_rel_decode (struct mem_read_abstraction_base *mra,
       break;
     case BM_OPR_L:
       op = x_opr_decode_with_size (mra, 1, 3);
-      if (op == NULL)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[2311]) {
+        if ((op == (void *) 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 2311\n");
+        else
+          fprintf(stderr, "reached bug index 2311\n");
+      }
+      if ((!FIXREVERTER[2311] && (op == (void *) 0 ))
+      #else
+      if (0
+      #endif
+      )
 	return -1;
+	#ifdef FRCOV
+	}
+	#endif
       operand[(*n_operands)++] = op;
       n = x_opr_n_bytes (mra, 1);
       if (n < 0)
@@ -2152,8 +3055,23 @@ bm_rel_decode (struct mem_read_abstraction_base *mra,
 	  }
 	else
 	  op = x_opr_decode (mra, 1);
-	if (op == NULL)
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[2314]) {
+	  if ((op == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 2314\n");
+	  else
+	    fprintf(stderr, "reached bug index 2314\n");
+	}
+	if ((!FIXREVERTER[2314] && (op == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	)
 	  return -1;
+	  #ifdef FRCOV
+	  }
+	  #endif
 	operand[(*n_operands)++] = op;
       }
       break;
@@ -2171,29 +3089,89 @@ bm_rel_decode (struct mem_read_abstraction_base *mra,
     case BM_OPR_B:
       imm |= (bm & 0x70) >> 4;
       op = create_immediate_operand (imm);
-      if (op == NULL)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[2315]) {
+        if ((op == (void *) 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 2315\n");
+        else
+          fprintf(stderr, "reached bug index 2315\n");
+      }
+      if ((!FIXREVERTER[2315] && (op == (void *) 0 ))
+      #else
+      if (0
+      #endif
+      )
 	return -1;
+	#ifdef FRCOV
+	}
+	#endif
       operand[(*n_operands)++] = op;
       break;
     case BM_RESERVED0:
       imm = (bm & 0x38) >> 3;
       op = create_immediate_operand (imm);
-      if (op == NULL)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[2316]) {
+        if ((op == (void *) 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 2316\n");
+        else
+          fprintf(stderr, "reached bug index 2316\n");
+      }
+      if ((!FIXREVERTER[2316] && (op == (void *) 0 ))
+      #else
+      if (0
+      #endif
+      )
 	return -1;
+	#ifdef FRCOV
+	}
+	#endif
       operand[(*n_operands)++] = op;
       break;
     case BM_REG_IMM:
       imm = (bm & 0xF8) >> 3;
       op = create_immediate_operand (imm);
-      if (op == NULL)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[2317]) {
+        if ((op == (void *) 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 2317\n");
+        else
+          fprintf(stderr, "reached bug index 2317\n");
+      }
+      if ((!FIXREVERTER[2317] && (op == (void *) 0 ))
+      #else
+      if (0
+      #endif
+      )
 	return -1;
+	#ifdef FRCOV
+	}
+	#endif
       operand[(*n_operands)++] = op;
       break;
     case BM_OPR_REG:
     case BM_RESERVED1:
       op = create_register_operand ((bm & 0x70) >> 4);
-      if (op == NULL)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[2318]) {
+        if ((op == (void *) 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 2318\n");
+        else
+          fprintf(stderr, "reached bug index 2318\n");
+      }
+      if ((!FIXREVERTER[2318] && (op == (void *) 0 ))
+      #else
+      if (0
+      #endif
+      )
 	return -1;
+	#ifdef FRCOV
+	}
+	#endif
       operand[(*n_operands)++] = op;
       x = x_opr_n_bytes (mra, 1);
       if (x < 0)
@@ -2210,8 +3188,23 @@ bm_n_bytes (struct mem_read_abstraction_base *mra)
 {
   uint8_t bm;
   int status = mra->read (mra, 0, 1, &bm);
-  if (status < 0)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[2320]) {
+    if ((status < 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 2320\n");
+    else
+      fprintf(stderr, "reached bug index 2320\n");
+  }
+  if ((!FIXREVERTER[2320] && (status < 0 ))
+  #else
+  if (0
+  #endif
+  )
     return status;
+    #ifdef FRCOV
+    }
+    #endif
 
   size_t i;
   enum BM_MODE mode = -1;
@@ -2238,8 +3231,23 @@ bm_n_bytes (struct mem_read_abstraction_base *mra)
     case BM_OPR_REG:
     case BM_RESERVED1:
       n = x_opr_n_bytes (mra, 1);
-      if (n < 0)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[2321]) {
+        if ((n < 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 2321\n");
+        else
+          fprintf(stderr, "reached bug index 2321\n");
+      }
+      if ((!FIXREVERTER[2321] && (n < 0 ))
+      #else
+      if (0
+      #endif
+      )
 	return n;
+	#ifdef FRCOV
+	}
+	#endif
       break;
     }
 
@@ -2253,8 +3261,23 @@ bm_rel_n_bytes (struct mem_read_abstraction_base *mra)
 
   bfd_byte rb;
   int status = mra->read (mra, n - 2, 1, &rb);
-  if (status != 0)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[2322]) {
+    if ((status != 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 2322\n");
+    else
+      fprintf(stderr, "reached bug index 2322\n");
+  }
+  if ((!FIXREVERTER[2322] && (status != 0 ))
+  #else
+  if (0
+  #endif
+  )
     return status;
+    #ifdef FRCOV
+    }
+    #endif
 
   if (rb & 0x80)
     n++;
@@ -2312,8 +3335,23 @@ shift_n_bytes (struct mem_read_abstraction_base *mra)
   bfd_byte sb;
   int opr1, opr2;
   int status = mra->read (mra, 0, 1, &sb);
-  if (status != 0)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[2324]) {
+    if ((status != 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 2324\n");
+    else
+      fprintf(stderr, "reached bug index 2324\n");
+  }
+  if ((!FIXREVERTER[2324] && (status != 0 ))
+  #else
+  if (0
+  #endif
+  )
     return status;
+    #ifdef FRCOV
+    }
+    #endif
 
   size_t i;
   enum SB_MODE mode = -1;
@@ -2331,19 +3369,64 @@ shift_n_bytes (struct mem_read_abstraction_base *mra)
     case SB_REG_OPR_EFF:
     case SB_ROT:
       opr1 = x_opr_n_bytes (mra, 1);
-      if (opr1 < 0)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[2325]) {
+        if ((opr1 < 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 2325\n");
+        else
+          fprintf(stderr, "reached bug index 2325\n");
+      }
+      if ((!FIXREVERTER[2325] && (opr1 < 0 ))
+      #else
+      if (0
+      #endif
+      )
 	return opr1;
+	#ifdef FRCOV
+	}
+	#endif
       return 2 + opr1;
     case SB_REG_OPR_OPR:
       opr1 = x_opr_n_bytes (mra, 1);
-      if (opr1 < 0)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[2326]) {
+        if ((opr1 < 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 2326\n");
+        else
+          fprintf(stderr, "reached bug index 2326\n");
+      }
+      if ((!FIXREVERTER[2326] && (opr1 < 0 ))
+      #else
+      if (0
+      #endif
+      )
 	return opr1;
+	#ifdef FRCOV
+	}
+	#endif
       opr2 = 0;
       if ((sb & 0x30) != 0x20)
 	{
 	  opr2 = x_opr_n_bytes (mra, opr1 + 1);
-	  if (opr2 < 0)
+	  
+	  #ifdef FRCOV
+	  {if (FIXREVERTER[2327]) {
+	    if ((opr2 < 0 ) && !(0))
+	      fprintf(stderr, "triggered bug index 2327\n");
+	    else
+	      fprintf(stderr, "reached bug index 2327\n");
+	  }
+	  if ((!FIXREVERTER[2327] && (opr2 < 0 ))
+	  #else
+	  if (0
+	  #endif
+	  )
 	    return opr2;
+	    #ifdef FRCOV
+	    }
+	    #endif
 	}
       return 2 + opr1 + opr2;
     default:
@@ -2360,13 +3443,43 @@ mov_imm_opr_n_bytes (struct mem_read_abstraction_base *mra)
 {
   bfd_byte byte;
   int status = mra->read (mra, -1, 1, &byte);
-  if (status < 0)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[2328]) {
+    if ((status < 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 2328\n");
+    else
+      fprintf(stderr, "reached bug index 2328\n");
+  }
+  if ((!FIXREVERTER[2328] && (status < 0 ))
+  #else
+  if (0
+  #endif
+  )
     return status;
+    #ifdef FRCOV
+    }
+    #endif
 
   int size = byte - 0x0c + 1;
   int n = x_opr_n_bytes (mra, size);
-  if (n < 0)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[2329]) {
+    if ((n < 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 2329\n");
+    else
+      fprintf(stderr, "reached bug index 2329\n");
+  }
+  if ((!FIXREVERTER[2329] && (n < 0 ))
+  #else
+  if (0
+  #endif
+  )
     return n;
+    #ifdef FRCOV
+    }
+    #endif
 
   return size + n + 1;
 }
@@ -2387,12 +3500,42 @@ mov_imm_opr (struct mem_read_abstraction_base *mra,
     return -1;
 
   op = create_immediate_operand (imm);
-  if (op == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[2331]) {
+    if ((op == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 2331\n");
+    else
+      fprintf(stderr, "reached bug index 2331\n");
+  }
+  if ((!FIXREVERTER[2331] && (op == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     return -1;
+    #ifdef FRCOV
+    }
+    #endif
   operand[(*n_operands)++] = op;
   op = x_opr_decode (mra, size);
-  if (op == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[2332]) {
+    if ((op == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 2332\n");
+    else
+      fprintf(stderr, "reached bug index 2332\n");
+  }
+  if ((!FIXREVERTER[2332] && (op == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     return -1;
+    #ifdef FRCOV
+    }
+    #endif
   operand[(*n_operands)++] = op;
   return 0;
 }
@@ -2424,8 +3567,23 @@ ld_18bit_decode (struct mem_read_abstraction_base *mra,
     }
 
   op = create_immediate_operand (imm);
-  if (op == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[2336]) {
+    if ((op == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 2336\n");
+    else
+      fprintf(stderr, "reached bug index 2336\n");
+  }
+  if ((!FIXREVERTER[2336] && (op == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     return -1;
+    #ifdef FRCOV
+    }
+    #endif
   operand[(*n_operands)++] = op;
   return 0;
 }
@@ -2460,8 +3618,23 @@ loop_prim_n_bytes (struct mem_read_abstraction_base *mra)
   int mx = 0;
   uint8_t lb;
   int status = mra->read (mra, mx++, 1, &lb);
-  if (status < 0)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[2338]) {
+    if ((status < 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 2338\n");
+    else
+      fprintf(stderr, "reached bug index 2338\n");
+  }
+  if ((!FIXREVERTER[2338] && (status < 0 ))
+  #else
+  if (0
+  #endif
+  )
     return status;
+    #ifdef FRCOV
+    }
+    #endif
 
   enum LP_MODE mode = -1;
   size_t i;
@@ -2478,15 +3651,45 @@ loop_prim_n_bytes (struct mem_read_abstraction_base *mra)
   if (mode == LP_OPR)
     {
       int n = x_opr_n_bytes (mra, mx);
-      if (n < 0)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[2339]) {
+        if ((n < 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 2339\n");
+        else
+          fprintf(stderr, "reached bug index 2339\n");
+      }
+      if ((!FIXREVERTER[2339] && (n < 0 ))
+      #else
+      if (0
+      #endif
+      )
 	return n;
+	#ifdef FRCOV
+	}
+	#endif
       mx += n;
     }
 
   uint8_t rb;
   status = mra->read (mra, mx++, 1, &rb);
-  if (status < 0)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[2340]) {
+    if ((status < 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 2340\n");
+    else
+      fprintf(stderr, "reached bug index 2340\n");
+  }
+  if ((!FIXREVERTER[2340] && (status < 0 ))
+  #else
+  if (0
+  #endif
+  )
     return status;
+    #ifdef FRCOV
+    }
+    #endif
   if (rb & 0x80)
     mx++;
 
@@ -2507,22 +3710,69 @@ exg_sex_discrim (struct mem_read_abstraction_base *mra,
     return operator;
 
   struct operand *op0 = create_register_operand ((eb & 0xf0) >> 4);
-  if (op0 == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[2342]) {
+    if ((op0 == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 2342\n");
+    else
+      fprintf(stderr, "reached bug index 2342\n");
+  }
+  if ((!FIXREVERTER[2342] && (op0 == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     return -1;
+    #ifdef FRCOV
+    }
+    #endif
   struct operand *op1 = create_register_operand (eb & 0xf);
-  if (op1 == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[2343]) {
+    if ((op1 == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 2343\n");
+    else
+      fprintf(stderr, "reached bug index 2343\n");
+  }
+  if ((!FIXREVERTER[2343] && (op1 == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     return -1;
+    #ifdef FRCOV
+    }
+    #endif
 
   int reg0 = ((struct register_operand *) op0)->reg;
   int reg1 = ((struct register_operand *) op1)->reg;
-  if (reg0 >= 0 && reg0 < S12Z_N_REGISTERS
-      && reg1 >= 0 && reg1 < S12Z_N_REGISTERS)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[2344]) {
+    fprintf(stderr, "reached bug index 2344\n");
+  }
+  if ((FIXREVERTER[2344] && (reg0 >= 0 && reg0 < 15 && reg1 >= 0 )) || (!FIXREVERTER[2344] && (reg0 >= 0 && reg0 < 15 && reg1 >= 0 && reg1 < 15 ))
+  #else
+  if (reg0 >= 0 && reg0 < 15 && reg1 >= 0 
+  #endif
+  )
     {
+      
+    #ifdef FRCOV
+      if (!(reg1 < 15 ))
+        fprintf(stderr, "triggered bug index 2344\n");
+      #endif
+    
       const struct reg *r0 = registers + reg0;
       const struct reg *r1 = registers + reg1;
 
       operator = r0->bytes < r1->bytes ? OP_sex : OP_exg;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
   free (op0);
   free (op1);
@@ -2543,12 +3793,42 @@ exg_sex_decode (struct mem_read_abstraction_base *mra,
 
   /* Ship out the operands.  */
   op = create_register_operand ((eb & 0xf0) >> 4);
-  if (op == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[2346]) {
+    if ((op == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 2346\n");
+    else
+      fprintf(stderr, "reached bug index 2346\n");
+  }
+  if ((!FIXREVERTER[2346] && (op == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     return -1;
+    #ifdef FRCOV
+    }
+    #endif
   operands[(*n_operands)++] = op;
   op = create_register_operand (eb & 0xf);
-  if (op == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[2347]) {
+    if ((op == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 2347\n");
+    else
+      fprintf(stderr, "reached bug index 2347\n");
+  }
+  if ((!FIXREVERTER[2347] && (op == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     return -1;
+    #ifdef FRCOV
+    }
+    #endif
   operands[(*n_operands)++] = op;
   return 0;
 }
@@ -2593,14 +3873,44 @@ loop_primitive_decode (struct mem_read_abstraction_base *mra,
     {
     case LP_REG:
       op = create_register_operand (lb & 0x07);
-      if (op == NULL)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[2350]) {
+        if ((op == (void *) 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 2350\n");
+        else
+          fprintf(stderr, "reached bug index 2350\n");
+      }
+      if ((!FIXREVERTER[2350] && (op == (void *) 0 ))
+      #else
+      if (0
+      #endif
+      )
 	return -1;
+	#ifdef FRCOV
+	}
+	#endif
       operands[(*n_operands)++] = op;
       break;
     case LP_XY:
       op = create_register_operand ((lb & 0x01) + REG_X);
-      if (op == NULL)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[2351]) {
+        if ((op == (void *) 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 2351\n");
+        else
+          fprintf(stderr, "reached bug index 2351\n");
+      }
+      if ((!FIXREVERTER[2351] && (op == (void *) 0 ))
+      #else
+      if (0
+      #endif
+      )
 	return -1;
+	#ifdef FRCOV
+	}
+	#endif
       operands[(*n_operands)++] = op;
       break;
     case LP_OPR:
@@ -2609,8 +3919,23 @@ loop_primitive_decode (struct mem_read_abstraction_base *mra,
 	return n;
       offs += n;
       op = x_opr_decode_with_size (mra, 1, lb & 0x03);
-      if (op == NULL)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[2353]) {
+        if ((op == (void *) 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 2353\n");
+        else
+          fprintf(stderr, "reached bug index 2353\n");
+      }
+      if ((!FIXREVERTER[2353] && (op == (void *) 0 ))
+      #else
+      if (0
+      #endif
+      )
 	return -1;
+	#ifdef FRCOV
+	}
+	#endif
       operands[(*n_operands)++] = op;
       break;
     }
@@ -2704,22 +4029,67 @@ shift_decode (struct mem_read_abstraction_base *mra, int *n_operands,
     case SB_REG_REG_N_EFF:
     case SB_REG_REG_N:
       op = create_register_operand (byte & 0x07);
-      if (op == NULL)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[2358]) {
+        if ((op == (void *) 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 2358\n");
+        else
+          fprintf(stderr, "reached bug index 2358\n");
+      }
+      if ((!FIXREVERTER[2358] && (op == (void *) 0 ))
+      #else
+      if (0
+      #endif
+      )
 	return -1;
+	#ifdef FRCOV
+	}
+	#endif
       operands[(*n_operands)++] = op;
       break;
     case SB_REG_OPR_EFF:
     case SB_REG_OPR_OPR:
       op = create_register_operand (byte & 0x07);
-      if (op == NULL)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[2359]) {
+        if ((op == (void *) 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 2359\n");
+        else
+          fprintf(stderr, "reached bug index 2359\n");
+      }
+      if ((!FIXREVERTER[2359] && (op == (void *) 0 ))
+      #else
+      if (0
+      #endif
+      )
 	return -1;
+	#ifdef FRCOV
+	}
+	#endif
       operands[(*n_operands)++] = op;
       break;
 
     case SB_ROT:
       op = x_opr_decode_with_size (mra, 1, osize);
-      if (op == NULL)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[2360]) {
+        if ((op == (void *) 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 2360\n");
+        else
+          fprintf(stderr, "reached bug index 2360\n");
+      }
+      if ((!FIXREVERTER[2360] && (op == (void *) 0 ))
+      #else
+      if (0
+      #endif
+      )
 	return -1;
+	#ifdef FRCOV
+	}
+	#endif
       operands[(*n_operands)++] = op;
       break;
 
@@ -2733,15 +4103,45 @@ shift_decode (struct mem_read_abstraction_base *mra, int *n_operands,
     case SB_REG_REG_N_EFF:
     case SB_REG_REG_N:
       op = create_register_operand_with_size (sb & 0x07, osize);
-      if (op == NULL)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[2361]) {
+        if ((op == (void *) 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 2361\n");
+        else
+          fprintf(stderr, "reached bug index 2361\n");
+      }
+      if ((!FIXREVERTER[2361] && (op == (void *) 0 ))
+      #else
+      if (0
+      #endif
+      )
 	return -1;
+	#ifdef FRCOV
+	}
+	#endif
       operands[(*n_operands)++] = op;
       break;
 
     case SB_REG_OPR_OPR:
       op = x_opr_decode_with_size (mra, 1, osize);
-      if (op == NULL)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[2362]) {
+        if ((op == (void *) 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 2362\n");
+        else
+          fprintf(stderr, "reached bug index 2362\n");
+      }
+      if ((!FIXREVERTER[2362] && (op == (void *) 0 ))
+      #else
+      if (0
+      #endif
+      )
 	return -1;
+	#ifdef FRCOV
+	}
+	#endif
       operands[(*n_operands)++] = op;
       break;
 
@@ -2755,8 +4155,23 @@ shift_decode (struct mem_read_abstraction_base *mra, int *n_operands,
     case SB_REG_OPR_EFF:
     case SB_OPR_N:
       op = x_opr_decode_with_size (mra, 1, osize);
-      if (op == NULL)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[2363]) {
+        if ((op == (void *) 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 2363\n");
+        else
+          fprintf(stderr, "reached bug index 2363\n");
+      }
+      if ((!FIXREVERTER[2363] && (op == (void *) 0 ))
+      #else
+      if (0
+      #endif
+      )
 	return -1;
+	#ifdef FRCOV
+	}
+	#endif
       operands[(*n_operands)++] = op;
       break;
 
@@ -2777,8 +4192,23 @@ shift_decode (struct mem_read_abstraction_base *mra, int *n_operands,
 	      {
 		int shift = ((sb & 0x08) >> 3) | ((xb & 0x0f) << 1);
 		op = create_immediate_operand (shift);
-		if (op == NULL)
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[2365]) {
+		  if ((op == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 2365\n");
+		  else
+		    fprintf(stderr, "reached bug index 2365\n");
+		}
+		if ((!FIXREVERTER[2365] && (op == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		)
 		  return -1;
+		  #ifdef FRCOV
+		  }
+		  #endif
 		operands[(*n_operands)++] = op;
 	      }
 	    else
@@ -2790,8 +4220,23 @@ shift_decode (struct mem_read_abstraction_base *mra, int *n_operands,
 	else
 	  {
 	    op = x_opr_decode (mra, 1);
-	    if (op == NULL)
+	    
+	    #ifdef FRCOV
+	    {if (FIXREVERTER[2366]) {
+	      if ((op == (void *) 0 ) && !(0))
+	        fprintf(stderr, "triggered bug index 2366\n");
+	      else
+	        fprintf(stderr, "reached bug index 2366\n");
+	    }
+	    if ((!FIXREVERTER[2366] && (op == (void *) 0 ))
+	    #else
+	    if (0
+	    #endif
+	    )
 	      return -1;
+	      #ifdef FRCOV
+	      }
+	      #endif
 	    operands[(*n_operands)++] = op;
 	  }
       }
@@ -2812,15 +4257,45 @@ shift_decode (struct mem_read_abstraction_base *mra, int *n_operands,
 	    imm <<= 1;
 	    imm |= (sb & 0x08) >> 3;
 	    op = create_immediate_operand (imm);
-	    if (op == NULL)
+	    
+	    #ifdef FRCOV
+	    {if (FIXREVERTER[2369]) {
+	      if ((op == (void *) 0 ) && !(0))
+	        fprintf(stderr, "triggered bug index 2369\n");
+	      else
+	        fprintf(stderr, "reached bug index 2369\n");
+	    }
+	    if ((!FIXREVERTER[2369] && (op == (void *) 0 ))
+	    #else
+	    if (0
+	    #endif
+	    )
 	      return -1;
+	      #ifdef FRCOV
+	      }
+	      #endif
 	    operands[(*n_operands)++] = op;
 	  }
 	else
 	  {
 	    op = x_opr_decode (mra, 1 + n);
-	    if (op == NULL)
+	    
+	    #ifdef FRCOV
+	    {if (FIXREVERTER[2370]) {
+	      if ((op == (void *) 0 ) && !(0))
+	        fprintf(stderr, "triggered bug index 2370\n");
+	      else
+	        fprintf(stderr, "reached bug index 2370\n");
+	    }
+	    if ((!FIXREVERTER[2370] && (op == (void *) 0 ))
+	    #else
+	    if (0
+	    #endif
+	    )
 	      return -1;
+	      #ifdef FRCOV
+	      }
+	      #endif
 	    operands[(*n_operands)++] = op;
 	  }
       }
@@ -2837,8 +4312,23 @@ shift_decode (struct mem_read_abstraction_base *mra, int *n_operands,
       {
 	int imm = (sb & 0x08) ? 2 : 1;
 	op = create_immediate_operand (imm);
-	if (op == NULL)
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[2371]) {
+	  if ((op == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 2371\n");
+	  else
+	    fprintf(stderr, "reached bug index 2371\n");
+	}
+	if ((!FIXREVERTER[2371] && (op == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	)
 	  return -1;
+	  #ifdef FRCOV
+	  }
+	  #endif
 	operands[(*n_operands)++] = op;
       }
       break;
@@ -2877,8 +4367,23 @@ psh_pul_decode (struct mem_read_abstraction_base *mra,
       if ((byte & 0x3F) == 0)
 	{
 	  op = create_register_all16_operand ();
-	  if (op == NULL)
+	  
+	  #ifdef FRCOV
+	  {if (FIXREVERTER[2374]) {
+	    if ((op == (void *) 0 ) && !(0))
+	      fprintf(stderr, "triggered bug index 2374\n");
+	    else
+	      fprintf(stderr, "reached bug index 2374\n");
+	  }
+	  if ((!FIXREVERTER[2374] && (op == (void *) 0 ))
+	  #else
+	  if (0
+	  #endif
+	  )
 	    return -1;
+	    #ifdef FRCOV
+	    }
+	    #endif
 	  operand[(*n_operands)++] = op;
 	}
       else
@@ -2887,8 +4392,23 @@ psh_pul_decode (struct mem_read_abstraction_base *mra,
 	    if (byte & (0x1 << bit))
 	      {
 		op = create_register_operand (oprregs2[bit]);
-		if (op == NULL)
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[2375]) {
+		  if ((op == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 2375\n");
+		  else
+		    fprintf(stderr, "reached bug index 2375\n");
+		}
+		if ((!FIXREVERTER[2375] && (op == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		)
 		  return -1;
+		  #ifdef FRCOV
+		  }
+		  #endif
 		operand[(*n_operands)++] = op;
 	      }
 	  }
@@ -2898,8 +4418,23 @@ psh_pul_decode (struct mem_read_abstraction_base *mra,
       if ((byte & 0x3F) == 0)
 	{
 	  op = create_register_all_operand ();
-	  if (op == NULL)
+	  
+	  #ifdef FRCOV
+	  {if (FIXREVERTER[2376]) {
+	    if ((op == (void *) 0 ) && !(0))
+	      fprintf(stderr, "triggered bug index 2376\n");
+	    else
+	      fprintf(stderr, "reached bug index 2376\n");
+	  }
+	  if ((!FIXREVERTER[2376] && (op == (void *) 0 ))
+	  #else
+	  if (0
+	  #endif
+	  )
 	    return -1;
+	    #ifdef FRCOV
+	    }
+	    #endif
 	  operand[(*n_operands)++] = op;
 	}
       else
@@ -2908,8 +4443,23 @@ psh_pul_decode (struct mem_read_abstraction_base *mra,
 	    if (byte & (0x1 << bit))
 	      {
 		op = create_register_operand (oprregs1[bit]);
-		if (op == NULL)
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[2377]) {
+		  if ((op == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 2377\n");
+		  else
+		    fprintf(stderr, "reached bug index 2377\n");
+		}
+		if ((!FIXREVERTER[2377] && (op == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		)
 		  return -1;
+		  #ifdef FRCOV
+		  }
+		  #endif
 		operand[(*n_operands)++] = op;
 	      }
 	  }
@@ -2968,20 +4518,65 @@ bit_field_decode (struct mem_read_abstraction_base *mra,
     case BB_REG_OPR_REG:
     case BB_REG_OPR_IMM:
       op = create_register_operand (reg1);
-      if (op == NULL)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[2381]) {
+        if ((op == (void *) 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 2381\n");
+        else
+          fprintf(stderr, "reached bug index 2381\n");
+      }
+      if ((!FIXREVERTER[2381] && (op == (void *) 0 ))
+      #else
+      if (0
+      #endif
+      )
 	return -1;
+	#ifdef FRCOV
+	}
+	#endif
       operands[(*n_operands)++] = op;
       break;
     case BB_OPR_REG_REG:
       op = x_opr_decode_with_size (mra, 1, (bb >> 2) & 0x03);
-      if (op == NULL)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[2382]) {
+        if ((op == (void *) 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 2382\n");
+        else
+          fprintf(stderr, "reached bug index 2382\n");
+      }
+      if ((!FIXREVERTER[2382] && (op == (void *) 0 ))
+      #else
+      if (0
+      #endif
+      )
 	return -1;
+	#ifdef FRCOV
+	}
+	#endif
       operands[(*n_operands)++] = op;
       break;
     case BB_OPR_REG_IMM:
       op = x_opr_decode_with_size (mra, 2, (bb >> 2) & 0x03);
-      if (op == NULL)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[2383]) {
+        if ((op == (void *) 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 2383\n");
+        else
+          fprintf(stderr, "reached bug index 2383\n");
+      }
+      if ((!FIXREVERTER[2383] && (op == (void *) 0 ))
+      #else
+      if (0
+      #endif
+      )
 	return -1;
+	#ifdef FRCOV
+	}
+	#endif
       operands[(*n_operands)++] = op;
       break;
     }
@@ -2994,8 +4589,23 @@ bit_field_decode (struct mem_read_abstraction_base *mra,
       {
 	int reg_src = (bb >> 2) & 0x07;
 	op = create_register_operand (reg_src);
-	if (op == NULL)
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[2384]) {
+	  if ((op == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 2384\n");
+	  else
+	    fprintf(stderr, "reached bug index 2384\n");
+	}
+	if ((!FIXREVERTER[2384] && (op == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	)
 	  return -1;
+	  #ifdef FRCOV
+	  }
+	  #endif
 	operands[(*n_operands)++] = op;
       }
       break;
@@ -3004,21 +4614,66 @@ bit_field_decode (struct mem_read_abstraction_base *mra,
       {
 	int reg_src = (byte2 & 0x07);
 	op = create_register_operand (reg_src);
-	if (op == NULL)
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[2385]) {
+	  if ((op == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 2385\n");
+	  else
+	    fprintf(stderr, "reached bug index 2385\n");
+	}
+	if ((!FIXREVERTER[2385] && (op == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	)
 	  return -1;
+	  #ifdef FRCOV
+	  }
+	  #endif
 	operands[(*n_operands)++] = op;
       }
       break;
     case BB_REG_OPR_REG:
       op = x_opr_decode_with_size (mra, 1, (bb >> 2) & 0x03);
-      if (op == NULL)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[2386]) {
+        if ((op == (void *) 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 2386\n");
+        else
+          fprintf(stderr, "reached bug index 2386\n");
+      }
+      if ((!FIXREVERTER[2386] && (op == (void *) 0 ))
+      #else
+      if (0
+      #endif
+      )
 	return -1;
+	#ifdef FRCOV
+	}
+	#endif
       operands[(*n_operands)++] = op;
       break;
     case BB_REG_OPR_IMM:
       op = x_opr_decode_with_size (mra, 2, (bb >> 2) & 0x03);
-      if (op == NULL)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[2387]) {
+        if ((op == (void *) 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 2387\n");
+        else
+          fprintf(stderr, "reached bug index 2387\n");
+      }
+      if ((!FIXREVERTER[2387] && (op == (void *) 0 ))
+      #else
+      if (0
+      #endif
+      )
 	return -1;
+	#ifdef FRCOV
+	}
+	#endif
       operands[(*n_operands)++] = op;
       break;
     }
@@ -3032,8 +4687,23 @@ bit_field_decode (struct mem_read_abstraction_base *mra,
       {
 	int reg_parm = bb & 0x03;
 	op = create_register_operand (reg_parm);
-	if (op == NULL)
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[2388]) {
+	  if ((op == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 2388\n");
+	  else
+	    fprintf(stderr, "reached bug index 2388\n");
+	}
+	if ((!FIXREVERTER[2388] && (op == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	)
 	  return -1;
+	  #ifdef FRCOV
+	  }
+	  #endif
 	operands[(*n_operands)++] = op;
       }
       break;
@@ -3050,8 +4720,23 @@ bit_field_decode (struct mem_read_abstraction_base *mra,
 	width <<= 3;
 	width |= i1 >> 5;
 	op = create_bitfield_operand (width, offset);
-	if (op == NULL)
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[2390]) {
+	  if ((op == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 2390\n");
+	  else
+	    fprintf(stderr, "reached bug index 2390\n");
+	}
+	if ((!FIXREVERTER[2390] && (op == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	)
 	  return -1;
+	  #ifdef FRCOV
+	  }
+	  #endif
 	operands[(*n_operands)++] = op;
       }
       break;
@@ -3097,8 +4782,23 @@ decode_s12z (enum optr *myoperator, short *osize,
   bfd_byte byte;
 
   int status = mra->read (mra, 0, 1, &byte);
-  if (status < 0)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[2391]) {
+    if ((status < 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 2391\n");
+    else
+      fprintf(stderr, "reached bug index 2391\n");
+  }
+  if ((!FIXREVERTER[2391] && (status < 0 ))
+  #else
+  if (0
+  #endif
+  )
     return status;
+    #ifdef FRCOV
+    }
+    #endif
 
   mra->advance (mra);
 
@@ -3110,8 +4810,23 @@ decode_s12z (enum optr *myoperator, short *osize,
 
       bfd_byte byte2;
       status = mra->read (mra, 0, 1, &byte2);
-      if (status < 0)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[2392]) {
+        if ((status < 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 2392\n");
+        else
+          fprintf(stderr, "reached bug index 2392\n");
+      }
+      if ((!FIXREVERTER[2392] && (status < 0 ))
+      #else
+      if (0
+      #endif
+      )
 	return status;
+	#ifdef FRCOV
+	}
+	#endif
       mra->advance (mra);
       opc = page2 + byte2;
     }
@@ -3122,8 +4837,23 @@ decode_s12z (enum optr *myoperator, short *osize,
   if (*myoperator != OP_INVALID && opc->insn_bytes)
     {
       int n = opc->insn_bytes (mra);
-      if (n < 0)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[2393]) {
+        if ((n < 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 2393\n");
+        else
+          fprintf(stderr, "reached bug index 2393\n");
+      }
+      if ((!FIXREVERTER[2393] && (n < 0 ))
+      #else
+      if (0
+      #endif
+      )
 	return n;
+	#ifdef FRCOV
+	}
+	#endif
       n_bytes += n;
     }
   else
diff --git a/opcodes/sparc-dis.c b/opcodes/sparc-dis.c
index fa7cfe6..d465bf0 100644
--- a/opcodes/sparc-dis.c
+++ b/opcodes/sparc-dis.c
@@ -1,3 +1,6 @@
+#ifdef FRCOV
+extern short FIXREVERTER[];
+#endif
 /* Print SPARC instructions.
    Copyright (C) 1989-2021 Free Software Foundation, Inc.
 
@@ -295,8 +298,23 @@ compare_opcodes (const void * a, const void * b)
     {
       if (op1->architecture & current_arch_mask)
 	return 1;
-      else if (op0->architecture != op1->architecture)
+      else 
+      #ifdef FRCOV
+      {if (FIXREVERTER[5023]) {
+        if ((op0 -> architecture != op1 -> architecture ) && !(0))
+          fprintf(stderr, "triggered bug index 5023\n");
+        else
+          fprintf(stderr, "reached bug index 5023\n");
+      }
+      if ((!FIXREVERTER[5023] && (op0 -> architecture != op1 -> architecture ))
+      #else
+      if (0
+      #endif
+      )
 	return op0->architecture - op1->architecture;
+	#ifdef FRCOV
+	}
+	#endif
     }
 
   /* If a bit is set in both match and lose, there is something
@@ -329,8 +347,23 @@ compare_opcodes (const void * a, const void * b)
       int x0 = (match0 & x) != 0;
       int x1 = (match1 & x) != 0;
 
-      if (x0 != x1)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[5024]) {
+        if ((x0 != x1 ) && !(0))
+          fprintf(stderr, "triggered bug index 5024\n");
+        else
+          fprintf(stderr, "reached bug index 5024\n");
+      }
+      if ((!FIXREVERTER[5024] && (x0 != x1 ))
+      #else
+      if (0
+      #endif
+      )
 	return x1 - x0;
+	#ifdef FRCOV
+	}
+	#endif
     }
 
   for (i = 0; i < 32; ++i)
@@ -339,8 +372,23 @@ compare_opcodes (const void * a, const void * b)
       int x0 = (lose0 & x) != 0;
       int x1 = (lose1 & x) != 0;
 
-      if (x0 != x1)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[5025]) {
+        if ((x0 != x1 ) && !(0))
+          fprintf(stderr, "triggered bug index 5025\n");
+        else
+          fprintf(stderr, "reached bug index 5025\n");
+      }
+      if ((!FIXREVERTER[5025] && (x0 != x1 ))
+      #else
+      if (0
+      #endif
+      )
 	return x1 - x0;
+	#ifdef FRCOV
+	}
+	#endif
     }
 
   /* They are functionally equal.  So as long as the opcode table is
@@ -350,9 +398,24 @@ compare_opcodes (const void * a, const void * b)
   {
     int alias_diff = (op0->flags & F_ALIAS) - (op1->flags & F_ALIAS);
 
-    if (alias_diff != 0)
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[5026]) {
+      if ((alias_diff != 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 5026\n");
+      else
+        fprintf(stderr, "reached bug index 5026\n");
+    }
+    if ((!FIXREVERTER[5026] && (alias_diff != 0 ))
+    #else
+    if (0
+    #endif
+    )
       /* Put the one that isn't an alias first.  */
       return alias_diff;
+      #ifdef FRCOV
+      }
+      #endif
   }
 
   /* Except for aliases, two "identical" instructions had
@@ -382,9 +445,24 @@ compare_opcodes (const void * a, const void * b)
   {
     int length_diff = strlen (op0->args) - strlen (op1->args);
 
-    if (length_diff != 0)
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[5027]) {
+      if ((length_diff != 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 5027\n");
+      else
+        fprintf(stderr, "reached bug index 5027\n");
+    }
+    if ((!FIXREVERTER[5027] && (length_diff != 0 ))
+    #else
+    if (0
+    #endif
+    )
       /* Put the one with fewer arguments first.  */
       return length_diff;
+      #ifdef FRCOV
+      }
+      #endif
   }
 
   /* Put 1+i before i+1.  */
diff --git a/opcodes/tic30-dis.c b/opcodes/tic30-dis.c
index bb96c07..cfa84e8 100644
--- a/opcodes/tic30-dis.c
+++ b/opcodes/tic30-dis.c
@@ -1,3 +1,6 @@
+#ifdef FRCOV
+extern short FIXREVERTER[];
+#endif
 /* Disassembly routines for TMS320C30 architecture
    Copyright (C) 1998-2021 Free Software Foundation, Inc.
    Contributed by Steven Haworth (steve@pm.cse.rmit.edu.au)
@@ -195,8 +198,23 @@ get_register_operand (unsigned char fragment, char *buffer)
 {
   const reg *current_reg = tic30_regtab;
 
-  if (buffer == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[7309]) {
+    if ((buffer == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 7309\n");
+    else
+      fprintf(stderr, "reached bug index 7309\n");
+  }
+  if ((!FIXREVERTER[7309] && (buffer == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     return 0;
+    #ifdef FRCOV
+    }
+    #endif
   for (; current_reg < tic30_regtab_end; current_reg++)
     {
       if ((fragment & 0x1F) == current_reg->opcode)
@@ -218,8 +236,23 @@ get_indirect_operand (unsigned short fragment,
   unsigned arnum;
   unsigned char disp;
 
-  if (buffer == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[7310]) {
+    if ((buffer == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 7310\n");
+    else
+      fprintf(stderr, "reached bug index 7310\n");
+  }
+  if ((!FIXREVERTER[7310] && (buffer == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     return 0;
+    #ifdef FRCOV
+    }
+    #endif
   /* Determine which bits identify the sections of the indirect
      operand based on the size in bytes.  */
   switch (size)
@@ -695,8 +728,23 @@ print_insn_tic30 (bfd_vma pc, disassemble_info *info)
   struct instruction insn = { 0, NULL, NULL };
   bfd_vma bufaddr = pc - info->buffer_vma;
 
-  if (bufaddr + 3 >= info->buffer_length)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[7323]) {
+    if ((bufaddr + 3 >= info -> buffer_length ) && !(0))
+      fprintf(stderr, "triggered bug index 7323\n");
+    else
+      fprintf(stderr, "reached bug index 7323\n");
+  }
+  if ((!FIXREVERTER[7323] && (bufaddr + 3 >= info -> buffer_length ))
+  #else
+  if (0
+  #endif
+  )
     return -1;
+    #ifdef FRCOV
+    }
+    #endif
 
   /* Obtain the current instruction word from the buffer.  */
   insn_word = (((unsigned) *(info->buffer + bufaddr) << 24)
diff --git a/opcodes/tic6x-dis.c b/opcodes/tic6x-dis.c
index 41cbd40..c9b4461 100644
--- a/opcodes/tic6x-dis.c
+++ b/opcodes/tic6x-dis.c
@@ -1,3 +1,6 @@
+#ifdef FRCOV
+extern short FIXREVERTER[];
+#endif
 /* TI C6X disassembler.
    Copyright (C) 2010-2021 Free Software Foundation, Inc.
    Contributed by Joseph Myers <joseph@codesourcery.com>
@@ -375,8 +378,23 @@ print_insn_tic6x (bfd_vma addr, struct disassemble_info *info)
 	  creg_value = tic6x_field_bits (opcode, creg_field);
 	  z_value = tic6x_field_bits (opcode, z_field);
 	  cond = conds[creg_value][z_value];
-	  if (cond == NULL)
+	  
+	  #ifdef FRCOV
+	  {if (FIXREVERTER[3165]) {
+	    if ((cond == (void *) 0 ) && !(0))
+	      fprintf(stderr, "triggered bug index 3165\n");
+	    else
+	      fprintf(stderr, "reached bug index 3165\n");
+	  }
+	  if ((!FIXREVERTER[3165] && (cond == (void *) 0 ))
+	  #else
+	  if (0
+	  #endif
+	  )
 	    continue;
+	    #ifdef FRCOV
+	    }
+	    #endif
 	}
 
       if (opc->flags & TIC6X_FLAG_INSN16_SPRED)
diff --git a/opcodes/tilegx-dis.c b/opcodes/tilegx-dis.c
index b5db949..bc3f8fb 100644
--- a/opcodes/tilegx-dis.c
+++ b/opcodes/tilegx-dis.c
@@ -1,3 +1,6 @@
+#ifdef FRCOV
+extern short FIXREVERTER[];
+#endif
 /* tilegx-dis.c.  Disassembly routines for the TILE-Gx architecture.
    Copyright (C) 2011-2021 Free Software Foundation, Inc.
 
@@ -88,8 +91,23 @@ print_insn_tilegx (bfd_vma memaddr, disassemble_info *info)
       ++num_printed;
 
       name = opcode->name;
-      if (name == NULL)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[7588]) {
+        if ((name == (void *) 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 7588\n");
+        else
+          fprintf(stderr, "reached bug index 7588\n");
+      }
+      if ((!FIXREVERTER[7588] && (name == (void *) 0 ))
+      #else
+      if (0
+      #endif
+      )
 	name = "<invalid>";
+	#ifdef FRCOV
+	}
+	#endif
       info->fprintf_func (info->stream, "%s", name);
 
       for (j = 0; j < opcode->num_operands; j++)
diff --git a/opcodes/tilepro-dis.c b/opcodes/tilepro-dis.c
index c0ed590..8a2450e 100644
--- a/opcodes/tilepro-dis.c
+++ b/opcodes/tilepro-dis.c
@@ -1,3 +1,6 @@
+#ifdef FRCOV
+extern short FIXREVERTER[];
+#endif
 /* tilepro-dis.c.  Disassembly routines for the TILEPro architecture.
    Copyright (C) 2011-2021 Free Software Foundation, Inc.
 
@@ -135,8 +138,23 @@ print_insn_tilepro (bfd_vma memaddr, disassemble_info *info)
       ++num_printed;
 
       name = opcode->name;
-      if (name == NULL)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[6998]) {
+        if ((name == (void *) 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 6998\n");
+        else
+          fprintf(stderr, "reached bug index 6998\n");
+      }
+      if ((!FIXREVERTER[6998] && (name == (void *) 0 ))
+      #else
+      if (0
+      #endif
+      )
 	name = "<invalid>";
+	#ifdef FRCOV
+	}
+	#endif
       info->fprintf_func (info->stream, "%s", name);
 
       for (j = 0; j < opcode->num_operands; j++)
diff --git a/opcodes/vax-dis.c b/opcodes/vax-dis.c
index e218d49..cf68237 100644
--- a/opcodes/vax-dis.c
+++ b/opcodes/vax-dis.c
@@ -1,3 +1,6 @@
+#ifdef FRCOV
+extern short FIXREVERTER[];
+#endif
 /* Print VAX instructions.
    Copyright (C) 1995-2021 Free Software Foundation, Inc.
    Contributed by Pauline Middelink <middelin@polyware.iaf.nl>
@@ -469,13 +472,28 @@ print_insn_vax (bfd_vma memaddr, disassemble_info *info)
 	  break;
 	}
     }
-  if (argp == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[9908]) {
+    if ((argp == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 9908\n");
+    else
+      fprintf(stderr, "reached bug index 9908\n");
+  }
+  if ((!FIXREVERTER[9908] && (argp == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     {
       /* Handle undefined instructions. */
       (*info->fprintf_func) (info->stream, ".word 0x%x",
 			     (buffer[0] << 8) + buffer[1]);
       return 2;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
   /* Point at first byte of argument data, and at descriptor for first
      argument.  */
diff --git a/opcodes/visium-dis.c b/opcodes/visium-dis.c
index d27aef5..a25db53 100644
--- a/opcodes/visium-dis.c
+++ b/opcodes/visium-dis.c
@@ -1,3 +1,6 @@
+#ifdef FRCOV
+extern short FIXREVERTER[];
+#endif
 /* Single instruction disassembler for the Visium.
 
    Copyright (C) 2002-2021 Free Software Foundation, Inc.
@@ -193,8 +196,23 @@ disassem_class1 (disassemble_info *info, unsigned int ins)
       break;
     case 1:
       /* BMI - Block Move Indirect.  */
-      if (ins != BMI)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[5433]) {
+        if ((ins != -2111635452 ) && !(0))
+          fprintf(stderr, "triggered bug index 5433\n");
+        else
+          fprintf(stderr, "reached bug index 5433\n");
+      }
+      if ((!FIXREVERTER[5433] && (ins != -2111635452 ))
+      #else
+      if (0
+      #endif
+      )
 	goto illegal_opcode;
+	#ifdef FRCOV
+	}
+	#endif
 
       (*info->fprintf_func) (info->stream, "bmi     r1,r2,r3");
       break;
@@ -204,23 +222,68 @@ disassem_class1 (disassemble_info *info, unsigned int ins)
       break;
     case 3:
       /* BMD - Block Move Direct.  */
-      if (ins != BMD)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[5434]) {
+        if ((ins != 40042500 ) && !(0))
+          fprintf(stderr, "triggered bug index 5434\n");
+        else
+          fprintf(stderr, "reached bug index 5434\n");
+      }
+      if ((!FIXREVERTER[5434] && (ins != 40042500 ))
+      #else
+      if (0
+      #endif
+      )
 	goto illegal_opcode;
+	#ifdef FRCOV
+	}
+	#endif
 
       (*info->fprintf_func) (info->stream, "bmd     r1,r2,r3");
       break;
     case 4:
       /* DSI - Disable Interrupts.  */
-      if (ins != DSI)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[5435]) {
+        if ((ins != -2105540604 ) && !(0))
+          fprintf(stderr, "triggered bug index 5435\n");
+        else
+          fprintf(stderr, "reached bug index 5435\n");
+      }
+      if ((!FIXREVERTER[5435] && (ins != -2105540604 ))
+      #else
+      if (0
+      #endif
+      )
 	goto illegal_opcode;
+	#ifdef FRCOV
+	}
+	#endif
 
       (*info->fprintf_func) (info->stream, "dsi");
       break;
 
     case 5:
       /* ENI - Enable Interrupts.  */
-      if (ins != ENI)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[5436]) {
+        if ((ins != 44040196 ) && !(0))
+          fprintf(stderr, "triggered bug index 5436\n");
+        else
+          fprintf(stderr, "reached bug index 5436\n");
+      }
+      if ((!FIXREVERTER[5436] && (ins != 44040196 ))
+      #else
+      if (0
+      #endif
+      )
 	goto illegal_opcode;
+	#ifdef FRCOV
+	}
+	#endif
 
       (*info->fprintf_func) (info->stream, "eni");
       break;
@@ -231,8 +294,23 @@ disassem_class1 (disassemble_info *info, unsigned int ins)
       break;
     case 7:
       /* RFI - Return from Interrupt.  */
-      if (ins != RFI)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[5437]) {
+        if ((ins != -2097282604 ) && !(0))
+          fprintf(stderr, "triggered bug index 5437\n");
+        else
+          fprintf(stderr, "reached bug index 5437\n");
+      }
+      if ((!FIXREVERTER[5437] && (ins != -2097282604 ))
+      #else
+      if (0
+      #endif
+      )
 	goto illegal_opcode;
+	#ifdef FRCOV
+	}
+	#endif
 
       (*info->fprintf_func) (info->stream, "rfi");
       break;
@@ -268,8 +346,23 @@ disassem_class1 (disassemble_info *info, unsigned int ins)
 	  /* Extension arithmetic module write */
 	  int fp_ins = (ins >> 27) & 0xf;
 
-	  if (size != 4)
+	  
+	  #ifdef FRCOV
+	  {if (FIXREVERTER[5438]) {
+	    if ((size != 4 ) && !(0))
+	      fprintf(stderr, "triggered bug index 5438\n");
+	    else
+	      fprintf(stderr, "reached bug index 5438\n");
+	  }
+	  if ((!FIXREVERTER[5438] && (size != 4 ))
+	  #else
+	  if (0
+	  #endif
+	  )
 	    goto illegal_opcode;
+	    #ifdef FRCOV
+	    }
+	    #endif
 
 	  if (ins & FP_SELECT_MASK)
 	    {
@@ -478,15 +571,45 @@ disassem_class2 (disassemble_info *info, unsigned int ins)
       break;
     case 8:
       /* WRTL instruction.  */
-      if (source_a != 0)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[5441]) {
+        if ((source_a != 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 5441\n");
+        else
+          fprintf(stderr, "reached bug index 5441\n");
+      }
+      if ((!FIXREVERTER[5441] && (source_a != 0 ))
+      #else
+      if (0
+      #endif
+      )
 	goto illegal_opcode;
+	#ifdef FRCOV
+	}
+	#endif
 
       (*info->fprintf_func) (info->stream, "wrtl    0x%04X", immediate);
       break;
     case 9:
       /* WRTU instruction.  */
-      if (source_a != 0)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[5442]) {
+        if ((source_a != 0 ) && !(0))
+          fprintf(stderr, "triggered bug index 5442\n");
+        else
+          fprintf(stderr, "reached bug index 5442\n");
+      }
+      if ((!FIXREVERTER[5442] && (source_a != 0 ))
+      #else
+      if (0
+      #endif
+      )
 	goto illegal_opcode;
+	#ifdef FRCOV
+	}
+	#endif
 
       (*info->fprintf_func) (info->stream, "wrtu    0x%04X", immediate);
       break;
@@ -587,8 +710,23 @@ disassem_class3 (disassemble_info *info, unsigned int ins)
       break;
     case 4:
       /* EXTW instruction.  */
-      if (size == 1)
+      
+      #ifdef FRCOV
+      {if (FIXREVERTER[5445]) {
+        if ((size == 1 ) && !(0))
+          fprintf(stderr, "triggered bug index 5445\n");
+        else
+          fprintf(stderr, "reached bug index 5445\n");
+      }
+      if ((!FIXREVERTER[5445] && (size == 1 ))
+      #else
+      if (0
+      #endif
+      )
 	goto illegal_opcode;
+	#ifdef FRCOV
+	}
+	#endif
 
       (*info->fprintf_func) (info->stream, "extw.%s  r%d,r%d",
 			     size_names[size], dest, source_a);
@@ -649,8 +787,23 @@ disassem_class3 (disassemble_info *info, unsigned int ins)
       {
 	unsigned cbf = (ins >> 27) & 0x000f;
 
-	if (size != 4)
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[5446]) {
+	  if ((size != 4 ) && !(0))
+	    fprintf(stderr, "triggered bug index 5446\n");
+	  else
+	    fprintf(stderr, "reached bug index 5446\n");
+	}
+	if ((!FIXREVERTER[5446] && (size != 4 ))
+	#else
+	if (0
+	#endif
+	)
 	  goto illegal_opcode;
+	  #ifdef FRCOV
+	  }
+	  #endif
 
 	(*info->fprintf_func) (info->stream, "bra     %s,r%d,r%d",
 			       cc_names[cbf], source_a, dest);
@@ -677,8 +830,23 @@ disassem_class3 (disassemble_info *info, unsigned int ins)
 	  /* Extension arithmetic module read.  */
 	  int fp_ins = (ins >> 27) & 0xf;
 
-	  if (size != 4)
+	  
+	  #ifdef FRCOV
+	  {if (FIXREVERTER[5447]) {
+	    if ((size != 4 ) && !(0))
+	      fprintf(stderr, "triggered bug index 5447\n");
+	    else
+	      fprintf(stderr, "reached bug index 5447\n");
+	  }
+	  if ((!FIXREVERTER[5447] && (size != 4 ))
+	  #else
+	  if (0
+	  #endif
+	  )
 	    goto illegal_opcode;
+	    #ifdef FRCOV
+	    }
+	    #endif
 
 	  if (ins & FP_SELECT_MASK)
 	    {
diff --git a/opcodes/wasm32-dis.c b/opcodes/wasm32-dis.c
index b701c6d..2397f7b 100644
--- a/opcodes/wasm32-dis.c
+++ b/opcodes/wasm32-dis.c
@@ -1,3 +1,6 @@
+#ifdef FRCOV
+extern short FIXREVERTER[];
+#endif
 /* Opcode printing code for the WebAssembly target
    Copyright (C) 2017-2021 Free Software Foundation, Inc.
 
@@ -139,8 +142,23 @@ wasm32_symbol_is_valid (asymbol *sym,
 {
   struct wasm32_private_data *private_data = info->private_data;
 
-  if (sym == NULL)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[2702]) {
+    if ((sym == (void *) 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 2702\n");
+    else
+      fprintf(stderr, "reached bug index 2702\n");
+  }
+  if ((!FIXREVERTER[2702] && (sym == (void *) 0 ))
+  #else
+  if (0
+  #endif
+  )
     return false;
+    #ifdef FRCOV
+    }
+    #endif
 
   if (strcmp(sym->section->name, "*ABS*") == 0)
     return false;
diff --git a/opcodes/xc16x-desc.c b/opcodes/xc16x-desc.c
index 8c1fbfc..74b8b5e 100644
--- a/opcodes/xc16x-desc.c
+++ b/opcodes/xc16x-desc.c
@@ -1,3 +1,6 @@
+#ifdef FRCOV
+extern short FIXREVERTER[];
+#endif
 /* DO NOT EDIT!  -*- buffer-read-only: t -*- vi:set ro:  */
 /* CPU data for xc16x.
 
@@ -3328,10 +3331,40 @@ xc16x_cgen_rebuild_tables (CGEN_CPU_TABLE *cd)
 	  cd->base_insn_bitsize = CGEN_SIZE_UNKNOWN;
 
 	/* Set min,max insn sizes.  */
-	if (isa->min_insn_bitsize < cd->min_insn_bitsize)
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[7195]) {
+	  if ((isa -> min_insn_bitsize < cd -> min_insn_bitsize  ) && !(0))
+	    fprintf(stderr, "triggered bug index 7195\n");
+	  else
+	    fprintf(stderr, "reached bug index 7195\n");
+	}
+	if ((!FIXREVERTER[7195] && (isa -> min_insn_bitsize < cd -> min_insn_bitsize  ))
+	#else
+	if (0
+	#endif
+	)
 	  cd->min_insn_bitsize = isa->min_insn_bitsize;
-	if (isa->max_insn_bitsize > cd->max_insn_bitsize)
+	  #ifdef FRCOV
+	  }
+	  #endif
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[7196]) {
+	  if ((isa -> max_insn_bitsize > cd -> max_insn_bitsize  ) && !(0))
+	    fprintf(stderr, "triggered bug index 7196\n");
+	  else
+	    fprintf(stderr, "reached bug index 7196\n");
+	}
+	if ((!FIXREVERTER[7196] && (isa -> max_insn_bitsize > cd -> max_insn_bitsize  ))
+	#else
+	if (0
+	#endif
+	)
 	  cd->max_insn_bitsize = isa->max_insn_bitsize;
+	  #ifdef FRCOV
+	  }
+	  #endif
       }
 
   /* Data derived from the mach spec.  */
@@ -3342,8 +3375,23 @@ xc16x_cgen_rebuild_tables (CGEN_CPU_TABLE *cd)
 
 	if (mach->insn_chunk_bitsize != 0)
 	{
-	  if (cd->insn_chunk_bitsize != 0 && cd->insn_chunk_bitsize != mach->insn_chunk_bitsize)
+	  
+	  #ifdef FRCOV
+	  {if (FIXREVERTER[7197]) {
+	    fprintf(stderr, "reached bug index 7197\n");
+	  }
+	  if ((FIXREVERTER[7197] && (cd -> insn_chunk_bitsize != 0 )) || (!FIXREVERTER[7197] && (cd -> insn_chunk_bitsize != 0 && cd -> insn_chunk_bitsize != mach -> insn_chunk_bitsize ))
+	  #else
+	  if (cd -> insn_chunk_bitsize != 0 
+	  #endif
+	  )
 	    {
+	      
+	    #ifdef FRCOV
+	      if (!(cd -> insn_chunk_bitsize != mach -> insn_chunk_bitsize ))
+	        fprintf(stderr, "triggered bug index 7197\n");
+	      #endif
+	    
 	      opcodes_error_handler
 		(/* xgettext:c-format */
 		 _("internal error: xc16x_cgen_rebuild_tables: "
@@ -3351,6 +3399,9 @@ xc16x_cgen_rebuild_tables (CGEN_CPU_TABLE *cd)
 		 cd->insn_chunk_bitsize, mach->insn_chunk_bitsize);
 	      abort ();
 	    }
+	    #ifdef FRCOV
+	    }
+	    #endif
 
  	  cd->insn_chunk_bitsize = mach->insn_chunk_bitsize;
 	}
@@ -3444,8 +3495,23 @@ xc16x_cgen_cpu_open (enum cgen_cpu_open_arg arg_type, ...)
   va_end (ap);
 
   /* Mach unspecified means "all".  */
-  if (machs == 0)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[7199]) {
+    if ((machs == 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 7199\n");
+    else
+      fprintf(stderr, "reached bug index 7199\n");
+  }
+  if ((!FIXREVERTER[7199] && (machs == 0 ))
+  #else
+  if (0
+  #endif
+  )
     machs = (1 << MAX_MACHS) - 1;
+    #ifdef FRCOV
+    }
+    #endif
   /* Base mach is always selected.  */
   machs |= 1;
   if (endian == CGEN_ENDIAN_UNKNOWN)
diff --git a/opcodes/xc16x-dis.c b/opcodes/xc16x-dis.c
index 33fbcc4..ca0febc 100644
--- a/opcodes/xc16x-dis.c
+++ b/opcodes/xc16x-dis.c
@@ -1,3 +1,6 @@
+#ifdef FRCOV
+extern short FIXREVERTER[];
+#endif
 /* DO NOT EDIT!  -*- buffer-read-only: t -*- vi:set ro:  */
 /* Disassembler interface for targets using CGEN. -*- C -*-
    CGEN: Cpu tools GENerator
@@ -839,10 +842,40 @@ print_insn_xc16x (bfd_vma pc, disassemble_info *info)
      but if not possible try to move this hook elsewhere rather than
      have two hooks.  */
   length = CGEN_PRINT_INSN (cd, pc, info);
-  if (length > 0)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[8168]) {
+    if ((length > 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 8168\n");
+    else
+      fprintf(stderr, "reached bug index 8168\n");
+  }
+  if ((!FIXREVERTER[8168] && (length > 0 ))
+  #else
+  if (0
+  #endif
+  )
     return length;
-  if (length < 0)
+    #ifdef FRCOV
+    }
+    #endif
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[8169]) {
+    if ((length < 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 8169\n");
+    else
+      fprintf(stderr, "reached bug index 8169\n");
+  }
+  if ((!FIXREVERTER[8169] && (length < 0 ))
+  #else
+  if (0
+  #endif
+  )
     return -1;
+    #ifdef FRCOV
+    }
+    #endif
 
   (*info->fprintf_func) (info->stream, UNKNOWN_INSN_MSG);
   return cd->default_insn_bitsize / 8;
diff --git a/opcodes/xgate-dis.c b/opcodes/xgate-dis.c
index d8c3d8b..871359d 100644
--- a/opcodes/xgate-dis.c
+++ b/opcodes/xgate-dis.c
@@ -1,3 +1,6 @@
+#ifdef FRCOV
+extern short FIXREVERTER[];
+#endif
 /* xgate-dis.c -- Freescale XGATE disassembly
    Copyright (C) 2009-2021 Free Software Foundation, Inc.
    Written by Sean Keys (skeys@ipdatasys.com)
@@ -301,10 +304,23 @@ ripBits (unsigned int *operandBitsRemaining,
   unsigned int operand = 0;
   int numBitsFound;
 
-  for (numBitsFound = 0, currentBit = 1u << ((opcodePTR->size * 8) - 1);
-       numBitsFound < numBitsRequested && currentBit != 0;
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[7796])
+    fprintf(stderr, "reached bug index 7796\n");
+  for (numBitsFound = 0 , currentBit = 1U << ((opcodePTR->size * 8) - 1); (FIXREVERTER[7796] && (numBitsFound < numBitsRequested )) || (!FIXREVERTER[7796] && (numBitsFound < numBitsRequested && currentBit != 0 ))
+  #else
+  for (numBitsFound = 0 , currentBit = 1U << ((opcodePTR->size * 8) - 1); numBitsFound < numBitsRequested 
+  #endif
+  ;
        currentBit >>= 1)
     {
+      
+    #ifdef FRCOV
+      if (!(currentBit != 0 ))
+        fprintf(stderr, "triggered bug index 7796\n");
+      #endif
+    
       if (currentBit & *operandBitsRemaining)
 	{
 	  *operandBitsRemaining &= ~(currentBit); /* Consume the current bit.  */
@@ -313,6 +329,9 @@ ripBits (unsigned int *operandBitsRemaining,
 	  operand |= (currentBit & memory) > 0;
 	}
     }
+    #ifdef FRCOV
+    }
+    #endif
   return operand;
 }
 
diff --git a/opcodes/xstormy16-desc.c b/opcodes/xstormy16-desc.c
index 6df7a59..ba9aecd 100644
--- a/opcodes/xstormy16-desc.c
+++ b/opcodes/xstormy16-desc.c
@@ -1,3 +1,6 @@
+#ifdef FRCOV
+extern short FIXREVERTER[];
+#endif
 /* DO NOT EDIT!  -*- buffer-read-only: t -*- vi:set ro:  */
 /* CPU data for xstormy16.
 
@@ -1296,10 +1299,40 @@ xstormy16_cgen_rebuild_tables (CGEN_CPU_TABLE *cd)
 	  cd->base_insn_bitsize = CGEN_SIZE_UNKNOWN;
 
 	/* Set min,max insn sizes.  */
-	if (isa->min_insn_bitsize < cd->min_insn_bitsize)
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[3329]) {
+	  if ((isa -> min_insn_bitsize < cd -> min_insn_bitsize  ) && !(0))
+	    fprintf(stderr, "triggered bug index 3329\n");
+	  else
+	    fprintf(stderr, "reached bug index 3329\n");
+	}
+	if ((!FIXREVERTER[3329] && (isa -> min_insn_bitsize < cd -> min_insn_bitsize  ))
+	#else
+	if (0
+	#endif
+	)
 	  cd->min_insn_bitsize = isa->min_insn_bitsize;
-	if (isa->max_insn_bitsize > cd->max_insn_bitsize)
+	  #ifdef FRCOV
+	  }
+	  #endif
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[3330]) {
+	  if ((isa -> max_insn_bitsize > cd -> max_insn_bitsize  ) && !(0))
+	    fprintf(stderr, "triggered bug index 3330\n");
+	  else
+	    fprintf(stderr, "reached bug index 3330\n");
+	}
+	if ((!FIXREVERTER[3330] && (isa -> max_insn_bitsize > cd -> max_insn_bitsize  ))
+	#else
+	if (0
+	#endif
+	)
 	  cd->max_insn_bitsize = isa->max_insn_bitsize;
+	  #ifdef FRCOV
+	  }
+	  #endif
       }
 
   /* Data derived from the mach spec.  */
@@ -1310,8 +1343,23 @@ xstormy16_cgen_rebuild_tables (CGEN_CPU_TABLE *cd)
 
 	if (mach->insn_chunk_bitsize != 0)
 	{
-	  if (cd->insn_chunk_bitsize != 0 && cd->insn_chunk_bitsize != mach->insn_chunk_bitsize)
+	  
+	  #ifdef FRCOV
+	  {if (FIXREVERTER[3331]) {
+	    fprintf(stderr, "reached bug index 3331\n");
+	  }
+	  if ((FIXREVERTER[3331] && (cd -> insn_chunk_bitsize != 0 )) || (!FIXREVERTER[3331] && (cd -> insn_chunk_bitsize != 0 && cd -> insn_chunk_bitsize != mach -> insn_chunk_bitsize ))
+	  #else
+	  if (cd -> insn_chunk_bitsize != 0 
+	  #endif
+	  )
 	    {
+	      
+	    #ifdef FRCOV
+	      if (!(cd -> insn_chunk_bitsize != mach -> insn_chunk_bitsize ))
+	        fprintf(stderr, "triggered bug index 3331\n");
+	      #endif
+	    
 	      opcodes_error_handler
 		(/* xgettext:c-format */
 		 _("internal error: xstormy16_cgen_rebuild_tables: "
@@ -1319,6 +1367,9 @@ xstormy16_cgen_rebuild_tables (CGEN_CPU_TABLE *cd)
 		 cd->insn_chunk_bitsize, mach->insn_chunk_bitsize);
 	      abort ();
 	    }
+	    #ifdef FRCOV
+	    }
+	    #endif
 
  	  cd->insn_chunk_bitsize = mach->insn_chunk_bitsize;
 	}
@@ -1412,8 +1463,23 @@ xstormy16_cgen_cpu_open (enum cgen_cpu_open_arg arg_type, ...)
   va_end (ap);
 
   /* Mach unspecified means "all".  */
-  if (machs == 0)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[3333]) {
+    if ((machs == 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 3333\n");
+    else
+      fprintf(stderr, "reached bug index 3333\n");
+  }
+  if ((!FIXREVERTER[3333] && (machs == 0 ))
+  #else
+  if (0
+  #endif
+  )
     machs = (1 << MAX_MACHS) - 1;
+    #ifdef FRCOV
+    }
+    #endif
   /* Base mach is always selected.  */
   machs |= 1;
   if (endian == CGEN_ENDIAN_UNKNOWN)
diff --git a/opcodes/xstormy16-dis.c b/opcodes/xstormy16-dis.c
index 24d22f1..f4025a2 100644
--- a/opcodes/xstormy16-dis.c
+++ b/opcodes/xstormy16-dis.c
@@ -1,3 +1,6 @@
+#ifdef FRCOV
+extern short FIXREVERTER[];
+#endif
 /* DO NOT EDIT!  -*- buffer-read-only: t -*- vi:set ro:  */
 /* Disassembler interface for targets using CGEN. -*- C -*-
    CGEN: Cpu tools GENerator
@@ -587,10 +590,40 @@ print_insn_xstormy16 (bfd_vma pc, disassemble_info *info)
      but if not possible try to move this hook elsewhere rather than
      have two hooks.  */
   length = CGEN_PRINT_INSN (cd, pc, info);
-  if (length > 0)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[9054]) {
+    if ((length > 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 9054\n");
+    else
+      fprintf(stderr, "reached bug index 9054\n");
+  }
+  if ((!FIXREVERTER[9054] && (length > 0 ))
+  #else
+  if (0
+  #endif
+  )
     return length;
-  if (length < 0)
+    #ifdef FRCOV
+    }
+    #endif
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[9055]) {
+    if ((length < 0 ) && !(0))
+      fprintf(stderr, "triggered bug index 9055\n");
+    else
+      fprintf(stderr, "reached bug index 9055\n");
+  }
+  if ((!FIXREVERTER[9055] && (length < 0 ))
+  #else
+  if (0
+  #endif
+  )
     return -1;
+    #ifdef FRCOV
+    }
+    #endif
 
   (*info->fprintf_func) (info->stream, UNKNOWN_INSN_MSG);
   return cd->default_insn_bitsize / 8;
diff --git a/opcodes/xtensa-dis.c b/opcodes/xtensa-dis.c
index c1cf4c8..bcbebd8 100644
--- a/opcodes/xtensa-dis.c
+++ b/opcodes/xtensa-dis.c
@@ -1,3 +1,6 @@
+#ifdef FRCOV
+extern short FIXREVERTER[];
+#endif
 /* xtensa-dis.c.  Disassembly functions for Xtensa.
    Copyright (C) 2003-2021 Free Software Foundation, Inc.
    Contributed by Bob Wilson at Tensilica, Inc. (bwilson@tensilica.com)
@@ -138,8 +141,23 @@ xtensa_instruction_fits (bfd_vma memaddr, int size,
   unsigned max_size;
 
   /* If no property table info, assume it fits.  */
-  if (insn_block == NULL || size <= 0)
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[7800]) {
+    if ((insn_block == (void *) 0 ) && !(size <= 0 ))
+      fprintf(stderr, "triggered bug index 7800\n");
+    else
+      fprintf(stderr, "reached bug index 7800\n");
+  }
+  if ((FIXREVERTER[7800] && (size <= 0 )) || (!FIXREVERTER[7800] && (insn_block == (void *) 0 || size <= 0 ))
+  #else
+  if (size <= 0 
+  #endif
+  )
     return 1;
+    #ifdef FRCOV
+    }
+    #endif
 
   /* If too high, limit nextstop by the next insn address.  */
   if (insn_block->address > memaddr)
diff --git a/opcodes/z80-dis.c b/opcodes/z80-dis.c
index 9b9f941..5b45f32 100644
--- a/opcodes/z80-dis.c
+++ b/opcodes/z80-dis.c
@@ -1,3 +1,6 @@
+#ifdef FRCOV
+extern short FIXREVERTER[];
+#endif
 /* Print Z80, Z180, EZ80 and R800 instructions
    Copyright (C) 2005-2021 Free Software Foundation, Inc.
    Contributed by Arnold Metselaar <arnold_m@operamail.com>
@@ -283,8 +286,23 @@ prt_rr_d (struct buffer *buf, disassemble_info * info, const char *txt)
   int rr;
 
   rr = (buf->data[buf->n_fetch - 1] >> 4) & 3;
-  if (rr == 3) /* SP is not supported */
+  
+  #ifdef FRCOV
+  {if (FIXREVERTER[7955]) {
+    if ((rr == 3 ) && !(0))
+      fprintf(stderr, "triggered bug index 7955\n");
+    else
+      fprintf(stderr, "reached bug index 7955\n");
+  }
+  if ((!FIXREVERTER[7955] && (rr == 3 ))
+  #else
+  if (0
+  #endif
+  ) /* SP is not supported */
     return 0;
+    #ifdef FRCOV
+    }
+    #endif
 
   snprintf (mytxt, TXTSIZ, txt, rr_str[rr]);
   return prt_d (buf, info, mytxt);
diff --git a/opcodes/z8k-dis.c b/opcodes/z8k-dis.c
index 11786c8..6bbbb9f 100644
--- a/opcodes/z8k-dis.c
+++ b/opcodes/z8k-dis.c
@@ -1,3 +1,6 @@
+#ifdef FRCOV
+extern short FIXREVERTER[];
+#endif
 /* Disassemble z8000 code.
    Copyright (C) 1992-2021 Free Software Foundation, Inc.
 
@@ -572,12 +575,27 @@ unparse_instr (instr_data_s *instr_data, int is_segmented)
 	  strcat (out_str, tmp_str);
 	  break;
 	case CLASS_IMM:
-	  if (datum_value == ARG_IMM2)	/* True with EI/DI instructions only.  */
+	  
+	  #ifdef FRCOV
+	  {if (FIXREVERTER[5846]) {
+	    if ((datum_value == 10 ) && !(0))
+	      fprintf(stderr, "triggered bug index 5846\n");
+	    else
+	      fprintf(stderr, "reached bug index 5846\n");
+	  }
+	  if ((!FIXREVERTER[5846] && (datum_value == 10 ))
+	  #else
+	  if (0
+	  #endif
+	  )	/* True with EI/DI instructions only.  */
 	    {
 	      print_intr (tmp_str, instr_data->interrupts);
 	      strcat (out_str, tmp_str);
 	      break;
 	    }
+	    #ifdef FRCOV
+	    }
+	    #endif
 	  sprintf (tmp_str, "#0x%0lx", instr_data->immediate);
 	  strcat (out_str, tmp_str);
 	  break;
diff --git a/zlib/adler32.c b/zlib/adler32.c
index b3d35e2..af0429d 100644
--- a/zlib/adler32.c
+++ b/zlib/adler32.c
@@ -1,3 +1,6 @@
+#ifdef FRCOV
+#include <stdio.h>
+#endif
 /* adler32.c -- compute the Adler-32 checksum of a data stream
  * Copyright (C) 1995-2011, 2016 Mark Adler
  * For conditions of distribution and use, see copyright notice in zlib.h
diff --git a/zlib/crc32.c b/zlib/crc32.c
index affcd46..72b2454 100644
--- a/zlib/crc32.c
+++ b/zlib/crc32.c
@@ -1,3 +1,6 @@
+#ifdef FRCOV
+#include <stdio.h>
+#endif
 /* crc32.c -- compute the CRC-32 of a data stream
  * Copyright (C) 1995-2006, 2010, 2011, 2012, 2016 Mark Adler
  * For conditions of distribution and use, see copyright notice in zlib.h
diff --git a/zlib/deflate.c b/zlib/deflate.c
index 586cd15..4dd325d 100644
--- a/zlib/deflate.c
+++ b/zlib/deflate.c
@@ -1,3 +1,6 @@
+#ifdef FRCOV
+#include <stdio.h>
+#endif
 /* deflate.c -- compress data using the deflation algorithm
  * Copyright (C) 1995-2017 Jean-loup Gailly and Mark Adler
  * For conditions of distribution and use, see copyright notice in zlib.h
diff --git a/zlib/inflate.c b/zlib/inflate.c
index ac333e8..9e4cfed 100644
--- a/zlib/inflate.c
+++ b/zlib/inflate.c
@@ -1,3 +1,6 @@
+#ifdef FRCOV
+#include <stdio.h>
+#endif
 /* inflate.c -- zlib decompression
  * Copyright (C) 1995-2016 Mark Adler
  * For conditions of distribution and use, see copyright notice in zlib.h
diff --git a/zlib/inftrees.c b/zlib/inftrees.c
index 2ea08fc..171addd 100644
--- a/zlib/inftrees.c
+++ b/zlib/inftrees.c
@@ -1,3 +1,9 @@
+#ifdef FRCOV
+extern short FIXREVERTER[];
+#endif
+#ifdef FRCOV
+#include <stdio.h>
+#endif
 /* inftrees.c -- generate Huffman trees for efficient decoding
  * Copyright (C) 1995-2017 Mark Adler
  * For conditions of distribution and use, see copyright notice in zlib.h
@@ -250,15 +256,45 @@ unsigned short FAR *work;
         /* go to next symbol, update count, len */
         sym++;
         if (--(count[len]) == 0) {
-            if (len == max) break;
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[7249]) {
+              if ((len == max ) && !(0))
+                fprintf(stderr, "triggered bug index 7249\n");
+              else
+                fprintf(stderr, "reached bug index 7249\n");
+            }
+            if ((!FIXREVERTER[7249] && (len == max ))
+            #else
+            if (0
+            #endif
+            ) break;
+            #ifdef FRCOV
+            }
+            #endif
             len = lens[work[sym]];
         }
 
         /* create new sub-table if needed */
         if (len > root && (huff & mask) != low) {
             /* if first time, transition to sub-tables */
-            if (drop == 0)
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[7250]) {
+              if ((drop == 0 ) && !(0))
+                fprintf(stderr, "triggered bug index 7250\n");
+              else
+                fprintf(stderr, "reached bug index 7250\n");
+            }
+            if ((!FIXREVERTER[7250] && (drop == 0 ))
+            #else
+            if (0
+            #endif
+            )
                 drop = root;
+                #ifdef FRCOV
+                }
+                #endif
 
             /* increment past last table */
             next += min;            /* here min is 1 << curr */
