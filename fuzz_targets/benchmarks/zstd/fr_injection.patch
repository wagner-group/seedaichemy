diff --git a/lib/common/entropy_common.c b/lib/common/entropy_common.c
index b12944e..89dda32 100644
--- a/lib/common/entropy_common.c
+++ b/lib/common/entropy_common.c
@@ -1,3 +1,7 @@
+#ifdef FRCOV
+#include <stdio.h>
+extern short FIXREVERTER[];
+#endif
 /*
    Common functions of New Generation Entropy library
    Copyright (C) 2016, Yann Collet.
@@ -89,7 +93,22 @@ size_t FSE_readNCount (short* normalizedCounter, unsigned* maxSVPtr, unsigned* t
     memset(normalizedCounter, 0, (*maxSVPtr+1) * sizeof(normalizedCounter[0]));   /* all symbols not present in NCount have a frequency of 0 */
     bitStream = MEM_readLE32(ip);
     nbBits = (bitStream & 0xF) + FSE_MIN_TABLELOG;   /* extract tableLog */
-    if (nbBits > FSE_TABLELOG_ABSOLUTE_MAX) return ERROR(tableLog_tooLarge);
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[93]) {
+      if ((nbBits > 15 ) && !(0))
+        fprintf(stderr, "triggered bug index 93\n");
+      else
+        fprintf(stderr, "reached bug index 93\n");
+    }
+    if ((!FIXREVERTER[93] && (nbBits > 15 ))
+    #else
+    if (0
+    #endif
+    ) return ERROR(tableLog_tooLarge);
+    #ifdef FRCOV
+    }
+    #endif
     bitStream >>= 4;
     bitCount = 4;
     *tableLogPtr = nbBits;
@@ -156,8 +175,38 @@ size_t FSE_readNCount (short* normalizedCounter, unsigned* maxSVPtr, unsigned* t
             }
             bitStream = MEM_readLE32(ip) >> (bitCount & 31);
     }   }   /* while ((remaining>1) & (charnum<=*maxSVPtr)) */
-    if (remaining != 1) return ERROR(corruption_detected);
-    if (bitCount > 32) return ERROR(corruption_detected);
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[94]) {
+      if ((remaining != 1 ) && !(0))
+        fprintf(stderr, "triggered bug index 94\n");
+      else
+        fprintf(stderr, "reached bug index 94\n");
+    }
+    if ((!FIXREVERTER[94] && (remaining != 1 ))
+    #else
+    if (0
+    #endif
+    ) return ERROR(corruption_detected);
+    #ifdef FRCOV
+    }
+    #endif
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[95]) {
+      if ((bitCount > 32 ) && !(0))
+        fprintf(stderr, "triggered bug index 95\n");
+      else
+        fprintf(stderr, "reached bug index 95\n");
+    }
+    if ((!FIXREVERTER[95] && (bitCount > 32 ))
+    #else
+    if (0
+    #endif
+    ) return ERROR(corruption_detected);
+    #ifdef FRCOV
+    }
+    #endif
     *maxSVPtr = charnum-1;
 
     ip += (bitCount+7)>>3;
@@ -188,8 +237,38 @@ size_t HUF_readStats(BYTE* huffWeight, size_t hwSize, U32* rankStats,
     if (iSize >= 128) {  /* special header */
         oSize = iSize - 127;
         iSize = ((oSize+1)/2);
-        if (iSize+1 > srcSize) return ERROR(srcSize_wrong);
-        if (oSize >= hwSize) return ERROR(corruption_detected);
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[96]) {
+          if ((iSize + 1 > srcSize ) && !(0))
+            fprintf(stderr, "triggered bug index 96\n");
+          else
+            fprintf(stderr, "reached bug index 96\n");
+        }
+        if ((!FIXREVERTER[96] && (iSize + 1 > srcSize ))
+        #else
+        if (0
+        #endif
+        ) return ERROR(srcSize_wrong);
+        #ifdef FRCOV
+        }
+        #endif
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[97]) {
+          if ((oSize >= hwSize ) && !(0))
+            fprintf(stderr, "triggered bug index 97\n");
+          else
+            fprintf(stderr, "reached bug index 97\n");
+        }
+        if ((!FIXREVERTER[97] && (oSize >= hwSize ))
+        #else
+        if (0
+        #endif
+        ) return ERROR(corruption_detected);
+        #ifdef FRCOV
+        }
+        #endif
         ip += 1;
         {   U32 n;
             for (n=0; n<oSize; n+=2) {
@@ -198,7 +277,22 @@ size_t HUF_readStats(BYTE* huffWeight, size_t hwSize, U32* rankStats,
     }   }   }
     else  {   /* header compressed with FSE (normal case) */
         FSE_DTable fseWorkspace[FSE_DTABLE_SIZE_U32(6)];  /* 6 is max possible tableLog for HUF header (maybe even 5, to be tested) */
-        if (iSize+1 > srcSize) return ERROR(srcSize_wrong);
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[99]) {
+          if ((iSize + 1 > srcSize ) && !(0))
+            fprintf(stderr, "triggered bug index 99\n");
+          else
+            fprintf(stderr, "reached bug index 99\n");
+        }
+        if ((!FIXREVERTER[99] && (iSize + 1 > srcSize ))
+        #else
+        if (0
+        #endif
+        ) return ERROR(srcSize_wrong);
+        #ifdef FRCOV
+        }
+        #endif
         oSize = FSE_decompress_wksp(huffWeight, hwSize-1, ip+1, iSize, fseWorkspace, 6);   /* max (hwSize-1) values decoded, as last one is implied */
         if (FSE_isError(oSize)) return oSize;
     }
@@ -211,7 +305,22 @@ size_t HUF_readStats(BYTE* huffWeight, size_t hwSize, U32* rankStats,
             rankStats[huffWeight[n]]++;
             weightTotal += (1 << huffWeight[n]) >> 1;
     }   }
-    if (weightTotal == 0) return ERROR(corruption_detected);
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[100]) {
+      if ((weightTotal == 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 100\n");
+      else
+        fprintf(stderr, "reached bug index 100\n");
+    }
+    if ((!FIXREVERTER[100] && (weightTotal == 0 ))
+    #else
+    if (0
+    #endif
+    ) return ERROR(corruption_detected);
+    #ifdef FRCOV
+    }
+    #endif
 
     /* get last non-null symbol weight (implied, total must be 2^n) */
     {   U32 const tableLog = BIT_highbit32(weightTotal) + 1;
diff --git a/lib/common/fse_decompress.c b/lib/common/fse_decompress.c
index 72bbead..5c48826 100644
--- a/lib/common/fse_decompress.c
+++ b/lib/common/fse_decompress.c
@@ -1,3 +1,7 @@
+#ifdef FRCOV
+#include <stdio.h>
+extern short FIXREVERTER[];
+#endif
 /* ******************************************************************
    FSE : Finite State Entropy decoder
    Copyright (C) 2013-2015, Yann Collet.
@@ -102,7 +106,22 @@ size_t FSE_buildDTable(FSE_DTable* dt, const short* normalizedCounter, unsigned
 
     /* Sanity Checks */
     if (maxSymbolValue > FSE_MAX_SYMBOL_VALUE) return ERROR(maxSymbolValue_tooLarge);
-    if (tableLog > FSE_MAX_TABLELOG) return ERROR(tableLog_tooLarge);
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[85]) {
+      if ((tableLog > 14 - 2 ) && !(0))
+        fprintf(stderr, "triggered bug index 85\n");
+      else
+        fprintf(stderr, "reached bug index 85\n");
+    }
+    if ((!FIXREVERTER[85] && (tableLog > 14 - 2 ))
+    #else
+    if (0
+    #endif
+    ) return ERROR(tableLog_tooLarge);
+    #ifdef FRCOV
+    }
+    #endif
 
     /* Init, lay down lowprob symbols */
     {   FSE_DTableHeader DTableH;
@@ -132,7 +151,22 @@ size_t FSE_buildDTable(FSE_DTable* dt, const short* normalizedCounter, unsigned
                 position = (position + step) & tableMask;
                 while (position > highThreshold) position = (position + step) & tableMask;   /* lowprob area */
         }   }
-        if (position!=0) return ERROR(GENERIC);   /* position must reach all cells once, otherwise normalizedCounter is incorrect */
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[86]) {
+          if ((position != 0 ) && !(0))
+            fprintf(stderr, "triggered bug index 86\n");
+          else
+            fprintf(stderr, "reached bug index 86\n");
+        }
+        if ((!FIXREVERTER[86] && (position != 0 ))
+        #else
+        if (0
+        #endif
+        ) return ERROR(GENERIC);
+        #ifdef FRCOV
+        }
+        #endif   /* position must reach all cells once, otherwise normalizedCounter is incorrect */
     }
 
     /* Build Decoding table */
@@ -286,7 +320,22 @@ size_t FSE_decompress_wksp(void* dst, size_t dstCapacity, const void* cSrc, size
     size_t const NCountLength = FSE_readNCount (counting, &maxSymbolValue, &tableLog, istart, cSrcSize);
     if (FSE_isError(NCountLength)) return NCountLength;
     //if (NCountLength >= cSrcSize) return ERROR(srcSize_wrong);   /* too small input size; supposed to be already checked in NCountLength, only remaining case : NCountLength==cSrcSize */
-    if (tableLog > maxLog) return ERROR(tableLog_tooLarge);
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[89]) {
+      if ((tableLog > maxLog ) && !(0))
+        fprintf(stderr, "triggered bug index 89\n");
+      else
+        fprintf(stderr, "reached bug index 89\n");
+    }
+    if ((!FIXREVERTER[89] && (tableLog > maxLog ))
+    #else
+    if (0
+    #endif
+    ) return ERROR(tableLog_tooLarge);
+    #ifdef FRCOV
+    }
+    #endif
     ip += NCountLength;
     cSrcSize -= NCountLength;
 
diff --git a/lib/decompress/huf_decompress.c b/lib/decompress/huf_decompress.c
index 3f8bd29..79eb78e 100644
--- a/lib/decompress/huf_decompress.c
+++ b/lib/decompress/huf_decompress.c
@@ -1,3 +1,7 @@
+#ifdef FRCOV
+#include <stdio.h>
+extern short FIXREVERTER[];
+#endif
 /* ******************************************************************
    huff0 huffman decoder,
    part of Finite State Entropy library
@@ -538,7 +542,22 @@ static void HUF_fillDTableX2(HUF_DEltX2* DTable, const U32 targetLog,
         if (targetLog-nbBits >= minBits) {   /* enough room for a second symbol */
             U32 sortedRank;
             int minWeight = nbBits + scaleLog;
-            if (minWeight < 1) minWeight = 1;
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[15]) {
+              if ((minWeight < 1 ) && !(0))
+                fprintf(stderr, "triggered bug index 15\n");
+              else
+                fprintf(stderr, "reached bug index 15\n");
+            }
+            if ((!FIXREVERTER[15] && (minWeight < 1 ))
+            #else
+            if (0
+            #endif
+            ) minWeight = 1;
+            #ifdef FRCOV
+            }
+            #endif
             sortedRank = rankStart[minWeight];
             HUF_fillDTableX2Level2(DTable+start, targetLog-nbBits, nbBits,
                            rankValOrigin[nbBits], minWeight,
@@ -907,7 +926,22 @@ static size_t HUF_decompress4X2_DCtx_wksp_bmi2(HUF_DTable* dctx, void* dst, size
     size_t hSize = HUF_readDTableX2_wksp(dctx, cSrc, cSrcSize,
                                          workSpace, wkspSize);
     if (HUF_isError(hSize)) return hSize;
-    if (hSize >= cSrcSize) return ERROR(srcSize_wrong);
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[18]) {
+      if ((hSize >= cSrcSize ) && !(0))
+        fprintf(stderr, "triggered bug index 18\n");
+      else
+        fprintf(stderr, "reached bug index 18\n");
+    }
+    if ((!FIXREVERTER[18] && (hSize >= cSrcSize ))
+    #else
+    if (0
+    #endif
+    ) return ERROR(srcSize_wrong);
+    #ifdef FRCOV
+    }
+    #endif
     ip += hSize; cSrcSize -= hSize;
 
     return HUF_decompress4X2_usingDTable_internal(dst, dstSize, ip, cSrcSize, dctx, bmi2);
@@ -1212,8 +1246,38 @@ size_t HUF_decompress4X_usingDTable_bmi2(void* dst, size_t maxDstSize, const voi
 size_t HUF_decompress4X_hufOnly_wksp_bmi2(HUF_DTable* dctx, void* dst, size_t dstSize, const void* cSrc, size_t cSrcSize, void* workSpace, size_t wkspSize, int bmi2)
 {
     /* validation checks */
-    if (dstSize == 0) return ERROR(dstSize_tooSmall);
-    if (cSrcSize == 0) return ERROR(corruption_detected);
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[40]) {
+      if ((dstSize == 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 40\n");
+      else
+        fprintf(stderr, "reached bug index 40\n");
+    }
+    if ((!FIXREVERTER[40] && (dstSize == 0 ))
+    #else
+    if (0
+    #endif
+    ) return ERROR(dstSize_tooSmall);
+    #ifdef FRCOV
+    }
+    #endif
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[41]) {
+      if ((cSrcSize == 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 41\n");
+      else
+        fprintf(stderr, "reached bug index 41\n");
+    }
+    if ((!FIXREVERTER[41] && (cSrcSize == 0 ))
+    #else
+    if (0
+    #endif
+    ) return ERROR(corruption_detected);
+    #ifdef FRCOV
+    }
+    #endif
 
     {   U32 const algoNb = HUF_selectDecoder(dstSize, cSrcSize);
 #if defined(HUF_FORCE_DECOMPRESS_X1)
diff --git a/lib/decompress/zstd_decompress.c b/lib/decompress/zstd_decompress.c
index e42872a..8b21397 100644
--- a/lib/decompress/zstd_decompress.c
+++ b/lib/decompress/zstd_decompress.c
@@ -1,3 +1,7 @@
+#ifdef FRCOV
+#include <stdio.h>
+extern short FIXREVERTER[];
+#endif
 /*
  * Copyright (c) 2016-present, Yann Collet, Facebook, Inc.
  * All rights reserved.
@@ -158,7 +162,22 @@ static void ZSTD_clearDict(ZSTD_DCtx* dctx)
 
 size_t ZSTD_freeDCtx(ZSTD_DCtx* dctx)
 {
-    if (dctx==NULL) return 0;   /* support free on NULL */
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[55]) {
+      if ((dctx == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 55\n");
+      else
+        fprintf(stderr, "reached bug index 55\n");
+    }
+    if ((!FIXREVERTER[55] && (dctx == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) return 0;
+    #ifdef FRCOV
+    }
+    #endif   /* support free on NULL */
     RETURN_ERROR_IF(dctx->staticSize, memory_allocation, "not compatible with static DCtx");
     {   ZSTD_customMem const cMem = dctx->customMem;
         ZSTD_clearDict(dctx);
@@ -588,7 +607,22 @@ static size_t ZSTD_copyRawBlock(void* dst, size_t dstCapacity,
 {
     DEBUGLOG(5, "ZSTD_copyRawBlock");
     if (dst == NULL) {
-        if (srcSize == 0) return 0;
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[59]) {
+          if ((srcSize == 0 ) && !(0))
+            fprintf(stderr, "triggered bug index 59\n");
+          else
+            fprintf(stderr, "reached bug index 59\n");
+        }
+        if ((!FIXREVERTER[59] && (srcSize == 0 ))
+        #else
+        if (0
+        #endif
+        ) return 0;
+        #ifdef FRCOV
+        }
+        #endif
         RETURN_ERROR(dstBuffer_null);
     }
     RETURN_ERROR_IF(srcSize > dstCapacity, dstSize_tooSmall);
@@ -601,7 +635,22 @@ static size_t ZSTD_setRleBlock(void* dst, size_t dstCapacity,
                                size_t regenSize)
 {
     if (dst == NULL) {
-        if (regenSize == 0) return 0;
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[61]) {
+          if ((regenSize == 0 ) && !(0))
+            fprintf(stderr, "triggered bug index 61\n");
+          else
+            fprintf(stderr, "reached bug index 61\n");
+        }
+        if ((!FIXREVERTER[61] && (regenSize == 0 ))
+        #else
+        if (0
+        #endif
+        ) return 0;
+        #ifdef FRCOV
+        }
+        #endif
         RETURN_ERROR(dstBuffer_null);
     }
     RETURN_ERROR_IF(regenSize > dstCapacity, dstSize_tooSmall);
@@ -1105,7 +1154,22 @@ ZSTD_loadDEntropy(ZSTD_entropyDTables_t* entropy,
 
 static size_t ZSTD_decompress_insertDictionary(ZSTD_DCtx* dctx, const void* dict, size_t dictSize)
 {
-    if (dictSize < 8) return ZSTD_refDictContent(dctx, dict, dictSize);
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[67]) {
+      if ((dictSize < 8 ) && !(0))
+        fprintf(stderr, "triggered bug index 67\n");
+      else
+        fprintf(stderr, "reached bug index 67\n");
+    }
+    if ((!FIXREVERTER[67] && (dictSize < 8 ))
+    #else
+    if (0
+    #endif
+    ) return ZSTD_refDictContent(dctx, dict, dictSize);
+    #ifdef FRCOV
+    }
+    #endif
     {   U32 const magic = MEM_readLE32(dict);
         if (magic != ZSTD_MAGIC_DICTIONARY) {
             return ZSTD_refDictContent(dctx, dict, dictSize);   /* pure content mode */
diff --git a/lib/legacy/zstd_v01.c b/lib/legacy/zstd_v01.c
index 35d8497..b33f673 100644
--- a/lib/legacy/zstd_v01.c
+++ b/lib/legacy/zstd_v01.c
@@ -1,3 +1,7 @@
+#ifdef FRCOV
+#include <stdio.h>
+extern short FIXREVERTER[];
+#endif
 /*
  * Copyright (c) 2016-present, Yann Collet, Facebook, Inc.
  * All rights reserved.
@@ -414,7 +418,22 @@ static size_t FSE_buildDTable
 
     /* Sanity Checks */
     if (maxSymbolValue > FSE_MAX_SYMBOL_VALUE) return (size_t)-FSE_ERROR_maxSymbolValue_tooLarge;
-    if (tableLog > FSE_MAX_TABLELOG) return (size_t)-FSE_ERROR_tableLog_tooLarge;
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[664]) {
+      if ((tableLog > 14 - 2 ) && !(0))
+        fprintf(stderr, "triggered bug index 664\n");
+      else
+        fprintf(stderr, "reached bug index 664\n");
+    }
+    if ((!FIXREVERTER[664] && (tableLog > 14 - 2 ))
+    #else
+    if (0
+    #endif
+    ) return (size_t)-FSE_ERROR_tableLog_tooLarge;
+    #ifdef FRCOV
+    }
+    #endif
 
     /* Init, lay down lowprob symbols */
     DTableH[0].tableLog = (U16)tableLog;
@@ -444,7 +463,22 @@ static size_t FSE_buildDTable
         }
     }
 
-    if (position!=0) return (size_t)-FSE_ERROR_GENERIC;   /* position must reach all cells once, otherwise normalizedCounter is incorrect */
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[665]) {
+      if ((position != 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 665\n");
+      else
+        fprintf(stderr, "reached bug index 665\n");
+    }
+    if ((!FIXREVERTER[665] && (position != 0 ))
+    #else
+    if (0
+    #endif
+    ) return (size_t)-FSE_ERROR_GENERIC;
+    #ifdef FRCOV
+    }
+    #endif   /* position must reach all cells once, otherwise normalizedCounter is incorrect */
 
     /* Build Decoding table */
     {
@@ -493,10 +527,40 @@ static size_t FSE_readNCount (short* normalizedCounter, unsigned* maxSVPtr, unsi
     unsigned charnum = 0;
     int previous0 = 0;
 
-    if (hbSize < 4) return (size_t)-FSE_ERROR_srcSize_wrong;
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[666]) {
+      if ((hbSize < 4 ) && !(0))
+        fprintf(stderr, "triggered bug index 666\n");
+      else
+        fprintf(stderr, "reached bug index 666\n");
+    }
+    if ((!FIXREVERTER[666] && (hbSize < 4 ))
+    #else
+    if (0
+    #endif
+    ) return (size_t)-FSE_ERROR_srcSize_wrong;
+    #ifdef FRCOV
+    }
+    #endif
     bitStream = FSE_readLE32(ip);
     nbBits = (bitStream & 0xF) + FSE_MIN_TABLELOG;   /* extract tableLog */
-    if (nbBits > FSE_TABLELOG_ABSOLUTE_MAX) return (size_t)-FSE_ERROR_tableLog_tooLarge;
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[667]) {
+      if ((nbBits > 15 ) && !(0))
+        fprintf(stderr, "triggered bug index 667\n");
+      else
+        fprintf(stderr, "reached bug index 667\n");
+    }
+    if ((!FIXREVERTER[667] && (nbBits > 15 ))
+    #else
+    if (0
+    #endif
+    ) return (size_t)-FSE_ERROR_tableLog_tooLarge;
+    #ifdef FRCOV
+    }
+    #endif
     bitStream >>= 4;
     bitCount = 4;
     *tableLogPtr = nbBits;
@@ -583,7 +647,22 @@ static size_t FSE_readNCount (short* normalizedCounter, unsigned* maxSVPtr, unsi
             }
         }
     }
-    if (remaining != 1) return (size_t)-FSE_ERROR_GENERIC;
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[668]) {
+      if ((remaining != 1 ) && !(0))
+        fprintf(stderr, "triggered bug index 668\n");
+      else
+        fprintf(stderr, "reached bug index 668\n");
+    }
+    if ((!FIXREVERTER[668] && (remaining != 1 ))
+    #else
+    if (0
+    #endif
+    ) return (size_t)-FSE_ERROR_GENERIC;
+    #ifdef FRCOV
+    }
+    #endif
     *maxSVPtr = charnum-1;
 
     ip += (bitCount+7)>>3;
@@ -623,7 +702,22 @@ static size_t FSE_buildDTable_raw (FSE_DTable* dt, unsigned nbBits)
     unsigned s;
 
     /* Sanity checks */
-    if (nbBits < 1) return (size_t)-FSE_ERROR_GENERIC;             /* min size */
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[669]) {
+      if ((nbBits < 1 ) && !(0))
+        fprintf(stderr, "triggered bug index 669\n");
+      else
+        fprintf(stderr, "reached bug index 669\n");
+    }
+    if ((!FIXREVERTER[669] && (nbBits < 1 ))
+    #else
+    if (0
+    #endif
+    ) return (size_t)-FSE_ERROR_GENERIC;
+    #ifdef FRCOV
+    }
+    #endif             /* min size */
 
     /* Build Decoding Table */
     DTableH->tableLog = (U16)nbBits;
@@ -647,7 +741,22 @@ static size_t FSE_buildDTable_raw (FSE_DTable* dt, unsigned nbBits)
  */
 static size_t FSE_initDStream(FSE_DStream_t* bitD, const void* srcBuffer, size_t srcSize)
 {
-    if (srcSize < 1) return (size_t)-FSE_ERROR_srcSize_wrong;
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[670]) {
+      if ((srcSize < 1 ) && !(0))
+        fprintf(stderr, "triggered bug index 670\n");
+      else
+        fprintf(stderr, "reached bug index 670\n");
+    }
+    if ((!FIXREVERTER[670] && (srcSize < 1 ))
+    #else
+    if (0
+    #endif
+    ) return (size_t)-FSE_ERROR_srcSize_wrong;
+    #ifdef FRCOV
+    }
+    #endif
 
     if (srcSize >=  sizeof(size_t))
     {
@@ -656,7 +765,22 @@ static size_t FSE_initDStream(FSE_DStream_t* bitD, const void* srcBuffer, size_t
         bitD->ptr   = (const char*)srcBuffer + srcSize - sizeof(size_t);
         bitD->bitContainer = FSE_readLEST(bitD->ptr);
         contain32 = ((const BYTE*)srcBuffer)[srcSize-1];
-        if (contain32 == 0) return (size_t)-FSE_ERROR_GENERIC;   /* stop bit not present */
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[671]) {
+          if ((contain32 == 0 ) && !(0))
+            fprintf(stderr, "triggered bug index 671\n");
+          else
+            fprintf(stderr, "reached bug index 671\n");
+        }
+        if ((!FIXREVERTER[671] && (contain32 == 0 ))
+        #else
+        if (0
+        #endif
+        ) return (size_t)-FSE_ERROR_GENERIC;
+        #ifdef FRCOV
+        }
+        #endif   /* stop bit not present */
         bitD->bitsConsumed = 8 - FSE_highbit32(contain32);
     }
     else
@@ -682,7 +806,22 @@ static size_t FSE_initDStream(FSE_DStream_t* bitD, const void* srcBuffer, size_t
             default:;
         }
         contain32 = ((const BYTE*)srcBuffer)[srcSize-1];
-        if (contain32 == 0) return (size_t)-FSE_ERROR_GENERIC;   /* stop bit not present */
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[672]) {
+          if ((contain32 == 0 ) && !(0))
+            fprintf(stderr, "triggered bug index 672\n");
+          else
+            fprintf(stderr, "reached bug index 672\n");
+        }
+        if ((!FIXREVERTER[672] && (contain32 == 0 ))
+        #else
+        if (0
+        #endif
+        ) return (size_t)-FSE_ERROR_GENERIC;
+        #ifdef FRCOV
+        }
+        #endif   /* stop bit not present */
         bitD->bitsConsumed = 8 - FSE_highbit32(contain32);
         bitD->bitsConsumed += (U32)(sizeof(size_t) - srcSize)*8;
     }
@@ -908,12 +1047,42 @@ static size_t FSE_decompress(void* dst, size_t maxDstSize, const void* cSrc, siz
     unsigned maxSymbolValue = FSE_MAX_SYMBOL_VALUE;
     size_t errorCode;
 
-    if (cSrcSize<2) return (size_t)-FSE_ERROR_srcSize_wrong;   /* too small input size */
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[675]) {
+      if ((cSrcSize < 2 ) && !(0))
+        fprintf(stderr, "triggered bug index 675\n");
+      else
+        fprintf(stderr, "reached bug index 675\n");
+    }
+    if ((!FIXREVERTER[675] && (cSrcSize < 2 ))
+    #else
+    if (0
+    #endif
+    ) return (size_t)-FSE_ERROR_srcSize_wrong;
+    #ifdef FRCOV
+    }
+    #endif   /* too small input size */
 
     /* normal FSE decoding mode */
     errorCode = FSE_readNCount (counting, &maxSymbolValue, &tableLog, istart, cSrcSize);
     if (FSE_isError(errorCode)) return errorCode;
-    if (errorCode >= cSrcSize) return (size_t)-FSE_ERROR_srcSize_wrong;   /* too small input size */
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[676]) {
+      if ((errorCode >= cSrcSize ) && !(0))
+        fprintf(stderr, "triggered bug index 676\n");
+      else
+        fprintf(stderr, "reached bug index 676\n");
+    }
+    if ((!FIXREVERTER[676] && (errorCode >= cSrcSize ))
+    #else
+    if (0
+    #endif
+    ) return (size_t)-FSE_ERROR_srcSize_wrong;
+    #ifdef FRCOV
+    }
+    #endif   /* too small input size */
     ip += errorCode;
     cSrcSize -= errorCode;
 
@@ -990,7 +1159,22 @@ static size_t HUF_readDTable (U16* DTable, const void* src, size_t srcSize)
         {
             oSize = iSize - 127;
             iSize = ((oSize+1)/2);
-            if (iSize+1 > srcSize) return (size_t)-FSE_ERROR_srcSize_wrong;
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[680]) {
+              if ((iSize + 1 > srcSize ) && !(0))
+                fprintf(stderr, "triggered bug index 680\n");
+              else
+                fprintf(stderr, "reached bug index 680\n");
+            }
+            if ((!FIXREVERTER[680] && (iSize + 1 > srcSize ))
+            #else
+            if (0
+            #endif
+            ) return (size_t)-FSE_ERROR_srcSize_wrong;
+            #ifdef FRCOV
+            }
+            #endif
             ip += 1;
             for (n=0; n<oSize; n+=2)
             {
@@ -1001,7 +1185,22 @@ static size_t HUF_readDTable (U16* DTable, const void* src, size_t srcSize)
     }
     else  /* header compressed with FSE (normal case) */
     {
-        if (iSize+1 > srcSize) return (size_t)-FSE_ERROR_srcSize_wrong;
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[681]) {
+          if ((iSize + 1 > srcSize ) && !(0))
+            fprintf(stderr, "triggered bug index 681\n");
+          else
+            fprintf(stderr, "reached bug index 681\n");
+        }
+        if ((!FIXREVERTER[681] && (iSize + 1 > srcSize ))
+        #else
+        if (0
+        #endif
+        ) return (size_t)-FSE_ERROR_srcSize_wrong;
+        #ifdef FRCOV
+        }
+        #endif
         oSize = FSE_decompress(huffWeight, HUF_MAX_SYMBOL_VALUE, ip+1, iSize);   /* max 255 values decoded, last one is implied */
         if (FSE_isError(oSize)) return oSize;
     }
@@ -1015,7 +1214,22 @@ static size_t HUF_readDTable (U16* DTable, const void* src, size_t srcSize)
         rankVal[huffWeight[n]]++;
         weightTotal += (1 << huffWeight[n]) >> 1;
     }
-    if (weightTotal == 0) return (size_t)-FSE_ERROR_corruptionDetected;
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[682]) {
+      if ((weightTotal == 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 682\n");
+      else
+        fprintf(stderr, "reached bug index 682\n");
+    }
+    if ((!FIXREVERTER[682] && (weightTotal == 0 ))
+    #else
+    if (0
+    #endif
+    ) return (size_t)-FSE_ERROR_corruptionDetected;
+    #ifdef FRCOV
+    }
+    #endif
 
     /* get last non-null symbol weight (implied, total must be 2^n) */
     maxBits = FSE_highbit32(weightTotal) + 1;
@@ -1026,7 +1240,22 @@ static size_t HUF_readDTable (U16* DTable, const void* src, size_t srcSize)
         U32 rest = total - weightTotal;
         U32 verif = 1 << FSE_highbit32(rest);
         U32 lastWeight = FSE_highbit32(rest) + 1;
-        if (verif != rest) return (size_t)-FSE_ERROR_corruptionDetected;    /* last value must be a clean power of 2 */
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[683]) {
+          if ((verif != rest ) && !(0))
+            fprintf(stderr, "triggered bug index 683\n");
+          else
+            fprintf(stderr, "reached bug index 683\n");
+        }
+        if ((!FIXREVERTER[683] && (verif != rest ))
+        #else
+        if (0
+        #endif
+        ) return (size_t)-FSE_ERROR_corruptionDetected;
+        #ifdef FRCOV
+        }
+        #endif    /* last value must be a clean power of 2 */
         huffWeight[oSize] = (BYTE)lastWeight;
         rankVal[lastWeight]++;
     }
@@ -1073,7 +1302,22 @@ static size_t HUF_decompress_usingDTable(   /* -3% slower when non static */
     const void* cSrc, size_t cSrcSize,
     const U16* DTable)
 {
-    if (cSrcSize < 6) return (size_t)-FSE_ERROR_srcSize_wrong;
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[684]) {
+      if ((cSrcSize < 6 ) && !(0))
+        fprintf(stderr, "triggered bug index 684\n");
+      else
+        fprintf(stderr, "reached bug index 684\n");
+    }
+    if ((!FIXREVERTER[684] && (cSrcSize < 6 ))
+    #else
+    if (0
+    #endif
+    ) return (size_t)-FSE_ERROR_srcSize_wrong;
+    #ifdef FRCOV
+    }
+    #endif
     {
         BYTE* const ostart = (BYTE*) dst;
         BYTE* op = ostart;
@@ -1180,7 +1424,22 @@ static size_t HUF_decompress (void* dst, size_t maxDstSize, const void* cSrc, si
 
     errorCode = HUF_readDTable (DTable, cSrc, cSrcSize);
     if (FSE_isError(errorCode)) return errorCode;
-    if (errorCode >= cSrcSize) return (size_t)-FSE_ERROR_srcSize_wrong;
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[686]) {
+      if ((errorCode >= cSrcSize ) && !(0))
+        fprintf(stderr, "triggered bug index 686\n");
+      else
+        fprintf(stderr, "reached bug index 686\n");
+    }
+    if ((!FIXREVERTER[686] && (errorCode >= cSrcSize ))
+    #else
+    if (0
+    #endif
+    ) return (size_t)-FSE_ERROR_srcSize_wrong;
+    #ifdef FRCOV
+    }
+    #endif
     ip += errorCode;
     cSrcSize -= errorCode;
 
@@ -1491,7 +1750,22 @@ static size_t ZSTDv01_getcBlockSize(const void* src, size_t srcSize, blockProper
 
 static size_t ZSTD_copyUncompressedBlock(void* dst, size_t maxDstSize, const void* src, size_t srcSize)
 {
-    if (srcSize > maxDstSize) return ERROR(dstSize_tooSmall);
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[690]) {
+      if ((srcSize > maxDstSize ) && !(0))
+        fprintf(stderr, "triggered bug index 690\n");
+      else
+        fprintf(stderr, "reached bug index 690\n");
+    }
+    if ((!FIXREVERTER[690] && (srcSize > maxDstSize ))
+    #else
+    if (0
+    #endif
+    ) return ERROR(dstSize_tooSmall);
+    #ifdef FRCOV
+    }
+    #endif
     memcpy(dst, src, srcSize);
     return srcSize;
 }
@@ -1508,14 +1782,44 @@ static size_t ZSTD_decompressLiterals(void* ctx,
     size_t litSize;
 
     /* check : minimum 2, for litSize, +1, for content */
-    if (srcSize <= 3) return ERROR(corruption_detected);
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[692]) {
+      if ((srcSize <= 3 ) && !(0))
+        fprintf(stderr, "triggered bug index 692\n");
+      else
+        fprintf(stderr, "reached bug index 692\n");
+    }
+    if ((!FIXREVERTER[692] && (srcSize <= 3 ))
+    #else
+    if (0
+    #endif
+    ) return ERROR(corruption_detected);
+    #ifdef FRCOV
+    }
+    #endif
 
     litSize = ip[1] + (ip[0]<<8);
     litSize += ((ip[-3] >> 3) & 7) << 16;   // mmmmh....
     op = oend - litSize;
 
     (void)ctx;
-    if (litSize > maxDstSize) return ERROR(dstSize_tooSmall);
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[693]) {
+      if ((litSize > maxDstSize ) && !(0))
+        fprintf(stderr, "triggered bug index 693\n");
+      else
+        fprintf(stderr, "reached bug index 693\n");
+    }
+    if ((!FIXREVERTER[693] && (litSize > maxDstSize ))
+    #else
+    if (0
+    #endif
+    ) return ERROR(dstSize_tooSmall);
+    #ifdef FRCOV
+    }
+    #endif
     errorCode = HUF_decompress(op, litSize, ip+2, srcSize-2);
     if (FSE_isError(errorCode)) return ERROR(GENERIC);
     return litSize;
@@ -1548,7 +1852,22 @@ static size_t ZSTDv01_decodeLiteralsBlock(void* ctx,
     case bt_rle:
         {
             size_t rleSize = litbp.origSize;
-            if (rleSize>maxDstSize) return ERROR(dstSize_tooSmall);
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[694]) {
+              if ((rleSize > maxDstSize ) && !(0))
+                fprintf(stderr, "triggered bug index 694\n");
+              else
+                fprintf(stderr, "reached bug index 694\n");
+            }
+            if ((!FIXREVERTER[694] && (rleSize > maxDstSize ))
+            #else
+            if (0
+            #endif
+            ) return ERROR(dstSize_tooSmall);
+            #ifdef FRCOV
+            }
+            #endif
             if (!srcSize) return ERROR(srcSize_wrong);
             memset(oend - rleSize, *ip, rleSize);
             *litStart = oend - rleSize;
@@ -1586,7 +1905,22 @@ static size_t ZSTDv01_decodeSeqHeaders(int* nbSeq, const BYTE** dumpsPtr, size_t
     size_t dumpsLength;
 
     /* check */
-    if (srcSize < 5) return ERROR(srcSize_wrong);
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[695]) {
+      if ((srcSize < 5 ) && !(0))
+        fprintf(stderr, "triggered bug index 695\n");
+      else
+        fprintf(stderr, "reached bug index 695\n");
+    }
+    if ((!FIXREVERTER[695] && (srcSize < 5 ))
+    #else
+    if (0
+    #endif
+    ) return ERROR(srcSize_wrong);
+    #ifdef FRCOV
+    }
+    #endif
 
     /* SeqHead */
     *nbSeq = ZSTD_readLE16(ip); ip+=2;
@@ -1630,7 +1964,22 @@ static size_t ZSTDv01_decodeSeqHeaders(int* nbSeq, const BYTE** dumpsPtr, size_t
             {   U32 max = MaxLL;
                 headerSize = FSE_readNCount(norm, &max, &LLlog, ip, iend-ip);
                 if (FSE_isError(headerSize)) return ERROR(GENERIC);
-                if (LLlog > LLFSELog) return ERROR(corruption_detected);
+                
+                #ifdef FRCOV
+                {if (FIXREVERTER[697]) {
+                  if ((LLlog > 10 ) && !(0))
+                    fprintf(stderr, "triggered bug index 697\n");
+                  else
+                    fprintf(stderr, "reached bug index 697\n");
+                }
+                if ((!FIXREVERTER[697] && (LLlog > 10 ))
+                #else
+                if (0
+                #endif
+                ) return ERROR(corruption_detected);
+                #ifdef FRCOV
+                }
+                #endif
                 ip += headerSize;
                 FSE_buildDTable(DTableLL, norm, max, LLlog);
         }   }
@@ -1648,7 +1997,22 @@ static size_t ZSTDv01_decodeSeqHeaders(int* nbSeq, const BYTE** dumpsPtr, size_t
             {   U32 max = MaxOff;
                 headerSize = FSE_readNCount(norm, &max, &Offlog, ip, iend-ip);
                 if (FSE_isError(headerSize)) return ERROR(GENERIC);
-                if (Offlog > OffFSELog) return ERROR(corruption_detected);
+                
+                #ifdef FRCOV
+                {if (FIXREVERTER[698]) {
+                  if ((Offlog > 9 ) && !(0))
+                    fprintf(stderr, "triggered bug index 698\n");
+                  else
+                    fprintf(stderr, "reached bug index 698\n");
+                }
+                if ((!FIXREVERTER[698] && (Offlog > 9 ))
+                #else
+                if (0
+                #endif
+                ) return ERROR(corruption_detected);
+                #ifdef FRCOV
+                }
+                #endif
                 ip += headerSize;
                 FSE_buildDTable(DTableOffb, norm, max, Offlog);
         }   }
@@ -1666,7 +2030,22 @@ static size_t ZSTDv01_decodeSeqHeaders(int* nbSeq, const BYTE** dumpsPtr, size_t
             {   U32 max = MaxML;
                 headerSize = FSE_readNCount(norm, &max, &MLlog, ip, iend-ip);
                 if (FSE_isError(headerSize)) return ERROR(GENERIC);
-                if (MLlog > MLFSELog) return ERROR(corruption_detected);
+                
+                #ifdef FRCOV
+                {if (FIXREVERTER[699]) {
+                  if ((MLlog > 10 ) && !(0))
+                    fprintf(stderr, "triggered bug index 699\n");
+                  else
+                    fprintf(stderr, "reached bug index 699\n");
+                }
+                if ((!FIXREVERTER[699] && (MLlog > 10 ))
+                #else
+                if (0
+                #endif
+                ) return ERROR(corruption_detected);
+                #ifdef FRCOV
+                }
+                #endif
                 ip += headerSize;
                 FSE_buildDTable(DTableML, norm, max, MLlog);
     }   }   }
@@ -1725,10 +2104,40 @@ static void ZSTD_decodeSequence(seq_t* seq, seqState_t* seqState)
         offsetCode = FSE_decodeSymbol(&(seqState->stateOffb), &(seqState->DStream));
         if (ZSTD_32bits()) FSE_reloadDStream(&(seqState->DStream));
         nbBits = offsetCode - 1;
-        if (offsetCode==0) nbBits = 0;   /* cmove */
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[700]) {
+          if ((offsetCode == 0 ) && !(0))
+            fprintf(stderr, "triggered bug index 700\n");
+          else
+            fprintf(stderr, "reached bug index 700\n");
+        }
+        if ((!FIXREVERTER[700] && (offsetCode == 0 ))
+        #else
+        if (0
+        #endif
+        ) nbBits = 0;
+        #ifdef FRCOV
+        }
+        #endif   /* cmove */
         offset = ((size_t)1 << (nbBits & ((sizeof(offset)*8)-1))) + FSE_readBits(&(seqState->DStream), nbBits);
         if (ZSTD_32bits()) FSE_reloadDStream(&(seqState->DStream));
-        if (offsetCode==0) offset = prevOffset;
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[701]) {
+          if ((offsetCode == 0 ) && !(0))
+            fprintf(stderr, "triggered bug index 701\n");
+          else
+            fprintf(stderr, "reached bug index 701\n");
+        }
+        if ((!FIXREVERTER[701] && (offsetCode == 0 ))
+        #else
+        if (0
+        #endif
+        ) offset = prevOffset;
+        #ifdef FRCOV
+        }
+        #endif
     }
 
     /* MatchLength */
@@ -1904,7 +2313,22 @@ static size_t ZSTD_decompressSequences(
 
         /* check if reached exact end */
         if ( !FSE_endOfDStream(&(seqState.DStream)) ) return ERROR(corruption_detected);   /* requested too much : data is corrupted */
-        if (nbSeq<0) return ERROR(corruption_detected);   /* requested too many sequences : data is corrupted */
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[705]) {
+          if ((nbSeq < 0 ) && !(0))
+            fprintf(stderr, "triggered bug index 705\n");
+          else
+            fprintf(stderr, "reached bug index 705\n");
+        }
+        if ((!FIXREVERTER[705] && (nbSeq < 0 ))
+        #else
+        if (0
+        #endif
+        ) return ERROR(corruption_detected);
+        #ifdef FRCOV
+        }
+        #endif   /* requested too many sequences : data is corrupted */
 
         /* last literal segment */
         {
@@ -1966,7 +2390,22 @@ size_t ZSTDv01_decompressDCtx(void* ctx, void* dst, size_t maxDstSize, const voi
 
         ip += ZSTD_blockHeaderSize;
         remainingSize -= ZSTD_blockHeaderSize;
-        if (blockSize > remainingSize) return ERROR(srcSize_wrong);
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[706]) {
+          if ((blockSize > remainingSize ) && !(0))
+            fprintf(stderr, "triggered bug index 706\n");
+          else
+            fprintf(stderr, "reached bug index 706\n");
+        }
+        if ((!FIXREVERTER[706] && (blockSize > remainingSize ))
+        #else
+        if (0
+        #endif
+        ) return ERROR(srcSize_wrong);
+        #ifdef FRCOV
+        }
+        #endif
 
         switch(blockProperties.blockType)
         {
@@ -1986,7 +2425,22 @@ size_t ZSTDv01_decompressDCtx(void* ctx, void* dst, size_t maxDstSize, const voi
         default:
             return ERROR(GENERIC);
         }
-        if (blockSize == 0) break;   /* bt_end */
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[707]) {
+          if ((blockSize == 0 ) && !(0))
+            fprintf(stderr, "triggered bug index 707\n");
+          else
+            fprintf(stderr, "reached bug index 707\n");
+        }
+        if ((!FIXREVERTER[707] && (blockSize == 0 ))
+        #else
+        if (0
+        #endif
+        ) break;
+        #ifdef FRCOV
+        }
+        #endif   /* bt_end */
 
         if (ZSTDv01_isError(errorCode)) return errorCode;
         op += errorCode;
@@ -2043,12 +2497,42 @@ void ZSTDv01_findFrameSizeInfoLegacy(const void *src, size_t srcSize, size_t* cS
 
         ip += ZSTD_blockHeaderSize;
         remainingSize -= ZSTD_blockHeaderSize;
-        if (blockSize > remainingSize) {
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[708]) {
+          if ((blockSize > remainingSize ) && !(0))
+            fprintf(stderr, "triggered bug index 708\n");
+          else
+            fprintf(stderr, "reached bug index 708\n");
+        }
+        if ((!FIXREVERTER[708] && (blockSize > remainingSize ))
+        #else
+        if (0
+        #endif
+        ) {
             ZSTD_errorFrameSizeInfoLegacy(cSize, dBound, ERROR(srcSize_wrong));
             return;
         }
-
-        if (blockSize == 0) break;   /* bt_end */
+        #ifdef FRCOV
+        }
+        #endif
+
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[709]) {
+          if ((blockSize == 0 ) && !(0))
+            fprintf(stderr, "triggered bug index 709\n");
+          else
+            fprintf(stderr, "reached bug index 709\n");
+        }
+        if ((!FIXREVERTER[709] && (blockSize == 0 ))
+        #else
+        if (0
+        #endif
+        ) break;
+        #ifdef FRCOV
+        }
+        #endif   /* bt_end */
 
         ip += blockSize;
         remainingSize -= blockSize;
diff --git a/lib/legacy/zstd_v02.c b/lib/legacy/zstd_v02.c
index 561bc41..6247745 100644
--- a/lib/legacy/zstd_v02.c
+++ b/lib/legacy/zstd_v02.c
@@ -1,3 +1,7 @@
+#ifdef FRCOV
+#include <stdio.h>
+extern short FIXREVERTER[];
+#endif
 /*
  * Copyright (c) 2016-present, Yann Collet, Facebook, Inc.
  * All rights reserved.
@@ -1105,7 +1109,22 @@ static size_t FSE_buildDTable
 
     /* Sanity Checks */
     if (maxSymbolValue > FSE_MAX_SYMBOL_VALUE) return ERROR(maxSymbolValue_tooLarge);
-    if (tableLog > FSE_MAX_TABLELOG) return ERROR(tableLog_tooLarge);
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[795]) {
+      if ((tableLog > 14 - 2 ) && !(0))
+        fprintf(stderr, "triggered bug index 795\n");
+      else
+        fprintf(stderr, "reached bug index 795\n");
+    }
+    if ((!FIXREVERTER[795] && (tableLog > 14 - 2 ))
+    #else
+    if (0
+    #endif
+    ) return ERROR(tableLog_tooLarge);
+    #ifdef FRCOV
+    }
+    #endif
 
     /* Init, lay down lowprob symbols */
     DTableH.tableLog = (U16)tableLog;
@@ -1135,7 +1154,22 @@ static size_t FSE_buildDTable
         }
     }
 
-    if (position!=0) return ERROR(GENERIC);   /* position must reach all cells once, otherwise normalizedCounter is incorrect */
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[796]) {
+      if ((position != 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 796\n");
+      else
+        fprintf(stderr, "reached bug index 796\n");
+    }
+    if ((!FIXREVERTER[796] && (position != 0 ))
+    #else
+    if (0
+    #endif
+    ) return ERROR(GENERIC);
+    #ifdef FRCOV
+    }
+    #endif   /* position must reach all cells once, otherwise normalizedCounter is incorrect */
 
     /* Build Decoding table */
     {
@@ -1184,10 +1218,40 @@ static size_t FSE_readNCount (short* normalizedCounter, unsigned* maxSVPtr, unsi
     unsigned charnum = 0;
     int previous0 = 0;
 
-    if (hbSize < 4) return ERROR(srcSize_wrong);
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[797]) {
+      if ((hbSize < 4 ) && !(0))
+        fprintf(stderr, "triggered bug index 797\n");
+      else
+        fprintf(stderr, "reached bug index 797\n");
+    }
+    if ((!FIXREVERTER[797] && (hbSize < 4 ))
+    #else
+    if (0
+    #endif
+    ) return ERROR(srcSize_wrong);
+    #ifdef FRCOV
+    }
+    #endif
     bitStream = MEM_readLE32(ip);
     nbBits = (bitStream & 0xF) + FSE_MIN_TABLELOG;   /* extract tableLog */
-    if (nbBits > FSE_TABLELOG_ABSOLUTE_MAX) return ERROR(tableLog_tooLarge);
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[798]) {
+      if ((nbBits > 15 ) && !(0))
+        fprintf(stderr, "triggered bug index 798\n");
+      else
+        fprintf(stderr, "reached bug index 798\n");
+    }
+    if ((!FIXREVERTER[798] && (nbBits > 15 ))
+    #else
+    if (0
+    #endif
+    ) return ERROR(tableLog_tooLarge);
+    #ifdef FRCOV
+    }
+    #endif
     bitStream >>= 4;
     bitCount = 4;
     *tableLogPtr = nbBits;
@@ -1274,7 +1338,22 @@ static size_t FSE_readNCount (short* normalizedCounter, unsigned* maxSVPtr, unsi
             }
         }
     }
-    if (remaining != 1) return ERROR(GENERIC);
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[799]) {
+      if ((remaining != 1 ) && !(0))
+        fprintf(stderr, "triggered bug index 799\n");
+      else
+        fprintf(stderr, "reached bug index 799\n");
+    }
+    if ((!FIXREVERTER[799] && (remaining != 1 ))
+    #else
+    if (0
+    #endif
+    ) return ERROR(GENERIC);
+    #ifdef FRCOV
+    }
+    #endif
     *maxSVPtr = charnum-1;
 
     ip += (bitCount+7)>>3;
@@ -1314,7 +1393,22 @@ static size_t FSE_buildDTable_raw (FSE_DTable* dt, unsigned nbBits)
     unsigned s;
 
     /* Sanity checks */
-    if (nbBits < 1) return ERROR(GENERIC);         /* min size */
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[800]) {
+      if ((nbBits < 1 ) && !(0))
+        fprintf(stderr, "triggered bug index 800\n");
+      else
+        fprintf(stderr, "reached bug index 800\n");
+    }
+    if ((!FIXREVERTER[800] && (nbBits < 1 ))
+    #else
+    if (0
+    #endif
+    ) return ERROR(GENERIC);
+    #ifdef FRCOV
+    }
+    #endif         /* min size */
 
     /* Build Decoding Table */
     DTableH->tableLog = (U16)nbBits;
@@ -1422,12 +1516,42 @@ static size_t FSE_decompress(void* dst, size_t maxDstSize, const void* cSrc, siz
     unsigned maxSymbolValue = FSE_MAX_SYMBOL_VALUE;
     size_t errorCode;
 
-    if (cSrcSize<2) return ERROR(srcSize_wrong);   /* too small input size */
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[803]) {
+      if ((cSrcSize < 2 ) && !(0))
+        fprintf(stderr, "triggered bug index 803\n");
+      else
+        fprintf(stderr, "reached bug index 803\n");
+    }
+    if ((!FIXREVERTER[803] && (cSrcSize < 2 ))
+    #else
+    if (0
+    #endif
+    ) return ERROR(srcSize_wrong);
+    #ifdef FRCOV
+    }
+    #endif   /* too small input size */
 
     /* normal FSE decoding mode */
     errorCode = FSE_readNCount (counting, &maxSymbolValue, &tableLog, istart, cSrcSize);
     if (FSE_isError(errorCode)) return errorCode;
-    if (errorCode >= cSrcSize) return ERROR(srcSize_wrong);   /* too small input size */
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[804]) {
+      if ((errorCode >= cSrcSize ) && !(0))
+        fprintf(stderr, "triggered bug index 804\n");
+      else
+        fprintf(stderr, "reached bug index 804\n");
+    }
+    if ((!FIXREVERTER[804] && (errorCode >= cSrcSize ))
+    #else
+    if (0
+    #endif
+    ) return ERROR(srcSize_wrong);
+    #ifdef FRCOV
+    }
+    #endif   /* too small input size */
     ip += errorCode;
     cSrcSize -= errorCode;
 
@@ -1562,8 +1686,38 @@ static size_t HUF_readStats(BYTE* huffWeight, size_t hwSize, U32* rankStats,
         {
             oSize = iSize - 127;
             iSize = ((oSize+1)/2);
-            if (iSize+1 > srcSize) return ERROR(srcSize_wrong);
-            if (oSize >= hwSize) return ERROR(corruption_detected);
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[806]) {
+              if ((iSize + 1 > srcSize ) && !(0))
+                fprintf(stderr, "triggered bug index 806\n");
+              else
+                fprintf(stderr, "reached bug index 806\n");
+            }
+            if ((!FIXREVERTER[806] && (iSize + 1 > srcSize ))
+            #else
+            if (0
+            #endif
+            ) return ERROR(srcSize_wrong);
+            #ifdef FRCOV
+            }
+            #endif
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[807]) {
+              if ((oSize >= hwSize ) && !(0))
+                fprintf(stderr, "triggered bug index 807\n");
+              else
+                fprintf(stderr, "reached bug index 807\n");
+            }
+            if ((!FIXREVERTER[807] && (oSize >= hwSize ))
+            #else
+            if (0
+            #endif
+            ) return ERROR(corruption_detected);
+            #ifdef FRCOV
+            }
+            #endif
             ip += 1;
             for (n=0; n<oSize; n+=2)
             {
@@ -1574,7 +1728,22 @@ static size_t HUF_readStats(BYTE* huffWeight, size_t hwSize, U32* rankStats,
     }
     else  /* header compressed with FSE (normal case) */
     {
-        if (iSize+1 > srcSize) return ERROR(srcSize_wrong);
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[808]) {
+          if ((iSize + 1 > srcSize ) && !(0))
+            fprintf(stderr, "triggered bug index 808\n");
+          else
+            fprintf(stderr, "reached bug index 808\n");
+        }
+        if ((!FIXREVERTER[808] && (iSize + 1 > srcSize ))
+        #else
+        if (0
+        #endif
+        ) return ERROR(srcSize_wrong);
+        #ifdef FRCOV
+        }
+        #endif
         oSize = FSE_decompress(huffWeight, hwSize-1, ip+1, iSize);   /* max (hwSize-1) values decoded, as last one is implied */
         if (FSE_isError(oSize)) return oSize;
     }
@@ -1588,17 +1757,62 @@ static size_t HUF_readStats(BYTE* huffWeight, size_t hwSize, U32* rankStats,
         rankStats[huffWeight[n]]++;
         weightTotal += (1 << huffWeight[n]) >> 1;
     }
-    if (weightTotal == 0) return ERROR(corruption_detected);
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[809]) {
+      if ((weightTotal == 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 809\n");
+      else
+        fprintf(stderr, "reached bug index 809\n");
+    }
+    if ((!FIXREVERTER[809] && (weightTotal == 0 ))
+    #else
+    if (0
+    #endif
+    ) return ERROR(corruption_detected);
+    #ifdef FRCOV
+    }
+    #endif
 
     /* get last non-null symbol weight (implied, total must be 2^n) */
     tableLog = BIT_highbit32(weightTotal) + 1;
-    if (tableLog > HUF_ABSOLUTEMAX_TABLELOG) return ERROR(corruption_detected);
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[810]) {
+      if ((tableLog > 16 ) && !(0))
+        fprintf(stderr, "triggered bug index 810\n");
+      else
+        fprintf(stderr, "reached bug index 810\n");
+    }
+    if ((!FIXREVERTER[810] && (tableLog > 16 ))
+    #else
+    if (0
+    #endif
+    ) return ERROR(corruption_detected);
+    #ifdef FRCOV
+    }
+    #endif
     {
         U32 total = 1 << tableLog;
         U32 rest = total - weightTotal;
         U32 verif = 1 << BIT_highbit32(rest);
         U32 lastWeight = BIT_highbit32(rest) + 1;
-        if (verif != rest) return ERROR(corruption_detected);    /* last value must be a clean power of 2 */
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[811]) {
+          if ((verif != rest ) && !(0))
+            fprintf(stderr, "triggered bug index 811\n");
+          else
+            fprintf(stderr, "reached bug index 811\n");
+        }
+        if ((!FIXREVERTER[811] && (verif != rest ))
+        #else
+        if (0
+        #endif
+        ) return ERROR(corruption_detected);
+        #ifdef FRCOV
+        }
+        #endif    /* last value must be a clean power of 2 */
         huffWeight[oSize] = (BYTE)lastWeight;
         rankStats[lastWeight]++;
     }
@@ -1714,7 +1928,22 @@ static size_t HUF_decompress4X2_usingDTable(
     const void* cSrc, size_t cSrcSize,
     const U16* DTable)
 {
-    if (cSrcSize < 10) return ERROR(corruption_detected);   /* strict minimum : jump table + 1 byte per stream */
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[814]) {
+      if ((cSrcSize < 10 ) && !(0))
+        fprintf(stderr, "triggered bug index 814\n");
+      else
+        fprintf(stderr, "reached bug index 814\n");
+    }
+    if ((!FIXREVERTER[814] && (cSrcSize < 10 ))
+    #else
+    if (0
+    #endif
+    ) return ERROR(corruption_detected);
+    #ifdef FRCOV
+    }
+    #endif   /* strict minimum : jump table + 1 byte per stream */
 
     {
         const BYTE* const istart = (const BYTE*) cSrc;
@@ -1750,7 +1979,22 @@ static size_t HUF_decompress4X2_usingDTable(
         U32 endSignal;
 
         length4 = cSrcSize - (length1 + length2 + length3 + 6);
-        if (length4 > cSrcSize) return ERROR(corruption_detected);   /* overflow */
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[815]) {
+          if ((length4 > cSrcSize ) && !(0))
+            fprintf(stderr, "triggered bug index 815\n");
+          else
+            fprintf(stderr, "reached bug index 815\n");
+        }
+        if ((!FIXREVERTER[815] && (length4 > cSrcSize ))
+        #else
+        if (0
+        #endif
+        ) return ERROR(corruption_detected);
+        #ifdef FRCOV
+        }
+        #endif   /* overflow */
         errorCode = BIT_initDStream(&bitD1, istart1, length1);
         if (HUF_isError(errorCode)) return errorCode;
         errorCode = BIT_initDStream(&bitD2, istart2, length2);
@@ -1814,7 +2058,22 @@ static size_t HUF_decompress4X2 (void* dst, size_t dstSize, const void* cSrc, si
 
     errorCode = HUF_readDTableX2 (DTable, cSrc, cSrcSize);
     if (HUF_isError(errorCode)) return errorCode;
-    if (errorCode >= cSrcSize) return ERROR(srcSize_wrong);
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[816]) {
+      if ((errorCode >= cSrcSize ) && !(0))
+        fprintf(stderr, "triggered bug index 816\n");
+      else
+        fprintf(stderr, "reached bug index 816\n");
+    }
+    if ((!FIXREVERTER[816] && (errorCode >= cSrcSize ))
+    #else
+    if (0
+    #endif
+    ) return ERROR(srcSize_wrong);
+    #ifdef FRCOV
+    }
+    #endif
     ip += errorCode;
     cSrcSize -= errorCode;
 
@@ -1896,7 +2155,22 @@ static void HUF_fillDTableX4(HUF_DEltX4* DTable, const U32 targetLog,
         {
             U32 sortedRank;
             int minWeight = nbBits + scaleLog;
-            if (minWeight < 1) minWeight = 1;
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[821]) {
+              if ((minWeight < 1 ) && !(0))
+                fprintf(stderr, "triggered bug index 821\n");
+              else
+                fprintf(stderr, "reached bug index 821\n");
+            }
+            if ((!FIXREVERTER[821] && (minWeight < 1 ))
+            #else
+            if (0
+            #endif
+            ) minWeight = 1;
+            #ifdef FRCOV
+            }
+            #endif
             sortedRank = rankStart[minWeight];
             HUF_fillDTableX4Level2(DTable+start, targetLog-nbBits, nbBits,
                            rankValOrigin[nbBits], minWeight,
@@ -2076,7 +2350,22 @@ static size_t HUF_decompress4X4_usingDTable(
     const void* cSrc, size_t cSrcSize,
     const U32* DTable)
 {
-    if (cSrcSize < 10) return ERROR(corruption_detected);   /* strict minimum : jump table + 1 byte per stream */
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[827]) {
+      if ((cSrcSize < 10 ) && !(0))
+        fprintf(stderr, "triggered bug index 827\n");
+      else
+        fprintf(stderr, "reached bug index 827\n");
+    }
+    if ((!FIXREVERTER[827] && (cSrcSize < 10 ))
+    #else
+    if (0
+    #endif
+    ) return ERROR(corruption_detected);
+    #ifdef FRCOV
+    }
+    #endif   /* strict minimum : jump table + 1 byte per stream */
 
     {
         const BYTE* const istart = (const BYTE*) cSrc;
@@ -2112,7 +2401,22 @@ static size_t HUF_decompress4X4_usingDTable(
         U32 endSignal;
 
         length4 = cSrcSize - (length1 + length2 + length3 + 6);
-        if (length4 > cSrcSize) return ERROR(corruption_detected);   /* overflow */
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[828]) {
+          if ((length4 > cSrcSize ) && !(0))
+            fprintf(stderr, "triggered bug index 828\n");
+          else
+            fprintf(stderr, "reached bug index 828\n");
+        }
+        if ((!FIXREVERTER[828] && (length4 > cSrcSize ))
+        #else
+        if (0
+        #endif
+        ) return ERROR(corruption_detected);
+        #ifdef FRCOV
+        }
+        #endif   /* overflow */
         errorCode = BIT_initDStream(&bitD1, istart1, length1);
         if (HUF_isError(errorCode)) return errorCode;
         errorCode = BIT_initDStream(&bitD2, istart2, length2);
@@ -2175,7 +2479,22 @@ static size_t HUF_decompress4X4 (void* dst, size_t dstSize, const void* cSrc, si
 
     size_t hSize = HUF_readDTableX4 (DTable, cSrc, cSrcSize);
     if (HUF_isError(hSize)) return hSize;
-    if (hSize >= cSrcSize) return ERROR(srcSize_wrong);
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[829]) {
+      if ((hSize >= cSrcSize ) && !(0))
+        fprintf(stderr, "triggered bug index 829\n");
+      else
+        fprintf(stderr, "reached bug index 829\n");
+    }
+    if ((!FIXREVERTER[829] && (hSize >= cSrcSize ))
+    #else
+    if (0
+    #endif
+    ) return ERROR(srcSize_wrong);
+    #ifdef FRCOV
+    }
+    #endif
     ip += hSize;
     cSrcSize -= hSize;
 
@@ -2233,7 +2552,22 @@ static void HUF_fillDTableX6LevelN(HUF_DDescX6* DDescription, HUF_DSeqX6* DSeque
         if ((level<3) && (sizeLog-totalBits >= minBits))   /* enough room for another symbol */
         {
             int nextMinWeight = totalBits + scaleLog;
-            if (nextMinWeight < 1) nextMinWeight = 1;
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[831]) {
+              if ((nextMinWeight < 1 ) && !(0))
+                fprintf(stderr, "triggered bug index 831\n");
+              else
+                fprintf(stderr, "reached bug index 831\n");
+            }
+            if ((!FIXREVERTER[831] && (nextMinWeight < 1 ))
+            #else
+            if (0
+            #endif
+            ) nextMinWeight = 1;
+            #ifdef FRCOV
+            }
+            #endif
             HUF_fillDTableX6LevelN(DDescription+start, DSequence+start, sizeLog-nbBits,
                            rankValOrigin, totalBits, nextMinWeight, maxWeight,
                            sortedSymbols, sortedListSize, rankStart,
@@ -2431,7 +2765,22 @@ static size_t HUF_decompress4X6_usingDTable(
     const void* cSrc, size_t cSrcSize,
     const U32* DTable)
 {
-    if (cSrcSize < 10) return ERROR(corruption_detected);   /* strict minimum : jump table + 1 byte per stream */
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[837]) {
+      if ((cSrcSize < 10 ) && !(0))
+        fprintf(stderr, "triggered bug index 837\n");
+      else
+        fprintf(stderr, "reached bug index 837\n");
+    }
+    if ((!FIXREVERTER[837] && (cSrcSize < 10 ))
+    #else
+    if (0
+    #endif
+    ) return ERROR(corruption_detected);
+    #ifdef FRCOV
+    }
+    #endif   /* strict minimum : jump table + 1 byte per stream */
 
     {
         const BYTE* const istart = (const BYTE*) cSrc;
@@ -2469,7 +2818,22 @@ static size_t HUF_decompress4X6_usingDTable(
         U32 endSignal;
 
         length4 = cSrcSize - (length1 + length2 + length3 + 6);
-        if (length4 > cSrcSize) return ERROR(corruption_detected);   /* overflow */
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[838]) {
+          if ((length4 > cSrcSize ) && !(0))
+            fprintf(stderr, "triggered bug index 838\n");
+          else
+            fprintf(stderr, "reached bug index 838\n");
+        }
+        if ((!FIXREVERTER[838] && (length4 > cSrcSize ))
+        #else
+        if (0
+        #endif
+        ) return ERROR(corruption_detected);
+        #ifdef FRCOV
+        }
+        #endif   /* overflow */
         errorCode = BIT_initDStream(&bitD1, istart1, length1);
         if (HUF_isError(errorCode)) return errorCode;
         errorCode = BIT_initDStream(&bitD2, istart2, length2);
@@ -2532,7 +2896,22 @@ static size_t HUF_decompress4X6 (void* dst, size_t dstSize, const void* cSrc, si
 
     size_t hSize = HUF_readDTableX6 (DTable, cSrc, cSrcSize);
     if (HUF_isError(hSize)) return hSize;
-    if (hSize >= cSrcSize) return ERROR(srcSize_wrong);
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[839]) {
+      if ((hSize >= cSrcSize ) && !(0))
+        fprintf(stderr, "triggered bug index 839\n");
+      else
+        fprintf(stderr, "reached bug index 839\n");
+    }
+    if ((!FIXREVERTER[839] && (hSize >= cSrcSize ))
+    #else
+    if (0
+    #endif
+    ) return ERROR(srcSize_wrong);
+    #ifdef FRCOV
+    }
+    #endif
     ip += hSize;
     cSrcSize -= hSize;
 
@@ -2579,10 +2958,70 @@ static size_t HUF_decompress (void* dst, size_t dstSize, const void* cSrc, size_
     int n;
 
     /* validation checks */
-    if (dstSize == 0) return ERROR(dstSize_tooSmall);
-    if (cSrcSize > dstSize) return ERROR(corruption_detected);   /* invalid */
-    if (cSrcSize == dstSize) { memcpy(dst, cSrc, dstSize); return dstSize; }   /* not compressed */
-    if (cSrcSize == 1) { memset(dst, *(const BYTE*)cSrc, dstSize); return dstSize; }   /* RLE */
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[842]) {
+      if ((dstSize == 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 842\n");
+      else
+        fprintf(stderr, "reached bug index 842\n");
+    }
+    if ((!FIXREVERTER[842] && (dstSize == 0 ))
+    #else
+    if (0
+    #endif
+    ) return ERROR(dstSize_tooSmall);
+    #ifdef FRCOV
+    }
+    #endif
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[843]) {
+      if ((cSrcSize > dstSize ) && !(0))
+        fprintf(stderr, "triggered bug index 843\n");
+      else
+        fprintf(stderr, "reached bug index 843\n");
+    }
+    if ((!FIXREVERTER[843] && (cSrcSize > dstSize ))
+    #else
+    if (0
+    #endif
+    ) return ERROR(corruption_detected);
+    #ifdef FRCOV
+    }
+    #endif   /* invalid */
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[845]) {
+      if ((cSrcSize == dstSize ) && !(0))
+        fprintf(stderr, "triggered bug index 845\n");
+      else
+        fprintf(stderr, "reached bug index 845\n");
+    }
+    if ((!FIXREVERTER[845] && (cSrcSize == dstSize ))
+    #else
+    if (0
+    #endif
+    ) { memcpy(dst, cSrc, dstSize); return dstSize; }
+    #ifdef FRCOV
+    }
+    #endif   /* not compressed */
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[846]) {
+      if ((cSrcSize == 1 ) && !(0))
+        fprintf(stderr, "triggered bug index 846\n");
+      else
+        fprintf(stderr, "reached bug index 846\n");
+    }
+    if ((!FIXREVERTER[846] && (cSrcSize == 1 ))
+    #else
+    if (0
+    #endif
+    ) { memset(dst, *(const BYTE*)cSrc, dstSize); return dstSize; }
+    #ifdef FRCOV
+    }
+    #endif   /* RLE */
 
     /* decoder timing evaluation */
     Q = (U32)(cSrcSize * 16 / dstSize);   /* Q < 16 since dstSize > cSrcSize */
@@ -2830,7 +3269,22 @@ static size_t ZSTD_getcBlockSize(const void* src, size_t srcSize, blockPropertie
 
 static size_t ZSTD_copyUncompressedBlock(void* dst, size_t maxDstSize, const void* src, size_t srcSize)
 {
-    if (srcSize > maxDstSize) return ERROR(dstSize_tooSmall);
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[850]) {
+      if ((srcSize > maxDstSize ) && !(0))
+        fprintf(stderr, "triggered bug index 850\n");
+      else
+        fprintf(stderr, "reached bug index 850\n");
+    }
+    if ((!FIXREVERTER[850] && (srcSize > maxDstSize ))
+    #else
+    if (0
+    #endif
+    ) return ERROR(dstSize_tooSmall);
+    #ifdef FRCOV
+    }
+    #endif
     memcpy(dst, src, srcSize);
     return srcSize;
 }
@@ -2921,7 +3375,22 @@ static size_t ZSTD_decodeSeqHeaders(int* nbSeq, const BYTE** dumpsPtr, size_t* d
     size_t dumpsLength;
 
     /* check */
-    if (srcSize < 5) return ERROR(srcSize_wrong);
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[852]) {
+      if ((srcSize < 5 ) && !(0))
+        fprintf(stderr, "triggered bug index 852\n");
+      else
+        fprintf(stderr, "reached bug index 852\n");
+    }
+    if ((!FIXREVERTER[852] && (srcSize < 5 ))
+    #else
+    if (0
+    #endif
+    ) return ERROR(srcSize_wrong);
+    #ifdef FRCOV
+    }
+    #endif
 
     /* SeqHead */
     *nbSeq = MEM_readLE16(ip); ip+=2;
@@ -2965,7 +3434,22 @@ static size_t ZSTD_decodeSeqHeaders(int* nbSeq, const BYTE** dumpsPtr, size_t* d
             {   U32 max = MaxLL;
                 headerSize = FSE_readNCount(norm, &max, &LLlog, ip, iend-ip);
                 if (FSE_isError(headerSize)) return ERROR(GENERIC);
-                if (LLlog > LLFSELog) return ERROR(corruption_detected);
+                
+                #ifdef FRCOV
+                {if (FIXREVERTER[854]) {
+                  if ((LLlog > 10 ) && !(0))
+                    fprintf(stderr, "triggered bug index 854\n");
+                  else
+                    fprintf(stderr, "reached bug index 854\n");
+                }
+                if ((!FIXREVERTER[854] && (LLlog > 10 ))
+                #else
+                if (0
+                #endif
+                ) return ERROR(corruption_detected);
+                #ifdef FRCOV
+                }
+                #endif
                 ip += headerSize;
                 FSE_buildDTable(DTableLL, norm, max, LLlog);
         }   }
@@ -2984,7 +3468,22 @@ static size_t ZSTD_decodeSeqHeaders(int* nbSeq, const BYTE** dumpsPtr, size_t* d
             {   U32 max = MaxOff;
                 headerSize = FSE_readNCount(norm, &max, &Offlog, ip, iend-ip);
                 if (FSE_isError(headerSize)) return ERROR(GENERIC);
-                if (Offlog > OffFSELog) return ERROR(corruption_detected);
+                
+                #ifdef FRCOV
+                {if (FIXREVERTER[855]) {
+                  if ((Offlog > 9 ) && !(0))
+                    fprintf(stderr, "triggered bug index 855\n");
+                  else
+                    fprintf(stderr, "reached bug index 855\n");
+                }
+                if ((!FIXREVERTER[855] && (Offlog > 9 ))
+                #else
+                if (0
+                #endif
+                ) return ERROR(corruption_detected);
+                #ifdef FRCOV
+                }
+                #endif
                 ip += headerSize;
                 FSE_buildDTable(DTableOffb, norm, max, Offlog);
         }   }
@@ -3002,7 +3501,22 @@ static size_t ZSTD_decodeSeqHeaders(int* nbSeq, const BYTE** dumpsPtr, size_t* d
             {   U32 max = MaxML;
                 headerSize = FSE_readNCount(norm, &max, &MLlog, ip, iend-ip);
                 if (FSE_isError(headerSize)) return ERROR(GENERIC);
-                if (MLlog > MLFSELog) return ERROR(corruption_detected);
+                
+                #ifdef FRCOV
+                {if (FIXREVERTER[856]) {
+                  if ((MLlog > 10 ) && !(0))
+                    fprintf(stderr, "triggered bug index 856\n");
+                  else
+                    fprintf(stderr, "reached bug index 856\n");
+                }
+                if ((!FIXREVERTER[856] && (MLlog > 10 ))
+                #else
+                if (0
+                #endif
+                ) return ERROR(corruption_detected);
+                #ifdef FRCOV
+                }
+                #endif
                 ip += headerSize;
                 FSE_buildDTable(DTableML, norm, max, MLlog);
     }   }   }
@@ -3063,10 +3577,40 @@ static void ZSTD_decodeSequence(seq_t* seq, seqState_t* seqState)
         offsetCode = FSE_decodeSymbol(&(seqState->stateOffb), &(seqState->DStream));   /* <= maxOff, by table construction */
         if (MEM_32bits()) BIT_reloadDStream(&(seqState->DStream));
         nbBits = offsetCode - 1;
-        if (offsetCode==0) nbBits = 0;   /* cmove */
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[858]) {
+          if ((offsetCode == 0 ) && !(0))
+            fprintf(stderr, "triggered bug index 858\n");
+          else
+            fprintf(stderr, "reached bug index 858\n");
+        }
+        if ((!FIXREVERTER[858] && (offsetCode == 0 ))
+        #else
+        if (0
+        #endif
+        ) nbBits = 0;
+        #ifdef FRCOV
+        }
+        #endif   /* cmove */
         offset = offsetPrefix[offsetCode] + BIT_readBits(&(seqState->DStream), nbBits);
         if (MEM_32bits()) BIT_reloadDStream(&(seqState->DStream));
-        if (offsetCode==0) offset = prevOffset;   /* cmove */
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[859]) {
+          if ((offsetCode == 0 ) && !(0))
+            fprintf(stderr, "triggered bug index 859\n");
+          else
+            fprintf(stderr, "reached bug index 859\n");
+        }
+        if ((!FIXREVERTER[859] && (offsetCode == 0 ))
+        #else
+        if (0
+        #endif
+        ) offset = prevOffset;
+        #ifdef FRCOV
+        }
+        #endif   /* cmove */
     }
 
     /* MatchLength */
@@ -3216,7 +3760,22 @@ static size_t ZSTD_decompressSequences(
 
         /* check if reached exact end */
         if ( !BIT_endOfDStream(&(seqState.DStream)) ) return ERROR(corruption_detected);   /* requested too much : data is corrupted */
-        if (nbSeq<0) return ERROR(corruption_detected);   /* requested too many sequences : data is corrupted */
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[862]) {
+          if ((nbSeq < 0 ) && !(0))
+            fprintf(stderr, "triggered bug index 862\n");
+          else
+            fprintf(stderr, "reached bug index 862\n");
+        }
+        if ((!FIXREVERTER[862] && (nbSeq < 0 ))
+        #else
+        if (0
+        #endif
+        ) return ERROR(corruption_detected);
+        #ifdef FRCOV
+        }
+        #endif   /* requested too many sequences : data is corrupted */
 
         /* last literal segment */
         {
@@ -3276,7 +3835,22 @@ static size_t ZSTD_decompressDCtx(void* ctx, void* dst, size_t maxDstSize, const
 
         ip += ZSTD_blockHeaderSize;
         remainingSize -= ZSTD_blockHeaderSize;
-        if (cBlockSize > remainingSize) return ERROR(srcSize_wrong);
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[864]) {
+          if ((cBlockSize > remainingSize ) && !(0))
+            fprintf(stderr, "triggered bug index 864\n");
+          else
+            fprintf(stderr, "reached bug index 864\n");
+        }
+        if ((!FIXREVERTER[864] && (cBlockSize > remainingSize ))
+        #else
+        if (0
+        #endif
+        ) return ERROR(srcSize_wrong);
+        #ifdef FRCOV
+        }
+        #endif
 
         switch(blockProperties.blockType)
         {
@@ -3296,7 +3870,22 @@ static size_t ZSTD_decompressDCtx(void* ctx, void* dst, size_t maxDstSize, const
         default:
             return ERROR(GENERIC);   /* impossible */
         }
-        if (cBlockSize == 0) break;   /* bt_end */
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[865]) {
+          if ((cBlockSize == 0 ) && !(0))
+            fprintf(stderr, "triggered bug index 865\n");
+          else
+            fprintf(stderr, "reached bug index 865\n");
+        }
+        if ((!FIXREVERTER[865] && (cBlockSize == 0 ))
+        #else
+        if (0
+        #endif
+        ) break;
+        #ifdef FRCOV
+        }
+        #endif   /* bt_end */
 
         if (ZSTD_isError(decodedSize)) return decodedSize;
         op += decodedSize;
@@ -3353,12 +3942,42 @@ void ZSTDv02_findFrameSizeInfoLegacy(const void *src, size_t srcSize, size_t* cS
 
         ip += ZSTD_blockHeaderSize;
         remainingSize -= ZSTD_blockHeaderSize;
-        if (cBlockSize > remainingSize) {
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[867]) {
+          if ((cBlockSize > remainingSize ) && !(0))
+            fprintf(stderr, "triggered bug index 867\n");
+          else
+            fprintf(stderr, "reached bug index 867\n");
+        }
+        if ((!FIXREVERTER[867] && (cBlockSize > remainingSize ))
+        #else
+        if (0
+        #endif
+        ) {
             ZSTD_errorFrameSizeInfoLegacy(cSize, dBound, ERROR(srcSize_wrong));
             return;
         }
-
-        if (cBlockSize == 0) break;   /* bt_end */
+        #ifdef FRCOV
+        }
+        #endif
+
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[868]) {
+          if ((cBlockSize == 0 ) && !(0))
+            fprintf(stderr, "triggered bug index 868\n");
+          else
+            fprintf(stderr, "reached bug index 868\n");
+        }
+        if ((!FIXREVERTER[868] && (cBlockSize == 0 ))
+        #else
+        if (0
+        #endif
+        ) break;
+        #ifdef FRCOV
+        }
+        #endif   /* bt_end */
 
         ip += cBlockSize;
         remainingSize -= cBlockSize;
diff --git a/lib/legacy/zstd_v03.c b/lib/legacy/zstd_v03.c
index a1bf0fa..3cf3a88 100644
--- a/lib/legacy/zstd_v03.c
+++ b/lib/legacy/zstd_v03.c
@@ -1,3 +1,7 @@
+#ifdef FRCOV
+#include <stdio.h>
+extern short FIXREVERTER[];
+#endif
 /*
  * Copyright (c) 2016-present, Yann Collet, Facebook, Inc.
  * All rights reserved.
@@ -1106,7 +1110,22 @@ static size_t FSE_buildDTable
 
     /* Sanity Checks */
     if (maxSymbolValue > FSE_MAX_SYMBOL_VALUE) return ERROR(maxSymbolValue_tooLarge);
-    if (tableLog > FSE_MAX_TABLELOG) return ERROR(tableLog_tooLarge);
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[324]) {
+      if ((tableLog > 14 - 2 ) && !(0))
+        fprintf(stderr, "triggered bug index 324\n");
+      else
+        fprintf(stderr, "reached bug index 324\n");
+    }
+    if ((!FIXREVERTER[324] && (tableLog > 14 - 2 ))
+    #else
+    if (0
+    #endif
+    ) return ERROR(tableLog_tooLarge);
+    #ifdef FRCOV
+    }
+    #endif
 
     /* Init, lay down lowprob symbols */
     DTableH.tableLog = (U16)tableLog;
@@ -1136,7 +1155,22 @@ static size_t FSE_buildDTable
         }
     }
 
-    if (position!=0) return ERROR(GENERIC);   /* position must reach all cells once, otherwise normalizedCounter is incorrect */
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[325]) {
+      if ((position != 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 325\n");
+      else
+        fprintf(stderr, "reached bug index 325\n");
+    }
+    if ((!FIXREVERTER[325] && (position != 0 ))
+    #else
+    if (0
+    #endif
+    ) return ERROR(GENERIC);
+    #ifdef FRCOV
+    }
+    #endif   /* position must reach all cells once, otherwise normalizedCounter is incorrect */
 
     /* Build Decoding table */
     {
@@ -1185,10 +1219,40 @@ static size_t FSE_readNCount (short* normalizedCounter, unsigned* maxSVPtr, unsi
     unsigned charnum = 0;
     int previous0 = 0;
 
-    if (hbSize < 4) return ERROR(srcSize_wrong);
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[326]) {
+      if ((hbSize < 4 ) && !(0))
+        fprintf(stderr, "triggered bug index 326\n");
+      else
+        fprintf(stderr, "reached bug index 326\n");
+    }
+    if ((!FIXREVERTER[326] && (hbSize < 4 ))
+    #else
+    if (0
+    #endif
+    ) return ERROR(srcSize_wrong);
+    #ifdef FRCOV
+    }
+    #endif
     bitStream = MEM_readLE32(ip);
     nbBits = (bitStream & 0xF) + FSE_MIN_TABLELOG;   /* extract tableLog */
-    if (nbBits > FSE_TABLELOG_ABSOLUTE_MAX) return ERROR(tableLog_tooLarge);
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[327]) {
+      if ((nbBits > 15 ) && !(0))
+        fprintf(stderr, "triggered bug index 327\n");
+      else
+        fprintf(stderr, "reached bug index 327\n");
+    }
+    if ((!FIXREVERTER[327] && (nbBits > 15 ))
+    #else
+    if (0
+    #endif
+    ) return ERROR(tableLog_tooLarge);
+    #ifdef FRCOV
+    }
+    #endif
     bitStream >>= 4;
     bitCount = 4;
     *tableLogPtr = nbBits;
@@ -1275,7 +1339,22 @@ static size_t FSE_readNCount (short* normalizedCounter, unsigned* maxSVPtr, unsi
             }
         }
     }
-    if (remaining != 1) return ERROR(GENERIC);
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[328]) {
+      if ((remaining != 1 ) && !(0))
+        fprintf(stderr, "triggered bug index 328\n");
+      else
+        fprintf(stderr, "reached bug index 328\n");
+    }
+    if ((!FIXREVERTER[328] && (remaining != 1 ))
+    #else
+    if (0
+    #endif
+    ) return ERROR(GENERIC);
+    #ifdef FRCOV
+    }
+    #endif
     *maxSVPtr = charnum-1;
 
     ip += (bitCount+7)>>3;
@@ -1315,7 +1394,22 @@ static size_t FSE_buildDTable_raw (FSE_DTable* dt, unsigned nbBits)
     unsigned s;
 
     /* Sanity checks */
-    if (nbBits < 1) return ERROR(GENERIC);         /* min size */
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[329]) {
+      if ((nbBits < 1 ) && !(0))
+        fprintf(stderr, "triggered bug index 329\n");
+      else
+        fprintf(stderr, "reached bug index 329\n");
+    }
+    if ((!FIXREVERTER[329] && (nbBits < 1 ))
+    #else
+    if (0
+    #endif
+    ) return ERROR(GENERIC);
+    #ifdef FRCOV
+    }
+    #endif         /* min size */
 
     /* Build Decoding Table */
     DTableH->tableLog = (U16)nbBits;
@@ -1423,12 +1517,42 @@ static size_t FSE_decompress(void* dst, size_t maxDstSize, const void* cSrc, siz
     unsigned maxSymbolValue = FSE_MAX_SYMBOL_VALUE;
     size_t errorCode;
 
-    if (cSrcSize<2) return ERROR(srcSize_wrong);   /* too small input size */
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[332]) {
+      if ((cSrcSize < 2 ) && !(0))
+        fprintf(stderr, "triggered bug index 332\n");
+      else
+        fprintf(stderr, "reached bug index 332\n");
+    }
+    if ((!FIXREVERTER[332] && (cSrcSize < 2 ))
+    #else
+    if (0
+    #endif
+    ) return ERROR(srcSize_wrong);
+    #ifdef FRCOV
+    }
+    #endif   /* too small input size */
 
     /* normal FSE decoding mode */
     errorCode = FSE_readNCount (counting, &maxSymbolValue, &tableLog, istart, cSrcSize);
     if (FSE_isError(errorCode)) return errorCode;
-    if (errorCode >= cSrcSize) return ERROR(srcSize_wrong);   /* too small input size */
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[333]) {
+      if ((errorCode >= cSrcSize ) && !(0))
+        fprintf(stderr, "triggered bug index 333\n");
+      else
+        fprintf(stderr, "reached bug index 333\n");
+    }
+    if ((!FIXREVERTER[333] && (errorCode >= cSrcSize ))
+    #else
+    if (0
+    #endif
+    ) return ERROR(srcSize_wrong);
+    #ifdef FRCOV
+    }
+    #endif   /* too small input size */
     ip += errorCode;
     cSrcSize -= errorCode;
 
@@ -1559,8 +1683,38 @@ static size_t HUF_readStats(BYTE* huffWeight, size_t hwSize, U32* rankStats,
         {
             oSize = iSize - 127;
             iSize = ((oSize+1)/2);
-            if (iSize+1 > srcSize) return ERROR(srcSize_wrong);
-            if (oSize >= hwSize) return ERROR(corruption_detected);
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[335]) {
+              if ((iSize + 1 > srcSize ) && !(0))
+                fprintf(stderr, "triggered bug index 335\n");
+              else
+                fprintf(stderr, "reached bug index 335\n");
+            }
+            if ((!FIXREVERTER[335] && (iSize + 1 > srcSize ))
+            #else
+            if (0
+            #endif
+            ) return ERROR(srcSize_wrong);
+            #ifdef FRCOV
+            }
+            #endif
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[336]) {
+              if ((oSize >= hwSize ) && !(0))
+                fprintf(stderr, "triggered bug index 336\n");
+              else
+                fprintf(stderr, "reached bug index 336\n");
+            }
+            if ((!FIXREVERTER[336] && (oSize >= hwSize ))
+            #else
+            if (0
+            #endif
+            ) return ERROR(corruption_detected);
+            #ifdef FRCOV
+            }
+            #endif
             ip += 1;
             for (n=0; n<oSize; n+=2)
             {
@@ -1571,7 +1725,22 @@ static size_t HUF_readStats(BYTE* huffWeight, size_t hwSize, U32* rankStats,
     }
     else  /* header compressed with FSE (normal case) */
     {
-        if (iSize+1 > srcSize) return ERROR(srcSize_wrong);
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[337]) {
+          if ((iSize + 1 > srcSize ) && !(0))
+            fprintf(stderr, "triggered bug index 337\n");
+          else
+            fprintf(stderr, "reached bug index 337\n");
+        }
+        if ((!FIXREVERTER[337] && (iSize + 1 > srcSize ))
+        #else
+        if (0
+        #endif
+        ) return ERROR(srcSize_wrong);
+        #ifdef FRCOV
+        }
+        #endif
         oSize = FSE_decompress(huffWeight, hwSize-1, ip+1, iSize);   /* max (hwSize-1) values decoded, as last one is implied */
         if (FSE_isError(oSize)) return oSize;
     }
@@ -1585,17 +1754,62 @@ static size_t HUF_readStats(BYTE* huffWeight, size_t hwSize, U32* rankStats,
         rankStats[huffWeight[n]]++;
         weightTotal += (1 << huffWeight[n]) >> 1;
     }
-    if (weightTotal == 0) return ERROR(corruption_detected);
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[338]) {
+      if ((weightTotal == 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 338\n");
+      else
+        fprintf(stderr, "reached bug index 338\n");
+    }
+    if ((!FIXREVERTER[338] && (weightTotal == 0 ))
+    #else
+    if (0
+    #endif
+    ) return ERROR(corruption_detected);
+    #ifdef FRCOV
+    }
+    #endif
 
     /* get last non-null symbol weight (implied, total must be 2^n) */
     tableLog = BIT_highbit32(weightTotal) + 1;
-    if (tableLog > HUF_ABSOLUTEMAX_TABLELOG) return ERROR(corruption_detected);
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[339]) {
+      if ((tableLog > 16 ) && !(0))
+        fprintf(stderr, "triggered bug index 339\n");
+      else
+        fprintf(stderr, "reached bug index 339\n");
+    }
+    if ((!FIXREVERTER[339] && (tableLog > 16 ))
+    #else
+    if (0
+    #endif
+    ) return ERROR(corruption_detected);
+    #ifdef FRCOV
+    }
+    #endif
     {
         U32 total = 1 << tableLog;
         U32 rest = total - weightTotal;
         U32 verif = 1 << BIT_highbit32(rest);
         U32 lastWeight = BIT_highbit32(rest) + 1;
-        if (verif != rest) return ERROR(corruption_detected);    /* last value must be a clean power of 2 */
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[340]) {
+          if ((verif != rest ) && !(0))
+            fprintf(stderr, "triggered bug index 340\n");
+          else
+            fprintf(stderr, "reached bug index 340\n");
+        }
+        if ((!FIXREVERTER[340] && (verif != rest ))
+        #else
+        if (0
+        #endif
+        ) return ERROR(corruption_detected);
+        #ifdef FRCOV
+        }
+        #endif    /* last value must be a clean power of 2 */
         huffWeight[oSize] = (BYTE)lastWeight;
         rankStats[lastWeight]++;
     }
@@ -1711,7 +1925,22 @@ static size_t HUF_decompress4X2_usingDTable(
     const void* cSrc, size_t cSrcSize,
     const U16* DTable)
 {
-    if (cSrcSize < 10) return ERROR(corruption_detected);   /* strict minimum : jump table + 1 byte per stream */
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[343]) {
+      if ((cSrcSize < 10 ) && !(0))
+        fprintf(stderr, "triggered bug index 343\n");
+      else
+        fprintf(stderr, "reached bug index 343\n");
+    }
+    if ((!FIXREVERTER[343] && (cSrcSize < 10 ))
+    #else
+    if (0
+    #endif
+    ) return ERROR(corruption_detected);
+    #ifdef FRCOV
+    }
+    #endif   /* strict minimum : jump table + 1 byte per stream */
 
     {
         const BYTE* const istart = (const BYTE*) cSrc;
@@ -1747,7 +1976,22 @@ static size_t HUF_decompress4X2_usingDTable(
         U32 endSignal;
 
         length4 = cSrcSize - (length1 + length2 + length3 + 6);
-        if (length4 > cSrcSize) return ERROR(corruption_detected);   /* overflow */
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[344]) {
+          if ((length4 > cSrcSize ) && !(0))
+            fprintf(stderr, "triggered bug index 344\n");
+          else
+            fprintf(stderr, "reached bug index 344\n");
+        }
+        if ((!FIXREVERTER[344] && (length4 > cSrcSize ))
+        #else
+        if (0
+        #endif
+        ) return ERROR(corruption_detected);
+        #ifdef FRCOV
+        }
+        #endif   /* overflow */
         errorCode = BIT_initDStream(&bitD1, istart1, length1);
         if (HUF_isError(errorCode)) return errorCode;
         errorCode = BIT_initDStream(&bitD2, istart2, length2);
@@ -1811,7 +2055,22 @@ static size_t HUF_decompress4X2 (void* dst, size_t dstSize, const void* cSrc, si
 
     errorCode = HUF_readDTableX2 (DTable, cSrc, cSrcSize);
     if (HUF_isError(errorCode)) return errorCode;
-    if (errorCode >= cSrcSize) return ERROR(srcSize_wrong);
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[345]) {
+      if ((errorCode >= cSrcSize ) && !(0))
+        fprintf(stderr, "triggered bug index 345\n");
+      else
+        fprintf(stderr, "reached bug index 345\n");
+    }
+    if ((!FIXREVERTER[345] && (errorCode >= cSrcSize ))
+    #else
+    if (0
+    #endif
+    ) return ERROR(srcSize_wrong);
+    #ifdef FRCOV
+    }
+    #endif
     ip += errorCode;
     cSrcSize -= errorCode;
 
@@ -1893,7 +2152,22 @@ static void HUF_fillDTableX4(HUF_DEltX4* DTable, const U32 targetLog,
         {
             U32 sortedRank;
             int minWeight = nbBits + scaleLog;
-            if (minWeight < 1) minWeight = 1;
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[350]) {
+              if ((minWeight < 1 ) && !(0))
+                fprintf(stderr, "triggered bug index 350\n");
+              else
+                fprintf(stderr, "reached bug index 350\n");
+            }
+            if ((!FIXREVERTER[350] && (minWeight < 1 ))
+            #else
+            if (0
+            #endif
+            ) minWeight = 1;
+            #ifdef FRCOV
+            }
+            #endif
             sortedRank = rankStart[minWeight];
             HUF_fillDTableX4Level2(DTable+start, targetLog-nbBits, nbBits,
                            rankValOrigin[nbBits], minWeight,
@@ -2073,7 +2347,22 @@ static size_t HUF_decompress4X4_usingDTable(
     const void* cSrc, size_t cSrcSize,
     const U32* DTable)
 {
-    if (cSrcSize < 10) return ERROR(corruption_detected);   /* strict minimum : jump table + 1 byte per stream */
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[356]) {
+      if ((cSrcSize < 10 ) && !(0))
+        fprintf(stderr, "triggered bug index 356\n");
+      else
+        fprintf(stderr, "reached bug index 356\n");
+    }
+    if ((!FIXREVERTER[356] && (cSrcSize < 10 ))
+    #else
+    if (0
+    #endif
+    ) return ERROR(corruption_detected);
+    #ifdef FRCOV
+    }
+    #endif   /* strict minimum : jump table + 1 byte per stream */
 
     {
         const BYTE* const istart = (const BYTE*) cSrc;
@@ -2109,7 +2398,22 @@ static size_t HUF_decompress4X4_usingDTable(
         U32 endSignal;
 
         length4 = cSrcSize - (length1 + length2 + length3 + 6);
-        if (length4 > cSrcSize) return ERROR(corruption_detected);   /* overflow */
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[357]) {
+          if ((length4 > cSrcSize ) && !(0))
+            fprintf(stderr, "triggered bug index 357\n");
+          else
+            fprintf(stderr, "reached bug index 357\n");
+        }
+        if ((!FIXREVERTER[357] && (length4 > cSrcSize ))
+        #else
+        if (0
+        #endif
+        ) return ERROR(corruption_detected);
+        #ifdef FRCOV
+        }
+        #endif   /* overflow */
         errorCode = BIT_initDStream(&bitD1, istart1, length1);
         if (HUF_isError(errorCode)) return errorCode;
         errorCode = BIT_initDStream(&bitD2, istart2, length2);
@@ -2172,7 +2476,22 @@ static size_t HUF_decompress4X4 (void* dst, size_t dstSize, const void* cSrc, si
 
     size_t hSize = HUF_readDTableX4 (DTable, cSrc, cSrcSize);
     if (HUF_isError(hSize)) return hSize;
-    if (hSize >= cSrcSize) return ERROR(srcSize_wrong);
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[358]) {
+      if ((hSize >= cSrcSize ) && !(0))
+        fprintf(stderr, "triggered bug index 358\n");
+      else
+        fprintf(stderr, "reached bug index 358\n");
+    }
+    if ((!FIXREVERTER[358] && (hSize >= cSrcSize ))
+    #else
+    if (0
+    #endif
+    ) return ERROR(srcSize_wrong);
+    #ifdef FRCOV
+    }
+    #endif
     ip += hSize;
     cSrcSize -= hSize;
 
@@ -2219,10 +2538,70 @@ static size_t HUF_decompress (void* dst, size_t dstSize, const void* cSrc, size_
     int n;
 
     /* validation checks */
-    if (dstSize == 0) return ERROR(dstSize_tooSmall);
-    if (cSrcSize > dstSize) return ERROR(corruption_detected);   /* invalid */
-    if (cSrcSize == dstSize) { memcpy(dst, cSrc, dstSize); return dstSize; }   /* not compressed */
-    if (cSrcSize == 1) { memset(dst, *(const BYTE*)cSrc, dstSize); return dstSize; }   /* RLE */
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[361]) {
+      if ((dstSize == 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 361\n");
+      else
+        fprintf(stderr, "reached bug index 361\n");
+    }
+    if ((!FIXREVERTER[361] && (dstSize == 0 ))
+    #else
+    if (0
+    #endif
+    ) return ERROR(dstSize_tooSmall);
+    #ifdef FRCOV
+    }
+    #endif
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[362]) {
+      if ((cSrcSize > dstSize ) && !(0))
+        fprintf(stderr, "triggered bug index 362\n");
+      else
+        fprintf(stderr, "reached bug index 362\n");
+    }
+    if ((!FIXREVERTER[362] && (cSrcSize > dstSize ))
+    #else
+    if (0
+    #endif
+    ) return ERROR(corruption_detected);
+    #ifdef FRCOV
+    }
+    #endif   /* invalid */
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[364]) {
+      if ((cSrcSize == dstSize ) && !(0))
+        fprintf(stderr, "triggered bug index 364\n");
+      else
+        fprintf(stderr, "reached bug index 364\n");
+    }
+    if ((!FIXREVERTER[364] && (cSrcSize == dstSize ))
+    #else
+    if (0
+    #endif
+    ) { memcpy(dst, cSrc, dstSize); return dstSize; }
+    #ifdef FRCOV
+    }
+    #endif   /* not compressed */
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[365]) {
+      if ((cSrcSize == 1 ) && !(0))
+        fprintf(stderr, "triggered bug index 365\n");
+      else
+        fprintf(stderr, "reached bug index 365\n");
+    }
+    if ((!FIXREVERTER[365] && (cSrcSize == 1 ))
+    #else
+    if (0
+    #endif
+    ) { memset(dst, *(const BYTE*)cSrc, dstSize); return dstSize; }
+    #ifdef FRCOV
+    }
+    #endif   /* RLE */
 
     /* decoder timing evaluation */
     Q = (U32)(cSrcSize * 16 / dstSize);   /* Q < 16 since dstSize > cSrcSize */
@@ -2471,7 +2850,22 @@ static size_t ZSTD_getcBlockSize(const void* src, size_t srcSize, blockPropertie
 
 static size_t ZSTD_copyUncompressedBlock(void* dst, size_t maxDstSize, const void* src, size_t srcSize)
 {
-    if (srcSize > maxDstSize) return ERROR(dstSize_tooSmall);
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[369]) {
+      if ((srcSize > maxDstSize ) && !(0))
+        fprintf(stderr, "triggered bug index 369\n");
+      else
+        fprintf(stderr, "reached bug index 369\n");
+    }
+    if ((!FIXREVERTER[369] && (srcSize > maxDstSize ))
+    #else
+    if (0
+    #endif
+    ) return ERROR(dstSize_tooSmall);
+    #ifdef FRCOV
+    }
+    #endif
     memcpy(dst, src, srcSize);
     return srcSize;
 }
@@ -2562,7 +2956,22 @@ static size_t ZSTD_decodeSeqHeaders(int* nbSeq, const BYTE** dumpsPtr, size_t* d
     size_t dumpsLength;
 
     /* check */
-    if (srcSize < 5) return ERROR(srcSize_wrong);
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[371]) {
+      if ((srcSize < 5 ) && !(0))
+        fprintf(stderr, "triggered bug index 371\n");
+      else
+        fprintf(stderr, "reached bug index 371\n");
+    }
+    if ((!FIXREVERTER[371] && (srcSize < 5 ))
+    #else
+    if (0
+    #endif
+    ) return ERROR(srcSize_wrong);
+    #ifdef FRCOV
+    }
+    #endif
 
     /* SeqHead */
     *nbSeq = MEM_readLE16(ip); ip+=2;
@@ -2606,7 +3015,22 @@ static size_t ZSTD_decodeSeqHeaders(int* nbSeq, const BYTE** dumpsPtr, size_t* d
             {   U32 max = MaxLL;
                 headerSize = FSE_readNCount(norm, &max, &LLlog, ip, iend-ip);
                 if (FSE_isError(headerSize)) return ERROR(GENERIC);
-                if (LLlog > LLFSELog) return ERROR(corruption_detected);
+                
+                #ifdef FRCOV
+                {if (FIXREVERTER[373]) {
+                  if ((LLlog > 10 ) && !(0))
+                    fprintf(stderr, "triggered bug index 373\n");
+                  else
+                    fprintf(stderr, "reached bug index 373\n");
+                }
+                if ((!FIXREVERTER[373] && (LLlog > 10 ))
+                #else
+                if (0
+                #endif
+                ) return ERROR(corruption_detected);
+                #ifdef FRCOV
+                }
+                #endif
                 ip += headerSize;
                 FSE_buildDTable(DTableLL, norm, max, LLlog);
         }   }
@@ -2625,7 +3049,22 @@ static size_t ZSTD_decodeSeqHeaders(int* nbSeq, const BYTE** dumpsPtr, size_t* d
             {   U32 max = MaxOff;
                 headerSize = FSE_readNCount(norm, &max, &Offlog, ip, iend-ip);
                 if (FSE_isError(headerSize)) return ERROR(GENERIC);
-                if (Offlog > OffFSELog) return ERROR(corruption_detected);
+                
+                #ifdef FRCOV
+                {if (FIXREVERTER[374]) {
+                  if ((Offlog > 9 ) && !(0))
+                    fprintf(stderr, "triggered bug index 374\n");
+                  else
+                    fprintf(stderr, "reached bug index 374\n");
+                }
+                if ((!FIXREVERTER[374] && (Offlog > 9 ))
+                #else
+                if (0
+                #endif
+                ) return ERROR(corruption_detected);
+                #ifdef FRCOV
+                }
+                #endif
                 ip += headerSize;
                 FSE_buildDTable(DTableOffb, norm, max, Offlog);
         }   }
@@ -2643,7 +3082,22 @@ static size_t ZSTD_decodeSeqHeaders(int* nbSeq, const BYTE** dumpsPtr, size_t* d
             {   U32 max = MaxML;
                 headerSize = FSE_readNCount(norm, &max, &MLlog, ip, iend-ip);
                 if (FSE_isError(headerSize)) return ERROR(GENERIC);
-                if (MLlog > MLFSELog) return ERROR(corruption_detected);
+                
+                #ifdef FRCOV
+                {if (FIXREVERTER[375]) {
+                  if ((MLlog > 10 ) && !(0))
+                    fprintf(stderr, "triggered bug index 375\n");
+                  else
+                    fprintf(stderr, "reached bug index 375\n");
+                }
+                if ((!FIXREVERTER[375] && (MLlog > 10 ))
+                #else
+                if (0
+                #endif
+                ) return ERROR(corruption_detected);
+                #ifdef FRCOV
+                }
+                #endif
                 ip += headerSize;
                 FSE_buildDTable(DTableML, norm, max, MLlog);
     }   }   }
@@ -2704,10 +3158,40 @@ static void ZSTD_decodeSequence(seq_t* seq, seqState_t* seqState)
         offsetCode = FSE_decodeSymbol(&(seqState->stateOffb), &(seqState->DStream));   /* <= maxOff, by table construction */
         if (MEM_32bits()) BIT_reloadDStream(&(seqState->DStream));
         nbBits = offsetCode - 1;
-        if (offsetCode==0) nbBits = 0;   /* cmove */
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[377]) {
+          if ((offsetCode == 0 ) && !(0))
+            fprintf(stderr, "triggered bug index 377\n");
+          else
+            fprintf(stderr, "reached bug index 377\n");
+        }
+        if ((!FIXREVERTER[377] && (offsetCode == 0 ))
+        #else
+        if (0
+        #endif
+        ) nbBits = 0;
+        #ifdef FRCOV
+        }
+        #endif   /* cmove */
         offset = offsetPrefix[offsetCode] + BIT_readBits(&(seqState->DStream), nbBits);
         if (MEM_32bits()) BIT_reloadDStream(&(seqState->DStream));
-        if (offsetCode==0) offset = prevOffset;   /* cmove */
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[378]) {
+          if ((offsetCode == 0 ) && !(0))
+            fprintf(stderr, "triggered bug index 378\n");
+          else
+            fprintf(stderr, "reached bug index 378\n");
+        }
+        if ((!FIXREVERTER[378] && (offsetCode == 0 ))
+        #else
+        if (0
+        #endif
+        ) offset = prevOffset;
+        #ifdef FRCOV
+        }
+        #endif   /* cmove */
     }
 
     /* MatchLength */
@@ -2857,7 +3341,22 @@ static size_t ZSTD_decompressSequences(
 
         /* check if reached exact end */
         if ( !BIT_endOfDStream(&(seqState.DStream)) ) return ERROR(corruption_detected);   /* requested too much : data is corrupted */
-        if (nbSeq<0) return ERROR(corruption_detected);   /* requested too many sequences : data is corrupted */
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[381]) {
+          if ((nbSeq < 0 ) && !(0))
+            fprintf(stderr, "triggered bug index 381\n");
+          else
+            fprintf(stderr, "reached bug index 381\n");
+        }
+        if ((!FIXREVERTER[381] && (nbSeq < 0 ))
+        #else
+        if (0
+        #endif
+        ) return ERROR(corruption_detected);
+        #ifdef FRCOV
+        }
+        #endif   /* requested too many sequences : data is corrupted */
 
         /* last literal segment */
         {
@@ -2917,7 +3416,22 @@ static size_t ZSTD_decompressDCtx(void* ctx, void* dst, size_t maxDstSize, const
 
         ip += ZSTD_blockHeaderSize;
         remainingSize -= ZSTD_blockHeaderSize;
-        if (cBlockSize > remainingSize) return ERROR(srcSize_wrong);
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[383]) {
+          if ((cBlockSize > remainingSize ) && !(0))
+            fprintf(stderr, "triggered bug index 383\n");
+          else
+            fprintf(stderr, "reached bug index 383\n");
+        }
+        if ((!FIXREVERTER[383] && (cBlockSize > remainingSize ))
+        #else
+        if (0
+        #endif
+        ) return ERROR(srcSize_wrong);
+        #ifdef FRCOV
+        }
+        #endif
 
         switch(blockProperties.blockType)
         {
@@ -2937,7 +3451,22 @@ static size_t ZSTD_decompressDCtx(void* ctx, void* dst, size_t maxDstSize, const
         default:
             return ERROR(GENERIC);   /* impossible */
         }
-        if (cBlockSize == 0) break;   /* bt_end */
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[384]) {
+          if ((cBlockSize == 0 ) && !(0))
+            fprintf(stderr, "triggered bug index 384\n");
+          else
+            fprintf(stderr, "reached bug index 384\n");
+        }
+        if ((!FIXREVERTER[384] && (cBlockSize == 0 ))
+        #else
+        if (0
+        #endif
+        ) break;
+        #ifdef FRCOV
+        }
+        #endif   /* bt_end */
 
         if (ZSTD_isError(decodedSize)) return decodedSize;
         op += decodedSize;
@@ -2994,12 +3523,42 @@ void ZSTDv03_findFrameSizeInfoLegacy(const void *src, size_t srcSize, size_t* cS
 
         ip += ZSTD_blockHeaderSize;
         remainingSize -= ZSTD_blockHeaderSize;
-        if (cBlockSize > remainingSize) {
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[386]) {
+          if ((cBlockSize > remainingSize ) && !(0))
+            fprintf(stderr, "triggered bug index 386\n");
+          else
+            fprintf(stderr, "reached bug index 386\n");
+        }
+        if ((!FIXREVERTER[386] && (cBlockSize > remainingSize ))
+        #else
+        if (0
+        #endif
+        ) {
             ZSTD_errorFrameSizeInfoLegacy(cSize, dBound, ERROR(srcSize_wrong));
             return;
         }
-
-        if (cBlockSize == 0) break;   /* bt_end */
+        #ifdef FRCOV
+        }
+        #endif
+
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[387]) {
+          if ((cBlockSize == 0 ) && !(0))
+            fprintf(stderr, "triggered bug index 387\n");
+          else
+            fprintf(stderr, "reached bug index 387\n");
+        }
+        if ((!FIXREVERTER[387] && (cBlockSize == 0 ))
+        #else
+        if (0
+        #endif
+        ) break;
+        #ifdef FRCOV
+        }
+        #endif   /* bt_end */
 
         ip += cBlockSize;
         remainingSize -= cBlockSize;
diff --git a/lib/legacy/zstd_v04.c b/lib/legacy/zstd_v04.c
index 4342330..a16c788 100644
--- a/lib/legacy/zstd_v04.c
+++ b/lib/legacy/zstd_v04.c
@@ -1,3 +1,7 @@
+#ifdef FRCOV
+#include <stdio.h>
+extern short FIXREVERTER[];
+#endif
 /*
  * Copyright (c) 2016-present, Yann Collet, Facebook, Inc.
  * All rights reserved.
@@ -1082,7 +1086,22 @@ static size_t FSE_buildDTable(FSE_DTable* dt, const short* normalizedCounter, un
 
     /* Sanity Checks */
     if (maxSymbolValue > FSE_MAX_SYMBOL_VALUE) return ERROR(maxSymbolValue_tooLarge);
-    if (tableLog > FSE_MAX_TABLELOG) return ERROR(tableLog_tooLarge);
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[716]) {
+      if ((tableLog > 14 - 2 ) && !(0))
+        fprintf(stderr, "triggered bug index 716\n");
+      else
+        fprintf(stderr, "reached bug index 716\n");
+    }
+    if ((!FIXREVERTER[716] && (tableLog > 14 - 2 ))
+    #else
+    if (0
+    #endif
+    ) return ERROR(tableLog_tooLarge);
+    #ifdef FRCOV
+    }
+    #endif
 
     /* Init, lay down lowprob symbols */
     memset(tableDecode, 0, sizeof(FSE_DECODE_TYPE) * (maxSymbolValue+1) );   /* useless init, but keep static analyzer happy, and we don't need to performance optimize legacy decoders */
@@ -1113,7 +1132,22 @@ static size_t FSE_buildDTable(FSE_DTable* dt, const short* normalizedCounter, un
         }
     }
 
-    if (position!=0) return ERROR(GENERIC);   /* position must reach all cells once, otherwise normalizedCounter is incorrect */
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[717]) {
+      if ((position != 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 717\n");
+      else
+        fprintf(stderr, "reached bug index 717\n");
+    }
+    if ((!FIXREVERTER[717] && (position != 0 ))
+    #else
+    if (0
+    #endif
+    ) return ERROR(GENERIC);
+    #ifdef FRCOV
+    }
+    #endif   /* position must reach all cells once, otherwise normalizedCounter is incorrect */
 
     /* Build Decoding table */
     {
@@ -1162,10 +1196,40 @@ static size_t FSE_readNCount (short* normalizedCounter, unsigned* maxSVPtr, unsi
     unsigned charnum = 0;
     int previous0 = 0;
 
-    if (hbSize < 4) return ERROR(srcSize_wrong);
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[718]) {
+      if ((hbSize < 4 ) && !(0))
+        fprintf(stderr, "triggered bug index 718\n");
+      else
+        fprintf(stderr, "reached bug index 718\n");
+    }
+    if ((!FIXREVERTER[718] && (hbSize < 4 ))
+    #else
+    if (0
+    #endif
+    ) return ERROR(srcSize_wrong);
+    #ifdef FRCOV
+    }
+    #endif
     bitStream = MEM_readLE32(ip);
     nbBits = (bitStream & 0xF) + FSE_MIN_TABLELOG;   /* extract tableLog */
-    if (nbBits > FSE_TABLELOG_ABSOLUTE_MAX) return ERROR(tableLog_tooLarge);
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[719]) {
+      if ((nbBits > 15 ) && !(0))
+        fprintf(stderr, "triggered bug index 719\n");
+      else
+        fprintf(stderr, "reached bug index 719\n");
+    }
+    if ((!FIXREVERTER[719] && (nbBits > 15 ))
+    #else
+    if (0
+    #endif
+    ) return ERROR(tableLog_tooLarge);
+    #ifdef FRCOV
+    }
+    #endif
     bitStream >>= 4;
     bitCount = 4;
     *tableLogPtr = nbBits;
@@ -1252,7 +1316,22 @@ static size_t FSE_readNCount (short* normalizedCounter, unsigned* maxSVPtr, unsi
             }
         }
     }
-    if (remaining != 1) return ERROR(GENERIC);
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[720]) {
+      if ((remaining != 1 ) && !(0))
+        fprintf(stderr, "triggered bug index 720\n");
+      else
+        fprintf(stderr, "reached bug index 720\n");
+    }
+    if ((!FIXREVERTER[720] && (remaining != 1 ))
+    #else
+    if (0
+    #endif
+    ) return ERROR(GENERIC);
+    #ifdef FRCOV
+    }
+    #endif
     *maxSVPtr = charnum-1;
 
     ip += (bitCount+7)>>3;
@@ -1294,7 +1373,22 @@ static size_t FSE_buildDTable_raw (FSE_DTable* dt, unsigned nbBits)
     unsigned s;
 
     /* Sanity checks */
-    if (nbBits < 1) return ERROR(GENERIC);         /* min size */
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[721]) {
+      if ((nbBits < 1 ) && !(0))
+        fprintf(stderr, "triggered bug index 721\n");
+      else
+        fprintf(stderr, "reached bug index 721\n");
+    }
+    if ((!FIXREVERTER[721] && (nbBits < 1 ))
+    #else
+    if (0
+    #endif
+    ) return ERROR(GENERIC);
+    #ifdef FRCOV
+    }
+    #endif         /* min size */
 
     /* Build Decoding Table */
     DTableH->tableLog = (U16)nbBits;
@@ -1405,12 +1499,42 @@ static size_t FSE_decompress(void* dst, size_t maxDstSize, const void* cSrc, siz
     unsigned maxSymbolValue = FSE_MAX_SYMBOL_VALUE;
     size_t errorCode;
 
-    if (cSrcSize<2) return ERROR(srcSize_wrong);   /* too small input size */
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[724]) {
+      if ((cSrcSize < 2 ) && !(0))
+        fprintf(stderr, "triggered bug index 724\n");
+      else
+        fprintf(stderr, "reached bug index 724\n");
+    }
+    if ((!FIXREVERTER[724] && (cSrcSize < 2 ))
+    #else
+    if (0
+    #endif
+    ) return ERROR(srcSize_wrong);
+    #ifdef FRCOV
+    }
+    #endif   /* too small input size */
 
     /* normal FSE decoding mode */
     errorCode = FSE_readNCount (counting, &maxSymbolValue, &tableLog, istart, cSrcSize);
     if (FSE_isError(errorCode)) return errorCode;
-    if (errorCode >= cSrcSize) return ERROR(srcSize_wrong);   /* too small input size */
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[725]) {
+      if ((errorCode >= cSrcSize ) && !(0))
+        fprintf(stderr, "triggered bug index 725\n");
+      else
+        fprintf(stderr, "reached bug index 725\n");
+    }
+    if ((!FIXREVERTER[725] && (errorCode >= cSrcSize ))
+    #else
+    if (0
+    #endif
+    ) return ERROR(srcSize_wrong);
+    #ifdef FRCOV
+    }
+    #endif   /* too small input size */
     ip += errorCode;
     cSrcSize -= errorCode;
 
@@ -1712,8 +1836,38 @@ static size_t HUF_readStats(BYTE* huffWeight, size_t hwSize, U32* rankStats,
         {
             oSize = iSize - 127;
             iSize = ((oSize+1)/2);
-            if (iSize+1 > srcSize) return ERROR(srcSize_wrong);
-            if (oSize >= hwSize) return ERROR(corruption_detected);
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[727]) {
+              if ((iSize + 1 > srcSize ) && !(0))
+                fprintf(stderr, "triggered bug index 727\n");
+              else
+                fprintf(stderr, "reached bug index 727\n");
+            }
+            if ((!FIXREVERTER[727] && (iSize + 1 > srcSize ))
+            #else
+            if (0
+            #endif
+            ) return ERROR(srcSize_wrong);
+            #ifdef FRCOV
+            }
+            #endif
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[728]) {
+              if ((oSize >= hwSize ) && !(0))
+                fprintf(stderr, "triggered bug index 728\n");
+              else
+                fprintf(stderr, "reached bug index 728\n");
+            }
+            if ((!FIXREVERTER[728] && (oSize >= hwSize ))
+            #else
+            if (0
+            #endif
+            ) return ERROR(corruption_detected);
+            #ifdef FRCOV
+            }
+            #endif
             ip += 1;
             for (n=0; n<oSize; n+=2)
             {
@@ -1724,7 +1878,22 @@ static size_t HUF_readStats(BYTE* huffWeight, size_t hwSize, U32* rankStats,
     }
     else  /* header compressed with FSE (normal case) */
     {
-        if (iSize+1 > srcSize) return ERROR(srcSize_wrong);
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[729]) {
+          if ((iSize + 1 > srcSize ) && !(0))
+            fprintf(stderr, "triggered bug index 729\n");
+          else
+            fprintf(stderr, "reached bug index 729\n");
+        }
+        if ((!FIXREVERTER[729] && (iSize + 1 > srcSize ))
+        #else
+        if (0
+        #endif
+        ) return ERROR(srcSize_wrong);
+        #ifdef FRCOV
+        }
+        #endif
         oSize = FSE_decompress(huffWeight, hwSize-1, ip+1, iSize);   /* max (hwSize-1) values decoded, as last one is implied */
         if (FSE_isError(oSize)) return oSize;
     }
@@ -1738,17 +1907,62 @@ static size_t HUF_readStats(BYTE* huffWeight, size_t hwSize, U32* rankStats,
         rankStats[huffWeight[n]]++;
         weightTotal += (1 << huffWeight[n]) >> 1;
     }
-    if (weightTotal == 0) return ERROR(corruption_detected);
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[730]) {
+      if ((weightTotal == 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 730\n");
+      else
+        fprintf(stderr, "reached bug index 730\n");
+    }
+    if ((!FIXREVERTER[730] && (weightTotal == 0 ))
+    #else
+    if (0
+    #endif
+    ) return ERROR(corruption_detected);
+    #ifdef FRCOV
+    }
+    #endif
 
     /* get last non-null symbol weight (implied, total must be 2^n) */
     tableLog = BIT_highbit32(weightTotal) + 1;
-    if (tableLog > HUF_ABSOLUTEMAX_TABLELOG) return ERROR(corruption_detected);
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[731]) {
+      if ((tableLog > 16 ) && !(0))
+        fprintf(stderr, "triggered bug index 731\n");
+      else
+        fprintf(stderr, "reached bug index 731\n");
+    }
+    if ((!FIXREVERTER[731] && (tableLog > 16 ))
+    #else
+    if (0
+    #endif
+    ) return ERROR(corruption_detected);
+    #ifdef FRCOV
+    }
+    #endif
     {
         U32 total = 1 << tableLog;
         U32 rest = total - weightTotal;
         U32 verif = 1 << BIT_highbit32(rest);
         U32 lastWeight = BIT_highbit32(rest) + 1;
-        if (verif != rest) return ERROR(corruption_detected);    /* last value must be a clean power of 2 */
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[732]) {
+          if ((verif != rest ) && !(0))
+            fprintf(stderr, "triggered bug index 732\n");
+          else
+            fprintf(stderr, "reached bug index 732\n");
+        }
+        if ((!FIXREVERTER[732] && (verif != rest ))
+        #else
+        if (0
+        #endif
+        ) return ERROR(corruption_detected);
+        #ifdef FRCOV
+        }
+        #endif    /* last value must be a clean power of 2 */
         huffWeight[oSize] = (BYTE)lastWeight;
         rankStats[lastWeight]++;
     }
@@ -1863,7 +2077,22 @@ static size_t HUF_decompress4X2_usingDTable(
     const void* cSrc, size_t cSrcSize,
     const U16* DTable)
 {
-    if (cSrcSize < 10) return ERROR(corruption_detected);   /* strict minimum : jump table + 1 byte per stream */
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[735]) {
+      if ((cSrcSize < 10 ) && !(0))
+        fprintf(stderr, "triggered bug index 735\n");
+      else
+        fprintf(stderr, "reached bug index 735\n");
+    }
+    if ((!FIXREVERTER[735] && (cSrcSize < 10 ))
+    #else
+    if (0
+    #endif
+    ) return ERROR(corruption_detected);
+    #ifdef FRCOV
+    }
+    #endif   /* strict minimum : jump table + 1 byte per stream */
 
     {
         const BYTE* const istart = (const BYTE*) cSrc;
@@ -1898,7 +2127,22 @@ static size_t HUF_decompress4X2_usingDTable(
         U32 endSignal;
 
         length4 = cSrcSize - (length1 + length2 + length3 + 6);
-        if (length4 > cSrcSize) return ERROR(corruption_detected);   /* overflow */
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[736]) {
+          if ((length4 > cSrcSize ) && !(0))
+            fprintf(stderr, "triggered bug index 736\n");
+          else
+            fprintf(stderr, "reached bug index 736\n");
+        }
+        if ((!FIXREVERTER[736] && (length4 > cSrcSize ))
+        #else
+        if (0
+        #endif
+        ) return ERROR(corruption_detected);
+        #ifdef FRCOV
+        }
+        #endif   /* overflow */
         errorCode = BIT_initDStream(&bitD1, istart1, length1);
         if (HUF_isError(errorCode)) return errorCode;
         errorCode = BIT_initDStream(&bitD2, istart2, length2);
@@ -1962,7 +2206,22 @@ static size_t HUF_decompress4X2 (void* dst, size_t dstSize, const void* cSrc, si
 
     errorCode = HUF_readDTableX2 (DTable, cSrc, cSrcSize);
     if (HUF_isError(errorCode)) return errorCode;
-    if (errorCode >= cSrcSize) return ERROR(srcSize_wrong);
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[737]) {
+      if ((errorCode >= cSrcSize ) && !(0))
+        fprintf(stderr, "triggered bug index 737\n");
+      else
+        fprintf(stderr, "reached bug index 737\n");
+    }
+    if ((!FIXREVERTER[737] && (errorCode >= cSrcSize ))
+    #else
+    if (0
+    #endif
+    ) return ERROR(srcSize_wrong);
+    #ifdef FRCOV
+    }
+    #endif
     ip += errorCode;
     cSrcSize -= errorCode;
 
@@ -2221,7 +2480,22 @@ static size_t HUF_decompress4X4_usingDTable(
     const void* cSrc, size_t cSrcSize,
     const U32* DTable)
 {
-    if (cSrcSize < 10) return ERROR(corruption_detected);   /* strict minimum : jump table + 1 byte per stream */
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[748]) {
+      if ((cSrcSize < 10 ) && !(0))
+        fprintf(stderr, "triggered bug index 748\n");
+      else
+        fprintf(stderr, "reached bug index 748\n");
+    }
+    if ((!FIXREVERTER[748] && (cSrcSize < 10 ))
+    #else
+    if (0
+    #endif
+    ) return ERROR(corruption_detected);
+    #ifdef FRCOV
+    }
+    #endif   /* strict minimum : jump table + 1 byte per stream */
 
     {
         const BYTE* const istart = (const BYTE*) cSrc;
@@ -2256,7 +2530,22 @@ static size_t HUF_decompress4X4_usingDTable(
         U32 endSignal;
 
         length4 = cSrcSize - (length1 + length2 + length3 + 6);
-        if (length4 > cSrcSize) return ERROR(corruption_detected);   /* overflow */
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[749]) {
+          if ((length4 > cSrcSize ) && !(0))
+            fprintf(stderr, "triggered bug index 749\n");
+          else
+            fprintf(stderr, "reached bug index 749\n");
+        }
+        if ((!FIXREVERTER[749] && (length4 > cSrcSize ))
+        #else
+        if (0
+        #endif
+        ) return ERROR(corruption_detected);
+        #ifdef FRCOV
+        }
+        #endif   /* overflow */
         errorCode = BIT_initDStream(&bitD1, istart1, length1);
         if (HUF_isError(errorCode)) return errorCode;
         errorCode = BIT_initDStream(&bitD2, istart2, length2);
@@ -2319,7 +2608,22 @@ static size_t HUF_decompress4X4 (void* dst, size_t dstSize, const void* cSrc, si
 
     size_t hSize = HUF_readDTableX4 (DTable, cSrc, cSrcSize);
     if (HUF_isError(hSize)) return hSize;
-    if (hSize >= cSrcSize) return ERROR(srcSize_wrong);
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[750]) {
+      if ((hSize >= cSrcSize ) && !(0))
+        fprintf(stderr, "triggered bug index 750\n");
+      else
+        fprintf(stderr, "reached bug index 750\n");
+    }
+    if ((!FIXREVERTER[750] && (hSize >= cSrcSize ))
+    #else
+    if (0
+    #endif
+    ) return ERROR(srcSize_wrong);
+    #ifdef FRCOV
+    }
+    #endif
     ip += hSize;
     cSrcSize -= hSize;
 
@@ -2366,10 +2670,55 @@ static size_t HUF_decompress (void* dst, size_t dstSize, const void* cSrc, size_
     int n;
 
     /* validation checks */
-    if (dstSize == 0) return ERROR(dstSize_tooSmall);
-    if (cSrcSize > dstSize) return ERROR(corruption_detected);   /* invalid */
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[753]) {
+      if ((dstSize == 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 753\n");
+      else
+        fprintf(stderr, "reached bug index 753\n");
+    }
+    if ((!FIXREVERTER[753] && (dstSize == 0 ))
+    #else
+    if (0
+    #endif
+    ) return ERROR(dstSize_tooSmall);
+    #ifdef FRCOV
+    }
+    #endif
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[754]) {
+      if ((cSrcSize > dstSize ) && !(0))
+        fprintf(stderr, "triggered bug index 754\n");
+      else
+        fprintf(stderr, "reached bug index 754\n");
+    }
+    if ((!FIXREVERTER[754] && (cSrcSize > dstSize ))
+    #else
+    if (0
+    #endif
+    ) return ERROR(corruption_detected);
+    #ifdef FRCOV
+    }
+    #endif   /* invalid */
     if (cSrcSize == dstSize) { memcpy(dst, cSrc, dstSize); return dstSize; }   /* not compressed */
-    if (cSrcSize == 1) { memset(dst, *(const BYTE*)cSrc, dstSize); return dstSize; }   /* RLE */
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[757]) {
+      if ((cSrcSize == 1 ) && !(0))
+        fprintf(stderr, "triggered bug index 757\n");
+      else
+        fprintf(stderr, "reached bug index 757\n");
+    }
+    if ((!FIXREVERTER[757] && (cSrcSize == 1 ))
+    #else
+    if (0
+    #endif
+    ) { memset(dst, *(const BYTE*)cSrc, dstSize); return dstSize; }
+    #ifdef FRCOV
+    }
+    #endif   /* RLE */
 
     /* decoder timing evaluation */
     Q = (U32)(cSrcSize * 16 / dstSize);   /* Q < 16 since dstSize > cSrcSize */
@@ -2520,7 +2869,22 @@ static size_t ZSTD_resetDCtx(ZSTD_DCtx* dctx)
 static ZSTD_DCtx* ZSTD_createDCtx(void)
 {
     ZSTD_DCtx* dctx = (ZSTD_DCtx*)malloc(sizeof(ZSTD_DCtx));
-    if (dctx==NULL) return NULL;
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[759]) {
+      if ((dctx == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 759\n");
+      else
+        fprintf(stderr, "reached bug index 759\n");
+    }
+    if ((!FIXREVERTER[759] && (dctx == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) return NULL;
+    #ifdef FRCOV
+    }
+    #endif
     ZSTD_resetDCtx(dctx);
     return dctx;
 }
@@ -2569,7 +2933,22 @@ static size_t ZSTD_getFrameParams(ZSTD_parameters* params, const void* src, size
 static size_t ZSTD_decodeFrameHeader_Part2(ZSTD_DCtx* zc, const void* src, size_t srcSize)
 {
     size_t result;
-    if (srcSize != zc->headerSize) return ERROR(srcSize_wrong);
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[762]) {
+      if ((srcSize != zc -> headerSize ) && !(0))
+        fprintf(stderr, "triggered bug index 762\n");
+      else
+        fprintf(stderr, "reached bug index 762\n");
+    }
+    if ((!FIXREVERTER[762] && (srcSize != zc -> headerSize ))
+    #else
+    if (0
+    #endif
+    ) return ERROR(srcSize_wrong);
+    #ifdef FRCOV
+    }
+    #endif
     result = ZSTD_getFrameParams(&(zc->params), src, srcSize);
     if ((MEM_32bits()) && (zc->params.windowLog > 25)) return ERROR(frameParameter_unsupported);
     return result;
@@ -2688,7 +3067,22 @@ static size_t ZSTD_decodeSeqHeaders(int* nbSeq, const BYTE** dumpsPtr, size_t* d
     size_t dumpsLength;
 
     /* check */
-    if (srcSize < 5) return ERROR(srcSize_wrong);
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[766]) {
+      if ((srcSize < 5 ) && !(0))
+        fprintf(stderr, "triggered bug index 766\n");
+      else
+        fprintf(stderr, "reached bug index 766\n");
+    }
+    if ((!FIXREVERTER[766] && (srcSize < 5 ))
+    #else
+    if (0
+    #endif
+    ) return ERROR(srcSize_wrong);
+    #ifdef FRCOV
+    }
+    #endif
 
     /* SeqHead */
     *nbSeq = MEM_readLE16(ip); ip+=2;
@@ -2732,7 +3126,22 @@ static size_t ZSTD_decodeSeqHeaders(int* nbSeq, const BYTE** dumpsPtr, size_t* d
             {   U32 max = MaxLL;
                 headerSize = FSE_readNCount(norm, &max, &LLlog, ip, iend-ip);
                 if (FSE_isError(headerSize)) return ERROR(GENERIC);
-                if (LLlog > LLFSELog) return ERROR(corruption_detected);
+                
+                #ifdef FRCOV
+                {if (FIXREVERTER[768]) {
+                  if ((LLlog > 10 ) && !(0))
+                    fprintf(stderr, "triggered bug index 768\n");
+                  else
+                    fprintf(stderr, "reached bug index 768\n");
+                }
+                if ((!FIXREVERTER[768] && (LLlog > 10 ))
+                #else
+                if (0
+                #endif
+                ) return ERROR(corruption_detected);
+                #ifdef FRCOV
+                }
+                #endif
                 ip += headerSize;
                 FSE_buildDTable(DTableLL, norm, max, LLlog);
         }   }
@@ -2751,7 +3160,22 @@ static size_t ZSTD_decodeSeqHeaders(int* nbSeq, const BYTE** dumpsPtr, size_t* d
             {   U32 max = MaxOff;
                 headerSize = FSE_readNCount(norm, &max, &Offlog, ip, iend-ip);
                 if (FSE_isError(headerSize)) return ERROR(GENERIC);
-                if (Offlog > OffFSELog) return ERROR(corruption_detected);
+                
+                #ifdef FRCOV
+                {if (FIXREVERTER[769]) {
+                  if ((Offlog > 9 ) && !(0))
+                    fprintf(stderr, "triggered bug index 769\n");
+                  else
+                    fprintf(stderr, "reached bug index 769\n");
+                }
+                if ((!FIXREVERTER[769] && (Offlog > 9 ))
+                #else
+                if (0
+                #endif
+                ) return ERROR(corruption_detected);
+                #ifdef FRCOV
+                }
+                #endif
                 ip += headerSize;
                 FSE_buildDTable(DTableOffb, norm, max, Offlog);
         }   }
@@ -2769,7 +3193,22 @@ static size_t ZSTD_decodeSeqHeaders(int* nbSeq, const BYTE** dumpsPtr, size_t* d
             {   U32 max = MaxML;
                 headerSize = FSE_readNCount(norm, &max, &MLlog, ip, iend-ip);
                 if (FSE_isError(headerSize)) return ERROR(GENERIC);
-                if (MLlog > MLFSELog) return ERROR(corruption_detected);
+                
+                #ifdef FRCOV
+                {if (FIXREVERTER[770]) {
+                  if ((MLlog > 10 ) && !(0))
+                    fprintf(stderr, "triggered bug index 770\n");
+                  else
+                    fprintf(stderr, "reached bug index 770\n");
+                }
+                if ((!FIXREVERTER[770] && (MLlog > 10 ))
+                #else
+                if (0
+                #endif
+                ) return ERROR(corruption_detected);
+                #ifdef FRCOV
+                }
+                #endif
                 ip += headerSize;
                 FSE_buildDTable(DTableML, norm, max, MLlog);
     }   }   }
@@ -2827,10 +3266,40 @@ static void ZSTD_decodeSequence(seq_t* seq, seqState_t* seqState)
         offsetCode = FSE_decodeSymbol(&(seqState->stateOffb), &(seqState->DStream));   /* <= maxOff, by table construction */
         if (MEM_32bits()) BIT_reloadDStream(&(seqState->DStream));
         nbBits = offsetCode - 1;
-        if (offsetCode==0) nbBits = 0;   /* cmove */
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[772]) {
+          if ((offsetCode == 0 ) && !(0))
+            fprintf(stderr, "triggered bug index 772\n");
+          else
+            fprintf(stderr, "reached bug index 772\n");
+        }
+        if ((!FIXREVERTER[772] && (offsetCode == 0 ))
+        #else
+        if (0
+        #endif
+        ) nbBits = 0;
+        #ifdef FRCOV
+        }
+        #endif   /* cmove */
         offset = offsetPrefix[offsetCode] + BIT_readBits(&(seqState->DStream), nbBits);
         if (MEM_32bits()) BIT_reloadDStream(&(seqState->DStream));
-        if (offsetCode==0) offset = prevOffset;   /* cmove */
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[773]) {
+          if ((offsetCode == 0 ) && !(0))
+            fprintf(stderr, "triggered bug index 773\n");
+          else
+            fprintf(stderr, "reached bug index 773\n");
+        }
+        if ((!FIXREVERTER[773] && (offsetCode == 0 ))
+        #else
+        if (0
+        #endif
+        ) offset = prevOffset;
+        #ifdef FRCOV
+        }
+        #endif   /* cmove */
         if (offsetCode | !litLength) seqState->prevOffset = seq->offset;   /* cmove */
     }
 
@@ -3090,7 +3559,22 @@ static size_t ZSTD_decompress_usingDict(ZSTD_DCtx* ctx,
 
         ip += ZSTD_blockHeaderSize;
         remainingSize -= ZSTD_blockHeaderSize;
-        if (cBlockSize > remainingSize) return ERROR(srcSize_wrong);
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[777]) {
+          if ((cBlockSize > remainingSize ) && !(0))
+            fprintf(stderr, "triggered bug index 777\n");
+          else
+            fprintf(stderr, "reached bug index 777\n");
+        }
+        if ((!FIXREVERTER[777] && (cBlockSize > remainingSize ))
+        #else
+        if (0
+        #endif
+        ) return ERROR(srcSize_wrong);
+        #ifdef FRCOV
+        }
+        #endif
 
         switch(blockProperties.blockType)
         {
@@ -3110,7 +3594,22 @@ static size_t ZSTD_decompress_usingDict(ZSTD_DCtx* ctx,
         default:
             return ERROR(GENERIC);   /* impossible */
         }
-        if (cBlockSize == 0) break;   /* bt_end */
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[778]) {
+          if ((cBlockSize == 0 ) && !(0))
+            fprintf(stderr, "triggered bug index 778\n");
+          else
+            fprintf(stderr, "reached bug index 778\n");
+        }
+        if ((!FIXREVERTER[778] && (cBlockSize == 0 ))
+        #else
+        if (0
+        #endif
+        ) break;
+        #ifdef FRCOV
+        }
+        #endif   /* bt_end */
 
         if (ZSTD_isError(decodedSize)) return decodedSize;
         op += decodedSize;
@@ -3158,12 +3657,42 @@ void ZSTDv04_findFrameSizeInfoLegacy(const void *src, size_t srcSize, size_t* cS
 
         ip += ZSTD_blockHeaderSize;
         remainingSize -= ZSTD_blockHeaderSize;
-        if (cBlockSize > remainingSize) {
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[779]) {
+          if ((cBlockSize > remainingSize ) && !(0))
+            fprintf(stderr, "triggered bug index 779\n");
+          else
+            fprintf(stderr, "reached bug index 779\n");
+        }
+        if ((!FIXREVERTER[779] && (cBlockSize > remainingSize ))
+        #else
+        if (0
+        #endif
+        ) {
             ZSTD_errorFrameSizeInfoLegacy(cSize, dBound, ERROR(srcSize_wrong));
             return;
         }
-
-        if (cBlockSize == 0) break;   /* bt_end */
+        #ifdef FRCOV
+        }
+        #endif
+
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[780]) {
+          if ((cBlockSize == 0 ) && !(0))
+            fprintf(stderr, "triggered bug index 780\n");
+          else
+            fprintf(stderr, "reached bug index 780\n");
+        }
+        if ((!FIXREVERTER[780] && (cBlockSize == 0 ))
+        #else
+        if (0
+        #endif
+        ) break;
+        #ifdef FRCOV
+        }
+        #endif   /* bt_end */
 
         ip += cBlockSize;
         remainingSize -= cBlockSize;
@@ -3185,7 +3714,22 @@ static size_t ZSTD_nextSrcSizeToDecompress(ZSTD_DCtx* dctx)
 static size_t ZSTD_decompressContinue(ZSTD_DCtx* ctx, void* dst, size_t maxDstSize, const void* src, size_t srcSize)
 {
     /* Sanity check */
-    if (srcSize != ctx->expected) return ERROR(srcSize_wrong);
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[781]) {
+      if ((srcSize != ctx -> expected ) && !(0))
+        fprintf(stderr, "triggered bug index 781\n");
+      else
+        fprintf(stderr, "reached bug index 781\n");
+    }
+    if ((!FIXREVERTER[781] && (srcSize != ctx -> expected ))
+    #else
+    if (0
+    #endif
+    ) return ERROR(srcSize_wrong);
+    #ifdef FRCOV
+    }
+    #endif
     ZSTD_checkContinuity(ctx, dst);
 
     /* Decompress : frame header; part 1 */
@@ -3362,7 +3906,22 @@ typedef ZBUFFv04_DCtx ZBUFF_DCtx;
 static ZBUFF_DCtx* ZBUFF_createDCtx(void)
 {
     ZBUFF_DCtx* zbc = (ZBUFF_DCtx*)malloc(sizeof(ZBUFF_DCtx));
-    if (zbc==NULL) return NULL;
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[782]) {
+      if ((zbc == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 782\n");
+      else
+        fprintf(stderr, "reached bug index 782\n");
+    }
+    if ((!FIXREVERTER[782] && (zbc == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) return NULL;
+    #ifdef FRCOV
+    }
+    #endif
     memset(zbc, 0, sizeof(*zbc));
     zbc->zc = ZSTD_createDCtx();
     zbc->stage = ZBUFFds_init;
@@ -3371,7 +3930,22 @@ static ZBUFF_DCtx* ZBUFF_createDCtx(void)
 
 static size_t ZBUFF_freeDCtx(ZBUFF_DCtx* zbc)
 {
-    if (zbc==NULL) return 0;   /* support free on null */
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[783]) {
+      if ((zbc == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 783\n");
+      else
+        fprintf(stderr, "reached bug index 783\n");
+    }
+    if ((!FIXREVERTER[783] && (zbc == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) return 0;
+    #ifdef FRCOV
+    }
+    #endif   /* support free on null */
     ZSTD_freeDCtx(zbc->zc);
     free(zbc->inBuff);
     free(zbc->outBuff);
@@ -3466,13 +4040,43 @@ static size_t ZBUFF_decompressContinue(ZBUFF_DCtx* zbc, void* dst, size_t* maxDs
                         free(zbc->inBuff);
                         zbc->inBuffSize = neededInSize;
                         zbc->inBuff = (char*)malloc(neededInSize);
-                        if (zbc->inBuff == NULL) return ERROR(memory_allocation);
+                        
+                        #ifdef FRCOV
+                        {if (FIXREVERTER[785]) {
+                          if ((zbc -> inBuff == (void *) 0 ) && !(0))
+                            fprintf(stderr, "triggered bug index 785\n");
+                          else
+                            fprintf(stderr, "reached bug index 785\n");
+                        }
+                        if ((!FIXREVERTER[785] && (zbc -> inBuff == (void *) 0 ))
+                        #else
+                        if (0
+                        #endif
+                        ) return ERROR(memory_allocation);
+                        #ifdef FRCOV
+                        }
+                        #endif
                     }
                     if (zbc->outBuffSize < neededOutSize) {
                         free(zbc->outBuff);
                         zbc->outBuffSize = neededOutSize;
                         zbc->outBuff = (char*)malloc(neededOutSize);
-                        if (zbc->outBuff == NULL) return ERROR(memory_allocation);
+                        
+                        #ifdef FRCOV
+                        {if (FIXREVERTER[786]) {
+                          if ((zbc -> outBuff == (void *) 0 ) && !(0))
+                            fprintf(stderr, "triggered bug index 786\n");
+                          else
+                            fprintf(stderr, "reached bug index 786\n");
+                        }
+                        if ((!FIXREVERTER[786] && (zbc -> outBuff == (void *) 0 ))
+                        #else
+                        if (0
+                        #endif
+                        ) return ERROR(memory_allocation);
+                        #ifdef FRCOV
+                        }
+                        #endif
                 }   }
                 if (zbc->dictSize)
                     ZSTD_decompress_insertDictionary(zbc->zc, zbc->dict, zbc->dictSize);
@@ -3489,12 +4093,27 @@ static size_t ZBUFF_decompressContinue(ZBUFF_DCtx* zbc, void* dst, size_t* maxDs
         case ZBUFFds_read:
             {
                 size_t neededInSize = ZSTD_nextSrcSizeToDecompress(zbc->zc);
-                if (neededInSize==0)   /* end of frame */
+                
+                #ifdef FRCOV
+                {if (FIXREVERTER[788]) {
+                  if ((neededInSize == 0 ) && !(0))
+                    fprintf(stderr, "triggered bug index 788\n");
+                  else
+                    fprintf(stderr, "reached bug index 788\n");
+                }
+                if ((!FIXREVERTER[788] && (neededInSize == 0 ))
+                #else
+                if (0
+                #endif
+                )   /* end of frame */
                 {
                     zbc->stage = ZBUFFds_init;
                     notDone = 0;
                     break;
                 }
+                #ifdef FRCOV
+                }
+                #endif
                 if ((size_t)(iend-ip) >= neededInSize)
                 {
                     /* directly decode from src */
@@ -3593,7 +4212,22 @@ size_t ZSTDv04_decompress(void* dst, size_t maxDstSize, const void* src, size_t
 #if defined(ZSTD_HEAPMODE) && (ZSTD_HEAPMODE==1)
     size_t regenSize;
     ZSTD_DCtx* dctx = ZSTD_createDCtx();
-    if (dctx==NULL) return ERROR(memory_allocation);
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[792]) {
+      if ((dctx == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 792\n");
+      else
+        fprintf(stderr, "reached bug index 792\n");
+    }
+    if ((!FIXREVERTER[792] && (dctx == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) return ERROR(memory_allocation);
+    #ifdef FRCOV
+    }
+    #endif
     regenSize = ZSTDv04_decompressDCtx(dctx, dst, maxDstSize, src, srcSize);
     ZSTD_freeDCtx(dctx);
     return regenSize;
diff --git a/lib/legacy/zstd_v05.c b/lib/legacy/zstd_v05.c
index 800aa15..107b32d 100644
--- a/lib/legacy/zstd_v05.c
+++ b/lib/legacy/zstd_v05.c
@@ -1,3 +1,7 @@
+#ifdef FRCOV
+#include <stdio.h>
+extern short FIXREVERTER[];
+#endif
 /*
  * Copyright (c) 2016-present, Yann Collet, Facebook, Inc.
  * All rights reserved.
@@ -1223,7 +1227,22 @@ size_t FSEv05_buildDTable(FSEv05_DTable* dt, const short* normalizedCounter, uns
 
     /* Sanity Checks */
     if (maxSymbolValue > FSEv05_MAX_SYMBOL_VALUE) return ERROR(maxSymbolValue_tooLarge);
-    if (tableLog > FSEv05_MAX_TABLELOG) return ERROR(tableLog_tooLarge);
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[474]) {
+      if ((tableLog > 14 - 2 ) && !(0))
+        fprintf(stderr, "triggered bug index 474\n");
+      else
+        fprintf(stderr, "reached bug index 474\n");
+    }
+    if ((!FIXREVERTER[474] && (tableLog > 14 - 2 ))
+    #else
+    if (0
+    #endif
+    ) return ERROR(tableLog_tooLarge);
+    #ifdef FRCOV
+    }
+    #endif
 
     /* Init, lay down lowprob symbols */
     memset(tableDecode, 0, sizeof(FSEv05_FUNCTION_TYPE) * (maxSymbolValue+1) );   /* useless init, but keep static analyzer happy, and we don't need to performance optimize legacy decoders */
@@ -1246,7 +1265,22 @@ size_t FSEv05_buildDTable(FSEv05_DTable* dt, const short* normalizedCounter, uns
             while (position > highThreshold) position = (position + step) & tableMask;   /* lowprob area */
     }   }
 
-    if (position!=0) return ERROR(GENERIC);   /* position must reach all cells once, otherwise normalizedCounter is incorrect */
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[475]) {
+      if ((position != 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 475\n");
+      else
+        fprintf(stderr, "reached bug index 475\n");
+    }
+    if ((!FIXREVERTER[475] && (position != 0 ))
+    #else
+    if (0
+    #endif
+    ) return ERROR(GENERIC);
+    #ifdef FRCOV
+    }
+    #endif   /* position must reach all cells once, otherwise normalizedCounter is incorrect */
 
     /* Build Decoding table */
     {
@@ -1293,10 +1327,40 @@ size_t FSEv05_readNCount (short* normalizedCounter, unsigned* maxSVPtr, unsigned
     unsigned charnum = 0;
     int previous0 = 0;
 
-    if (hbSize < 4) return ERROR(srcSize_wrong);
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[476]) {
+      if ((hbSize < 4 ) && !(0))
+        fprintf(stderr, "triggered bug index 476\n");
+      else
+        fprintf(stderr, "reached bug index 476\n");
+    }
+    if ((!FIXREVERTER[476] && (hbSize < 4 ))
+    #else
+    if (0
+    #endif
+    ) return ERROR(srcSize_wrong);
+    #ifdef FRCOV
+    }
+    #endif
     bitStream = MEM_readLE32(ip);
     nbBits = (bitStream & 0xF) + FSEv05_MIN_TABLELOG;   /* extract tableLog */
-    if (nbBits > FSEv05_TABLELOG_ABSOLUTE_MAX) return ERROR(tableLog_tooLarge);
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[477]) {
+      if ((nbBits > 15 ) && !(0))
+        fprintf(stderr, "triggered bug index 477\n");
+      else
+        fprintf(stderr, "reached bug index 477\n");
+    }
+    if ((!FIXREVERTER[477] && (nbBits > 15 ))
+    #else
+    if (0
+    #endif
+    ) return ERROR(tableLog_tooLarge);
+    #ifdef FRCOV
+    }
+    #endif
     bitStream >>= 4;
     bitCount = 4;
     *tableLogPtr = nbBits;
@@ -1364,7 +1428,22 @@ size_t FSEv05_readNCount (short* normalizedCounter, unsigned* maxSVPtr, unsigned
             }
             bitStream = MEM_readLE32(ip) >> (bitCount & 31);
     }   }
-    if (remaining != 1) return ERROR(GENERIC);
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[478]) {
+      if ((remaining != 1 ) && !(0))
+        fprintf(stderr, "triggered bug index 478\n");
+      else
+        fprintf(stderr, "reached bug index 478\n");
+    }
+    if ((!FIXREVERTER[478] && (remaining != 1 ))
+    #else
+    if (0
+    #endif
+    ) return ERROR(GENERIC);
+    #ifdef FRCOV
+    }
+    #endif
     *maxSVPtr = charnum-1;
 
     ip += (bitCount+7)>>3;
@@ -1407,7 +1486,22 @@ size_t FSEv05_buildDTable_raw (FSEv05_DTable* dt, unsigned nbBits)
     unsigned s;
 
     /* Sanity checks */
-    if (nbBits < 1) return ERROR(GENERIC);         /* min size */
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[479]) {
+      if ((nbBits < 1 ) && !(0))
+        fprintf(stderr, "triggered bug index 479\n");
+      else
+        fprintf(stderr, "reached bug index 479\n");
+    }
+    if ((!FIXREVERTER[479] && (nbBits < 1 ))
+    #else
+    if (0
+    #endif
+    ) return ERROR(GENERIC);
+    #ifdef FRCOV
+    }
+    #endif         /* min size */
 
     /* Build Decoding Table */
     DTableH->tableLog = (U16)nbBits;
@@ -1513,12 +1607,42 @@ size_t FSEv05_decompress(void* dst, size_t maxDstSize, const void* cSrc, size_t
     unsigned maxSymbolValue = FSEv05_MAX_SYMBOL_VALUE;
     size_t errorCode;
 
-    if (cSrcSize<2) return ERROR(srcSize_wrong);   /* too small input size */
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[482]) {
+      if ((cSrcSize < 2 ) && !(0))
+        fprintf(stderr, "triggered bug index 482\n");
+      else
+        fprintf(stderr, "reached bug index 482\n");
+    }
+    if ((!FIXREVERTER[482] && (cSrcSize < 2 ))
+    #else
+    if (0
+    #endif
+    ) return ERROR(srcSize_wrong);
+    #ifdef FRCOV
+    }
+    #endif   /* too small input size */
 
     /* normal FSEv05 decoding mode */
     errorCode = FSEv05_readNCount (counting, &maxSymbolValue, &tableLog, istart, cSrcSize);
     if (FSEv05_isError(errorCode)) return errorCode;
-    if (errorCode >= cSrcSize) return ERROR(srcSize_wrong);   /* too small input size */
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[483]) {
+      if ((errorCode >= cSrcSize ) && !(0))
+        fprintf(stderr, "triggered bug index 483\n");
+      else
+        fprintf(stderr, "reached bug index 483\n");
+    }
+    if ((!FIXREVERTER[483] && (errorCode >= cSrcSize ))
+    #else
+    if (0
+    #endif
+    ) return ERROR(srcSize_wrong);
+    #ifdef FRCOV
+    }
+    #endif   /* too small input size */
     ip += errorCode;
     cSrcSize -= errorCode;
 
@@ -1816,15 +1940,60 @@ static size_t HUFv05_readStats(BYTE* huffWeight, size_t hwSize, U32* rankStats,
         else {   /* Incompressible */
             oSize = iSize - 127;
             iSize = ((oSize+1)/2);
-            if (iSize+1 > srcSize) return ERROR(srcSize_wrong);
-            if (oSize >= hwSize) return ERROR(corruption_detected);
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[485]) {
+              if ((iSize + 1 > srcSize ) && !(0))
+                fprintf(stderr, "triggered bug index 485\n");
+              else
+                fprintf(stderr, "reached bug index 485\n");
+            }
+            if ((!FIXREVERTER[485] && (iSize + 1 > srcSize ))
+            #else
+            if (0
+            #endif
+            ) return ERROR(srcSize_wrong);
+            #ifdef FRCOV
+            }
+            #endif
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[486]) {
+              if ((oSize >= hwSize ) && !(0))
+                fprintf(stderr, "triggered bug index 486\n");
+              else
+                fprintf(stderr, "reached bug index 486\n");
+            }
+            if ((!FIXREVERTER[486] && (oSize >= hwSize ))
+            #else
+            if (0
+            #endif
+            ) return ERROR(corruption_detected);
+            #ifdef FRCOV
+            }
+            #endif
             ip += 1;
             for (n=0; n<oSize; n+=2) {
                 huffWeight[n]   = ip[n/2] >> 4;
                 huffWeight[n+1] = ip[n/2] & 15;
     }   }   }
     else  {   /* header compressed with FSEv05 (normal case) */
-        if (iSize+1 > srcSize) return ERROR(srcSize_wrong);
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[487]) {
+          if ((iSize + 1 > srcSize ) && !(0))
+            fprintf(stderr, "triggered bug index 487\n");
+          else
+            fprintf(stderr, "reached bug index 487\n");
+        }
+        if ((!FIXREVERTER[487] && (iSize + 1 > srcSize ))
+        #else
+        if (0
+        #endif
+        ) return ERROR(srcSize_wrong);
+        #ifdef FRCOV
+        }
+        #endif
         oSize = FSEv05_decompress(huffWeight, hwSize-1, ip+1, iSize);   /* max (hwSize-1) values decoded, as last one is implied */
         if (FSEv05_isError(oSize)) return oSize;
     }
@@ -1837,17 +2006,62 @@ static size_t HUFv05_readStats(BYTE* huffWeight, size_t hwSize, U32* rankStats,
         rankStats[huffWeight[n]]++;
         weightTotal += (1 << huffWeight[n]) >> 1;
     }
-    if (weightTotal == 0) return ERROR(corruption_detected);
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[488]) {
+      if ((weightTotal == 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 488\n");
+      else
+        fprintf(stderr, "reached bug index 488\n");
+    }
+    if ((!FIXREVERTER[488] && (weightTotal == 0 ))
+    #else
+    if (0
+    #endif
+    ) return ERROR(corruption_detected);
+    #ifdef FRCOV
+    }
+    #endif
 
     /* get last non-null symbol weight (implied, total must be 2^n) */
     tableLog = BITv05_highbit32(weightTotal) + 1;
-    if (tableLog > HUFv05_ABSOLUTEMAX_TABLELOG) return ERROR(corruption_detected);
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[489]) {
+      if ((tableLog > 16 ) && !(0))
+        fprintf(stderr, "triggered bug index 489\n");
+      else
+        fprintf(stderr, "reached bug index 489\n");
+    }
+    if ((!FIXREVERTER[489] && (tableLog > 16 ))
+    #else
+    if (0
+    #endif
+    ) return ERROR(corruption_detected);
+    #ifdef FRCOV
+    }
+    #endif
     {   /* determine last weight */
         U32 total = 1 << tableLog;
         U32 rest = total - weightTotal;
         U32 verif = 1 << BITv05_highbit32(rest);
         U32 lastWeight = BITv05_highbit32(rest) + 1;
-        if (verif != rest) return ERROR(corruption_detected);    /* last value must be a clean power of 2 */
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[490]) {
+          if ((verif != rest ) && !(0))
+            fprintf(stderr, "triggered bug index 490\n");
+          else
+            fprintf(stderr, "reached bug index 490\n");
+        }
+        if ((!FIXREVERTER[490] && (verif != rest ))
+        #else
+        if (0
+        #endif
+        ) return ERROR(corruption_detected);
+        #ifdef FRCOV
+        }
+        #endif    /* last value must be a clean power of 2 */
         huffWeight[oSize] = (BYTE)lastWeight;
         rankStats[lastWeight]++;
     }
@@ -1965,7 +2179,22 @@ size_t HUFv05_decompress1X2_usingDTable(
     const HUFv05_DEltX2* const dt = ((const HUFv05_DEltX2*)dtPtr)+1;
     BITv05_DStream_t bitD;
 
-    if (dstSize <= cSrcSize) return ERROR(dstSize_tooSmall);
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[493]) {
+      if ((dstSize <= cSrcSize ) && !(0))
+        fprintf(stderr, "triggered bug index 493\n");
+      else
+        fprintf(stderr, "reached bug index 493\n");
+    }
+    if ((!FIXREVERTER[493] && (dstSize <= cSrcSize ))
+    #else
+    if (0
+    #endif
+    ) return ERROR(dstSize_tooSmall);
+    #ifdef FRCOV
+    }
+    #endif
     { size_t const errorCode = BITv05_initDStream(&bitD, cSrc, cSrcSize);
       if (HUFv05_isError(errorCode)) return errorCode; }
 
@@ -1985,7 +2214,22 @@ size_t HUFv05_decompress1X2 (void* dst, size_t dstSize, const void* cSrc, size_t
 
     errorCode = HUFv05_readDTableX2 (DTable, cSrc, cSrcSize);
     if (HUFv05_isError(errorCode)) return errorCode;
-    if (errorCode >= cSrcSize) return ERROR(srcSize_wrong);
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[494]) {
+      if ((errorCode >= cSrcSize ) && !(0))
+        fprintf(stderr, "triggered bug index 494\n");
+      else
+        fprintf(stderr, "reached bug index 494\n");
+    }
+    if ((!FIXREVERTER[494] && (errorCode >= cSrcSize ))
+    #else
+    if (0
+    #endif
+    ) return ERROR(srcSize_wrong);
+    #ifdef FRCOV
+    }
+    #endif
     ip += errorCode;
     cSrcSize -= errorCode;
 
@@ -1999,7 +2243,22 @@ size_t HUFv05_decompress4X2_usingDTable(
     const U16* DTable)
 {
     /* Check */
-    if (cSrcSize < 10) return ERROR(corruption_detected);   /* strict minimum : jump table + 1 byte per stream */
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[495]) {
+      if ((cSrcSize < 10 ) && !(0))
+        fprintf(stderr, "triggered bug index 495\n");
+      else
+        fprintf(stderr, "reached bug index 495\n");
+    }
+    if ((!FIXREVERTER[495] && (cSrcSize < 10 ))
+    #else
+    if (0
+    #endif
+    ) return ERROR(corruption_detected);
+    #ifdef FRCOV
+    }
+    #endif   /* strict minimum : jump table + 1 byte per stream */
     {
         const BYTE* const istart = (const BYTE*) cSrc;
         BYTE* const ostart = (BYTE*) dst;
@@ -2033,7 +2292,22 @@ size_t HUFv05_decompress4X2_usingDTable(
         U32 endSignal;
 
         length4 = cSrcSize - (length1 + length2 + length3 + 6);
-        if (length4 > cSrcSize) return ERROR(corruption_detected);   /* overflow */
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[496]) {
+          if ((length4 > cSrcSize ) && !(0))
+            fprintf(stderr, "triggered bug index 496\n");
+          else
+            fprintf(stderr, "reached bug index 496\n");
+        }
+        if ((!FIXREVERTER[496] && (length4 > cSrcSize ))
+        #else
+        if (0
+        #endif
+        ) return ERROR(corruption_detected);
+        #ifdef FRCOV
+        }
+        #endif   /* overflow */
         errorCode = BITv05_initDStream(&bitD1, istart1, length1);
         if (HUFv05_isError(errorCode)) return errorCode;
         errorCode = BITv05_initDStream(&bitD2, istart2, length2);
@@ -2095,7 +2369,22 @@ size_t HUFv05_decompress4X2 (void* dst, size_t dstSize, const void* cSrc, size_t
 
     errorCode = HUFv05_readDTableX2 (DTable, cSrc, cSrcSize);
     if (HUFv05_isError(errorCode)) return errorCode;
-    if (errorCode >= cSrcSize) return ERROR(srcSize_wrong);
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[497]) {
+      if ((errorCode >= cSrcSize ) && !(0))
+        fprintf(stderr, "triggered bug index 497\n");
+      else
+        fprintf(stderr, "reached bug index 497\n");
+    }
+    if ((!FIXREVERTER[497] && (errorCode >= cSrcSize ))
+    #else
+    if (0
+    #endif
+    ) return ERROR(srcSize_wrong);
+    #ifdef FRCOV
+    }
+    #endif
     ip += errorCode;
     cSrcSize -= errorCode;
 
@@ -2380,7 +2669,22 @@ size_t HUFv05_decompress4X4_usingDTable(
     const void* cSrc, size_t cSrcSize,
     const unsigned* DTable)
 {
-    if (cSrcSize < 10) return ERROR(corruption_detected);   /* strict minimum : jump table + 1 byte per stream */
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[509]) {
+      if ((cSrcSize < 10 ) && !(0))
+        fprintf(stderr, "triggered bug index 509\n");
+      else
+        fprintf(stderr, "reached bug index 509\n");
+    }
+    if ((!FIXREVERTER[509] && (cSrcSize < 10 ))
+    #else
+    if (0
+    #endif
+    ) return ERROR(corruption_detected);
+    #ifdef FRCOV
+    }
+    #endif   /* strict minimum : jump table + 1 byte per stream */
 
     {
         const BYTE* const istart = (const BYTE*) cSrc;
@@ -2477,7 +2781,22 @@ size_t HUFv05_decompress4X4 (void* dst, size_t dstSize, const void* cSrc, size_t
 
     size_t hSize = HUFv05_readDTableX4 (DTable, cSrc, cSrcSize);
     if (HUFv05_isError(hSize)) return hSize;
-    if (hSize >= cSrcSize) return ERROR(srcSize_wrong);
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[511]) {
+      if ((hSize >= cSrcSize ) && !(0))
+        fprintf(stderr, "triggered bug index 511\n");
+      else
+        fprintf(stderr, "reached bug index 511\n");
+    }
+    if ((!FIXREVERTER[511] && (hSize >= cSrcSize ))
+    #else
+    if (0
+    #endif
+    ) return ERROR(srcSize_wrong);
+    #ifdef FRCOV
+    }
+    #endif
     ip += hSize;
     cSrcSize -= hSize;
 
@@ -2526,7 +2845,22 @@ size_t HUFv05_decompress (void* dst, size_t dstSize, const void* cSrc, size_t cS
     /* validation checks */
     if (dstSize == 0) return ERROR(dstSize_tooSmall);
     if (cSrcSize >= dstSize) return ERROR(corruption_detected);   /* invalid, or not compressed, but not compressed already dealt with */
-    if (cSrcSize == 1) { memset(dst, *(const BYTE*)cSrc, dstSize); return dstSize; }   /* RLE */
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[516]) {
+      if ((cSrcSize == 1 ) && !(0))
+        fprintf(stderr, "triggered bug index 516\n");
+      else
+        fprintf(stderr, "reached bug index 516\n");
+    }
+    if ((!FIXREVERTER[516] && (cSrcSize == 1 ))
+    #else
+    if (0
+    #endif
+    ) { memset(dst, *(const BYTE*)cSrc, dstSize); return dstSize; }
+    #ifdef FRCOV
+    }
+    #endif   /* RLE */
 
     /* decoder timing evaluation */
     Q = (U32)(cSrcSize * 16 / dstSize);   /* Q < 16 since dstSize > cSrcSize */
@@ -2681,7 +3015,22 @@ size_t ZSTDv05_decompressBegin(ZSTDv05_DCtx* dctx)
 ZSTDv05_DCtx* ZSTDv05_createDCtx(void)
 {
     ZSTDv05_DCtx* dctx = (ZSTDv05_DCtx*)malloc(sizeof(ZSTDv05_DCtx));
-    if (dctx==NULL) return NULL;
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[518]) {
+      if ((dctx == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 518\n");
+      else
+        fprintf(stderr, "reached bug index 518\n");
+    }
+    if ((!FIXREVERTER[518] && (dctx == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) return NULL;
+    #ifdef FRCOV
+    }
+    #endif
     ZSTDv05_decompressBegin(dctx);
     return dctx;
 }
@@ -2819,8 +3168,23 @@ size_t ZSTDv05_getFrameParams(ZSTDv05_parameters* params, const void* src, size_
 static size_t ZSTDv05_decodeFrameHeader_Part2(ZSTDv05_DCtx* zc, const void* src, size_t srcSize)
 {
     size_t result;
-    if (srcSize != zc->headerSize)
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[521]) {
+      if ((srcSize != zc -> headerSize ) && !(0))
+        fprintf(stderr, "triggered bug index 521\n");
+      else
+        fprintf(stderr, "reached bug index 521\n");
+    }
+    if ((!FIXREVERTER[521] && (srcSize != zc -> headerSize ))
+    #else
+    if (0
+    #endif
+    )
         return ERROR(srcSize_wrong);
+        #ifdef FRCOV
+        }
+        #endif
     result = ZSTDv05_getFrameParams(&(zc->params), src, srcSize);
     if ((MEM_32bits()) && (zc->params.windowLog > 25)) return ERROR(frameParameter_unsupported);
     return result;
@@ -2897,7 +3261,22 @@ static size_t ZSTDv05_decodeLiteralsBlock(ZSTDv05_DCtx* dctx,
                 break;
             }
             if (litSize > BLOCKSIZE) return ERROR(corruption_detected);
-            if (litCSize + lhSize > srcSize) return ERROR(corruption_detected);
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[527]) {
+              if ((litCSize + lhSize > srcSize ) && !(0))
+                fprintf(stderr, "triggered bug index 527\n");
+              else
+                fprintf(stderr, "reached bug index 527\n");
+            }
+            if ((!FIXREVERTER[527] && (litCSize + lhSize > srcSize ))
+            #else
+            if (0
+            #endif
+            ) return ERROR(corruption_detected);
+            #ifdef FRCOV
+            }
+            #endif
 
             if (HUFv05_isError(singleStream ?
                             HUFv05_decompress1X2(dctx->litBuffer, litSize, istart+lhSize, litCSize) :
@@ -2914,8 +3293,23 @@ static size_t ZSTDv05_decodeLiteralsBlock(ZSTDv05_DCtx* dctx,
             size_t errorCode;
             size_t litSize, litCSize;
             U32 lhSize = ((istart[0]) >> 4) & 3;
-            if (lhSize != 1)  /* only case supported for now : small litSize, single stream */
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[528]) {
+              if ((lhSize != 1 ) && !(0))
+                fprintf(stderr, "triggered bug index 528\n");
+              else
+                fprintf(stderr, "reached bug index 528\n");
+            }
+            if ((!FIXREVERTER[528] && (lhSize != 1 ))
+            #else
+            if (0
+            #endif
+            )  /* only case supported for now : small litSize, single stream */
                 return ERROR(corruption_detected);
+                #ifdef FRCOV
+                }
+                #endif
             if (!dctx->flagStaticTables)
                 return ERROR(dictionary_corrupted);
 
@@ -2923,7 +3317,22 @@ static size_t ZSTDv05_decodeLiteralsBlock(ZSTDv05_DCtx* dctx,
             lhSize=3;
             litSize  = ((istart[0] & 15) << 6) + (istart[1] >> 2);
             litCSize = ((istart[1] &  3) << 8) + istart[2];
-            if (litCSize + lhSize > srcSize) return ERROR(corruption_detected);
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[529]) {
+              if ((litCSize + lhSize > srcSize ) && !(0))
+                fprintf(stderr, "triggered bug index 529\n");
+              else
+                fprintf(stderr, "reached bug index 529\n");
+            }
+            if ((!FIXREVERTER[529] && (litCSize + lhSize > srcSize ))
+            #else
+            if (0
+            #endif
+            ) return ERROR(corruption_detected);
+            #ifdef FRCOV
+            }
+            #endif
 
             errorCode = HUFv05_decompress1X4_usingDTable(dctx->litBuffer, litSize, istart+lhSize, litCSize, dctx->hufTableX4);
             if (HUFv05_isError(errorCode)) return ERROR(corruption_detected);
@@ -2952,7 +3361,22 @@ static size_t ZSTDv05_decodeLiteralsBlock(ZSTDv05_DCtx* dctx,
             }
 
             if (lhSize+litSize+WILDCOPY_OVERLENGTH > srcSize) {  /* risk reading beyond src buffer with wildcopy */
-                if (litSize+lhSize > srcSize) return ERROR(corruption_detected);
+                
+                #ifdef FRCOV
+                {if (FIXREVERTER[530]) {
+                  if ((litSize + lhSize > srcSize ) && !(0))
+                    fprintf(stderr, "triggered bug index 530\n");
+                  else
+                    fprintf(stderr, "reached bug index 530\n");
+                }
+                if ((!FIXREVERTER[530] && (litSize + lhSize > srcSize ))
+                #else
+                if (0
+                #endif
+                ) return ERROR(corruption_detected);
+                #ifdef FRCOV
+                }
+                #endif
                 memcpy(dctx->litBuffer, istart+lhSize, litSize);
                 dctx->litPtr = dctx->litBuffer;
                 dctx->litSize = litSize;
@@ -3006,8 +3430,23 @@ static size_t ZSTDv05_decodeSeqHeaders(int* nbSeq, const BYTE** dumpsPtr, size_t
     size_t dumpsLength;
 
     /* check */
-    if (srcSize < MIN_SEQUENCES_SIZE)
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[532]) {
+      if ((srcSize < 1 ) && !(0))
+        fprintf(stderr, "triggered bug index 532\n");
+      else
+        fprintf(stderr, "reached bug index 532\n");
+    }
+    if ((!FIXREVERTER[532] && (srcSize < 1 ))
+    #else
+    if (0
+    #endif
+    )
         return ERROR(srcSize_wrong);
+        #ifdef FRCOV
+        }
+        #endif
 
     /* SeqHead */
     *nbSeq = *ip++;
@@ -3063,7 +3502,22 @@ static size_t ZSTDv05_decodeSeqHeaders(int* nbSeq, const BYTE** dumpsPtr, size_t
             {   unsigned max = MaxLL;
                 headerSize = FSEv05_readNCount(norm, &max, &LLlog, ip, iend-ip);
                 if (FSEv05_isError(headerSize)) return ERROR(GENERIC);
-                if (LLlog > LLFSEv05Log) return ERROR(corruption_detected);
+                
+                #ifdef FRCOV
+                {if (FIXREVERTER[534]) {
+                  if ((LLlog > 10 ) && !(0))
+                    fprintf(stderr, "triggered bug index 534\n");
+                  else
+                    fprintf(stderr, "reached bug index 534\n");
+                }
+                if ((!FIXREVERTER[534] && (LLlog > 10 ))
+                #else
+                if (0
+                #endif
+                ) return ERROR(corruption_detected);
+                #ifdef FRCOV
+                }
+                #endif
                 ip += headerSize;
                 FSEv05_buildDTable(DTableLL, norm, max, LLlog);
         }   }
@@ -3087,7 +3541,22 @@ static size_t ZSTDv05_decodeSeqHeaders(int* nbSeq, const BYTE** dumpsPtr, size_t
             {   unsigned max = MaxOff;
                 headerSize = FSEv05_readNCount(norm, &max, &Offlog, ip, iend-ip);
                 if (FSEv05_isError(headerSize)) return ERROR(GENERIC);
-                if (Offlog > OffFSEv05Log) return ERROR(corruption_detected);
+                
+                #ifdef FRCOV
+                {if (FIXREVERTER[535]) {
+                  if ((Offlog > 9 ) && !(0))
+                    fprintf(stderr, "triggered bug index 535\n");
+                  else
+                    fprintf(stderr, "reached bug index 535\n");
+                }
+                if ((!FIXREVERTER[535] && (Offlog > 9 ))
+                #else
+                if (0
+                #endif
+                ) return ERROR(corruption_detected);
+                #ifdef FRCOV
+                }
+                #endif
                 ip += headerSize;
                 FSEv05_buildDTable(DTableOffb, norm, max, Offlog);
         }   }
@@ -3111,7 +3580,22 @@ static size_t ZSTDv05_decodeSeqHeaders(int* nbSeq, const BYTE** dumpsPtr, size_t
             {   unsigned max = MaxML;
                 headerSize = FSEv05_readNCount(norm, &max, &MLlog, ip, iend-ip);
                 if (FSEv05_isError(headerSize)) return ERROR(GENERIC);
-                if (MLlog > MLFSEv05Log) return ERROR(corruption_detected);
+                
+                #ifdef FRCOV
+                {if (FIXREVERTER[536]) {
+                  if ((MLlog > 10 ) && !(0))
+                    fprintf(stderr, "triggered bug index 536\n");
+                  else
+                    fprintf(stderr, "reached bug index 536\n");
+                }
+                if ((!FIXREVERTER[536] && (MLlog > 10 ))
+                #else
+                if (0
+                #endif
+                ) return ERROR(corruption_detected);
+                #ifdef FRCOV
+                }
+                #endif
                 ip += headerSize;
                 FSEv05_buildDTable(DTableML, norm, max, MLlog);
     }   }   }
@@ -3170,10 +3654,40 @@ static void ZSTDv05_decodeSequence(seq_t* seq, seqState_t* seqState)
                 524288, 1048576, 2097152, 4194304, 8388608, 16777216, 33554432, /*fake*/ 1, 1, 1, 1, 1 };
         U32 offsetCode = FSEv05_peakSymbol(&(seqState->stateOffb));   /* <= maxOff, by table construction */
         U32 nbBits = offsetCode - 1;
-        if (offsetCode==0) nbBits = 0;   /* cmove */
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[538]) {
+          if ((offsetCode == 0 ) && !(0))
+            fprintf(stderr, "triggered bug index 538\n");
+          else
+            fprintf(stderr, "reached bug index 538\n");
+        }
+        if ((!FIXREVERTER[538] && (offsetCode == 0 ))
+        #else
+        if (0
+        #endif
+        ) nbBits = 0;
+        #ifdef FRCOV
+        }
+        #endif   /* cmove */
         offset = offsetPrefix[offsetCode] + BITv05_readBits(&(seqState->DStream), nbBits);
         if (MEM_32bits()) BITv05_reloadDStream(&(seqState->DStream));
-        if (offsetCode==0) offset = prevOffset;   /* repcode, cmove */
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[539]) {
+          if ((offsetCode == 0 ) && !(0))
+            fprintf(stderr, "triggered bug index 539\n");
+          else
+            fprintf(stderr, "reached bug index 539\n");
+        }
+        if ((!FIXREVERTER[539] && (offsetCode == 0 ))
+        #else
+        if (0
+        #endif
+        ) offset = prevOffset;
+        #ifdef FRCOV
+        }
+        #endif   /* repcode, cmove */
         if (offsetCode | !litLength) seqState->prevOffset = seq->offset;   /* cmove */
         FSEv05_decodeSymbol(&(seqState->stateOffb), &(seqState->DStream));    /* update */
     }
@@ -3438,7 +3952,22 @@ static size_t ZSTDv05_decompress_continueDCtx(ZSTDv05_DCtx* dctx,
 
         ip += ZSTDv05_blockHeaderSize;
         remainingSize -= ZSTDv05_blockHeaderSize;
-        if (cBlockSize > remainingSize) return ERROR(srcSize_wrong);
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[543]) {
+          if ((cBlockSize > remainingSize ) && !(0))
+            fprintf(stderr, "triggered bug index 543\n");
+          else
+            fprintf(stderr, "reached bug index 543\n");
+        }
+        if ((!FIXREVERTER[543] && (cBlockSize > remainingSize ))
+        #else
+        if (0
+        #endif
+        ) return ERROR(srcSize_wrong);
+        #ifdef FRCOV
+        }
+        #endif
 
         switch(blockProperties.blockType)
         {
@@ -3458,7 +3987,22 @@ static size_t ZSTDv05_decompress_continueDCtx(ZSTDv05_DCtx* dctx,
         default:
             return ERROR(GENERIC);   /* impossible */
         }
-        if (cBlockSize == 0) break;   /* bt_end */
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[544]) {
+          if ((cBlockSize == 0 ) && !(0))
+            fprintf(stderr, "triggered bug index 544\n");
+          else
+            fprintf(stderr, "reached bug index 544\n");
+        }
+        if ((!FIXREVERTER[544] && (cBlockSize == 0 ))
+        #else
+        if (0
+        #endif
+        ) break;
+        #ifdef FRCOV
+        }
+        #endif   /* bt_end */
 
         if (ZSTDv05_isError(decodedSize)) return decodedSize;
         op += decodedSize;
@@ -3548,12 +4092,42 @@ void ZSTDv05_findFrameSizeInfoLegacy(const void *src, size_t srcSize, size_t* cS
 
         ip += ZSTDv05_blockHeaderSize;
         remainingSize -= ZSTDv05_blockHeaderSize;
-        if (cBlockSize > remainingSize) {
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[546]) {
+          if ((cBlockSize > remainingSize ) && !(0))
+            fprintf(stderr, "triggered bug index 546\n");
+          else
+            fprintf(stderr, "reached bug index 546\n");
+        }
+        if ((!FIXREVERTER[546] && (cBlockSize > remainingSize ))
+        #else
+        if (0
+        #endif
+        ) {
             ZSTD_errorFrameSizeInfoLegacy(cSize, dBound, ERROR(srcSize_wrong));
             return;
         }
-
-        if (cBlockSize == 0) break;   /* bt_end */
+        #ifdef FRCOV
+        }
+        #endif
+
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[547]) {
+          if ((cBlockSize == 0 ) && !(0))
+            fprintf(stderr, "triggered bug index 547\n");
+          else
+            fprintf(stderr, "reached bug index 547\n");
+        }
+        if ((!FIXREVERTER[547] && (cBlockSize == 0 ))
+        #else
+        if (0
+        #endif
+        ) break;
+        #ifdef FRCOV
+        }
+        #endif   /* bt_end */
 
         ip += cBlockSize;
         remainingSize -= cBlockSize;
@@ -3575,7 +4149,22 @@ size_t ZSTDv05_nextSrcSizeToDecompress(ZSTDv05_DCtx* dctx)
 size_t ZSTDv05_decompressContinue(ZSTDv05_DCtx* dctx, void* dst, size_t maxDstSize, const void* src, size_t srcSize)
 {
     /* Sanity check */
-    if (srcSize != dctx->expected) return ERROR(srcSize_wrong);
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[548]) {
+      if ((srcSize != dctx -> expected ) && !(0))
+        fprintf(stderr, "triggered bug index 548\n");
+      else
+        fprintf(stderr, "reached bug index 548\n");
+    }
+    if ((!FIXREVERTER[548] && (srcSize != dctx -> expected ))
+    #else
+    if (0
+    #endif
+    ) return ERROR(srcSize_wrong);
+    #ifdef FRCOV
+    }
+    #endif
     ZSTDv05_checkContinuity(dctx, dst);
 
     /* Decompress : frame header; part 1 */
@@ -3672,7 +4261,22 @@ static size_t ZSTDv05_loadEntropy(ZSTDv05_DCtx* dctx, const void* dict, size_t d
 
     offcodeHeaderSize = FSEv05_readNCount(offcodeNCount, &offcodeMaxValue, &offcodeLog, dict, dictSize);
     if (FSEv05_isError(offcodeHeaderSize)) return ERROR(dictionary_corrupted);
-    if (offcodeLog > OffFSEv05Log) return ERROR(dictionary_corrupted);
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[552]) {
+      if ((offcodeLog > 9 ) && !(0))
+        fprintf(stderr, "triggered bug index 552\n");
+      else
+        fprintf(stderr, "reached bug index 552\n");
+    }
+    if ((!FIXREVERTER[552] && (offcodeLog > 9 ))
+    #else
+    if (0
+    #endif
+    ) return ERROR(dictionary_corrupted);
+    #ifdef FRCOV
+    }
+    #endif
     errorCode = FSEv05_buildDTable(dctx->OffTable, offcodeNCount, offcodeMaxValue, offcodeLog);
     if (FSEv05_isError(errorCode)) return ERROR(dictionary_corrupted);
     dict = (const char*)dict + offcodeHeaderSize;
@@ -3680,14 +4284,44 @@ static size_t ZSTDv05_loadEntropy(ZSTDv05_DCtx* dctx, const void* dict, size_t d
 
     matchlengthHeaderSize = FSEv05_readNCount(matchlengthNCount, &matchlengthMaxValue, &matchlengthLog, dict, dictSize);
     if (FSEv05_isError(matchlengthHeaderSize)) return ERROR(dictionary_corrupted);
-    if (matchlengthLog > MLFSEv05Log) return ERROR(dictionary_corrupted);
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[553]) {
+      if ((matchlengthLog > 10 ) && !(0))
+        fprintf(stderr, "triggered bug index 553\n");
+      else
+        fprintf(stderr, "reached bug index 553\n");
+    }
+    if ((!FIXREVERTER[553] && (matchlengthLog > 10 ))
+    #else
+    if (0
+    #endif
+    ) return ERROR(dictionary_corrupted);
+    #ifdef FRCOV
+    }
+    #endif
     errorCode = FSEv05_buildDTable(dctx->MLTable, matchlengthNCount, matchlengthMaxValue, matchlengthLog);
     if (FSEv05_isError(errorCode)) return ERROR(dictionary_corrupted);
     dict = (const char*)dict + matchlengthHeaderSize;
     dictSize -= matchlengthHeaderSize;
 
     litlengthHeaderSize = FSEv05_readNCount(litlengthNCount, &litlengthMaxValue, &litlengthLog, dict, dictSize);
-    if (litlengthLog > LLFSEv05Log) return ERROR(dictionary_corrupted);
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[554]) {
+      if ((litlengthLog > 10 ) && !(0))
+        fprintf(stderr, "triggered bug index 554\n");
+      else
+        fprintf(stderr, "reached bug index 554\n");
+    }
+    if ((!FIXREVERTER[554] && (litlengthLog > 10 ))
+    #else
+    if (0
+    #endif
+    ) return ERROR(dictionary_corrupted);
+    #ifdef FRCOV
+    }
+    #endif
     if (FSEv05_isError(litlengthHeaderSize)) return ERROR(dictionary_corrupted);
     errorCode = FSEv05_buildDTable(dctx->LLTable, litlengthNCount, litlengthMaxValue, litlengthLog);
     if (FSEv05_isError(errorCode)) return ERROR(dictionary_corrupted);
@@ -3839,7 +4473,22 @@ struct ZBUFFv05_DCtx_s {
 ZBUFFv05_DCtx* ZBUFFv05_createDCtx(void)
 {
     ZBUFFv05_DCtx* zbc = (ZBUFFv05_DCtx*)malloc(sizeof(ZBUFFv05_DCtx));
-    if (zbc==NULL) return NULL;
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[557]) {
+      if ((zbc == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 557\n");
+      else
+        fprintf(stderr, "reached bug index 557\n");
+    }
+    if ((!FIXREVERTER[557] && (zbc == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) return NULL;
+    #ifdef FRCOV
+    }
+    #endif
     memset(zbc, 0, sizeof(*zbc));
     zbc->zc = ZSTDv05_createDCtx();
     zbc->stage = ZBUFFv05ds_init;
@@ -3848,7 +4497,22 @@ ZBUFFv05_DCtx* ZBUFFv05_createDCtx(void)
 
 size_t ZBUFFv05_freeDCtx(ZBUFFv05_DCtx* zbc)
 {
-    if (zbc==NULL) return 0;   /* support free on null */
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[558]) {
+      if ((zbc == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 558\n");
+      else
+        fprintf(stderr, "reached bug index 558\n");
+    }
+    if ((!FIXREVERTER[558] && (zbc == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) return 0;
+    #ifdef FRCOV
+    }
+    #endif   /* support free on null */
     ZSTDv05_freeDCtx(zbc->zc);
     free(zbc->inBuff);
     free(zbc->outBuff);
@@ -3934,13 +4598,43 @@ size_t ZBUFFv05_decompressContinue(ZBUFFv05_DCtx* zbc, void* dst, size_t* maxDst
                         free(zbc->inBuff);
                         zbc->inBuffSize = neededInSize;
                         zbc->inBuff = (char*)malloc(neededInSize);
-                        if (zbc->inBuff == NULL) return ERROR(memory_allocation);
+                        
+                        #ifdef FRCOV
+                        {if (FIXREVERTER[559]) {
+                          if ((zbc -> inBuff == (void *) 0 ) && !(0))
+                            fprintf(stderr, "triggered bug index 559\n");
+                          else
+                            fprintf(stderr, "reached bug index 559\n");
+                        }
+                        if ((!FIXREVERTER[559] && (zbc -> inBuff == (void *) 0 ))
+                        #else
+                        if (0
+                        #endif
+                        ) return ERROR(memory_allocation);
+                        #ifdef FRCOV
+                        }
+                        #endif
                     }
                     if (zbc->outBuffSize < neededOutSize) {
                         free(zbc->outBuff);
                         zbc->outBuffSize = neededOutSize;
                         zbc->outBuff = (char*)malloc(neededOutSize);
-                        if (zbc->outBuff == NULL) return ERROR(memory_allocation);
+                        
+                        #ifdef FRCOV
+                        {if (FIXREVERTER[560]) {
+                          if ((zbc -> outBuff == (void *) 0 ) && !(0))
+                            fprintf(stderr, "triggered bug index 560\n");
+                          else
+                            fprintf(stderr, "reached bug index 560\n");
+                        }
+                        if ((!FIXREVERTER[560] && (zbc -> outBuff == (void *) 0 ))
+                        #else
+                        if (0
+                        #endif
+                        ) return ERROR(memory_allocation);
+                        #ifdef FRCOV
+                        }
+                        #endif
                 }   }
                 if (zbc->hPos) {
                     /* some data already loaded into headerBuffer : transfer into inBuff */
diff --git a/lib/legacy/zstd_v06.c b/lib/legacy/zstd_v06.c
index f907a3a..7c18ea6 100644
--- a/lib/legacy/zstd_v06.c
+++ b/lib/legacy/zstd_v06.c
@@ -1,3 +1,7 @@
+#ifdef FRCOV
+#include <stdio.h>
+extern short FIXREVERTER[];
+#endif
 /*
  * Copyright (c) 2016-present, Yann Collet, Facebook, Inc.
  * All rights reserved.
@@ -1274,7 +1278,22 @@ size_t FSEv06_readNCount (short* normalizedCounter, unsigned* maxSVPtr, unsigned
     unsigned charnum = 0;
     int previous0 = 0;
 
-    if (hbSize < 4) return ERROR(srcSize_wrong);
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[399]) {
+      if ((hbSize < 4 ) && !(0))
+        fprintf(stderr, "triggered bug index 399\n");
+      else
+        fprintf(stderr, "reached bug index 399\n");
+    }
+    if ((!FIXREVERTER[399] && (hbSize < 4 ))
+    #else
+    if (0
+    #endif
+    ) return ERROR(srcSize_wrong);
+    #ifdef FRCOV
+    }
+    #endif
     bitStream = MEM_readLE32(ip);
     nbBits = (bitStream & 0xF) + FSEv06_MIN_TABLELOG;   /* extract tableLog */
     if (nbBits > FSEv06_TABLELOG_ABSOLUTE_MAX) return ERROR(tableLog_tooLarge);
@@ -1498,7 +1517,22 @@ size_t FSEv06_buildDTable(FSEv06_DTable* dt, const short* normalizedCounter, uns
                 while (position > highThreshold) position = (position + step) & tableMask;   /* lowprob area */
         }   }
 
-        if (position!=0) return ERROR(GENERIC);   /* position must reach all cells once, otherwise normalizedCounter is incorrect */
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[406]) {
+          if ((position != 0 ) && !(0))
+            fprintf(stderr, "triggered bug index 406\n");
+          else
+            fprintf(stderr, "reached bug index 406\n");
+        }
+        if ((!FIXREVERTER[406] && (position != 0 ))
+        #else
+        if (0
+        #endif
+        ) return ERROR(GENERIC);
+        #ifdef FRCOV
+        }
+        #endif   /* position must reach all cells once, otherwise normalizedCounter is incorrect */
     }
 
     /* Build Decoding table */
@@ -1655,7 +1689,22 @@ size_t FSEv06_decompress(void* dst, size_t maxDstSize, const void* cSrc, size_t
     unsigned tableLog;
     unsigned maxSymbolValue = FSEv06_MAX_SYMBOL_VALUE;
 
-    if (cSrcSize<2) return ERROR(srcSize_wrong);   /* too small input size */
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[410]) {
+      if ((cSrcSize < 2 ) && !(0))
+        fprintf(stderr, "triggered bug index 410\n");
+      else
+        fprintf(stderr, "reached bug index 410\n");
+    }
+    if ((!FIXREVERTER[410] && (cSrcSize < 2 ))
+    #else
+    if (0
+    #endif
+    ) return ERROR(srcSize_wrong);
+    #ifdef FRCOV
+    }
+    #endif   /* too small input size */
 
     /* normal FSE decoding mode */
     {   size_t const NCountLength = FSEv06_readNCount (counting, &maxSymbolValue, &tableLog, istart, cSrcSize);
@@ -2133,7 +2182,22 @@ size_t HUFv06_decompress4X2_usingDTable(
     const U16* DTable)
 {
     /* Check */
-    if (cSrcSize < 10) return ERROR(corruption_detected);  /* strict minimum : jump table + 1 byte per stream */
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[413]) {
+      if ((cSrcSize < 10 ) && !(0))
+        fprintf(stderr, "triggered bug index 413\n");
+      else
+        fprintf(stderr, "reached bug index 413\n");
+    }
+    if ((!FIXREVERTER[413] && (cSrcSize < 10 ))
+    #else
+    if (0
+    #endif
+    ) return ERROR(corruption_detected);
+    #ifdef FRCOV
+    }
+    #endif  /* strict minimum : jump table + 1 byte per stream */
 
     {   const BYTE* const istart = (const BYTE*) cSrc;
         BYTE* const ostart = (BYTE*) dst;
@@ -2508,7 +2572,22 @@ size_t HUFv06_decompress4X4_usingDTable(
     const void* cSrc, size_t cSrcSize,
     const U32* DTable)
 {
-    if (cSrcSize < 10) return ERROR(corruption_detected);   /* strict minimum : jump table + 1 byte per stream */
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[425]) {
+      if ((cSrcSize < 10 ) && !(0))
+        fprintf(stderr, "triggered bug index 425\n");
+      else
+        fprintf(stderr, "reached bug index 425\n");
+    }
+    if ((!FIXREVERTER[425] && (cSrcSize < 10 ))
+    #else
+    if (0
+    #endif
+    ) return ERROR(corruption_detected);
+    #ifdef FRCOV
+    }
+    #endif   /* strict minimum : jump table + 1 byte per stream */
 
     {   const BYTE* const istart = (const BYTE*) cSrc;
         BYTE* const ostart = (BYTE*) dst;
@@ -2542,7 +2621,22 @@ size_t HUFv06_decompress4X4_usingDTable(
         U32 endSignal;
 
         length4 = cSrcSize - (length1 + length2 + length3 + 6);
-        if (length4 > cSrcSize) return ERROR(corruption_detected);   /* overflow */
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[426]) {
+          if ((length4 > cSrcSize ) && !(0))
+            fprintf(stderr, "triggered bug index 426\n");
+          else
+            fprintf(stderr, "reached bug index 426\n");
+        }
+        if ((!FIXREVERTER[426] && (length4 > cSrcSize ))
+        #else
+        if (0
+        #endif
+        ) return ERROR(corruption_detected);
+        #ifdef FRCOV
+        }
+        #endif   /* overflow */
         errorCode = BITv06_initDStream(&bitD1, istart1, length1);
         if (HUFv06_isError(errorCode)) return errorCode;
         errorCode = BITv06_initDStream(&bitD2, istart2, length2);
@@ -2604,7 +2698,22 @@ size_t HUFv06_decompress4X4 (void* dst, size_t dstSize, const void* cSrc, size_t
 
     size_t hSize = HUFv06_readDTableX4 (DTable, cSrc, cSrcSize);
     if (HUFv06_isError(hSize)) return hSize;
-    if (hSize >= cSrcSize) return ERROR(srcSize_wrong);
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[427]) {
+      if ((hSize >= cSrcSize ) && !(0))
+        fprintf(stderr, "triggered bug index 427\n");
+      else
+        fprintf(stderr, "reached bug index 427\n");
+    }
+    if ((!FIXREVERTER[427] && (hSize >= cSrcSize ))
+    #else
+    if (0
+    #endif
+    ) return ERROR(srcSize_wrong);
+    #ifdef FRCOV
+    }
+    #endif
     ip += hSize;
     cSrcSize -= hSize;
 
@@ -2648,10 +2757,55 @@ size_t HUFv06_decompress (void* dst, size_t dstSize, const void* cSrc, size_t cS
     U32 Dtime[3];   /* decompression time estimation */
 
     /* validation checks */
-    if (dstSize == 0) return ERROR(dstSize_tooSmall);
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[430]) {
+      if ((dstSize == 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 430\n");
+      else
+        fprintf(stderr, "reached bug index 430\n");
+    }
+    if ((!FIXREVERTER[430] && (dstSize == 0 ))
+    #else
+    if (0
+    #endif
+    ) return ERROR(dstSize_tooSmall);
+    #ifdef FRCOV
+    }
+    #endif
     if (cSrcSize > dstSize) return ERROR(corruption_detected);   /* invalid */
-    if (cSrcSize == dstSize) { memcpy(dst, cSrc, dstSize); return dstSize; }   /* not compressed */
-    if (cSrcSize == 1) { memset(dst, *(const BYTE*)cSrc, dstSize); return dstSize; }   /* RLE */
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[433]) {
+      if ((cSrcSize == dstSize ) && !(0))
+        fprintf(stderr, "triggered bug index 433\n");
+      else
+        fprintf(stderr, "reached bug index 433\n");
+    }
+    if ((!FIXREVERTER[433] && (cSrcSize == dstSize ))
+    #else
+    if (0
+    #endif
+    ) { memcpy(dst, cSrc, dstSize); return dstSize; }
+    #ifdef FRCOV
+    }
+    #endif   /* not compressed */
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[434]) {
+      if ((cSrcSize == 1 ) && !(0))
+        fprintf(stderr, "triggered bug index 434\n");
+      else
+        fprintf(stderr, "reached bug index 434\n");
+    }
+    if ((!FIXREVERTER[434] && (cSrcSize == 1 ))
+    #else
+    if (0
+    #endif
+    ) { memset(dst, *(const BYTE*)cSrc, dstSize); return dstSize; }
+    #ifdef FRCOV
+    }
+    #endif   /* RLE */
 
     /* decoder timing evaluation */
     {   U32 const Q = (U32)(cSrcSize * 16 / dstSize);   /* Q < 16 since dstSize > cSrcSize */
@@ -2842,7 +2996,22 @@ size_t ZSTDv06_decompressBegin(ZSTDv06_DCtx* dctx)
 ZSTDv06_DCtx* ZSTDv06_createDCtx(void)
 {
     ZSTDv06_DCtx* dctx = (ZSTDv06_DCtx*)malloc(sizeof(ZSTDv06_DCtx));
-    if (dctx==NULL) return NULL;
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[436]) {
+      if ((dctx == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 436\n");
+      else
+        fprintf(stderr, "reached bug index 436\n");
+    }
+    if ((!FIXREVERTER[436] && (dctx == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) return NULL;
+    #ifdef FRCOV
+    }
+    #endif
     ZSTDv06_decompressBegin(dctx);
     return dctx;
 }
@@ -3043,7 +3212,22 @@ static size_t ZSTDv06_getcBlockSize(const void* src, size_t srcSize, blockProper
 static size_t ZSTDv06_copyRawBlock(void* dst, size_t dstCapacity, const void* src, size_t srcSize)
 {
     if (dst==NULL) return ERROR(dstSize_tooSmall);
-    if (srcSize > dstCapacity) return ERROR(dstSize_tooSmall);
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[438]) {
+      if ((srcSize > dstCapacity ) && !(0))
+        fprintf(stderr, "triggered bug index 438\n");
+      else
+        fprintf(stderr, "reached bug index 438\n");
+    }
+    if ((!FIXREVERTER[438] && (srcSize > dstCapacity ))
+    #else
+    if (0
+    #endif
+    ) return ERROR(dstSize_tooSmall);
+    #ifdef FRCOV
+    }
+    #endif
     memcpy(dst, src, srcSize);
     return srcSize;
 }
@@ -3087,7 +3271,22 @@ static size_t ZSTDv06_decodeLiteralsBlock(ZSTDv06_DCtx* dctx,
                 litCSize = ((istart[2] &  3) << 16) + (istart[3] << 8) + istart[4];
                 break;
             }
-            if (litSize > ZSTDv06_BLOCKSIZE_MAX) return ERROR(corruption_detected);
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[441]) {
+              if ((litSize > 128 * 1024 ) && !(0))
+                fprintf(stderr, "triggered bug index 441\n");
+              else
+                fprintf(stderr, "reached bug index 441\n");
+            }
+            if ((!FIXREVERTER[441] && (litSize > 128 * 1024 ))
+            #else
+            if (0
+            #endif
+            ) return ERROR(corruption_detected);
+            #ifdef FRCOV
+            }
+            #endif
             if (litCSize + lhSize > srcSize) return ERROR(corruption_detected);
 
             if (HUFv06_isError(singleStream ?
@@ -3103,8 +3302,23 @@ static size_t ZSTDv06_decodeLiteralsBlock(ZSTDv06_DCtx* dctx,
     case IS_PCH:
         {   size_t litSize, litCSize;
             U32 lhSize = ((istart[0]) >> 4) & 3;
-            if (lhSize != 1)  /* only case supported for now : small litSize, single stream */
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[443]) {
+              if ((lhSize != 1 ) && !(0))
+                fprintf(stderr, "triggered bug index 443\n");
+              else
+                fprintf(stderr, "reached bug index 443\n");
+            }
+            if ((!FIXREVERTER[443] && (lhSize != 1 ))
+            #else
+            if (0
+            #endif
+            )  /* only case supported for now : small litSize, single stream */
                 return ERROR(corruption_detected);
+                #ifdef FRCOV
+                }
+                #endif
             if (!dctx->flagRepeatTable)
                 return ERROR(dictionary_corrupted);
 
@@ -3112,7 +3326,22 @@ static size_t ZSTDv06_decodeLiteralsBlock(ZSTDv06_DCtx* dctx,
             lhSize=3;
             litSize  = ((istart[0] & 15) << 6) + (istart[1] >> 2);
             litCSize = ((istart[1] &  3) << 8) + istart[2];
-            if (litCSize + lhSize > srcSize) return ERROR(corruption_detected);
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[444]) {
+              if ((litCSize + lhSize > srcSize ) && !(0))
+                fprintf(stderr, "triggered bug index 444\n");
+              else
+                fprintf(stderr, "reached bug index 444\n");
+            }
+            if ((!FIXREVERTER[444] && (litCSize + lhSize > srcSize ))
+            #else
+            if (0
+            #endif
+            ) return ERROR(corruption_detected);
+            #ifdef FRCOV
+            }
+            #endif
 
             {   size_t const errorCode = HUFv06_decompress1X4_usingDTable(dctx->litBuffer, litSize, istart+lhSize, litCSize, dctx->hufTableX4);
                 if (HUFv06_isError(errorCode)) return ERROR(corruption_detected);
@@ -3140,7 +3369,22 @@ static size_t ZSTDv06_decodeLiteralsBlock(ZSTDv06_DCtx* dctx,
             }
 
             if (lhSize+litSize+WILDCOPY_OVERLENGTH > srcSize) {  /* risk reading beyond src buffer with wildcopy */
-                if (litSize+lhSize > srcSize) return ERROR(corruption_detected);
+                
+                #ifdef FRCOV
+                {if (FIXREVERTER[445]) {
+                  if ((litSize + lhSize > srcSize ) && !(0))
+                    fprintf(stderr, "triggered bug index 445\n");
+                  else
+                    fprintf(stderr, "reached bug index 445\n");
+                }
+                if ((!FIXREVERTER[445] && (litSize + lhSize > srcSize ))
+                #else
+                if (0
+                #endif
+                ) return ERROR(corruption_detected);
+                #ifdef FRCOV
+                }
+                #endif
                 memcpy(dctx->litBuffer, istart+lhSize, litSize);
                 dctx->litPtr = dctx->litBuffer;
                 dctx->litSize = litSize;
@@ -3224,7 +3468,22 @@ static size_t ZSTDv06_decodeSeqHeaders(int* nbSeqPtr,
     const BYTE* ip = istart;
 
     /* check */
-    if (srcSize < MIN_SEQUENCES_SIZE) return ERROR(srcSize_wrong);
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[450]) {
+      if ((srcSize < 1 ) && !(0))
+        fprintf(stderr, "triggered bug index 450\n");
+      else
+        fprintf(stderr, "reached bug index 450\n");
+    }
+    if ((!FIXREVERTER[450] && (srcSize < 1 ))
+    #else
+    if (0
+    #endif
+    ) return ERROR(srcSize_wrong);
+    #ifdef FRCOV
+    }
+    #endif
 
     /* SeqHead */
     {   int nbSeq = *ip++;
@@ -3526,7 +3785,22 @@ static size_t ZSTDv06_decompressBlock_internal(ZSTDv06_DCtx* dctx,
 {   /* blockType == blockCompressed */
     const BYTE* ip = (const BYTE*)src;
 
-    if (srcSize >= ZSTDv06_BLOCKSIZE_MAX) return ERROR(srcSize_wrong);
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[456]) {
+      if ((srcSize >= 128 * 1024 ) && !(0))
+        fprintf(stderr, "triggered bug index 456\n");
+      else
+        fprintf(stderr, "reached bug index 456\n");
+    }
+    if ((!FIXREVERTER[456] && (srcSize >= 128 * 1024 ))
+    #else
+    if (0
+    #endif
+    ) return ERROR(srcSize_wrong);
+    #ifdef FRCOV
+    }
+    #endif
 
     /* Decode literals sub-block */
     {   size_t const litCSize = ZSTDv06_decodeLiteralsBlock(dctx, src, srcSize);
@@ -3723,7 +3997,22 @@ size_t ZSTDv06_nextSrcSizeToDecompress(ZSTDv06_DCtx* dctx)
 size_t ZSTDv06_decompressContinue(ZSTDv06_DCtx* dctx, void* dst, size_t dstCapacity, const void* src, size_t srcSize)
 {
     /* Sanity check */
-    if (srcSize != dctx->expected) return ERROR(srcSize_wrong);
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[458]) {
+      if ((srcSize != dctx -> expected ) && !(0))
+        fprintf(stderr, "triggered bug index 458\n");
+      else
+        fprintf(stderr, "reached bug index 458\n");
+    }
+    if ((!FIXREVERTER[458] && (srcSize != dctx -> expected ))
+    #else
+    if (0
+    #endif
+    ) return ERROR(srcSize_wrong);
+    #ifdef FRCOV
+    }
+    #endif
     if (dstCapacity) ZSTDv06_checkContinuity(dctx, dst);
 
     /* Decompress : frame header; part 1 */
@@ -3815,7 +4104,22 @@ static size_t ZSTDv06_loadEntropy(ZSTDv06_DCtx* dctx, const void* dict, size_t d
         U32 offcodeMaxValue=MaxOff, offcodeLog;
         offcodeHeaderSize = FSEv06_readNCount(offcodeNCount, &offcodeMaxValue, &offcodeLog, dict, dictSize);
         if (FSEv06_isError(offcodeHeaderSize)) return ERROR(dictionary_corrupted);
-        if (offcodeLog > OffFSELog) return ERROR(dictionary_corrupted);
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[460]) {
+          if ((offcodeLog > 8 ) && !(0))
+            fprintf(stderr, "triggered bug index 460\n");
+          else
+            fprintf(stderr, "reached bug index 460\n");
+        }
+        if ((!FIXREVERTER[460] && (offcodeLog > 8 ))
+        #else
+        if (0
+        #endif
+        ) return ERROR(dictionary_corrupted);
+        #ifdef FRCOV
+        }
+        #endif
         { size_t const errorCode = FSEv06_buildDTable(dctx->OffTable, offcodeNCount, offcodeMaxValue, offcodeLog);
           if (FSEv06_isError(errorCode)) return ERROR(dictionary_corrupted); }
         dict = (const char*)dict + offcodeHeaderSize;
@@ -3826,7 +4130,22 @@ static size_t ZSTDv06_loadEntropy(ZSTDv06_DCtx* dctx, const void* dict, size_t d
         unsigned matchlengthMaxValue = MaxML, matchlengthLog;
         matchlengthHeaderSize = FSEv06_readNCount(matchlengthNCount, &matchlengthMaxValue, &matchlengthLog, dict, dictSize);
         if (FSEv06_isError(matchlengthHeaderSize)) return ERROR(dictionary_corrupted);
-        if (matchlengthLog > MLFSELog) return ERROR(dictionary_corrupted);
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[462]) {
+          if ((matchlengthLog > 9 ) && !(0))
+            fprintf(stderr, "triggered bug index 462\n");
+          else
+            fprintf(stderr, "reached bug index 462\n");
+        }
+        if ((!FIXREVERTER[462] && (matchlengthLog > 9 ))
+        #else
+        if (0
+        #endif
+        ) return ERROR(dictionary_corrupted);
+        #ifdef FRCOV
+        }
+        #endif
         { size_t const errorCode = FSEv06_buildDTable(dctx->MLTable, matchlengthNCount, matchlengthMaxValue, matchlengthLog);
           if (FSEv06_isError(errorCode)) return ERROR(dictionary_corrupted); }
         dict = (const char*)dict + matchlengthHeaderSize;
@@ -3837,7 +4156,22 @@ static size_t ZSTDv06_loadEntropy(ZSTDv06_DCtx* dctx, const void* dict, size_t d
         unsigned litlengthMaxValue = MaxLL, litlengthLog;
         litlengthHeaderSize = FSEv06_readNCount(litlengthNCount, &litlengthMaxValue, &litlengthLog, dict, dictSize);
         if (FSEv06_isError(litlengthHeaderSize)) return ERROR(dictionary_corrupted);
-        if (litlengthLog > LLFSELog) return ERROR(dictionary_corrupted);
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[464]) {
+          if ((litlengthLog > 9 ) && !(0))
+            fprintf(stderr, "triggered bug index 464\n");
+          else
+            fprintf(stderr, "reached bug index 464\n");
+        }
+        if ((!FIXREVERTER[464] && (litlengthLog > 9 ))
+        #else
+        if (0
+        #endif
+        ) return ERROR(dictionary_corrupted);
+        #ifdef FRCOV
+        }
+        #endif
         { size_t const errorCode = FSEv06_buildDTable(dctx->LLTable, litlengthNCount, litlengthMaxValue, litlengthLog);
           if (FSEv06_isError(errorCode)) return ERROR(dictionary_corrupted); }
     }
@@ -3963,7 +4297,22 @@ struct ZBUFFv06_DCtx_s {
 ZBUFFv06_DCtx* ZBUFFv06_createDCtx(void)
 {
     ZBUFFv06_DCtx* zbd = (ZBUFFv06_DCtx*)malloc(sizeof(ZBUFFv06_DCtx));
-    if (zbd==NULL) return NULL;
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[465]) {
+      if ((zbd == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 465\n");
+      else
+        fprintf(stderr, "reached bug index 465\n");
+    }
+    if ((!FIXREVERTER[465] && (zbd == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) return NULL;
+    #ifdef FRCOV
+    }
+    #endif
     memset(zbd, 0, sizeof(*zbd));
     zbd->zd = ZSTDv06_createDCtx();
     zbd->stage = ZBUFFds_init;
@@ -3972,7 +4321,22 @@ ZBUFFv06_DCtx* ZBUFFv06_createDCtx(void)
 
 size_t ZBUFFv06_freeDCtx(ZBUFFv06_DCtx* zbd)
 {
-    if (zbd==NULL) return 0;   /* support free on null */
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[466]) {
+      if ((zbd == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 466\n");
+      else
+        fprintf(stderr, "reached bug index 466\n");
+    }
+    if ((!FIXREVERTER[466] && (zbd == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) return 0;
+    #ifdef FRCOV
+    }
+    #endif   /* support free on null */
     ZSTDv06_freeDCtx(zbd->zd);
     free(zbd->inBuff);
     free(zbd->outBuff);
@@ -4057,14 +4421,44 @@ size_t ZBUFFv06_decompressContinue(ZBUFFv06_DCtx* zbd,
                     free(zbd->inBuff);
                     zbd->inBuffSize = blockSize;
                     zbd->inBuff = (char*)malloc(blockSize);
-                    if (zbd->inBuff == NULL) return ERROR(memory_allocation);
+                    
+                    #ifdef FRCOV
+                    {if (FIXREVERTER[467]) {
+                      if ((zbd -> inBuff == (void *) 0 ) && !(0))
+                        fprintf(stderr, "triggered bug index 467\n");
+                      else
+                        fprintf(stderr, "reached bug index 467\n");
+                    }
+                    if ((!FIXREVERTER[467] && (zbd -> inBuff == (void *) 0 ))
+                    #else
+                    if (0
+                    #endif
+                    ) return ERROR(memory_allocation);
+                    #ifdef FRCOV
+                    }
+                    #endif
                 }
                 {   size_t const neededOutSize = ((size_t)1 << zbd->fParams.windowLog) + blockSize + WILDCOPY_OVERLENGTH * 2;
                     if (zbd->outBuffSize < neededOutSize) {
                         free(zbd->outBuff);
                         zbd->outBuffSize = neededOutSize;
                         zbd->outBuff = (char*)malloc(neededOutSize);
-                        if (zbd->outBuff == NULL) return ERROR(memory_allocation);
+                        
+                        #ifdef FRCOV
+                        {if (FIXREVERTER[468]) {
+                          if ((zbd -> outBuff == (void *) 0 ) && !(0))
+                            fprintf(stderr, "triggered bug index 468\n");
+                          else
+                            fprintf(stderr, "reached bug index 468\n");
+                        }
+                        if ((!FIXREVERTER[468] && (zbd -> outBuff == (void *) 0 ))
+                        #else
+                        if (0
+                        #endif
+                        ) return ERROR(memory_allocation);
+                        #ifdef FRCOV
+                        }
+                        #endif
             }   }   }
             zbd->stage = ZBUFFds_read;
 	    /* fall-through */
diff --git a/lib/legacy/zstd_v07.c b/lib/legacy/zstd_v07.c
index a83ddc9..52f996e 100644
--- a/lib/legacy/zstd_v07.c
+++ b/lib/legacy/zstd_v07.c
@@ -1,3 +1,7 @@
+#ifdef FRCOV
+#include <stdio.h>
+extern short FIXREVERTER[];
+#endif
 /*
  * Copyright (c) 2016-present, Yann Collet, Facebook, Inc.
  * All rights reserved.
@@ -1218,10 +1222,40 @@ size_t FSEv07_readNCount (short* normalizedCounter, unsigned* maxSVPtr, unsigned
     unsigned charnum = 0;
     int previous0 = 0;
 
-    if (hbSize < 4) return ERROR(srcSize_wrong);
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[566]) {
+      if ((hbSize < 4 ) && !(0))
+        fprintf(stderr, "triggered bug index 566\n");
+      else
+        fprintf(stderr, "reached bug index 566\n");
+    }
+    if ((!FIXREVERTER[566] && (hbSize < 4 ))
+    #else
+    if (0
+    #endif
+    ) return ERROR(srcSize_wrong);
+    #ifdef FRCOV
+    }
+    #endif
     bitStream = MEM_readLE32(ip);
     nbBits = (bitStream & 0xF) + FSEv07_MIN_TABLELOG;   /* extract tableLog */
-    if (nbBits > FSEv07_TABLELOG_ABSOLUTE_MAX) return ERROR(tableLog_tooLarge);
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[567]) {
+      if ((nbBits > 15 ) && !(0))
+        fprintf(stderr, "triggered bug index 567\n");
+      else
+        fprintf(stderr, "reached bug index 567\n");
+    }
+    if ((!FIXREVERTER[567] && (nbBits > 15 ))
+    #else
+    if (0
+    #endif
+    ) return ERROR(tableLog_tooLarge);
+    #ifdef FRCOV
+    }
+    #endif
     bitStream >>= 4;
     bitCount = 4;
     *tableLogPtr = nbBits;
@@ -1288,7 +1322,22 @@ size_t FSEv07_readNCount (short* normalizedCounter, unsigned* maxSVPtr, unsigned
             }
             bitStream = MEM_readLE32(ip) >> (bitCount & 31);
     }   }   /* while ((remaining>1) && (charnum<=*maxSVPtr)) */
-    if (remaining != 1) return ERROR(GENERIC);
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[568]) {
+      if ((remaining != 1 ) && !(0))
+        fprintf(stderr, "triggered bug index 568\n");
+      else
+        fprintf(stderr, "reached bug index 568\n");
+    }
+    if ((!FIXREVERTER[568] && (remaining != 1 ))
+    #else
+    if (0
+    #endif
+    ) return ERROR(GENERIC);
+    #ifdef FRCOV
+    }
+    #endif
     *maxSVPtr = charnum-1;
 
     ip += (bitCount+7)>>3;
@@ -1326,8 +1375,38 @@ size_t HUFv07_readStats(BYTE* huffWeight, size_t hwSize, U32* rankStats,
         else {   /* Incompressible */
             oSize = iSize - 127;
             iSize = ((oSize+1)/2);
-            if (iSize+1 > srcSize) return ERROR(srcSize_wrong);
-            if (oSize >= hwSize) return ERROR(corruption_detected);
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[570]) {
+              if ((iSize + 1 > srcSize ) && !(0))
+                fprintf(stderr, "triggered bug index 570\n");
+              else
+                fprintf(stderr, "reached bug index 570\n");
+            }
+            if ((!FIXREVERTER[570] && (iSize + 1 > srcSize ))
+            #else
+            if (0
+            #endif
+            ) return ERROR(srcSize_wrong);
+            #ifdef FRCOV
+            }
+            #endif
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[571]) {
+              if ((oSize >= hwSize ) && !(0))
+                fprintf(stderr, "triggered bug index 571\n");
+              else
+                fprintf(stderr, "reached bug index 571\n");
+            }
+            if ((!FIXREVERTER[571] && (oSize >= hwSize ))
+            #else
+            if (0
+            #endif
+            ) return ERROR(corruption_detected);
+            #ifdef FRCOV
+            }
+            #endif
             ip += 1;
             {   U32 n;
                 for (n=0; n<oSize; n+=2) {
@@ -1335,7 +1414,22 @@ size_t HUFv07_readStats(BYTE* huffWeight, size_t hwSize, U32* rankStats,
                     huffWeight[n+1] = ip[n/2] & 15;
     }   }   }   }
     else  {   /* header compressed with FSE (normal case) */
-        if (iSize+1 > srcSize) return ERROR(srcSize_wrong);
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[572]) {
+          if ((iSize + 1 > srcSize ) && !(0))
+            fprintf(stderr, "triggered bug index 572\n");
+          else
+            fprintf(stderr, "reached bug index 572\n");
+        }
+        if ((!FIXREVERTER[572] && (iSize + 1 > srcSize ))
+        #else
+        if (0
+        #endif
+        ) return ERROR(srcSize_wrong);
+        #ifdef FRCOV
+        }
+        #endif
         oSize = FSEv07_decompress(huffWeight, hwSize-1, ip+1, iSize);   /* max (hwSize-1) values decoded, as last one is implied */
         if (FSEv07_isError(oSize)) return oSize;
     }
@@ -1348,7 +1442,22 @@ size_t HUFv07_readStats(BYTE* huffWeight, size_t hwSize, U32* rankStats,
             rankStats[huffWeight[n]]++;
             weightTotal += (1 << huffWeight[n]) >> 1;
     }   }
-    if (weightTotal == 0) return ERROR(corruption_detected);
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[573]) {
+      if ((weightTotal == 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 573\n");
+      else
+        fprintf(stderr, "reached bug index 573\n");
+    }
+    if ((!FIXREVERTER[573] && (weightTotal == 0 ))
+    #else
+    if (0
+    #endif
+    ) return ERROR(corruption_detected);
+    #ifdef FRCOV
+    }
+    #endif
 
     /* get last non-null symbol weight (implied, total must be 2^n) */
     {   U32 const tableLog = BITv07_highbit32(weightTotal) + 1;
@@ -1487,7 +1596,22 @@ size_t FSEv07_buildDTable(FSEv07_DTable* dt, const short* normalizedCounter, uns
 
     /* Sanity Checks */
     if (maxSymbolValue > FSEv07_MAX_SYMBOL_VALUE) return ERROR(maxSymbolValue_tooLarge);
-    if (tableLog > FSEv07_MAX_TABLELOG) return ERROR(tableLog_tooLarge);
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[577]) {
+      if ((tableLog > 14 - 2 ) && !(0))
+        fprintf(stderr, "triggered bug index 577\n");
+      else
+        fprintf(stderr, "reached bug index 577\n");
+    }
+    if ((!FIXREVERTER[577] && (tableLog > 14 - 2 ))
+    #else
+    if (0
+    #endif
+    ) return ERROR(tableLog_tooLarge);
+    #ifdef FRCOV
+    }
+    #endif
 
     /* Init, lay down lowprob symbols */
     {   FSEv07_DTableHeader DTableH;
@@ -1518,7 +1642,22 @@ size_t FSEv07_buildDTable(FSEv07_DTable* dt, const short* normalizedCounter, uns
                 while (position > highThreshold) position = (position + step) & tableMask;   /* lowprob area */
         }   }
 
-        if (position!=0) return ERROR(GENERIC);   /* position must reach all cells once, otherwise normalizedCounter is incorrect */
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[578]) {
+          if ((position != 0 ) && !(0))
+            fprintf(stderr, "triggered bug index 578\n");
+          else
+            fprintf(stderr, "reached bug index 578\n");
+        }
+        if ((!FIXREVERTER[578] && (position != 0 ))
+        #else
+        if (0
+        #endif
+        ) return ERROR(GENERIC);
+        #ifdef FRCOV
+        }
+        #endif   /* position must reach all cells once, otherwise normalizedCounter is incorrect */
     }
 
     /* Build Decoding table */
@@ -1675,7 +1814,22 @@ size_t FSEv07_decompress(void* dst, size_t maxDstSize, const void* cSrc, size_t
     unsigned tableLog;
     unsigned maxSymbolValue = FSEv07_MAX_SYMBOL_VALUE;
 
-    if (cSrcSize<2) return ERROR(srcSize_wrong);   /* too small input size */
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[582]) {
+      if ((cSrcSize < 2 ) && !(0))
+        fprintf(stderr, "triggered bug index 582\n");
+      else
+        fprintf(stderr, "reached bug index 582\n");
+    }
+    if ((!FIXREVERTER[582] && (cSrcSize < 2 ))
+    #else
+    if (0
+    #endif
+    ) return ERROR(srcSize_wrong);
+    #ifdef FRCOV
+    }
+    #endif   /* too small input size */
 
     /* normal FSE decoding mode */
     {   size_t const NCountLength = FSEv07_readNCount (counting, &maxSymbolValue, &tableLog, istart, cSrcSize);
@@ -1923,7 +2077,22 @@ static size_t HUFv07_decompress4X2_usingDTable_internal(
     const HUFv07_DTable* DTable)
 {
     /* Check */
-    if (cSrcSize < 10) return ERROR(corruption_detected);  /* strict minimum : jump table + 1 byte per stream */
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[585]) {
+      if ((cSrcSize < 10 ) && !(0))
+        fprintf(stderr, "triggered bug index 585\n");
+      else
+        fprintf(stderr, "reached bug index 585\n");
+    }
+    if ((!FIXREVERTER[585] && (cSrcSize < 10 ))
+    #else
+    if (0
+    #endif
+    ) return ERROR(corruption_detected);
+    #ifdef FRCOV
+    }
+    #endif  /* strict minimum : jump table + 1 byte per stream */
 
     {   const BYTE* const istart = (const BYTE*) cSrc;
         BYTE* const ostart = (BYTE*) dst;
@@ -2333,7 +2502,22 @@ static size_t HUFv07_decompress4X4_usingDTable_internal(
     const void* cSrc, size_t cSrcSize,
     const HUFv07_DTable* DTable)
 {
-    if (cSrcSize < 10) return ERROR(corruption_detected);   /* strict minimum : jump table + 1 byte per stream */
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[596]) {
+      if ((cSrcSize < 10 ) && !(0))
+        fprintf(stderr, "triggered bug index 596\n");
+      else
+        fprintf(stderr, "reached bug index 596\n");
+    }
+    if ((!FIXREVERTER[596] && (cSrcSize < 10 ))
+    #else
+    if (0
+    #endif
+    ) return ERROR(corruption_detected);
+    #ifdef FRCOV
+    }
+    #endif   /* strict minimum : jump table + 1 byte per stream */
 
     {   const BYTE* const istart = (const BYTE*) cSrc;
         BYTE* const ostart = (BYTE*) dst;
@@ -2438,7 +2622,22 @@ size_t HUFv07_decompress4X4_DCtx (HUFv07_DTable* dctx, void* dst, size_t dstSize
 
     size_t hSize = HUFv07_readDTableX4 (dctx, cSrc, cSrcSize);
     if (HUFv07_isError(hSize)) return hSize;
-    if (hSize >= cSrcSize) return ERROR(srcSize_wrong);
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[597]) {
+      if ((hSize >= cSrcSize ) && !(0))
+        fprintf(stderr, "triggered bug index 597\n");
+      else
+        fprintf(stderr, "reached bug index 597\n");
+    }
+    if ((!FIXREVERTER[597] && (hSize >= cSrcSize ))
+    #else
+    if (0
+    #endif
+    ) return ERROR(srcSize_wrong);
+    #ifdef FRCOV
+    }
+    #endif
     ip += hSize; cSrcSize -= hSize;
 
     return HUFv07_decompress4X4_usingDTable_internal(dst, dstSize, ip, cSrcSize, dctx);
@@ -2998,7 +3197,22 @@ ZSTDv07_DCtx* ZSTDv07_createDCtx(void)
 
 size_t ZSTDv07_freeDCtx(ZSTDv07_DCtx* dctx)
 {
-    if (dctx==NULL) return 0;   /* support free on NULL */
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[626]) {
+      if ((dctx == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 626\n");
+      else
+        fprintf(stderr, "reached bug index 626\n");
+    }
+    if ((!FIXREVERTER[626] && (dctx == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) return 0;
+    #ifdef FRCOV
+    }
+    #endif   /* support free on NULL */
     dctx->customMem.customFree(dctx->customMem.opaque, dctx);
     return 0;   /* reserved as a potential error code in the future */
 }
@@ -3314,7 +3528,22 @@ static size_t ZSTDv07_decodeLiteralsBlock(ZSTDv07_DCtx* dctx,
                 litCSize = ((istart[2] &  3) << 16) + (istart[3] << 8) + istart[4];
                 break;
             }
-            if (litSize > ZSTDv07_BLOCKSIZE_ABSOLUTEMAX) return ERROR(corruption_detected);
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[630]) {
+              if ((litSize > 128 * 1024 ) && !(0))
+                fprintf(stderr, "triggered bug index 630\n");
+              else
+                fprintf(stderr, "reached bug index 630\n");
+            }
+            if ((!FIXREVERTER[630] && (litSize > 128 * 1024 ))
+            #else
+            if (0
+            #endif
+            ) return ERROR(corruption_detected);
+            #ifdef FRCOV
+            }
+            #endif
             if (litCSize + lhSize > srcSize) return ERROR(corruption_detected);
 
             if (HUFv07_isError(singleStream ?
@@ -3331,8 +3560,23 @@ static size_t ZSTDv07_decodeLiteralsBlock(ZSTDv07_DCtx* dctx,
     case lbt_repeat:
         {   size_t litSize, litCSize;
             U32 lhSize = ((istart[0]) >> 4) & 3;
-            if (lhSize != 1)  /* only case supported for now : small litSize, single stream */
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[632]) {
+              if ((lhSize != 1 ) && !(0))
+                fprintf(stderr, "triggered bug index 632\n");
+              else
+                fprintf(stderr, "reached bug index 632\n");
+            }
+            if ((!FIXREVERTER[632] && (lhSize != 1 ))
+            #else
+            if (0
+            #endif
+            )  /* only case supported for now : small litSize, single stream */
                 return ERROR(corruption_detected);
+                #ifdef FRCOV
+                }
+                #endif
             if (dctx->litEntropy==0)
                 return ERROR(dictionary_corrupted);
 
@@ -3340,7 +3584,22 @@ static size_t ZSTDv07_decodeLiteralsBlock(ZSTDv07_DCtx* dctx,
             lhSize=3;
             litSize  = ((istart[0] & 15) << 6) + (istart[1] >> 2);
             litCSize = ((istart[1] &  3) << 8) + istart[2];
-            if (litCSize + lhSize > srcSize) return ERROR(corruption_detected);
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[634]) {
+              if ((litCSize + lhSize > srcSize ) && !(0))
+                fprintf(stderr, "triggered bug index 634\n");
+              else
+                fprintf(stderr, "reached bug index 634\n");
+            }
+            if ((!FIXREVERTER[634] && (litCSize + lhSize > srcSize ))
+            #else
+            if (0
+            #endif
+            ) return ERROR(corruption_detected);
+            #ifdef FRCOV
+            }
+            #endif
 
             {   size_t const errorCode = HUFv07_decompress1X4_usingDTable(dctx->litBuffer, litSize, istart+lhSize, litCSize, dctx->hufTable);
                 if (HUFv07_isError(errorCode)) return ERROR(corruption_detected);
@@ -3368,7 +3627,22 @@ static size_t ZSTDv07_decodeLiteralsBlock(ZSTDv07_DCtx* dctx,
             }
 
             if (lhSize+litSize+WILDCOPY_OVERLENGTH > srcSize) {  /* risk reading beyond src buffer with wildcopy */
-                if (litSize+lhSize > srcSize) return ERROR(corruption_detected);
+                
+                #ifdef FRCOV
+                {if (FIXREVERTER[635]) {
+                  if ((litSize + lhSize > srcSize ) && !(0))
+                    fprintf(stderr, "triggered bug index 635\n");
+                  else
+                    fprintf(stderr, "reached bug index 635\n");
+                }
+                if ((!FIXREVERTER[635] && (litSize + lhSize > srcSize ))
+                #else
+                if (0
+                #endif
+                ) return ERROR(corruption_detected);
+                #ifdef FRCOV
+                }
+                #endif
                 memcpy(dctx->litBuffer, istart+lhSize, litSize);
                 dctx->litPtr = dctx->litBuffer;
                 dctx->litSize = litSize;
@@ -3397,7 +3671,22 @@ static size_t ZSTDv07_decodeLiteralsBlock(ZSTDv07_DCtx* dctx,
                 if (srcSize<4) return ERROR(corruption_detected);   /* srcSize >= MIN_CBLOCK_SIZE == 3; here we need lhSize+1 = 4 */
                 break;
             }
-            if (litSize > ZSTDv07_BLOCKSIZE_ABSOLUTEMAX) return ERROR(corruption_detected);
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[637]) {
+              if ((litSize > 128 * 1024 ) && !(0))
+                fprintf(stderr, "triggered bug index 637\n");
+              else
+                fprintf(stderr, "reached bug index 637\n");
+            }
+            if ((!FIXREVERTER[637] && (litSize > 128 * 1024 ))
+            #else
+            if (0
+            #endif
+            ) return ERROR(corruption_detected);
+            #ifdef FRCOV
+            }
+            #endif
             memset(dctx->litBuffer, istart[lhSize], litSize + WILDCOPY_OVERLENGTH);
             dctx->litPtr = dctx->litBuffer;
             dctx->litSize = litSize;
@@ -3436,7 +3725,22 @@ static size_t ZSTDv07_buildSeqTable(FSEv07_DTable* DTable, U32 type, U32 max, U3
             S16 norm[MaxSeq+1];
             size_t const headerSize = FSEv07_readNCount(norm, &max, &tableLog, src, srcSize);
             if (FSEv07_isError(headerSize)) return ERROR(corruption_detected);
-            if (tableLog > maxLog) return ERROR(corruption_detected);
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[639]) {
+              if ((tableLog > maxLog ) && !(0))
+                fprintf(stderr, "triggered bug index 639\n");
+              else
+                fprintf(stderr, "reached bug index 639\n");
+            }
+            if ((!FIXREVERTER[639] && (tableLog > maxLog ))
+            #else
+            if (0
+            #endif
+            ) return ERROR(corruption_detected);
+            #ifdef FRCOV
+            }
+            #endif
             FSEv07_buildDTable(DTable, norm, max, tableLog);
             return headerSize;
     }   }
@@ -3452,7 +3756,22 @@ static size_t ZSTDv07_decodeSeqHeaders(int* nbSeqPtr,
     const BYTE* ip = istart;
 
     /* check */
-    if (srcSize < MIN_SEQUENCES_SIZE) return ERROR(srcSize_wrong);
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[640]) {
+      if ((srcSize < 1 ) && !(0))
+        fprintf(stderr, "triggered bug index 640\n");
+      else
+        fprintf(stderr, "reached bug index 640\n");
+    }
+    if ((!FIXREVERTER[640] && (srcSize < 1 ))
+    #else
+    if (0
+    #endif
+    ) return ERROR(srcSize_wrong);
+    #ifdef FRCOV
+    }
+    #endif
 
     /* SeqHead */
     {   int nbSeq = *ip++;
@@ -3739,7 +4058,22 @@ static size_t ZSTDv07_decompressBlock_internal(ZSTDv07_DCtx* dctx,
 {   /* blockType == blockCompressed */
     const BYTE* ip = (const BYTE*)src;
 
-    if (srcSize >= ZSTDv07_BLOCKSIZE_ABSOLUTEMAX) return ERROR(srcSize_wrong);
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[646]) {
+      if ((srcSize >= 128 * 1024 ) && !(0))
+        fprintf(stderr, "triggered bug index 646\n");
+      else
+        fprintf(stderr, "reached bug index 646\n");
+    }
+    if ((!FIXREVERTER[646] && (srcSize >= 128 * 1024 ))
+    #else
+    if (0
+    #endif
+    ) return ERROR(srcSize_wrong);
+    #ifdef FRCOV
+    }
+    #endif
 
     /* Decode literals sub-block */
     {   size_t const litCSize = ZSTDv07_decodeLiteralsBlock(dctx, src, srcSize);
@@ -3775,7 +4109,22 @@ ZSTDLIBv07_API size_t ZSTDv07_insertBlock(ZSTDv07_DCtx* dctx, const void* blockS
 
 static size_t ZSTDv07_generateNxBytes(void* dst, size_t dstCapacity, BYTE byte, size_t length)
 {
-    if (length > dstCapacity) return ERROR(dstSize_tooSmall);
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[647]) {
+      if ((length > dstCapacity ) && !(0))
+        fprintf(stderr, "triggered bug index 647\n");
+      else
+        fprintf(stderr, "reached bug index 647\n");
+    }
+    if ((!FIXREVERTER[647] && (length > dstCapacity ))
+    #else
+    if (0
+    #endif
+    ) return ERROR(dstSize_tooSmall);
+    #ifdef FRCOV
+    }
+    #endif
     memset(dst, byte, length);
     return length;
 }
@@ -3979,7 +4328,22 @@ int ZSTDv07_isSkipFrame(ZSTDv07_DCtx* dctx)
 size_t ZSTDv07_decompressContinue(ZSTDv07_DCtx* dctx, void* dst, size_t dstCapacity, const void* src, size_t srcSize)
 {
     /* Sanity check */
-    if (srcSize != dctx->expected) return ERROR(srcSize_wrong);
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[648]) {
+      if ((srcSize != dctx -> expected ) && !(0))
+        fprintf(stderr, "triggered bug index 648\n");
+      else
+        fprintf(stderr, "reached bug index 648\n");
+    }
+    if ((!FIXREVERTER[648] && (srcSize != dctx -> expected ))
+    #else
+    if (0
+    #endif
+    ) return ERROR(srcSize_wrong);
+    #ifdef FRCOV
+    }
+    #endif
     if (dstCapacity) ZSTDv07_checkContinuity(dctx, dst);
 
     switch (dctx->stage)
@@ -4098,7 +4462,22 @@ static size_t ZSTDv07_loadEntropy(ZSTDv07_DCtx* dctx, const void* const dict, si
         U32 offcodeMaxValue=MaxOff, offcodeLog;
         size_t const offcodeHeaderSize = FSEv07_readNCount(offcodeNCount, &offcodeMaxValue, &offcodeLog, dictPtr, dictEnd-dictPtr);
         if (FSEv07_isError(offcodeHeaderSize)) return ERROR(dictionary_corrupted);
-        if (offcodeLog > OffFSELog) return ERROR(dictionary_corrupted);
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[650]) {
+          if ((offcodeLog > 8 ) && !(0))
+            fprintf(stderr, "triggered bug index 650\n");
+          else
+            fprintf(stderr, "reached bug index 650\n");
+        }
+        if ((!FIXREVERTER[650] && (offcodeLog > 8 ))
+        #else
+        if (0
+        #endif
+        ) return ERROR(dictionary_corrupted);
+        #ifdef FRCOV
+        }
+        #endif
         { size_t const errorCode = FSEv07_buildDTable(dctx->OffTable, offcodeNCount, offcodeMaxValue, offcodeLog);
           if (FSEv07_isError(errorCode)) return ERROR(dictionary_corrupted); }
         dictPtr += offcodeHeaderSize;
@@ -4108,7 +4487,22 @@ static size_t ZSTDv07_loadEntropy(ZSTDv07_DCtx* dctx, const void* const dict, si
         unsigned matchlengthMaxValue = MaxML, matchlengthLog;
         size_t const matchlengthHeaderSize = FSEv07_readNCount(matchlengthNCount, &matchlengthMaxValue, &matchlengthLog, dictPtr, dictEnd-dictPtr);
         if (FSEv07_isError(matchlengthHeaderSize)) return ERROR(dictionary_corrupted);
-        if (matchlengthLog > MLFSELog) return ERROR(dictionary_corrupted);
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[652]) {
+          if ((matchlengthLog > 9 ) && !(0))
+            fprintf(stderr, "triggered bug index 652\n");
+          else
+            fprintf(stderr, "reached bug index 652\n");
+        }
+        if ((!FIXREVERTER[652] && (matchlengthLog > 9 ))
+        #else
+        if (0
+        #endif
+        ) return ERROR(dictionary_corrupted);
+        #ifdef FRCOV
+        }
+        #endif
         { size_t const errorCode = FSEv07_buildDTable(dctx->MLTable, matchlengthNCount, matchlengthMaxValue, matchlengthLog);
           if (FSEv07_isError(errorCode)) return ERROR(dictionary_corrupted); }
         dictPtr += matchlengthHeaderSize;
@@ -4118,7 +4512,22 @@ static size_t ZSTDv07_loadEntropy(ZSTDv07_DCtx* dctx, const void* const dict, si
         unsigned litlengthMaxValue = MaxLL, litlengthLog;
         size_t const litlengthHeaderSize = FSEv07_readNCount(litlengthNCount, &litlengthMaxValue, &litlengthLog, dictPtr, dictEnd-dictPtr);
         if (FSEv07_isError(litlengthHeaderSize)) return ERROR(dictionary_corrupted);
-        if (litlengthLog > LLFSELog) return ERROR(dictionary_corrupted);
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[654]) {
+          if ((litlengthLog > 9 ) && !(0))
+            fprintf(stderr, "triggered bug index 654\n");
+          else
+            fprintf(stderr, "reached bug index 654\n");
+        }
+        if ((!FIXREVERTER[654] && (litlengthLog > 9 ))
+        #else
+        if (0
+        #endif
+        ) return ERROR(dictionary_corrupted);
+        #ifdef FRCOV
+        }
+        #endif
         { size_t const errorCode = FSEv07_buildDTable(dctx->LLTable, litlengthNCount, litlengthMaxValue, litlengthLog);
           if (FSEv07_isError(errorCode)) return ERROR(dictionary_corrupted); }
         dictPtr += litlengthHeaderSize;
@@ -4136,7 +4545,22 @@ static size_t ZSTDv07_loadEntropy(ZSTDv07_DCtx* dctx, const void* const dict, si
 
 static size_t ZSTDv07_decompress_insertDictionary(ZSTDv07_DCtx* dctx, const void* dict, size_t dictSize)
 {
-    if (dictSize < 8) return ZSTDv07_refDictContent(dctx, dict, dictSize);
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[655]) {
+      if ((dictSize < 8 ) && !(0))
+        fprintf(stderr, "triggered bug index 655\n");
+      else
+        fprintf(stderr, "reached bug index 655\n");
+    }
+    if ((!FIXREVERTER[655] && (dictSize < 8 ))
+    #else
+    if (0
+    #endif
+    ) return ZSTDv07_refDictContent(dctx, dict, dictSize);
+    #ifdef FRCOV
+    }
+    #endif
     {   U32 const magic = MEM_readLE32(dict);
         if (magic != ZSTDv07_DICT_MAGIC) {
             return ZSTDv07_refDictContent(dctx, dict, dictSize);   /* pure content mode */
@@ -4339,18 +4763,63 @@ ZBUFFv07_DCtx* ZBUFFv07_createDCtx_advanced(ZSTDv07_customMem customMem)
         return NULL;
 
     zbd = (ZBUFFv07_DCtx*)customMem.customAlloc(customMem.opaque, sizeof(ZBUFFv07_DCtx));
-    if (zbd==NULL) return NULL;
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[656]) {
+      if ((zbd == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 656\n");
+      else
+        fprintf(stderr, "reached bug index 656\n");
+    }
+    if ((!FIXREVERTER[656] && (zbd == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) return NULL;
+    #ifdef FRCOV
+    }
+    #endif
     memset(zbd, 0, sizeof(ZBUFFv07_DCtx));
     memcpy(&zbd->customMem, &customMem, sizeof(ZSTDv07_customMem));
     zbd->zd = ZSTDv07_createDCtx_advanced(customMem);
-    if (zbd->zd == NULL) { ZBUFFv07_freeDCtx(zbd); return NULL; }
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[657]) {
+      if ((zbd -> zd == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 657\n");
+      else
+        fprintf(stderr, "reached bug index 657\n");
+    }
+    if ((!FIXREVERTER[657] && (zbd -> zd == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) { ZBUFFv07_freeDCtx(zbd); return NULL; }
+    #ifdef FRCOV
+    }
+    #endif
     zbd->stage = ZBUFFds_init;
     return zbd;
 }
 
 size_t ZBUFFv07_freeDCtx(ZBUFFv07_DCtx* zbd)
 {
-    if (zbd==NULL) return 0;   /* support free on null */
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[658]) {
+      if ((zbd == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 658\n");
+      else
+        fprintf(stderr, "reached bug index 658\n");
+    }
+    if ((!FIXREVERTER[658] && (zbd == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) return 0;
+    #ifdef FRCOV
+    }
+    #endif   /* support free on null */
     ZSTDv07_freeDCtx(zbd->zd);
     if (zbd->inBuff) zbd->customMem.customFree(zbd->customMem.opaque, zbd->inBuff);
     if (zbd->outBuff) zbd->customMem.customFree(zbd->customMem.opaque, zbd->outBuff);
@@ -4437,14 +4906,44 @@ size_t ZBUFFv07_decompressContinue(ZBUFFv07_DCtx* zbd,
                     zbd->customMem.customFree(zbd->customMem.opaque, zbd->inBuff);
                     zbd->inBuffSize = blockSize;
                     zbd->inBuff = (char*)zbd->customMem.customAlloc(zbd->customMem.opaque, blockSize);
-                    if (zbd->inBuff == NULL) return ERROR(memory_allocation);
+                    
+                    #ifdef FRCOV
+                    {if (FIXREVERTER[659]) {
+                      if ((zbd -> inBuff == (void *) 0 ) && !(0))
+                        fprintf(stderr, "triggered bug index 659\n");
+                      else
+                        fprintf(stderr, "reached bug index 659\n");
+                    }
+                    if ((!FIXREVERTER[659] && (zbd -> inBuff == (void *) 0 ))
+                    #else
+                    if (0
+                    #endif
+                    ) return ERROR(memory_allocation);
+                    #ifdef FRCOV
+                    }
+                    #endif
                 }
                 {   size_t const neededOutSize = zbd->fParams.windowSize + blockSize + WILDCOPY_OVERLENGTH * 2;
                     if (zbd->outBuffSize < neededOutSize) {
                         zbd->customMem.customFree(zbd->customMem.opaque, zbd->outBuff);
                         zbd->outBuffSize = neededOutSize;
                         zbd->outBuff = (char*)zbd->customMem.customAlloc(zbd->customMem.opaque, neededOutSize);
-                        if (zbd->outBuff == NULL) return ERROR(memory_allocation);
+                        
+                        #ifdef FRCOV
+                        {if (FIXREVERTER[660]) {
+                          if ((zbd -> outBuff == (void *) 0 ) && !(0))
+                            fprintf(stderr, "triggered bug index 660\n");
+                          else
+                            fprintf(stderr, "reached bug index 660\n");
+                        }
+                        if ((!FIXREVERTER[660] && (zbd -> outBuff == (void *) 0 ))
+                        #else
+                        if (0
+                        #endif
+                        ) return ERROR(memory_allocation);
+                        #ifdef FRCOV
+                        }
+                        #endif
             }   }   }
             zbd->stage = ZBUFFds_read;
             /* pass-through */
diff --git a/tests/fuzz/stream_decompress.c b/tests/fuzz/stream_decompress.c
index 68e120d..c93c76f 100644
--- a/tests/fuzz/stream_decompress.c
+++ b/tests/fuzz/stream_decompress.c
@@ -1,3 +1,7 @@
+#ifdef FRCOV
+#define FIXREVERTER_SIZE 869
+short FIXREVERTER[FIXREVERTER_SIZE];
+#endif
 /*
  * Copyright (c) 2016-present, Facebook, Inc.
  * All rights reserved.
@@ -49,8 +53,42 @@ static ZSTD_inBuffer makeInBuffer(const uint8_t **src, size_t *size)
   return buffer;
 }
 
+
+#ifdef FRCOV
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#endif
 int LLVMFuzzerTestOneInput(const uint8_t *src, size_t size)
 {
+    
+    #ifdef FRCOV
+    char *fixReverterEnv = getenv("FIXREVERTER");
+    char *fixReverterToken = strtok(fixReverterEnv, " ");
+    if (fixReverterToken == NULL) {
+      for (int i = 0; i < FIXREVERTER_SIZE; i++)
+        FIXREVERTER[i] = 1;
+    } else if (!strcmp("on", fixReverterToken)) {
+      for (int i = 0; i < FIXREVERTER_SIZE; i++)
+        FIXREVERTER[i] = 0;
+      fixReverterToken = strtok(NULL, " ");
+      while (fixReverterToken != NULL) {
+        FIXREVERTER[atoi(fixReverterToken)] = 1;
+        fixReverterToken = strtok(NULL, " ");
+      }
+    } else if (!strcmp("off", fixReverterToken)) {
+      for (int i = 0; i < FIXREVERTER_SIZE; i++)
+        FIXREVERTER[i] = 1;
+      fixReverterToken = strtok(NULL, " ");
+      while (fixReverterToken != NULL) {
+        FIXREVERTER[atoi(fixReverterToken)] = 0;
+        fixReverterToken = strtok(NULL, " ");
+      }
+    } else {
+      fprintf(stderr, "[FIXREVERTER] - first token must be on or off\n");
+      exit(0);
+    }
+    #endif
     seed = FUZZ_seed(&src, &size);
 
     /* Allocate all buffers and contexts if not already allocated */
