diff --git a/Makefile.in b/Makefile.in
index a3e61e5..ab982c1 100644
--- a/Makefile.in
+++ b/Makefile.in
@@ -1,7 +1,7 @@
-# Makefile.in generated by automake 1.14.1 from Makefile.am.
+# Makefile.in generated by automake 1.16.1 from Makefile.am.
 # @configure_input@
 
-# Copyright (C) 1994-2013 Free Software Foundation, Inc.
+# Copyright (C) 1994-2018 Free Software Foundation, Inc.
 
 # This Makefile.in is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
@@ -19,7 +19,17 @@
 #
 
 VPATH = @srcdir@
-am__is_gnu_make = test -n '$(MAKEFILE_LIST)' && test -n '$(MAKELEVEL)'
+am__is_gnu_make = { \
+  if test -z '$(MAKELEVEL)'; then \
+    false; \
+  elif test -n '$(MAKE_HOST)'; then \
+    true; \
+  elif test -n '$(MAKE_VERSION)' && test -n '$(CURDIR)'; then \
+    true; \
+  else \
+    false; \
+  fi; \
+}
 am__make_running_with_option = \
   case $${target_option-} in \
       ?) ;; \
@@ -83,18 +93,20 @@ POST_UNINSTALL = :
 build_triplet = @build@
 host_triplet = @host@
 subdir = .
-DIST_COMMON = $(srcdir)/Makefile.in $(srcdir)/Makefile.am \
-	$(top_srcdir)/configure $(am__configure_deps) \
-	$(srcdir)/lcms2.pc.in AUTHORS COPYING ChangeLog INSTALL \
-	compile config.guess config.sub depcomp install-sh missing \
-	ltmain.sh
 ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
 am__aclocal_m4_deps = $(top_srcdir)/m4/acx_pthread.m4 \
+	$(top_srcdir)/m4/ax_append_compile_flags.m4 \
+	$(top_srcdir)/m4/ax_append_flag.m4 \
+	$(top_srcdir)/m4/ax_check_compile_flag.m4 \
+	$(top_srcdir)/m4/ax_gcc_func_attribute.m4 \
+	$(top_srcdir)/m4/ax_require_defined.m4 \
 	$(top_srcdir)/m4/libtool.m4 $(top_srcdir)/m4/ltoptions.m4 \
 	$(top_srcdir)/m4/ltsugar.m4 $(top_srcdir)/m4/ltversion.m4 \
 	$(top_srcdir)/m4/lt~obsolete.m4 $(top_srcdir)/configure.ac
 am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
 	$(ACLOCAL_M4)
+DIST_COMMON = $(srcdir)/Makefile.am $(top_srcdir)/configure \
+	$(am__configure_deps) $(am__DIST_COMMON)
 am__CONFIG_DISTCLEAN_FILES = config.status config.cache config.log \
  configure.lineno config.status.lineno
 mkinstalldirs = $(install_sh) -d
@@ -163,7 +175,7 @@ am__recursive_targets = \
   $(RECURSIVE_CLEAN_TARGETS) \
   $(am__extra_recursive_targets)
 AM_RECURSIVE_TARGETS = $(am__recursive_targets:-recursive=) TAGS CTAGS \
-	cscope distdir dist dist-all distcheck
+	cscope distdir distdir-am dist dist-all distcheck
 am__tagged_files = $(HEADERS) $(SOURCES) $(TAGS_FILES) $(LISP)
 # Read a list of newline-separated strings from the standard input,
 # and print each of them once, without duplicates.  Input order is
@@ -185,6 +197,9 @@ ETAGS = etags
 CTAGS = ctags
 CSCOPE = cscope
 DIST_SUBDIRS = $(SUBDIRS)
+am__DIST_COMMON = $(srcdir)/Makefile.in $(srcdir)/lcms2.pc.in AUTHORS \
+	COPYING ChangeLog INSTALL compile config.guess config.sub \
+	depcomp install-sh ltmain.sh missing
 DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
 distdir = $(PACKAGE)-$(VERSION)
 top_distdir = $(distdir)
@@ -358,6 +373,7 @@ pdfdir = @pdfdir@
 prefix = @prefix@
 program_transform_name = @program_transform_name@
 psdir = @psdir@
+runstatedir = @runstatedir@
 sbindir = @sbindir@
 sharedstatedir = @sharedstatedir@
 srcdir = @srcdir@
@@ -399,15 +415,14 @@ $(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ $(srcdir)/Makefile.am  $(am__confi
 	echo ' cd $(top_srcdir) && $(AUTOMAKE) --foreign Makefile'; \
 	$(am__cd) $(top_srcdir) && \
 	  $(AUTOMAKE) --foreign Makefile
-.PRECIOUS: Makefile
 Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
 	@case '$?' in \
 	  *config.status*) \
 	    echo ' $(SHELL) ./config.status'; \
 	    $(SHELL) ./config.status;; \
 	  *) \
-	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $@ $(am__depfiles_maybe)'; \
-	    cd $(top_builddir) && $(SHELL) ./config.status $@ $(am__depfiles_maybe);; \
+	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $@ $(am__maybe_remake_depfiles)'; \
+	    cd $(top_builddir) && $(SHELL) ./config.status $@ $(am__maybe_remake_depfiles);; \
 	esac;
 
 $(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
@@ -557,7 +572,10 @@ distclean-tags:
 	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
 	-rm -f cscope.out cscope.in.out cscope.po.out cscope.files
 
-distdir: $(DISTFILES)
+distdir: $(BUILT_SOURCES)
+	$(MAKE) $(AM_MAKEFLAGS) distdir-am
+
+distdir-am: $(DISTFILES)
 	$(am__remove_distdir)
 	test -d "$(distdir)" || mkdir "$(distdir)"
 	@srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
@@ -622,7 +640,7 @@ distdir: $(DISTFILES)
 	  ! -type d ! -perm -444 -exec $(install_sh) -c -m a+r {} {} \; \
 	|| chmod -R a+r "$(distdir)"
 dist-gzip: distdir
-	tardir=$(distdir) && $(am__tar) | GZIP=$(GZIP_ENV) gzip -c >$(distdir).tar.gz
+	tardir=$(distdir) && $(am__tar) | eval GZIP= gzip $(GZIP_ENV) -c >$(distdir).tar.gz
 	$(am__post_remove_distdir)
 
 dist-bzip2: distdir
@@ -638,17 +656,17 @@ dist-xz: distdir
 	$(am__post_remove_distdir)
 
 dist-tarZ: distdir
-	@echo WARNING: "Support for shar distribution archives is" \
-	               "deprecated." >&2
+	@echo WARNING: "Support for distribution archives compressed with" \
+		       "legacy program 'compress' is deprecated." >&2
 	@echo WARNING: "It will be removed altogether in Automake 2.0" >&2
 	tardir=$(distdir) && $(am__tar) | compress -c >$(distdir).tar.Z
 	$(am__post_remove_distdir)
 
 dist-shar: distdir
-	@echo WARNING: "Support for distribution archives compressed with" \
-		       "legacy program 'compress' is deprecated." >&2
+	@echo WARNING: "Support for shar distribution archives is" \
+	               "deprecated." >&2
 	@echo WARNING: "It will be removed altogether in Automake 2.0" >&2
-	shar $(distdir) | GZIP=$(GZIP_ENV) gzip -c >$(distdir).shar.gz
+	shar $(distdir) | eval GZIP= gzip $(GZIP_ENV) -c >$(distdir).shar.gz
 	$(am__post_remove_distdir)
 dist-zip: distdir
 	-rm -f $(distdir).zip
@@ -665,7 +683,7 @@ dist dist-all:
 distcheck: dist
 	case '$(DIST_ARCHIVES)' in \
 	*.tar.gz*) \
-	  GZIP=$(GZIP_ENV) gzip -dc $(distdir).tar.gz | $(am__untar) ;;\
+	  eval GZIP= gzip $(GZIP_ENV) -dc $(distdir).tar.gz | $(am__untar) ;;\
 	*.tar.bz2*) \
 	  bzip2 -dc $(distdir).tar.bz2 | $(am__untar) ;;\
 	*.tar.lz*) \
@@ -675,23 +693,23 @@ distcheck: dist
 	*.tar.Z*) \
 	  uncompress -c $(distdir).tar.Z | $(am__untar) ;;\
 	*.shar.gz*) \
-	  GZIP=$(GZIP_ENV) gzip -dc $(distdir).shar.gz | unshar ;;\
+	  eval GZIP= gzip $(GZIP_ENV) -dc $(distdir).shar.gz | unshar ;;\
 	*.zip*) \
 	  unzip $(distdir).zip ;;\
 	esac
 	chmod -R a-w $(distdir)
 	chmod u+w $(distdir)
-	mkdir $(distdir)/_build $(distdir)/_inst
+	mkdir $(distdir)/_build $(distdir)/_build/sub $(distdir)/_inst
 	chmod a-w $(distdir)
 	test -d $(distdir)/_build || exit 0; \
 	dc_install_base=`$(am__cd) $(distdir)/_inst && pwd | sed -e 's,^[^:\\/]:[\\/],/,'` \
 	  && dc_destdir="$${TMPDIR-/tmp}/am-dc-$$$$/" \
 	  && am__cwd=`pwd` \
-	  && $(am__cd) $(distdir)/_build \
-	  && ../configure \
+	  && $(am__cd) $(distdir)/_build/sub \
+	  && ../../configure \
 	    $(AM_DISTCHECK_CONFIGURE_FLAGS) \
 	    $(DISTCHECK_CONFIGURE_FLAGS) \
-	    --srcdir=.. --prefix="$$dc_install_base" \
+	    --srcdir=../.. --prefix="$$dc_install_base" \
 	  && $(MAKE) $(AM_MAKEFLAGS) \
 	  && $(MAKE) $(AM_MAKEFLAGS) dvi \
 	  && $(MAKE) $(AM_MAKEFLAGS) check \
@@ -873,6 +891,8 @@ uninstall-am: uninstall-local uninstall-pkgconfigDATA
 	mostlyclean-libtool pdf pdf-am ps ps-am tags tags-am uninstall \
 	uninstall-am uninstall-local uninstall-pkgconfigDATA
 
+.PRECIOUS: Makefile
+
 
 # Make sure get rid of VC stuff...
 clean-local:
diff --git a/aclocal.m4 b/aclocal.m4
index 8963d9a..ed6a6af 100644
--- a/aclocal.m4
+++ b/aclocal.m4
@@ -1,6 +1,6 @@
-# generated automatically by aclocal 1.14.1 -*- Autoconf -*-
+# generated automatically by aclocal 1.16.1 -*- Autoconf -*-
 
-# Copyright (C) 1996-2013 Free Software Foundation, Inc.
+# Copyright (C) 1996-2018 Free Software Foundation, Inc.
 
 # This file is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
@@ -20,7 +20,7 @@ You have another version of autoconf.  It may work, but is not guaranteed to.
 If you have problems, you may need to regenerate the build system entirely.
 To do so, use the procedure documented by the package, typically 'autoreconf'.])])
 
-# Copyright (C) 2002-2013 Free Software Foundation, Inc.
+# Copyright (C) 2002-2018 Free Software Foundation, Inc.
 #
 # This file is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
@@ -32,10 +32,10 @@ To do so, use the procedure documented by the package, typically 'autoreconf'.])
 # generated from the m4 files accompanying Automake X.Y.
 # (This private macro should not be called outside this file.)
 AC_DEFUN([AM_AUTOMAKE_VERSION],
-[am__api_version='1.14'
+[am__api_version='1.16'
 dnl Some users find AM_AUTOMAKE_VERSION and mistake it for a way to
 dnl require some minimum version.  Point them to the right macro.
-m4_if([$1], [1.14.1], [],
+m4_if([$1], [1.16.1], [],
       [AC_FATAL([Do not call $0, use AM_INIT_AUTOMAKE([$1]).])])dnl
 ])
 
@@ -51,14 +51,14 @@ m4_define([_AM_AUTOCONF_VERSION], [])
 # Call AM_AUTOMAKE_VERSION and AM_AUTOMAKE_VERSION so they can be traced.
 # This function is AC_REQUIREd by AM_INIT_AUTOMAKE.
 AC_DEFUN([AM_SET_CURRENT_AUTOMAKE_VERSION],
-[AM_AUTOMAKE_VERSION([1.14.1])dnl
+[AM_AUTOMAKE_VERSION([1.16.1])dnl
 m4_ifndef([AC_AUTOCONF_VERSION],
   [m4_copy([m4_PACKAGE_VERSION], [AC_AUTOCONF_VERSION])])dnl
 _AM_AUTOCONF_VERSION(m4_defn([AC_AUTOCONF_VERSION]))])
 
 # AM_AUX_DIR_EXPAND                                         -*- Autoconf -*-
 
-# Copyright (C) 2001-2013 Free Software Foundation, Inc.
+# Copyright (C) 2001-2018 Free Software Foundation, Inc.
 #
 # This file is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
@@ -103,15 +103,14 @@ _AM_AUTOCONF_VERSION(m4_defn([AC_AUTOCONF_VERSION]))])
 # configured tree to be moved without reconfiguration.
 
 AC_DEFUN([AM_AUX_DIR_EXPAND],
-[dnl Rely on autoconf to set up CDPATH properly.
-AC_PREREQ([2.50])dnl
-# expand $ac_aux_dir to an absolute path
-am_aux_dir=`cd $ac_aux_dir && pwd`
+[AC_REQUIRE([AC_CONFIG_AUX_DIR_DEFAULT])dnl
+# Expand $ac_aux_dir to an absolute path.
+am_aux_dir=`cd "$ac_aux_dir" && pwd`
 ])
 
 # AM_CONDITIONAL                                            -*- Autoconf -*-
 
-# Copyright (C) 1997-2013 Free Software Foundation, Inc.
+# Copyright (C) 1997-2018 Free Software Foundation, Inc.
 #
 # This file is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
@@ -142,7 +141,7 @@ AC_CONFIG_COMMANDS_PRE(
 Usually this means the macro was only invoked conditionally.]])
 fi])])
 
-# Copyright (C) 1999-2013 Free Software Foundation, Inc.
+# Copyright (C) 1999-2018 Free Software Foundation, Inc.
 #
 # This file is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
@@ -333,13 +332,12 @@ _AM_SUBST_NOTMAKE([am__nodep])dnl
 
 # Generate code to set up dependency tracking.              -*- Autoconf -*-
 
-# Copyright (C) 1999-2013 Free Software Foundation, Inc.
+# Copyright (C) 1999-2018 Free Software Foundation, Inc.
 #
 # This file is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
 # with or without modifications, as long as this notice is preserved.
 
-
 # _AM_OUTPUT_DEPENDENCY_COMMANDS
 # ------------------------------
 AC_DEFUN([_AM_OUTPUT_DEPENDENCY_COMMANDS],
@@ -347,49 +345,41 @@ AC_DEFUN([_AM_OUTPUT_DEPENDENCY_COMMANDS],
   # Older Autoconf quotes --file arguments for eval, but not when files
   # are listed without --file.  Let's play safe and only enable the eval
   # if we detect the quoting.
-  case $CONFIG_FILES in
-  *\'*) eval set x "$CONFIG_FILES" ;;
-  *)   set x $CONFIG_FILES ;;
-  esac
+  # TODO: see whether this extra hack can be removed once we start
+  # requiring Autoconf 2.70 or later.
+  AS_CASE([$CONFIG_FILES],
+          [*\'*], [eval set x "$CONFIG_FILES"],
+          [*], [set x $CONFIG_FILES])
   shift
-  for mf
+  # Used to flag and report bootstrapping failures.
+  am_rc=0
+  for am_mf
   do
     # Strip MF so we end up with the name of the file.
-    mf=`echo "$mf" | sed -e 's/:.*$//'`
-    # Check whether this is an Automake generated Makefile or not.
-    # We used to match only the files named 'Makefile.in', but
-    # some people rename them; so instead we look at the file content.
-    # Grep'ing the first line is not enough: some people post-process
-    # each Makefile.in and add a new line on top of each file to say so.
-    # Grep'ing the whole file is not good either: AIX grep has a line
+    am_mf=`AS_ECHO(["$am_mf"]) | sed -e 's/:.*$//'`
+    # Check whether this is an Automake generated Makefile which includes
+    # dependency-tracking related rules and includes.
+    # Grep'ing the whole file directly is not great: AIX grep has a line
     # limit of 2048, but all sed's we know have understand at least 4000.
-    if sed -n 's,^#.*generated by automake.*,X,p' "$mf" | grep X >/dev/null 2>&1; then
-      dirpart=`AS_DIRNAME("$mf")`
-    else
-      continue
-    fi
-    # Extract the definition of DEPDIR, am__include, and am__quote
-    # from the Makefile without running 'make'.
-    DEPDIR=`sed -n 's/^DEPDIR = //p' < "$mf"`
-    test -z "$DEPDIR" && continue
-    am__include=`sed -n 's/^am__include = //p' < "$mf"`
-    test -z "$am__include" && continue
-    am__quote=`sed -n 's/^am__quote = //p' < "$mf"`
-    # Find all dependency output files, they are included files with
-    # $(DEPDIR) in their names.  We invoke sed twice because it is the
-    # simplest approach to changing $(DEPDIR) to its actual value in the
-    # expansion.
-    for file in `sed -n "
-      s/^$am__include $am__quote\(.*(DEPDIR).*\)$am__quote"'$/\1/p' <"$mf" | \
-	 sed -e 's/\$(DEPDIR)/'"$DEPDIR"'/g'`; do
-      # Make sure the directory exists.
-      test -f "$dirpart/$file" && continue
-      fdir=`AS_DIRNAME(["$file"])`
-      AS_MKDIR_P([$dirpart/$fdir])
-      # echo "creating $dirpart/$file"
-      echo '# dummy' > "$dirpart/$file"
-    done
+    sed -n 's,^am--depfiles:.*,X,p' "$am_mf" | grep X >/dev/null 2>&1 \
+      || continue
+    am_dirpart=`AS_DIRNAME(["$am_mf"])`
+    am_filepart=`AS_BASENAME(["$am_mf"])`
+    AM_RUN_LOG([cd "$am_dirpart" \
+      && sed -e '/# am--include-marker/d' "$am_filepart" \
+        | $MAKE -f - am--depfiles]) || am_rc=$?
   done
+  if test $am_rc -ne 0; then
+    AC_MSG_FAILURE([Something went wrong bootstrapping makefile fragments
+    for automatic dependency tracking.  Try re-running configure with the
+    '--disable-dependency-tracking' option to at least be able to build
+    the package (albeit without support for automatic dependency tracking).])
+  fi
+  AS_UNSET([am_dirpart])
+  AS_UNSET([am_filepart])
+  AS_UNSET([am_mf])
+  AS_UNSET([am_rc])
+  rm -f conftest-deps.mk
 }
 ])# _AM_OUTPUT_DEPENDENCY_COMMANDS
 
@@ -398,18 +388,17 @@ AC_DEFUN([_AM_OUTPUT_DEPENDENCY_COMMANDS],
 # -----------------------------
 # This macro should only be invoked once -- use via AC_REQUIRE.
 #
-# This code is only required when automatic dependency tracking
-# is enabled.  FIXME.  This creates each '.P' file that we will
-# need in order to bootstrap the dependency handling code.
+# This code is only required when automatic dependency tracking is enabled.
+# This creates each '.Po' and '.Plo' makefile fragment that we'll need in
+# order to bootstrap the dependency handling code.
 AC_DEFUN([AM_OUTPUT_DEPENDENCY_COMMANDS],
 [AC_CONFIG_COMMANDS([depfiles],
      [test x"$AMDEP_TRUE" != x"" || _AM_OUTPUT_DEPENDENCY_COMMANDS],
-     [AMDEP_TRUE="$AMDEP_TRUE" ac_aux_dir="$ac_aux_dir"])
-])
+     [AMDEP_TRUE="$AMDEP_TRUE" MAKE="${MAKE-make}"])])
 
 # Do all the work for Automake.                             -*- Autoconf -*-
 
-# Copyright (C) 1996-2013 Free Software Foundation, Inc.
+# Copyright (C) 1996-2018 Free Software Foundation, Inc.
 #
 # This file is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
@@ -496,11 +485,11 @@ AC_REQUIRE([AM_PROG_INSTALL_STRIP])dnl
 AC_REQUIRE([AC_PROG_MKDIR_P])dnl
 # For better backward compatibility.  To be removed once Automake 1.9.x
 # dies out for good.  For more background, see:
-# <http://lists.gnu.org/archive/html/automake/2012-07/msg00001.html>
-# <http://lists.gnu.org/archive/html/automake/2012-07/msg00014.html>
+# <https://lists.gnu.org/archive/html/automake/2012-07/msg00001.html>
+# <https://lists.gnu.org/archive/html/automake/2012-07/msg00014.html>
 AC_SUBST([mkdir_p], ['$(MKDIR_P)'])
-# We need awk for the "check" target.  The system "awk" is bad on
-# some platforms.
+# We need awk for the "check" target (and possibly the TAP driver).  The
+# system "awk" is bad on some platforms.
 AC_REQUIRE([AC_PROG_AWK])dnl
 AC_REQUIRE([AC_PROG_MAKE_SET])dnl
 AC_REQUIRE([AM_SET_LEADING_DOT])dnl
@@ -564,7 +553,7 @@ END
 Aborting the configuration process, to ensure you take notice of the issue.
 
 You can download and install GNU coreutils to get an 'rm' implementation
-that behaves properly: <http://www.gnu.org/software/coreutils/>.
+that behaves properly: <https://www.gnu.org/software/coreutils/>.
 
 If you want to complete the configuration process using your problematic
 'rm' anyway, export the environment variable ACCEPT_INFERIOR_RM_PROGRAM
@@ -573,7 +562,11 @@ to "yes", and re-run configure.
 END
     AC_MSG_ERROR([Your 'rm' program is bad, sorry.])
   fi
-fi])
+fi
+dnl The trailing newline in this macro's definition is deliberate, for
+dnl backward compatibility and to allow trailing 'dnl'-style comments
+dnl after the AM_INIT_AUTOMAKE invocation. See automake bug#16841.
+])
 
 dnl Hook into '_AC_COMPILER_EXEEXT' early to learn its expansion.  Do not
 dnl add the conditional right here, as _AC_COMPILER_EXEEXT may be further
@@ -602,7 +595,7 @@ for _am_header in $config_headers :; do
 done
 echo "timestamp for $_am_arg" >`AS_DIRNAME(["$_am_arg"])`/stamp-h[]$_am_stamp_count])
 
-# Copyright (C) 2001-2013 Free Software Foundation, Inc.
+# Copyright (C) 2001-2018 Free Software Foundation, Inc.
 #
 # This file is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
@@ -613,7 +606,7 @@ echo "timestamp for $_am_arg" >`AS_DIRNAME(["$_am_arg"])`/stamp-h[]$_am_stamp_co
 # Define $install_sh.
 AC_DEFUN([AM_PROG_INSTALL_SH],
 [AC_REQUIRE([AM_AUX_DIR_EXPAND])dnl
-if test x"${install_sh}" != xset; then
+if test x"${install_sh+set}" != xset; then
   case $am_aux_dir in
   *\ * | *\	*)
     install_sh="\${SHELL} '$am_aux_dir/install-sh'" ;;
@@ -623,7 +616,7 @@ if test x"${install_sh}" != xset; then
 fi
 AC_SUBST([install_sh])])
 
-# Copyright (C) 2003-2013 Free Software Foundation, Inc.
+# Copyright (C) 2003-2018 Free Software Foundation, Inc.
 #
 # This file is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
@@ -645,7 +638,7 @@ AC_SUBST([am__leading_dot])])
 # Add --enable-maintainer-mode option to configure.         -*- Autoconf -*-
 # From Jim Meyering
 
-# Copyright (C) 1996-2013 Free Software Foundation, Inc.
+# Copyright (C) 1996-2018 Free Software Foundation, Inc.
 #
 # This file is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
@@ -680,7 +673,7 @@ AC_MSG_CHECKING([whether to enable maintainer-specific portions of Makefiles])
 
 # Check to see how 'make' treats includes.	            -*- Autoconf -*-
 
-# Copyright (C) 2001-2013 Free Software Foundation, Inc.
+# Copyright (C) 2001-2018 Free Software Foundation, Inc.
 #
 # This file is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
@@ -688,49 +681,42 @@ AC_MSG_CHECKING([whether to enable maintainer-specific portions of Makefiles])
 
 # AM_MAKE_INCLUDE()
 # -----------------
-# Check to see how make treats includes.
+# Check whether make has an 'include' directive that can support all
+# the idioms we need for our automatic dependency tracking code.
 AC_DEFUN([AM_MAKE_INCLUDE],
-[am_make=${MAKE-make}
-cat > confinc << 'END'
+[AC_MSG_CHECKING([whether ${MAKE-make} supports the include directive])
+cat > confinc.mk << 'END'
 am__doit:
-	@echo this is the am__doit target
+	@echo this is the am__doit target >confinc.out
 .PHONY: am__doit
 END
-# If we don't find an include directive, just comment out the code.
-AC_MSG_CHECKING([for style of include used by $am_make])
 am__include="#"
 am__quote=
-_am_result=none
-# First try GNU make style include.
-echo "include confinc" > confmf
-# Ignore all kinds of additional output from 'make'.
-case `$am_make -s -f confmf 2> /dev/null` in #(
-*the\ am__doit\ target*)
-  am__include=include
-  am__quote=
-  _am_result=GNU
-  ;;
-esac
-# Now try BSD make style include.
-if test "$am__include" = "#"; then
-   echo '.include "confinc"' > confmf
-   case `$am_make -s -f confmf 2> /dev/null` in #(
-   *the\ am__doit\ target*)
-     am__include=.include
-     am__quote="\""
-     _am_result=BSD
-     ;;
-   esac
-fi
-AC_SUBST([am__include])
-AC_SUBST([am__quote])
-AC_MSG_RESULT([$_am_result])
-rm -f confinc confmf
-])
+# BSD make does it like this.
+echo '.include "confinc.mk" # ignored' > confmf.BSD
+# Other make implementations (GNU, Solaris 10, AIX) do it like this.
+echo 'include confinc.mk # ignored' > confmf.GNU
+_am_result=no
+for s in GNU BSD; do
+  AM_RUN_LOG([${MAKE-make} -f confmf.$s && cat confinc.out])
+  AS_CASE([$?:`cat confinc.out 2>/dev/null`],
+      ['0:this is the am__doit target'],
+      [AS_CASE([$s],
+          [BSD], [am__include='.include' am__quote='"'],
+          [am__include='include' am__quote=''])])
+  if test "$am__include" != "#"; then
+    _am_result="yes ($s style)"
+    break
+  fi
+done
+rm -f confinc.* confmf.*
+AC_MSG_RESULT([${_am_result}])
+AC_SUBST([am__include])])
+AC_SUBST([am__quote])])
 
 # Fake the existence of programs that GNU maintainers use.  -*- Autoconf -*-
 
-# Copyright (C) 1997-2013 Free Software Foundation, Inc.
+# Copyright (C) 1997-2018 Free Software Foundation, Inc.
 #
 # This file is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
@@ -769,7 +755,7 @@ fi
 
 # Helper functions for option handling.                     -*- Autoconf -*-
 
-# Copyright (C) 2001-2013 Free Software Foundation, Inc.
+# Copyright (C) 2001-2018 Free Software Foundation, Inc.
 #
 # This file is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
@@ -798,7 +784,7 @@ AC_DEFUN([_AM_SET_OPTIONS],
 AC_DEFUN([_AM_IF_OPTION],
 [m4_ifset(_AM_MANGLE_OPTION([$1]), [$2], [$3])])
 
-# Copyright (C) 1999-2013 Free Software Foundation, Inc.
+# Copyright (C) 1999-2018 Free Software Foundation, Inc.
 #
 # This file is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
@@ -845,7 +831,7 @@ AC_LANG_POP([C])])
 # For backward compatibility.
 AC_DEFUN_ONCE([AM_PROG_CC_C_O], [AC_REQUIRE([AC_PROG_CC])])
 
-# Copyright (C) 2001-2013 Free Software Foundation, Inc.
+# Copyright (C) 2001-2018 Free Software Foundation, Inc.
 #
 # This file is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
@@ -864,7 +850,7 @@ AC_DEFUN([AM_RUN_LOG],
 
 # Check to make sure that the build environment is sane.    -*- Autoconf -*-
 
-# Copyright (C) 1996-2013 Free Software Foundation, Inc.
+# Copyright (C) 1996-2018 Free Software Foundation, Inc.
 #
 # This file is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
@@ -945,7 +931,7 @@ AC_CONFIG_COMMANDS_PRE(
 rm -f conftest.file
 ])
 
-# Copyright (C) 2009-2013 Free Software Foundation, Inc.
+# Copyright (C) 2009-2018 Free Software Foundation, Inc.
 #
 # This file is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
@@ -1005,7 +991,7 @@ AC_SUBST([AM_BACKSLASH])dnl
 _AM_SUBST_NOTMAKE([AM_BACKSLASH])dnl
 ])
 
-# Copyright (C) 2001-2013 Free Software Foundation, Inc.
+# Copyright (C) 2001-2018 Free Software Foundation, Inc.
 #
 # This file is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
@@ -1033,7 +1019,7 @@ fi
 INSTALL_STRIP_PROGRAM="\$(install_sh) -c -s"
 AC_SUBST([INSTALL_STRIP_PROGRAM])])
 
-# Copyright (C) 2006-2013 Free Software Foundation, Inc.
+# Copyright (C) 2006-2018 Free Software Foundation, Inc.
 #
 # This file is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
@@ -1052,7 +1038,7 @@ AC_DEFUN([AM_SUBST_NOTMAKE], [_AM_SUBST_NOTMAKE($@)])
 
 # Check how to create a tarball.                            -*- Autoconf -*-
 
-# Copyright (C) 2004-2013 Free Software Foundation, Inc.
+# Copyright (C) 2004-2018 Free Software Foundation, Inc.
 #
 # This file is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
@@ -1184,6 +1170,11 @@ AC_SUBST([am__untar])
 ]) # _AM_PROG_TAR
 
 m4_include([m4/acx_pthread.m4])
+m4_include([m4/ax_append_compile_flags.m4])
+m4_include([m4/ax_append_flag.m4])
+m4_include([m4/ax_check_compile_flag.m4])
+m4_include([m4/ax_gcc_func_attribute.m4])
+m4_include([m4/ax_require_defined.m4])
 m4_include([m4/libtool.m4])
 m4_include([m4/ltoptions.m4])
 m4_include([m4/ltsugar.m4])
diff --git a/configure b/configure
index 0316ad5..0747651 100755
--- a/configure
+++ b/configure
@@ -693,7 +693,6 @@ am__nodep
 AMDEPBACKSLASH
 AMDEP_FALSE
 AMDEP_TRUE
-am__quote
 am__include
 DEPDIR
 OBJEXT
@@ -760,6 +759,7 @@ infodir
 docdir
 oldincludedir
 includedir
+runstatedir
 localstatedir
 sharedstatedir
 sysconfdir
@@ -778,7 +778,8 @@ PACKAGE_VERSION
 PACKAGE_TARNAME
 PACKAGE_NAME
 PATH_SEPARATOR
-SHELL'
+SHELL
+am__quote'
 ac_subst_files=''
 ac_user_opts='
 enable_option_checking
@@ -848,6 +849,7 @@ datadir='${datarootdir}'
 sysconfdir='${prefix}/etc'
 sharedstatedir='${prefix}/com'
 localstatedir='${prefix}/var'
+runstatedir='${localstatedir}/run'
 includedir='${prefix}/include'
 oldincludedir='/usr/include'
 docdir='${datarootdir}/doc/${PACKAGE_TARNAME}'
@@ -1100,6 +1102,15 @@ do
   | -silent | --silent | --silen | --sile | --sil)
     silent=yes ;;
 
+  -runstatedir | --runstatedir | --runstatedi | --runstated \
+  | --runstate | --runstat | --runsta | --runst | --runs \
+  | --run | --ru | --r)
+    ac_prev=runstatedir ;;
+  -runstatedir=* | --runstatedir=* | --runstatedi=* | --runstated=* \
+  | --runstate=* | --runstat=* | --runsta=* | --runst=* | --runs=* \
+  | --run=* | --ru=* | --r=*)
+    runstatedir=$ac_optarg ;;
+
   -sbindir | --sbindir | --sbindi | --sbind | --sbin | --sbi | --sb)
     ac_prev=sbindir ;;
   -sbindir=* | --sbindir=* | --sbindi=* | --sbind=* | --sbin=* \
@@ -1237,7 +1248,7 @@ fi
 for ac_var in	exec_prefix prefix bindir sbindir libexecdir datarootdir \
 		datadir sysconfdir sharedstatedir localstatedir includedir \
 		oldincludedir docdir infodir htmldir dvidir pdfdir psdir \
-		libdir localedir mandir
+		libdir localedir mandir runstatedir
 do
   eval ac_val=\$$ac_var
   # Remove trailing slashes.
@@ -1390,6 +1401,7 @@ Fine tuning of the installation directories:
   --sysconfdir=DIR        read-only single-machine data [PREFIX/etc]
   --sharedstatedir=DIR    modifiable architecture-independent data [PREFIX/com]
   --localstatedir=DIR     modifiable single-machine data [PREFIX/var]
+  --runstatedir=DIR       modifiable per-process data [LOCALSTATEDIR/run]
   --libdir=DIR            object code libraries [EPREFIX/lib]
   --includedir=DIR        C header files [PREFIX/include]
   --oldincludedir=DIR     C header files for non-gcc [/usr/include]
@@ -2501,7 +2513,7 @@ case $host_os in *\ *) host_os=`echo "$host_os" | sed 's/ /-/g'`;; esac
 
 
 
-am__api_version='1.14'
+am__api_version='1.16'
 
 # Find a good install program.  We prefer a C program (faster),
 # so one script is as good as another.  But avoid the broken or
@@ -2673,8 +2685,8 @@ test "$program_suffix" != NONE &&
 ac_script='s/[\\$]/&&/g;s/;s,x,x,$//'
 program_transform_name=`$as_echo "$program_transform_name" | sed "$ac_script"`
 
-# expand $ac_aux_dir to an absolute path
-am_aux_dir=`cd $ac_aux_dir && pwd`
+# Expand $ac_aux_dir to an absolute path.
+am_aux_dir=`cd "$ac_aux_dir" && pwd`
 
 if test x"${MISSING+set}" != xset; then
   case $am_aux_dir in
@@ -2693,7 +2705,7 @@ else
 $as_echo "$as_me: WARNING: 'missing' script is too old or missing" >&2;}
 fi
 
-if test x"${install_sh}" != xset; then
+if test x"${install_sh+set}" != xset; then
   case $am_aux_dir in
   *\ * | *\	*)
     install_sh="\${SHELL} '$am_aux_dir/install-sh'" ;;
@@ -3008,12 +3020,12 @@ MAKEINFO=${MAKEINFO-"${am_missing_run}makeinfo"}
 
 # For better backward compatibility.  To be removed once Automake 1.9.x
 # dies out for good.  For more background, see:
-# <http://lists.gnu.org/archive/html/automake/2012-07/msg00001.html>
-# <http://lists.gnu.org/archive/html/automake/2012-07/msg00014.html>
+# <https://lists.gnu.org/archive/html/automake/2012-07/msg00001.html>
+# <https://lists.gnu.org/archive/html/automake/2012-07/msg00014.html>
 mkdir_p='$(MKDIR_P)'
 
-# We need awk for the "check" target.  The system "awk" is bad on
-# some platforms.
+# We need awk for the "check" target (and possibly the TAP driver).  The
+# system "awk" is bad on some platforms.
 # Always define AMTAR for backward compatibility.  Yes, it's still used
 # in the wild :-(  We should find a proper way to deprecate it ...
 AMTAR='$${TAR-tar}'
@@ -3060,7 +3072,7 @@ END
 Aborting the configuration process, to ensure you take notice of the issue.
 
 You can download and install GNU coreutils to get an 'rm' implementation
-that behaves properly: <http://www.gnu.org/software/coreutils/>.
+that behaves properly: <https://www.gnu.org/software/coreutils/>.
 
 If you want to complete the configuration process using your problematic
 'rm' anyway, export the environment variable ACCEPT_INFERIOR_RM_PROGRAM
@@ -3072,50 +3084,51 @@ END
 fi
 
 
+
 # Check for programs
 DEPDIR="${am__leading_dot}deps"
 
 ac_config_commands="$ac_config_commands depfiles"
 
-
-am_make=${MAKE-make}
-cat > confinc << 'END'
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether ${MAKE-make} supports the include directive" >&5
+$as_echo_n "checking whether ${MAKE-make} supports the include directive... " >&6; }
+cat > confinc.mk << 'END'
 am__doit:
-	@echo this is the am__doit target
+	@echo this is the am__doit target >confinc.out
 .PHONY: am__doit
 END
-# If we don't find an include directive, just comment out the code.
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for style of include used by $am_make" >&5
-$as_echo_n "checking for style of include used by $am_make... " >&6; }
 am__include="#"
 am__quote=
-_am_result=none
-# First try GNU make style include.
-echo "include confinc" > confmf
-# Ignore all kinds of additional output from 'make'.
-case `$am_make -s -f confmf 2> /dev/null` in #(
-*the\ am__doit\ target*)
-  am__include=include
-  am__quote=
-  _am_result=GNU
-  ;;
-esac
-# Now try BSD make style include.
-if test "$am__include" = "#"; then
-   echo '.include "confinc"' > confmf
-   case `$am_make -s -f confmf 2> /dev/null` in #(
-   *the\ am__doit\ target*)
-     am__include=.include
-     am__quote="\""
-     _am_result=BSD
+# BSD make does it like this.
+echo '.include "confinc.mk" # ignored' > confmf.BSD
+# Other make implementations (GNU, Solaris 10, AIX) do it like this.
+echo 'include confinc.mk # ignored' > confmf.GNU
+_am_result=no
+for s in GNU BSD; do
+  { echo "$as_me:$LINENO: ${MAKE-make} -f confmf.$s && cat confinc.out" >&5
+   (${MAKE-make} -f confmf.$s && cat confinc.out) >&5 2>&5
+   ac_status=$?
+   echo "$as_me:$LINENO: \$? = $ac_status" >&5
+   (exit $ac_status); }
+  case $?:`cat confinc.out 2>/dev/null` in #(
+  '0:this is the am__doit target') :
+    case $s in #(
+  BSD) :
+    am__include='.include' am__quote='"' ;; #(
+  *) :
+    am__include='include' am__quote='' ;;
+esac ;; #(
+  *) :
      ;;
-   esac
-fi
-
-
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $_am_result" >&5
-$as_echo "$_am_result" >&6; }
-rm -f confinc confmf
+esac
+  if test "$am__include" != "#"; then
+    _am_result="yes ($s style)"
+    break
+  fi
+done
+rm -f confinc.* confmf.*
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: ${_am_result}" >&5
+$as_echo "${_am_result}" >&6; }
 
 # Check whether --enable-dependency-tracking was given.
 if test "${enable_dependency_tracking+set}" = set; then :
@@ -15887,6 +15900,141 @@ esac
 
 
 
+# Check if the C compiler supports the "visibility" function attribute
+# If supported, defines HAVE_FUNC_ATTRIBUTE_VISIBILITY
+
+
+
+    { $as_echo "$as_me:${as_lineno-$LINENO}: checking for __attribute__((visibility))" >&5
+$as_echo_n "checking for __attribute__((visibility))... " >&6; }
+if ${ax_cv_have_func_attribute_visibility+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+
+        cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+
+                    int foo_def( void ) __attribute__((visibility("default")));
+                    int foo_hid( void ) __attribute__((visibility("hidden")));
+                    int foo_int( void ) __attribute__((visibility("internal")));
+                    int foo_pro( void ) __attribute__((visibility("protected")));
+
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+                                      if test -s conftest.err; then :
+  ax_cv_have_func_attribute_visibility=no
+else
+  ax_cv_have_func_attribute_visibility=yes
+fi
+else
+  ax_cv_have_func_attribute_visibility=no
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ax_cv_have_func_attribute_visibility" >&5
+$as_echo "$ax_cv_have_func_attribute_visibility" >&6; }
+
+    if test yes = $ax_cv_have_func_attribute_visibility; then :
+
+cat >>confdefs.h <<_ACEOF
+#define HAVE_FUNC_ATTRIBUTE_VISIBILITY 1
+_ACEOF
+
+fi
+
+
+
+
+# Check if the compiler supports "-fvisibility=hidden" and if yes, add it to CFLAGS
+# This means that symbols that are not marked explicitly for export (CMSAPI)
+# will not be reachable in the shared library.
+
+
+
+
+for flag in "-fvisibility=hidden"; do
+  as_CACHEVAR=`$as_echo "ax_cv_check_cflags__$flag" | $as_tr_sh`
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether C compiler accepts $flag" >&5
+$as_echo_n "checking whether C compiler accepts $flag... " >&6; }
+if eval \${$as_CACHEVAR+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+
+  ax_check_save_flags=$CFLAGS
+  CFLAGS="$CFLAGS  $flag"
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"; then :
+  eval "$as_CACHEVAR=yes"
+else
+  eval "$as_CACHEVAR=no"
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+  CFLAGS=$ax_check_save_flags
+fi
+eval ac_res=\$$as_CACHEVAR
+	       { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_res" >&5
+$as_echo "$ac_res" >&6; }
+if eval test \"x\$"$as_CACHEVAR"\" = x"yes"; then :
+
+if ${CFLAGS+:} false; then :
+
+  case " $CFLAGS " in #(
+  *" $flag "*) :
+    { { $as_echo "$as_me:${as_lineno-$LINENO}: : CFLAGS already contains \$flag"; } >&5
+  (: CFLAGS already contains $flag) 2>&5
+  ac_status=$?
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; } ;; #(
+  *) :
+
+     as_fn_append CFLAGS " $flag"
+     { { $as_echo "$as_me:${as_lineno-$LINENO}: : CFLAGS=\"\$CFLAGS\""; } >&5
+  (: CFLAGS="$CFLAGS") 2>&5
+  ac_status=$?
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; }
+     ;;
+esac
+
+else
+
+  CFLAGS=$flag
+  { { $as_echo "$as_me:${as_lineno-$LINENO}: : CFLAGS=\"\$CFLAGS\""; } >&5
+  (: CFLAGS="$CFLAGS") 2>&5
+  ac_status=$?
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; }
+
+fi
+
+else
+  :
+fi
+
+done
+
+
 # If words are stored with the most significant byte first (like
 # Motorola and SPARC CPUs), define `WORDS_BIGENDIAN'.
  { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether byte ordering is bigendian" >&5
@@ -18239,7 +18387,7 @@ cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
 #
 # INIT-COMMANDS
 #
-AMDEP_TRUE="$AMDEP_TRUE" ac_aux_dir="$ac_aux_dir"
+AMDEP_TRUE="$AMDEP_TRUE" MAKE="${MAKE-make}"
 
 
 # The HP-UX ksh and POSIX shell print the target directory to stdout
@@ -19071,29 +19219,35 @@ $as_echo "$as_me: executing $ac_file commands" >&6;}
   # Older Autoconf quotes --file arguments for eval, but not when files
   # are listed without --file.  Let's play safe and only enable the eval
   # if we detect the quoting.
-  case $CONFIG_FILES in
-  *\'*) eval set x "$CONFIG_FILES" ;;
-  *)   set x $CONFIG_FILES ;;
-  esac
+  # TODO: see whether this extra hack can be removed once we start
+  # requiring Autoconf 2.70 or later.
+  case $CONFIG_FILES in #(
+  *\'*) :
+    eval set x "$CONFIG_FILES" ;; #(
+  *) :
+    set x $CONFIG_FILES ;; #(
+  *) :
+     ;;
+esac
   shift
-  for mf
+  # Used to flag and report bootstrapping failures.
+  am_rc=0
+  for am_mf
   do
     # Strip MF so we end up with the name of the file.
-    mf=`echo "$mf" | sed -e 's/:.*$//'`
-    # Check whether this is an Automake generated Makefile or not.
-    # We used to match only the files named 'Makefile.in', but
-    # some people rename them; so instead we look at the file content.
-    # Grep'ing the first line is not enough: some people post-process
-    # each Makefile.in and add a new line on top of each file to say so.
-    # Grep'ing the whole file is not good either: AIX grep has a line
+    am_mf=`$as_echo "$am_mf" | sed -e 's/:.*$//'`
+    # Check whether this is an Automake generated Makefile which includes
+    # dependency-tracking related rules and includes.
+    # Grep'ing the whole file directly is not great: AIX grep has a line
     # limit of 2048, but all sed's we know have understand at least 4000.
-    if sed -n 's,^#.*generated by automake.*,X,p' "$mf" | grep X >/dev/null 2>&1; then
-      dirpart=`$as_dirname -- "$mf" ||
-$as_expr X"$mf" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
-	 X"$mf" : 'X\(//\)[^/]' \| \
-	 X"$mf" : 'X\(//\)$' \| \
-	 X"$mf" : 'X\(/\)' \| . 2>/dev/null ||
-$as_echo X"$mf" |
+    sed -n 's,^am--depfiles:.*,X,p' "$am_mf" | grep X >/dev/null 2>&1 \
+      || continue
+    am_dirpart=`$as_dirname -- "$am_mf" ||
+$as_expr X"$am_mf" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
+	 X"$am_mf" : 'X\(//\)[^/]' \| \
+	 X"$am_mf" : 'X\(//\)$' \| \
+	 X"$am_mf" : 'X\(/\)' \| . 2>/dev/null ||
+$as_echo X"$am_mf" |
     sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{
 	    s//\1/
 	    q
@@ -19111,53 +19265,48 @@ $as_echo X"$mf" |
 	    q
 	  }
 	  s/.*/./; q'`
-    else
-      continue
-    fi
-    # Extract the definition of DEPDIR, am__include, and am__quote
-    # from the Makefile without running 'make'.
-    DEPDIR=`sed -n 's/^DEPDIR = //p' < "$mf"`
-    test -z "$DEPDIR" && continue
-    am__include=`sed -n 's/^am__include = //p' < "$mf"`
-    test -z "$am__include" && continue
-    am__quote=`sed -n 's/^am__quote = //p' < "$mf"`
-    # Find all dependency output files, they are included files with
-    # $(DEPDIR) in their names.  We invoke sed twice because it is the
-    # simplest approach to changing $(DEPDIR) to its actual value in the
-    # expansion.
-    for file in `sed -n "
-      s/^$am__include $am__quote\(.*(DEPDIR).*\)$am__quote"'$/\1/p' <"$mf" | \
-	 sed -e 's/\$(DEPDIR)/'"$DEPDIR"'/g'`; do
-      # Make sure the directory exists.
-      test -f "$dirpart/$file" && continue
-      fdir=`$as_dirname -- "$file" ||
-$as_expr X"$file" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
-	 X"$file" : 'X\(//\)[^/]' \| \
-	 X"$file" : 'X\(//\)$' \| \
-	 X"$file" : 'X\(/\)' \| . 2>/dev/null ||
-$as_echo X"$file" |
-    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{
-	    s//\1/
-	    q
-	  }
-	  /^X\(\/\/\)[^/].*/{
+    am_filepart=`$as_basename -- "$am_mf" ||
+$as_expr X/"$am_mf" : '.*/\([^/][^/]*\)/*$' \| \
+	 X"$am_mf" : 'X\(//\)$' \| \
+	 X"$am_mf" : 'X\(/\)' \| . 2>/dev/null ||
+$as_echo X/"$am_mf" |
+    sed '/^.*\/\([^/][^/]*\)\/*$/{
 	    s//\1/
 	    q
 	  }
-	  /^X\(\/\/\)$/{
+	  /^X\/\(\/\/\)$/{
 	    s//\1/
 	    q
 	  }
-	  /^X\(\/\).*/{
+	  /^X\/\(\/\).*/{
 	    s//\1/
 	    q
 	  }
 	  s/.*/./; q'`
-      as_dir=$dirpart/$fdir; as_fn_mkdir_p
-      # echo "creating $dirpart/$file"
-      echo '# dummy' > "$dirpart/$file"
-    done
+    { echo "$as_me:$LINENO: cd "$am_dirpart" \
+      && sed -e '/# am--include-marker/d' "$am_filepart" \
+        | $MAKE -f - am--depfiles" >&5
+   (cd "$am_dirpart" \
+      && sed -e '/# am--include-marker/d' "$am_filepart" \
+        | $MAKE -f - am--depfiles) >&5 2>&5
+   ac_status=$?
+   echo "$as_me:$LINENO: \$? = $ac_status" >&5
+   (exit $ac_status); } || am_rc=$?
   done
+  if test $am_rc -ne 0; then
+    { { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
+$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
+as_fn_error $? "Something went wrong bootstrapping makefile fragments
+    for automatic dependency tracking.  Try re-running configure with the
+    '--disable-dependency-tracking' option to at least be able to build
+    the package (albeit without support for automatic dependency tracking).
+See \`config.log' for more details" "$LINENO" 5; }
+  fi
+  { am_dirpart=; unset am_dirpart;}
+  { am_filepart=; unset am_filepart;}
+  { am_mf=; unset am_mf;}
+  { am_rc=; unset am_rc;}
+  rm -f conftest-deps.mk
 }
  ;;
     "libtool":C)
diff --git a/include/Makefile.in b/include/Makefile.in
index a5af4d1..d19e4ef 100644
--- a/include/Makefile.in
+++ b/include/Makefile.in
@@ -1,7 +1,7 @@
-# Makefile.in generated by automake 1.14.1 from Makefile.am.
+# Makefile.in generated by automake 1.16.1 from Makefile.am.
 # @configure_input@
 
-# Copyright (C) 1994-2013 Free Software Foundation, Inc.
+# Copyright (C) 1994-2018 Free Software Foundation, Inc.
 
 # This Makefile.in is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
@@ -19,7 +19,17 @@
 # Based on a work by Bob Friesenhahn
 
 VPATH = @srcdir@
-am__is_gnu_make = test -n '$(MAKEFILE_LIST)' && test -n '$(MAKELEVEL)'
+am__is_gnu_make = { \
+  if test -z '$(MAKELEVEL)'; then \
+    false; \
+  elif test -n '$(MAKE_HOST)'; then \
+    true; \
+  elif test -n '$(MAKE_VERSION)' && test -n '$(CURDIR)'; then \
+    true; \
+  else \
+    false; \
+  fi; \
+}
 am__make_running_with_option = \
   case $${target_option-} in \
       ?) ;; \
@@ -83,15 +93,20 @@ POST_UNINSTALL = :
 build_triplet = @build@
 host_triplet = @host@
 subdir = include
-DIST_COMMON = $(srcdir)/Makefile.in $(srcdir)/Makefile.am \
-	$(include_HEADERS)
 ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
 am__aclocal_m4_deps = $(top_srcdir)/m4/acx_pthread.m4 \
+	$(top_srcdir)/m4/ax_append_compile_flags.m4 \
+	$(top_srcdir)/m4/ax_append_flag.m4 \
+	$(top_srcdir)/m4/ax_check_compile_flag.m4 \
+	$(top_srcdir)/m4/ax_gcc_func_attribute.m4 \
+	$(top_srcdir)/m4/ax_require_defined.m4 \
 	$(top_srcdir)/m4/libtool.m4 $(top_srcdir)/m4/ltoptions.m4 \
 	$(top_srcdir)/m4/ltsugar.m4 $(top_srcdir)/m4/ltversion.m4 \
 	$(top_srcdir)/m4/lt~obsolete.m4 $(top_srcdir)/configure.ac
 am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
 	$(ACLOCAL_M4)
+DIST_COMMON = $(srcdir)/Makefile.am $(include_HEADERS) \
+	$(am__DIST_COMMON)
 mkinstalldirs = $(install_sh) -d
 CONFIG_CLEAN_FILES =
 CONFIG_CLEAN_VPATH_FILES =
@@ -162,6 +177,7 @@ am__define_uniq_tagged_files = \
   done | $(am__uniquify_input)`
 ETAGS = etags
 CTAGS = ctags
+am__DIST_COMMON = $(srcdir)/Makefile.in
 DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
 ACLOCAL = @ACLOCAL@
 AMTAR = @AMTAR@
@@ -294,6 +310,7 @@ pdfdir = @pdfdir@
 prefix = @prefix@
 program_transform_name = @program_transform_name@
 psdir = @psdir@
+runstatedir = @runstatedir@
 sbindir = @sbindir@
 sharedstatedir = @sharedstatedir@
 srcdir = @srcdir@
@@ -319,14 +336,13 @@ $(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ $(srcdir)/Makefile.am  $(am__confi
 	echo ' cd $(top_srcdir) && $(AUTOMAKE) --foreign include/Makefile'; \
 	$(am__cd) $(top_srcdir) && \
 	  $(AUTOMAKE) --foreign include/Makefile
-.PRECIOUS: Makefile
 Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
 	@case '$?' in \
 	  *config.status*) \
 	    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \
 	  *) \
-	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \
-	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \
+	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__maybe_remake_depfiles)'; \
+	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__maybe_remake_depfiles);; \
 	esac;
 
 $(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
@@ -417,7 +433,10 @@ cscopelist-am: $(am__tagged_files)
 distclean-tags:
 	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
 
-distdir: $(DISTFILES)
+distdir: $(BUILT_SOURCES)
+	$(MAKE) $(AM_MAKEFLAGS) distdir-am
+
+distdir-am: $(DISTFILES)
 	@srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
 	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
 	list='$(DISTFILES)'; \
@@ -566,6 +585,8 @@ uninstall-am: uninstall-includeHEADERS
 	ps ps-am tags tags-am uninstall uninstall-am \
 	uninstall-includeHEADERS
 
+.PRECIOUS: Makefile
+
 
 # Tell versions [3.59,3.63) of GNU make to not export all variables.
 # Otherwise a system limit (for SysV at least) may be exceeded.
diff --git a/src/Makefile.in b/src/Makefile.in
index dd44d47..9af159b 100644
--- a/src/Makefile.in
+++ b/src/Makefile.in
@@ -1,7 +1,7 @@
-# Makefile.in generated by automake 1.14.1 from Makefile.am.
+# Makefile.in generated by automake 1.16.1 from Makefile.am.
 # @configure_input@
 
-# Copyright (C) 1994-2013 Free Software Foundation, Inc.
+# Copyright (C) 1994-2018 Free Software Foundation, Inc.
 
 # This Makefile.in is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
@@ -19,7 +19,17 @@
 #
 
 VPATH = @srcdir@
-am__is_gnu_make = test -n '$(MAKEFILE_LIST)' && test -n '$(MAKELEVEL)'
+am__is_gnu_make = { \
+  if test -z '$(MAKELEVEL)'; then \
+    false; \
+  elif test -n '$(MAKE_HOST)'; then \
+    true; \
+  elif test -n '$(MAKE_VERSION)' && test -n '$(CURDIR)'; then \
+    true; \
+  else \
+    false; \
+  fi; \
+}
 am__make_running_with_option = \
   case $${target_option-} in \
       ?) ;; \
@@ -83,15 +93,19 @@ POST_UNINSTALL = :
 build_triplet = @build@
 host_triplet = @host@
 subdir = src
-DIST_COMMON = $(srcdir)/Makefile.in $(srcdir)/Makefile.am \
-	$(top_srcdir)/depcomp
 ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
 am__aclocal_m4_deps = $(top_srcdir)/m4/acx_pthread.m4 \
+	$(top_srcdir)/m4/ax_append_compile_flags.m4 \
+	$(top_srcdir)/m4/ax_append_flag.m4 \
+	$(top_srcdir)/m4/ax_check_compile_flag.m4 \
+	$(top_srcdir)/m4/ax_gcc_func_attribute.m4 \
+	$(top_srcdir)/m4/ax_require_defined.m4 \
 	$(top_srcdir)/m4/libtool.m4 $(top_srcdir)/m4/ltoptions.m4 \
 	$(top_srcdir)/m4/ltsugar.m4 $(top_srcdir)/m4/ltversion.m4 \
 	$(top_srcdir)/m4/lt~obsolete.m4 $(top_srcdir)/configure.ac
 am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
 	$(ACLOCAL_M4)
+DIST_COMMON = $(srcdir)/Makefile.am $(am__DIST_COMMON)
 mkinstalldirs = $(install_sh) -d
 CONFIG_CLEAN_FILES =
 CONFIG_CLEAN_VPATH_FILES =
@@ -154,7 +168,21 @@ am__v_at_0 = @
 am__v_at_1 = 
 DEFAULT_INCLUDES = -I.@am__isrc@
 depcomp = $(SHELL) $(top_srcdir)/depcomp
-am__depfiles_maybe = depfiles
+am__maybe_remake_depfiles = depfiles
+am__depfiles_remade = ./$(DEPDIR)/cmsalpha.Plo \
+	./$(DEPDIR)/cmscam02.Plo ./$(DEPDIR)/cmscgats.Plo \
+	./$(DEPDIR)/cmscnvrt.Plo ./$(DEPDIR)/cmserr.Plo \
+	./$(DEPDIR)/cmsgamma.Plo ./$(DEPDIR)/cmsgmt.Plo \
+	./$(DEPDIR)/cmshalf.Plo ./$(DEPDIR)/cmsintrp.Plo \
+	./$(DEPDIR)/cmsio0.Plo ./$(DEPDIR)/cmsio1.Plo \
+	./$(DEPDIR)/cmslut.Plo ./$(DEPDIR)/cmsmd5.Plo \
+	./$(DEPDIR)/cmsmtrx.Plo ./$(DEPDIR)/cmsnamed.Plo \
+	./$(DEPDIR)/cmsopt.Plo ./$(DEPDIR)/cmspack.Plo \
+	./$(DEPDIR)/cmspcs.Plo ./$(DEPDIR)/cmsplugin.Plo \
+	./$(DEPDIR)/cmsps2.Plo ./$(DEPDIR)/cmssamp.Plo \
+	./$(DEPDIR)/cmssm.Plo ./$(DEPDIR)/cmstypes.Plo \
+	./$(DEPDIR)/cmsvirt.Plo ./$(DEPDIR)/cmswtpnt.Plo \
+	./$(DEPDIR)/cmsxform.Plo
 am__mv = mv -f
 COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \
 	$(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
@@ -200,6 +228,7 @@ am__define_uniq_tagged_files = \
   done | $(am__uniquify_input)`
 ETAGS = etags
 CTAGS = ctags
+am__DIST_COMMON = $(srcdir)/Makefile.in $(top_srcdir)/depcomp
 DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
 ACLOCAL = @ACLOCAL@
 AMTAR = @AMTAR@
@@ -334,6 +363,7 @@ pdfdir = @pdfdir@
 prefix = @prefix@
 program_transform_name = @program_transform_name@
 psdir = @psdir@
+runstatedir = @runstatedir@
 sbindir = @sbindir@
 sharedstatedir = @sharedstatedir@
 srcdir = @srcdir@
@@ -375,14 +405,13 @@ $(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ $(srcdir)/Makefile.am  $(am__confi
 	echo ' cd $(top_srcdir) && $(AUTOMAKE) --foreign src/Makefile'; \
 	$(am__cd) $(top_srcdir) && \
 	  $(AUTOMAKE) --foreign src/Makefile
-.PRECIOUS: Makefile
 Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
 	@case '$?' in \
 	  *config.status*) \
 	    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \
 	  *) \
-	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \
-	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \
+	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__maybe_remake_depfiles)'; \
+	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__maybe_remake_depfiles);; \
 	esac;
 
 $(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
@@ -438,32 +467,38 @@ mostlyclean-compile:
 distclean-compile:
 	-rm -f *.tab.c
 
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cmsalpha.Plo@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cmscam02.Plo@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cmscgats.Plo@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cmscnvrt.Plo@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cmserr.Plo@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cmsgamma.Plo@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cmsgmt.Plo@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cmshalf.Plo@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cmsintrp.Plo@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cmsio0.Plo@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cmsio1.Plo@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cmslut.Plo@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cmsmd5.Plo@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cmsmtrx.Plo@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cmsnamed.Plo@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cmsopt.Plo@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cmspack.Plo@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cmspcs.Plo@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cmsplugin.Plo@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cmsps2.Plo@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cmssamp.Plo@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cmssm.Plo@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cmstypes.Plo@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cmsvirt.Plo@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cmswtpnt.Plo@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cmsxform.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cmsalpha.Plo@am__quote@ # am--include-marker
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cmscam02.Plo@am__quote@ # am--include-marker
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cmscgats.Plo@am__quote@ # am--include-marker
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cmscnvrt.Plo@am__quote@ # am--include-marker
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cmserr.Plo@am__quote@ # am--include-marker
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cmsgamma.Plo@am__quote@ # am--include-marker
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cmsgmt.Plo@am__quote@ # am--include-marker
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cmshalf.Plo@am__quote@ # am--include-marker
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cmsintrp.Plo@am__quote@ # am--include-marker
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cmsio0.Plo@am__quote@ # am--include-marker
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cmsio1.Plo@am__quote@ # am--include-marker
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cmslut.Plo@am__quote@ # am--include-marker
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cmsmd5.Plo@am__quote@ # am--include-marker
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cmsmtrx.Plo@am__quote@ # am--include-marker
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cmsnamed.Plo@am__quote@ # am--include-marker
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cmsopt.Plo@am__quote@ # am--include-marker
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cmspack.Plo@am__quote@ # am--include-marker
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cmspcs.Plo@am__quote@ # am--include-marker
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cmsplugin.Plo@am__quote@ # am--include-marker
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cmsps2.Plo@am__quote@ # am--include-marker
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cmssamp.Plo@am__quote@ # am--include-marker
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cmssm.Plo@am__quote@ # am--include-marker
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cmstypes.Plo@am__quote@ # am--include-marker
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cmsvirt.Plo@am__quote@ # am--include-marker
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cmswtpnt.Plo@am__quote@ # am--include-marker
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cmsxform.Plo@am__quote@ # am--include-marker
+
+$(am__depfiles_remade):
+	@$(MKDIR_P) $(@D)
+	@echo '# dummy' >$@-t && $(am__mv) $@-t $@
+
+am--depfiles: $(am__depfiles_remade)
 
 .c.o:
 @am__fastdepCC_TRUE@	$(AM_V_CC)depbase=`echo $@ | sed 's|[^/]*$$|$(DEPDIR)/&|;s|\.o$$||'`;\
@@ -547,7 +582,10 @@ cscopelist-am: $(am__tagged_files)
 distclean-tags:
 	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
 
-distdir: $(DISTFILES)
+distdir: $(BUILT_SOURCES)
+	$(MAKE) $(AM_MAKEFLAGS) distdir-am
+
+distdir-am: $(DISTFILES)
 	@srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
 	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
 	list='$(DISTFILES)'; \
@@ -620,7 +658,32 @@ clean-am: clean-generic clean-libLTLIBRARIES clean-libtool \
 	mostlyclean-am
 
 distclean: distclean-am
-	-rm -rf ./$(DEPDIR)
+		-rm -f ./$(DEPDIR)/cmsalpha.Plo
+	-rm -f ./$(DEPDIR)/cmscam02.Plo
+	-rm -f ./$(DEPDIR)/cmscgats.Plo
+	-rm -f ./$(DEPDIR)/cmscnvrt.Plo
+	-rm -f ./$(DEPDIR)/cmserr.Plo
+	-rm -f ./$(DEPDIR)/cmsgamma.Plo
+	-rm -f ./$(DEPDIR)/cmsgmt.Plo
+	-rm -f ./$(DEPDIR)/cmshalf.Plo
+	-rm -f ./$(DEPDIR)/cmsintrp.Plo
+	-rm -f ./$(DEPDIR)/cmsio0.Plo
+	-rm -f ./$(DEPDIR)/cmsio1.Plo
+	-rm -f ./$(DEPDIR)/cmslut.Plo
+	-rm -f ./$(DEPDIR)/cmsmd5.Plo
+	-rm -f ./$(DEPDIR)/cmsmtrx.Plo
+	-rm -f ./$(DEPDIR)/cmsnamed.Plo
+	-rm -f ./$(DEPDIR)/cmsopt.Plo
+	-rm -f ./$(DEPDIR)/cmspack.Plo
+	-rm -f ./$(DEPDIR)/cmspcs.Plo
+	-rm -f ./$(DEPDIR)/cmsplugin.Plo
+	-rm -f ./$(DEPDIR)/cmsps2.Plo
+	-rm -f ./$(DEPDIR)/cmssamp.Plo
+	-rm -f ./$(DEPDIR)/cmssm.Plo
+	-rm -f ./$(DEPDIR)/cmstypes.Plo
+	-rm -f ./$(DEPDIR)/cmsvirt.Plo
+	-rm -f ./$(DEPDIR)/cmswtpnt.Plo
+	-rm -f ./$(DEPDIR)/cmsxform.Plo
 	-rm -f Makefile
 distclean-am: clean-am distclean-compile distclean-generic \
 	distclean-tags
@@ -666,7 +729,32 @@ install-ps-am:
 installcheck-am:
 
 maintainer-clean: maintainer-clean-am
-	-rm -rf ./$(DEPDIR)
+		-rm -f ./$(DEPDIR)/cmsalpha.Plo
+	-rm -f ./$(DEPDIR)/cmscam02.Plo
+	-rm -f ./$(DEPDIR)/cmscgats.Plo
+	-rm -f ./$(DEPDIR)/cmscnvrt.Plo
+	-rm -f ./$(DEPDIR)/cmserr.Plo
+	-rm -f ./$(DEPDIR)/cmsgamma.Plo
+	-rm -f ./$(DEPDIR)/cmsgmt.Plo
+	-rm -f ./$(DEPDIR)/cmshalf.Plo
+	-rm -f ./$(DEPDIR)/cmsintrp.Plo
+	-rm -f ./$(DEPDIR)/cmsio0.Plo
+	-rm -f ./$(DEPDIR)/cmsio1.Plo
+	-rm -f ./$(DEPDIR)/cmslut.Plo
+	-rm -f ./$(DEPDIR)/cmsmd5.Plo
+	-rm -f ./$(DEPDIR)/cmsmtrx.Plo
+	-rm -f ./$(DEPDIR)/cmsnamed.Plo
+	-rm -f ./$(DEPDIR)/cmsopt.Plo
+	-rm -f ./$(DEPDIR)/cmspack.Plo
+	-rm -f ./$(DEPDIR)/cmspcs.Plo
+	-rm -f ./$(DEPDIR)/cmsplugin.Plo
+	-rm -f ./$(DEPDIR)/cmsps2.Plo
+	-rm -f ./$(DEPDIR)/cmssamp.Plo
+	-rm -f ./$(DEPDIR)/cmssm.Plo
+	-rm -f ./$(DEPDIR)/cmstypes.Plo
+	-rm -f ./$(DEPDIR)/cmsvirt.Plo
+	-rm -f ./$(DEPDIR)/cmswtpnt.Plo
+	-rm -f ./$(DEPDIR)/cmsxform.Plo
 	-rm -f Makefile
 maintainer-clean-am: distclean-am maintainer-clean-generic
 
@@ -687,9 +775,9 @@ uninstall-am: uninstall-libLTLIBRARIES
 
 .MAKE: install-am install-strip
 
-.PHONY: CTAGS GTAGS TAGS all all-am check check-am clean clean-generic \
-	clean-libLTLIBRARIES clean-libtool cscopelist-am ctags \
-	ctags-am distclean distclean-compile distclean-generic \
+.PHONY: CTAGS GTAGS TAGS all all-am am--depfiles check check-am clean \
+	clean-generic clean-libLTLIBRARIES clean-libtool cscopelist-am \
+	ctags ctags-am distclean distclean-compile distclean-generic \
 	distclean-libtool distclean-tags distdir dvi dvi-am html \
 	html-am info info-am install install-am install-data \
 	install-data-am install-dvi install-dvi-am install-exec \
@@ -701,6 +789,8 @@ uninstall-am: uninstall-libLTLIBRARIES
 	mostlyclean-generic mostlyclean-libtool pdf pdf-am ps ps-am \
 	tags tags-am uninstall uninstall-am uninstall-libLTLIBRARIES
 
+.PRECIOUS: Makefile
+
 
 # Tell versions [3.59,3.63) of GNU make to not export all variables.
 # Otherwise a system limit (for SysV at least) may be exceeded.
diff --git a/src/cmsalpha.c b/src/cmsalpha.c
index 471d9a5..126e38c 100644
--- a/src/cmsalpha.c
+++ b/src/cmsalpha.c
@@ -1,3 +1,7 @@
+#ifdef FRCOV
+#include <stdio.h>
+extern short FIXREVERTER[];
+#endif
 //---------------------------------------------------------------------------------
 //
 //  Little Color Management System
@@ -47,8 +51,23 @@ int trueBytesSize(cmsUInt32Number Format)
        int fmt_bytes = T_BYTES(Format);
 
        // For double, the T_BYTES field returns zero
-       if (fmt_bytes == 0)
+       
+       #ifdef FRCOV
+       {if (FIXREVERTER[417]) {
+         if ((fmt_bytes == 0 ) && !(0))
+           fprintf(stderr, "triggered bug index 417\n");
+         else
+           fprintf(stderr, "reached bug index 417\n");
+       }
+       if ((!FIXREVERTER[417] && (fmt_bytes == 0 ))
+       #else
+       if (0
+       #endif
+       )
               return sizeof(double);
+              #ifdef FRCOV
+              }
+              #endif
       
        // Otherwise, it is already correct for all formats
        return fmt_bytes;
@@ -306,11 +325,26 @@ static cmsFormatterAlphaFn FormattersAlpha[5][5] = {
         int in_n  = FormatterPos(in);
         int out_n = FormatterPos(out);
 
-        if (in_n < 0 || out_n < 0 || in_n > 4 || out_n > 4) {
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[418]) {
+          if ((in_n < 0 || out_n < 0 || in_n > 4 || out_n > 4 ) && !(0))
+            fprintf(stderr, "triggered bug index 418\n");
+          else
+            fprintf(stderr, "reached bug index 418\n");
+        }
+        if ((!FIXREVERTER[418] && (in_n < 0 || out_n < 0 || in_n > 4 || out_n > 4 ))
+        #else
+        if (0
+        #endif
+        ) {
 
                cmsSignalError(id, cmsERROR_UNKNOWN_EXTENSION, "Unrecognized alpha channel width");
                return NULL;
         }
+        #ifdef FRCOV
+        }
+        #endif
 
         return FormattersAlpha[in_n][out_n];
 }
@@ -332,8 +366,23 @@ void ComputeIncrementsForChunky(cmsUInt32Number Format,
        int pixelSize = channelSize * total_chans;
        
 	   // Sanity check
-	   if (total_chans <= 0 || total_chans >= cmsMAXCHANNELS)
+	   
+	   #ifdef FRCOV
+	   {if (FIXREVERTER[419]) {
+	     if ((total_chans <= 0 || total_chans >= 16 ) && !(0))
+	       fprintf(stderr, "triggered bug index 419\n");
+	     else
+	       fprintf(stderr, "reached bug index 419\n");
+	   }
+	   if ((!FIXREVERTER[419] && (total_chans <= 0 || total_chans >= 16 ))
+	   #else
+	   if (0
+	   #endif
+	   )
 		   return;
+		   #ifdef FRCOV
+		   }
+		   #endif
 
         memset(channels, 0, sizeof(channels));
 
@@ -389,8 +438,23 @@ void ComputeIncrementsForPlanar(cmsUInt32Number Format,
        int channelSize = trueBytesSize(Format);
       
        // Sanity check
-       if (total_chans <= 0 || total_chans >= cmsMAXCHANNELS)
+       
+       #ifdef FRCOV
+       {if (FIXREVERTER[420]) {
+         if ((total_chans <= 0 || total_chans >= 16 ) && !(0))
+           fprintf(stderr, "triggered bug index 420\n");
+         else
+           fprintf(stderr, "reached bug index 420\n");
+       }
+       if ((!FIXREVERTER[420] && (total_chans <= 0 || total_chans >= 16 ))
+       #else
+       if (0
+       #endif
+       )
            return;
+           #ifdef FRCOV
+           }
+           #endif
 
        memset(channels, 0, sizeof(channels));
 
diff --git a/src/cmscnvrt.c b/src/cmscnvrt.c
index 6c92148..bf12631 100644
--- a/src/cmscnvrt.c
+++ b/src/cmscnvrt.c
@@ -1,3 +1,7 @@
+#ifdef FRCOV
+#include <stdio.h>
+extern short FIXREVERTER[];
+#endif
 //---------------------------------------------------------------------------------
 //
 //  Little Color Management System
@@ -542,7 +546,22 @@ cmsPipeline* DefaultICCintents(cmsContext       ContextID,
 
     // Allocate an empty LUT for holding the result. 0 as channel count means 'undefined'
     Result = cmsPipelineAlloc(ContextID, 0, 0);
-    if (Result == NULL) return NULL;
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[373]) {
+      if ((Result == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 373\n");
+      else
+        fprintf(stderr, "reached bug index 373\n");
+    }
+    if ((!FIXREVERTER[373] && (Result == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) return NULL;
+    #ifdef FRCOV
+    }
+    #endif
 
     CurrentColorSpace = cmsGetColorSpace(hProfiles[0]);
 
@@ -589,7 +608,22 @@ cmsPipeline* DefaultICCintents(cmsContext       ContextID,
 
             // Get the involved LUT from the profile
             Lut = _cmsReadDevicelinkLUT(hProfile, Intent);
-            if (Lut == NULL) goto Error;
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[374]) {
+              if ((Lut == (void *) 0 ) && !(0))
+                fprintf(stderr, "triggered bug index 374\n");
+              else
+                fprintf(stderr, "reached bug index 374\n");
+            }
+            if ((!FIXREVERTER[374] && (Lut == (void *) 0 ))
+            #else
+            if (0
+            #endif
+            ) goto Error;
+            #ifdef FRCOV
+            }
+            #endif
 
             // What about abstract profiles?
              if (ClassSig == cmsSigAbstractClass && i > 0) {
@@ -615,7 +649,22 @@ cmsPipeline* DefaultICCintents(cmsContext       ContextID,
 
                 // Output direction means PCS connection. Intent may apply here
                 Lut = _cmsReadOutputLUT(hProfile, Intent);
-                if (Lut == NULL) goto Error;
+                
+                #ifdef FRCOV
+                {if (FIXREVERTER[376]) {
+                  if ((Lut == (void *) 0 ) && !(0))
+                    fprintf(stderr, "triggered bug index 376\n");
+                  else
+                    fprintf(stderr, "reached bug index 376\n");
+                }
+                if ((!FIXREVERTER[376] && (Lut == (void *) 0 ))
+                #else
+                if (0
+                #endif
+                ) goto Error;
+                #ifdef FRCOV
+                }
+                #endif
 
 
                 if (!ComputeConversion(i, hProfiles, Intent, BPC[i], AdaptationStates[i], &m, &off)) goto Error;
@@ -643,7 +692,22 @@ cmsPipeline* DefaultICCintents(cmsContext       ContextID,
                   ColorSpaceOut == cmsSigCmykData) {
 
                   cmsStage* clip = _cmsStageClipNegatives(Result->ContextID, cmsChannelsOf(ColorSpaceOut));
-                  if (clip == NULL) goto Error;
+                  
+                  #ifdef FRCOV
+                  {if (FIXREVERTER[377]) {
+                    if ((clip == (void *) 0 ) && !(0))
+                      fprintf(stderr, "triggered bug index 377\n");
+                    else
+                      fprintf(stderr, "reached bug index 377\n");
+                  }
+                  if ((!FIXREVERTER[377] && (clip == (void *) 0 ))
+                  #else
+                  if (0
+                  #endif
+                  ) goto Error;
+                  #ifdef FRCOV
+                  }
+                  #endif
 
                   if (!cmsPipelineInsertStage(Result, cmsAT_END, clip))
                          goto Error;
@@ -745,7 +809,22 @@ cmsPipeline*  BlackPreservingKOnlyIntents(cmsContext     ContextID,
 
 
     // Sanity check
-    if (nProfiles < 1 || nProfiles > 255) return NULL;
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[378]) {
+      if ((nProfiles < 1 || nProfiles > 255 ) && !(0))
+        fprintf(stderr, "triggered bug index 378\n");
+      else
+        fprintf(stderr, "reached bug index 378\n");
+    }
+    if ((!FIXREVERTER[378] && (nProfiles < 1 || nProfiles > 255 ))
+    #else
+    if (0
+    #endif
+    ) return NULL;
+    #ifdef FRCOV
+    }
+    #endif
 
     // Translate black-preserving intents to ICC ones
     for (i=0; i < nProfiles; i++)
@@ -760,7 +839,22 @@ cmsPipeline*  BlackPreservingKOnlyIntents(cmsContext     ContextID,
 
     // Allocate an empty LUT for holding the result
     Result = cmsPipelineAlloc(ContextID, 4, 4);
-    if (Result == NULL) return NULL;
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[379]) {
+      if ((Result == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 379\n");
+      else
+        fprintf(stderr, "reached bug index 379\n");
+    }
+    if ((!FIXREVERTER[379] && (Result == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) return NULL;
+    #ifdef FRCOV
+    }
+    #endif
 
     // Create a LUT holding normal ICC transform
     bp.cmyk2cmyk = DefaultICCintents(ContextID,
@@ -771,7 +865,22 @@ cmsPipeline*  BlackPreservingKOnlyIntents(cmsContext     ContextID,
         AdaptationStates,
         dwFlags);
 
-    if (bp.cmyk2cmyk == NULL) goto Error;
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[380]) {
+      if ((bp . cmyk2cmyk == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 380\n");
+      else
+        fprintf(stderr, "reached bug index 380\n");
+    }
+    if ((!FIXREVERTER[380] && (bp . cmyk2cmyk == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) goto Error;
+    #ifdef FRCOV
+    }
+    #endif
 
     // Now, compute the tone curve
     bp.KTone = _cmsBuildKToneCurve(ContextID,
@@ -783,7 +892,22 @@ cmsPipeline*  BlackPreservingKOnlyIntents(cmsContext     ContextID,
         AdaptationStates,
         dwFlags);
 
-    if (bp.KTone == NULL) goto Error;
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[381]) {
+      if ((bp . KTone == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 381\n");
+      else
+        fprintf(stderr, "reached bug index 381\n");
+    }
+    if ((!FIXREVERTER[381] && (bp . KTone == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) goto Error;
+    #ifdef FRCOV
+    }
+    #endif
 
 
     // How many gridpoints are we going to use?
@@ -791,7 +915,22 @@ cmsPipeline*  BlackPreservingKOnlyIntents(cmsContext     ContextID,
 
     // Create the CLUT. 16 bits
     CLUT = cmsStageAllocCLut16bit(ContextID, nGridPoints, 4, 4, NULL);
-    if (CLUT == NULL) goto Error;
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[382]) {
+      if ((CLUT == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 382\n");
+      else
+        fprintf(stderr, "reached bug index 382\n");
+    }
+    if ((!FIXREVERTER[382] && (CLUT == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) goto Error;
+    #ifdef FRCOV
+    }
+    #endif
 
     // This is the one and only MPE in this LUT
     if (!cmsPipelineInsertStage(Result, cmsAT_BEGIN, CLUT))
@@ -937,7 +1076,22 @@ cmsPipeline* BlackPreservingKPlaneIntents(cmsContext     ContextID,
     cmsHPROFILE hLab;
 
     // Sanity check
-    if (nProfiles < 1 || nProfiles > 255) return NULL;
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[383]) {
+      if ((nProfiles < 1 || nProfiles > 255 ) && !(0))
+        fprintf(stderr, "triggered bug index 383\n");
+      else
+        fprintf(stderr, "reached bug index 383\n");
+    }
+    if ((!FIXREVERTER[383] && (nProfiles < 1 || nProfiles > 255 ))
+    #else
+    if (0
+    #endif
+    ) return NULL;
+    #ifdef FRCOV
+    }
+    #endif
 
     // Translate black-preserving intents to ICC ones
     for (i=0; i < nProfiles; i++)
@@ -951,7 +1105,22 @@ cmsPipeline* BlackPreservingKPlaneIntents(cmsContext     ContextID,
 
     // Allocate an empty LUT for holding the result
     Result = cmsPipelineAlloc(ContextID, 4, 4);
-    if (Result == NULL) return NULL;
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[384]) {
+      if ((Result == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 384\n");
+      else
+        fprintf(stderr, "reached bug index 384\n");
+    }
+    if ((!FIXREVERTER[384] && (Result == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) return NULL;
+    #ifdef FRCOV
+    }
+    #endif
 
 
     memset(&bp, 0, sizeof(bp));
@@ -959,7 +1128,22 @@ cmsPipeline* BlackPreservingKPlaneIntents(cmsContext     ContextID,
     // We need the input LUT of the last profile, assuming this one is responsible of
     // black generation. This LUT will be searched in inverse order.
     bp.LabK2cmyk = _cmsReadInputLUT(hProfiles[nProfiles-1], INTENT_RELATIVE_COLORIMETRIC);
-    if (bp.LabK2cmyk == NULL) goto Cleanup;
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[385]) {
+      if ((bp . LabK2cmyk == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 385\n");
+      else
+        fprintf(stderr, "reached bug index 385\n");
+    }
+    if ((!FIXREVERTER[385] && (bp . LabK2cmyk == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) goto Cleanup;
+    #ifdef FRCOV
+    }
+    #endif
 
     // Get total area coverage (in 0..1 domain)
     bp.MaxTAC = cmsDetectTAC(hProfiles[nProfiles-1]) / 100.0;
@@ -974,7 +1158,22 @@ cmsPipeline* BlackPreservingKPlaneIntents(cmsContext     ContextID,
                                          BPC,
                                          AdaptationStates,
                                          dwFlags);
-    if (bp.cmyk2cmyk == NULL) goto Cleanup;
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[386]) {
+      if ((bp . cmyk2cmyk == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 386\n");
+      else
+        fprintf(stderr, "reached bug index 386\n");
+    }
+    if ((!FIXREVERTER[386] && (bp . cmyk2cmyk == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) goto Cleanup;
+    #ifdef FRCOV
+    }
+    #endif
 
     // Now the tone curve
     bp.KTone = _cmsBuildKToneCurve(ContextID, 4096, nProfiles,
@@ -983,7 +1182,22 @@ cmsPipeline* BlackPreservingKPlaneIntents(cmsContext     ContextID,
                                    BPC,
                                    AdaptationStates,
                                    dwFlags);
-    if (bp.KTone == NULL) goto Cleanup;
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[387]) {
+      if ((bp . KTone == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 387\n");
+      else
+        fprintf(stderr, "reached bug index 387\n");
+    }
+    if ((!FIXREVERTER[387] && (bp . KTone == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) goto Cleanup;
+    #ifdef FRCOV
+    }
+    #endif
 
     // To measure the output, Last profile to Lab
     hLab = cmsCreateLab4ProfileTHR(ContextID, NULL);
@@ -991,7 +1205,22 @@ cmsPipeline* BlackPreservingKPlaneIntents(cmsContext     ContextID,
                                          CHANNELS_SH(4)|BYTES_SH(2), hLab, TYPE_Lab_DBL,
                                          INTENT_RELATIVE_COLORIMETRIC,
                                          cmsFLAGS_NOCACHE|cmsFLAGS_NOOPTIMIZE);
-    if ( bp.hProofOutput == NULL) goto Cleanup;
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[388]) {
+      if ((bp . hProofOutput == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 388\n");
+      else
+        fprintf(stderr, "reached bug index 388\n");
+    }
+    if ((!FIXREVERTER[388] && (bp . hProofOutput == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) goto Cleanup;
+    #ifdef FRCOV
+    }
+    #endif
 
     // Same as anterior, but lab in the 0..1 range
     bp.cmyk2Lab = cmsCreateTransformTHR(ContextID, hProfiles[nProfiles-1],
@@ -999,7 +1228,22 @@ cmsPipeline* BlackPreservingKPlaneIntents(cmsContext     ContextID,
                                          FLOAT_SH(1)|CHANNELS_SH(3)|BYTES_SH(4),
                                          INTENT_RELATIVE_COLORIMETRIC,
                                          cmsFLAGS_NOCACHE|cmsFLAGS_NOOPTIMIZE);
-    if (bp.cmyk2Lab == NULL) goto Cleanup;
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[389]) {
+      if ((bp . cmyk2Lab == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 389\n");
+      else
+        fprintf(stderr, "reached bug index 389\n");
+    }
+    if ((!FIXREVERTER[389] && (bp . cmyk2Lab == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) goto Cleanup;
+    #ifdef FRCOV
+    }
+    #endif
     cmsCloseProfile(hLab);
 
     // Error estimation (for debug only)
@@ -1010,7 +1254,22 @@ cmsPipeline* BlackPreservingKPlaneIntents(cmsContext     ContextID,
 
 
     CLUT = cmsStageAllocCLut16bit(ContextID, nGridPoints, 4, 4, NULL);
-    if (CLUT == NULL) goto Cleanup;
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[390]) {
+      if ((CLUT == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 390\n");
+      else
+        fprintf(stderr, "reached bug index 390\n");
+    }
+    if ((!FIXREVERTER[390] && (CLUT == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) goto Cleanup;
+    #ifdef FRCOV
+    }
+    #endif
 
     if (!cmsPipelineInsertStage(Result, cmsAT_BEGIN, CLUT))
         goto Cleanup;
@@ -1046,10 +1305,25 @@ cmsPipeline* _cmsLinkProfiles(cmsContext     ContextID,
     cmsIntentsList* Intent;
 
     // Make sure a reasonable number of profiles is provided
-    if (nProfiles <= 0 || nProfiles > 255) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[391]) {
+      if ((nProfiles <= 0 || nProfiles > 255 ) && !(0))
+        fprintf(stderr, "triggered bug index 391\n");
+      else
+        fprintf(stderr, "reached bug index 391\n");
+    }
+    if ((!FIXREVERTER[391] && (nProfiles <= 0 || nProfiles > 255 ))
+    #else
+    if (0
+    #endif
+    ) {
          cmsSignalError(ContextID, cmsERROR_RANGE, "Couldn't link '%d' profiles", nProfiles);
         return NULL;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
     for (i=0; i < nProfiles; i++) {
 
@@ -1075,10 +1349,25 @@ cmsPipeline* _cmsLinkProfiles(cmsContext     ContextID,
     // preserve primaries. This solution is not perfect, but works well on most cases.
 
     Intent = SearchIntent(ContextID, TheIntents[0]);
-    if (Intent == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[392]) {
+      if ((Intent == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 392\n");
+      else
+        fprintf(stderr, "reached bug index 392\n");
+    }
+    if ((!FIXREVERTER[392] && (Intent == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         cmsSignalError(ContextID, cmsERROR_UNKNOWN_EXTENSION, "Unsupported intent '%d'", TheIntents[0]);
         return NULL;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
     // Call the handler
     return Intent ->Link(ContextID, nProfiles, TheIntents, hProfiles, BPC, AdaptationStates, dwFlags);
diff --git a/src/cmserr.c b/src/cmserr.c
index 8fb1a9e..babb061 100644
--- a/src/cmserr.c
+++ b/src/cmserr.c
@@ -1,3 +1,7 @@
+#ifdef FRCOV
+#include <stdio.h>
+extern short FIXREVERTER[];
+#endif
 //---------------------------------------------------------------------------------
 //
 //  Little Color Management System
@@ -104,7 +108,22 @@ static
 void* _cmsMallocZeroDefaultFn(cmsContext ContextID, cmsUInt32Number size)
 {
     void *pt = _cmsMalloc(ContextID, size);
-    if (pt == NULL) return NULL;
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[294]) {
+      if ((pt == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 294\n");
+      else
+        fprintf(stderr, "reached bug index 294\n");
+    }
+    if ((!FIXREVERTER[294] && (pt == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) return NULL;
+    #ifdef FRCOV
+    }
+    #endif
 
     memset(pt, 0, size);
     return pt;
diff --git a/src/cmsgamma.c b/src/cmsgamma.c
index 3d59105..a0e3231 100644
--- a/src/cmsgamma.c
+++ b/src/cmsgamma.c
@@ -1,3 +1,7 @@
+#ifdef FRCOV
+#include <stdio.h>
+extern short FIXREVERTER[];
+#endif
 //---------------------------------------------------------------------------------
 //
 //  Little Color Management System
@@ -217,10 +221,25 @@ cmsToneCurve* AllocateToneCurveStruct(cmsContext ContextID, cmsInt32Number nEntr
     int i;
 
     // We allow huge tables, which are then restricted for smoothing operations
-    if (nEntries > 65530 || nEntries < 0) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[128]) {
+      if ((nEntries > 65530 || nEntries < 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 128\n");
+      else
+        fprintf(stderr, "reached bug index 128\n");
+    }
+    if ((!FIXREVERTER[128] && (nEntries > 65530 || nEntries < 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         cmsSignalError(ContextID, cmsERROR_RANGE, "Couldn't create tone curve of more than 65530 entries");
         return NULL;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
     if (nEntries <= 0 && nSegments <= 0) {
         cmsSignalError(ContextID, cmsERROR_RANGE, "Couldn't create tone curve with zero segments and no table");
@@ -238,10 +257,40 @@ cmsToneCurve* AllocateToneCurveStruct(cmsContext ContextID, cmsInt32Number nEntr
     }
     else {
         p ->Segments = (cmsCurveSegment*) _cmsCalloc(ContextID, nSegments, sizeof(cmsCurveSegment));
-        if (p ->Segments == NULL) goto Error;
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[129]) {
+          if ((p -> Segments == (void *) 0 ) && !(0))
+            fprintf(stderr, "triggered bug index 129\n");
+          else
+            fprintf(stderr, "reached bug index 129\n");
+        }
+        if ((!FIXREVERTER[129] && (p -> Segments == (void *) 0 ))
+        #else
+        if (0
+        #endif
+        ) goto Error;
+        #ifdef FRCOV
+        }
+        #endif
 
         p ->Evals    = (cmsParametricCurveEvaluator*) _cmsCalloc(ContextID, nSegments, sizeof(cmsParametricCurveEvaluator));
-        if (p ->Evals == NULL) goto Error;
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[130]) {
+          if ((p -> Evals == (void *) 0 ) && !(0))
+            fprintf(stderr, "triggered bug index 130\n");
+          else
+            fprintf(stderr, "reached bug index 130\n");
+        }
+        if ((!FIXREVERTER[130] && (p -> Evals == (void *) 0 ))
+        #else
+        if (0
+        #endif
+        ) goto Error;
+        #ifdef FRCOV
+        }
+        #endif
     }
 
     p -> nSegments = nSegments;
@@ -253,7 +302,22 @@ cmsToneCurve* AllocateToneCurveStruct(cmsContext ContextID, cmsInt32Number nEntr
     }
     else {
        p ->Table16 = (cmsUInt16Number*)  _cmsCalloc(ContextID, nEntries, sizeof(cmsUInt16Number));
-       if (p ->Table16 == NULL) goto Error;
+       
+       #ifdef FRCOV
+       {if (FIXREVERTER[131]) {
+         if ((p -> Table16 == (void *) 0 ) && !(0))
+           fprintf(stderr, "triggered bug index 131\n");
+         else
+           fprintf(stderr, "reached bug index 131\n");
+       }
+       if ((!FIXREVERTER[131] && (p -> Table16 == (void *) 0 ))
+       #else
+       if (0
+       #endif
+       ) goto Error;
+       #ifdef FRCOV
+       }
+       #endif
     }
 
     p -> nEntries  = nEntries;
@@ -267,12 +331,42 @@ cmsToneCurve* AllocateToneCurveStruct(cmsContext ContextID, cmsInt32Number nEntr
 
     // Initialize the segments stuff. The evaluator for each segment is located and a pointer to it
     // is placed in advance to maximize performance.
-    if (Segments != NULL && (nSegments > 0)) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[134]) {
+      fprintf(stderr, "reached bug index 134\n");
+    }
+    if ((FIXREVERTER[134] && (Segments != (void *) 0 )) || (!FIXREVERTER[134] && (Segments != (void *) 0 && nSegments > 0 ))
+    #else
+    if (Segments != (void *) 0 
+    #endif
+    ) {
+      
+    #ifdef FRCOV
+      if (!(nSegments > 0 ))
+        fprintf(stderr, "triggered bug index 134\n");
+      #endif
+    
 
         _cmsParametricCurvesCollection *c;
 
         p ->SegInterp = (cmsInterpParams**) _cmsCalloc(ContextID, nSegments, sizeof(cmsInterpParams*));
-        if (p ->SegInterp == NULL) goto Error;
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[133]) {
+          if ((p -> SegInterp == (void *) 0 ) && !(0))
+            fprintf(stderr, "triggered bug index 133\n");
+          else
+            fprintf(stderr, "reached bug index 133\n");
+        }
+        if ((!FIXREVERTER[133] && (p -> SegInterp == (void *) 0 ))
+        #else
+        if (0
+        #endif
+        ) goto Error;
+        #ifdef FRCOV
+        }
+        #endif
 
         for (i=0; i< nSegments; i++) {
 
@@ -293,6 +387,9 @@ cmsToneCurve* AllocateToneCurveStruct(cmsContext ContextID, cmsInt32Number nEntr
                     p ->Evals[i] = c ->Evaluator;
         }
     }
+    #ifdef FRCOV
+    }
+    #endif
 
     p ->InterpParams = _cmsComputeInterpParams(ContextID, p ->nEntries, 1, 1, p->Table16, CMS_LERP_FLAGS_16BITS);
     if (p->InterpParams != NULL)
@@ -659,7 +756,22 @@ cmsToneCurve* CMSEXPORT cmsBuildSegmentedToneCurve(cmsContext ContextID,
     }
 
     g = AllocateToneCurveStruct(ContextID, nGridPoints, nSegments, Segments, NULL);
-    if (g == NULL) return NULL;
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[135]) {
+      if ((g == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 135\n");
+      else
+        fprintf(stderr, "reached bug index 135\n");
+    }
+    if ((!FIXREVERTER[135] && (g == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) return NULL;
+    #ifdef FRCOV
+    }
+    #endif
 
     // Once we have the floating point version, we can approximate a 16 bit table of 4096 entries
     // for performance reasons. This table would normally not be used except on 8/16 bits transforms.
@@ -730,10 +842,25 @@ cmsToneCurve* CMSEXPORT cmsBuildParametricToneCurve(cmsContext ContextID, cmsInt
 
     _cmsAssert(Params != NULL);
 
-    if (c == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[136]) {
+      if ((c == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 136\n");
+      else
+        fprintf(stderr, "reached bug index 136\n");
+    }
+    if ((!FIXREVERTER[136] && (c == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         cmsSignalError(ContextID, cmsERROR_UNKNOWN_EXTENSION, "Invalid parametric curve type %d", Type);
         return NULL;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
     memset(&Seg0, 0, sizeof(Seg0));
 
@@ -761,7 +888,22 @@ void CMSEXPORT cmsFreeToneCurve(cmsToneCurve* Curve)
 {
     cmsContext ContextID;
 
-    if (Curve == NULL) return;
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[137]) {
+      if ((Curve == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 137\n");
+      else
+        fprintf(stderr, "reached bug index 137\n");
+    }
+    if ((!FIXREVERTER[137] && (Curve == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) return;
+    #ifdef FRCOV
+    }
+    #endif
 
     ContextID = Curve ->InterpParams->ContextID;
 
@@ -811,7 +953,22 @@ void CMSEXPORT cmsFreeToneCurveTriple(cmsToneCurve* Curve[3])
 // Duplicate a gamma table
 cmsToneCurve* CMSEXPORT cmsDupToneCurve(const cmsToneCurve* In)
 {
-    if (In == NULL) return NULL;
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[138]) {
+      if ((In == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 138\n");
+      else
+        fprintf(stderr, "reached bug index 138\n");
+    }
+    if ((!FIXREVERTER[138] && (In == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) return NULL;
+    #ifdef FRCOV
+    }
+    #endif
 
     return  AllocateToneCurveStruct(In ->InterpParams ->ContextID, In ->nEntries, In ->nSegments, In ->Segments, In ->Table16);
 }
@@ -836,10 +993,40 @@ cmsToneCurve* CMSEXPORT cmsJoinToneCurve(cmsContext ContextID,
     _cmsAssert(Y != NULL);
 
     Yreversed = cmsReverseToneCurveEx(nResultingPoints, Y);
-    if (Yreversed == NULL) goto Error;
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[139]) {
+      if ((Yreversed == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 139\n");
+      else
+        fprintf(stderr, "reached bug index 139\n");
+    }
+    if ((!FIXREVERTER[139] && (Yreversed == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) goto Error;
+    #ifdef FRCOV
+    }
+    #endif
 
     Res = (cmsFloat32Number*) _cmsCalloc(ContextID, nResultingPoints, sizeof(cmsFloat32Number));
-    if (Res == NULL) goto Error;
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[140]) {
+      if ((Res == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 140\n");
+      else
+        fprintf(stderr, "reached bug index 140\n");
+    }
+    if ((!FIXREVERTER[140] && (Res == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) goto Error;
+    #ifdef FRCOV
+    }
+    #endif
 
     //Iterate
     for (i=0; i <  nResultingPoints; i++) {
@@ -933,8 +1120,23 @@ cmsToneCurve* CMSEXPORT cmsReverseToneCurveEx(cmsInt32Number nResultSamples, con
 
     // Nope, reverse the table.
     out = cmsBuildTabulatedToneCurve16(InCurve ->InterpParams->ContextID, nResultSamples, NULL);
-    if (out == NULL)
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[141]) {
+      if ((out == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 141\n");
+      else
+        fprintf(stderr, "reached bug index 141\n");
+    }
+    if ((!FIXREVERTER[141] && (out == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    )
         return NULL;
+        #ifdef FRCOV
+        }
+        #endif
 
     // We want to know if this is an ascending or descending table
     Ascending = !cmsIsToneCurveDescending(InCurve);
@@ -1141,7 +1343,22 @@ cmsBool  CMSEXPORT cmsIsToneCurveMonotonic(const cmsToneCurve* t)
 
     // Degenerated curves are monotonic? Ok, let's pass them
     n = t ->nEntries;
-    if (n < 2) return TRUE;
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[147]) {
+      if ((n < 2 ) && !(0))
+        fprintf(stderr, "triggered bug index 147\n");
+      else
+        fprintf(stderr, "reached bug index 147\n");
+    }
+    if ((!FIXREVERTER[147] && (n < 2 ))
+    #else
+    if (0
+    #endif
+    ) return TRUE;
+    #ifdef FRCOV
+    }
+    #endif
 
     // Curve direction
     lDescending = cmsIsToneCurveDescending(t);
@@ -1197,7 +1414,22 @@ cmsInt32Number  CMSEXPORT cmsGetToneCurveParametricType(const cmsToneCurve* t)
 {
     _cmsAssert(t != NULL);
 
-    if (t -> nSegments != 1) return 0;
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[148]) {
+      if ((t -> nSegments != 1 ) && !(0))
+        fprintf(stderr, "triggered bug index 148\n");
+      else
+        fprintf(stderr, "reached bug index 148\n");
+    }
+    if ((!FIXREVERTER[148] && (t -> nSegments != 1 ))
+    #else
+    if (0
+    #endif
+    ) return 0;
+    #ifdef FRCOV
+    }
+    #endif
     return t ->Segments[0].Type;
 }
 
diff --git a/src/cmsgmt.c b/src/cmsgmt.c
index b82f3be..35082f7 100644
--- a/src/cmsgmt.c
+++ b/src/cmsgmt.c
@@ -1,3 +1,7 @@
+#ifdef FRCOV
+#include <stdio.h>
+extern short FIXREVERTER[];
+#endif
 //---------------------------------------------------------------------------------
 //
 //  Little Color Management System
@@ -49,11 +53,41 @@ cmsHTRANSFORM _cmsChain2Lab(cmsContext            ContextID,
 
     // This is a rather big number and there is no need of dynamic memory
     // since we are adding a profile, 254 + 1 = 255 and this is the limit
-    if (nProfiles > 254) return NULL;
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[396]) {
+      if ((nProfiles > 254 ) && !(0))
+        fprintf(stderr, "triggered bug index 396\n");
+      else
+        fprintf(stderr, "reached bug index 396\n");
+    }
+    if ((!FIXREVERTER[396] && (nProfiles > 254 ))
+    #else
+    if (0
+    #endif
+    ) return NULL;
+    #ifdef FRCOV
+    }
+    #endif
 
     // The output space
     hLab = cmsCreateLab4ProfileTHR(ContextID, NULL);
-    if (hLab == NULL) return NULL;
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[397]) {
+      if ((hLab == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 397\n");
+      else
+        fprintf(stderr, "reached bug index 397\n");
+    }
+    if ((!FIXREVERTER[397] && (hLab == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) return NULL;
+    #ifdef FRCOV
+    }
+    #endif
 
     // Create a copy of parameters
     for (i=0; i < nProfiles; i++) {
@@ -106,10 +140,40 @@ cmsToneCurve* ComputeKToLstar(cmsContext            ContextID,
     cmsFloat32Number* SampledPoints;
 
     xform = _cmsChain2Lab(ContextID, nProfiles, TYPE_CMYK_FLT, TYPE_Lab_DBL, Intents, hProfiles, BPC, AdaptationStates, dwFlags);
-    if (xform == NULL) return NULL;
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[398]) {
+      if ((xform == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 398\n");
+      else
+        fprintf(stderr, "reached bug index 398\n");
+    }
+    if ((!FIXREVERTER[398] && (xform == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) return NULL;
+    #ifdef FRCOV
+    }
+    #endif
 
     SampledPoints = (cmsFloat32Number*) _cmsCalloc(ContextID, nPoints, sizeof(cmsFloat32Number));
-    if (SampledPoints  == NULL) goto Error;
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[399]) {
+      if ((SampledPoints == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 399\n");
+      else
+        fprintf(stderr, "reached bug index 399\n");
+    }
+    if ((!FIXREVERTER[399] && (SampledPoints == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) goto Error;
+    #ifdef FRCOV
+    }
+    #endif
 
     for (i=0; i < nPoints; i++) {
 
@@ -158,7 +222,22 @@ cmsToneCurve* _cmsBuildKToneCurve(cmsContext        ContextID,
     // Create individual curves. BPC works also as each K to L* is
     // computed as a BPC to zero black point in case of L*
     in  = ComputeKToLstar(ContextID, nPoints, nProfiles - 1, Intents, hProfiles, BPC, AdaptationStates, dwFlags);
-    if (in == NULL) return NULL;
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[400]) {
+      if ((in == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 400\n");
+      else
+        fprintf(stderr, "reached bug index 400\n");
+    }
+    if ((!FIXREVERTER[400] && (in == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) return NULL;
+    #ifdef FRCOV
+    }
+    #endif
 
     out = ComputeKToLstar(ContextID, nPoints, 1,
                             Intents + (nProfiles - 1),
@@ -166,10 +245,25 @@ cmsToneCurve* _cmsBuildKToneCurve(cmsContext        ContextID,
                             BPC + (nProfiles - 1),
                             AdaptationStates + (nProfiles - 1),
                             dwFlags);
-    if (out == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[401]) {
+      if ((out == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 401\n");
+      else
+        fprintf(stderr, "reached bug index 401\n");
+    }
+    if ((!FIXREVERTER[401] && (out == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         cmsFreeToneCurve(in);
         return NULL;
-    }
+    }
+    #ifdef FRCOV
+    }
+    #endif
 
     // Build the relationship. This effectively limits the maximum accuracy to 16 bits, but
     // since this is used on black-preserving LUTs, we are not losing  accuracy in any case
@@ -179,7 +273,22 @@ cmsToneCurve* _cmsBuildKToneCurve(cmsContext        ContextID,
     cmsFreeToneCurve(in); cmsFreeToneCurve(out);
 
     // Something went wrong...
-    if (KTone == NULL) return NULL;
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[402]) {
+      if ((KTone == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 402\n");
+      else
+        fprintf(stderr, "reached bug index 402\n");
+    }
+    if ((!FIXREVERTER[402] && (KTone == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) return NULL;
+    #ifdef FRCOV
+    }
+    #endif
 
     // Make sure it is monotonic
     if (!cmsIsToneCurveMonotonic(KTone)) {
@@ -308,13 +417,43 @@ cmsPipeline* _cmsCreateGamutCheckPipeline(cmsContext ContextID,
     memset(&Chain, 0, sizeof(GAMUTCHAIN));
 
 
-    if (nGamutPCSposition <= 0 || nGamutPCSposition > 255) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[403]) {
+      if ((nGamutPCSposition <= 0 || nGamutPCSposition > 255 ) && !(0))
+        fprintf(stderr, "triggered bug index 403\n");
+      else
+        fprintf(stderr, "reached bug index 403\n");
+    }
+    if ((!FIXREVERTER[403] && (nGamutPCSposition <= 0 || nGamutPCSposition > 255 ))
+    #else
+    if (0
+    #endif
+    ) {
         cmsSignalError(ContextID, cmsERROR_RANGE, "Wrong position of PCS. 1..255 expected, %d found.", nGamutPCSposition);
         return NULL;
-    }
+    }
+    #ifdef FRCOV
+    }
+    #endif
 
     hLab = cmsCreateLab4ProfileTHR(ContextID, NULL);
-    if (hLab == NULL) return NULL;
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[404]) {
+      if ((hLab == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 404\n");
+      else
+        fprintf(stderr, "reached bug index 404\n");
+    }
+    if ((!FIXREVERTER[404] && (hLab == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) return NULL;
+    #ifdef FRCOV
+    }
+    #endif
 
 
     // The figure of merit. On matrix-shaper profiles, should be almost zero as
@@ -476,16 +615,61 @@ cmsFloat64Number CMSEXPORT cmsDetectTAC(cmsHPROFILE hProfile)
     bp.MaxTAC = 0;    // Initial TAC is 0
 
     //  for safety
-    if (bp.nOutputChans >= cmsMAXCHANNELS) return 0;
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[406]) {
+      if ((bp . nOutputChans >= 16 ) && !(0))
+        fprintf(stderr, "triggered bug index 406\n");
+      else
+        fprintf(stderr, "reached bug index 406\n");
+    }
+    if ((!FIXREVERTER[406] && (bp . nOutputChans >= 16 ))
+    #else
+    if (0
+    #endif
+    ) return 0;
+    #ifdef FRCOV
+    }
+    #endif
 
     hLab = cmsCreateLab4ProfileTHR(ContextID, NULL);
-    if (hLab == NULL) return 0;
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[407]) {
+      if ((hLab == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 407\n");
+      else
+        fprintf(stderr, "reached bug index 407\n");
+    }
+    if ((!FIXREVERTER[407] && (hLab == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) return 0;
+    #ifdef FRCOV
+    }
+    #endif
     // Setup a roundtrip on perceptual intent in output profile for TAC estimation
     bp.hRoundTrip = cmsCreateTransformTHR(ContextID, hLab, TYPE_Lab_16,
                                           hProfile, dwFormatter, INTENT_PERCEPTUAL, cmsFLAGS_NOOPTIMIZE|cmsFLAGS_NOCACHE);
 
     cmsCloseProfile(hLab);
-    if (bp.hRoundTrip == NULL) return 0;
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[408]) {
+      if ((bp . hRoundTrip == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 408\n");
+      else
+        fprintf(stderr, "reached bug index 408\n");
+    }
+    if ((!FIXREVERTER[408] && (bp . hRoundTrip == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) return 0;
+    #ifdef FRCOV
+    }
+    #endif
 
     // For L* we only need black and white. For C* we need many points
     GridPoints[0] = 6;
diff --git a/src/cmsintrp.c b/src/cmsintrp.c
index 60d6a0e..821f42b 100644
--- a/src/cmsintrp.c
+++ b/src/cmsintrp.c
@@ -1,3 +1,7 @@
+#ifdef FRCOV
+#include <stdio.h>
+extern short FIXREVERTER[];
+#endif
 //---------------------------------------------------------------------------------
 //
 //  Little Color Management System
@@ -110,14 +114,44 @@ cmsInterpParams* _cmsComputeInterpParamsEx(cmsContext ContextID,
     int i;
 
     // Check for maximum inputs
-    if (InputChan > MAX_INPUT_DIMENSIONS) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[342]) {
+      if ((InputChan > 8 ) && !(0))
+        fprintf(stderr, "triggered bug index 342\n");
+      else
+        fprintf(stderr, "reached bug index 342\n");
+    }
+    if ((!FIXREVERTER[342] && (InputChan > 8 ))
+    #else
+    if (0
+    #endif
+    ) {
              cmsSignalError(ContextID, cmsERROR_RANGE, "Too many input channels (%d channels, max=%d)", InputChan, MAX_INPUT_DIMENSIONS);
             return NULL;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
     // Creates an empty object
     p = (cmsInterpParams*) _cmsMallocZero(ContextID, sizeof(cmsInterpParams));
-    if (p == NULL) return NULL;
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[343]) {
+      if ((p == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 343\n");
+      else
+        fprintf(stderr, "reached bug index 343\n");
+    }
+    if ((!FIXREVERTER[343] && (p == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) return NULL;
+    #ifdef FRCOV
+    }
+    #endif
 
     // Keep original parameters
     p -> dwFlags  = dwFlags;
diff --git a/src/cmsio0.c b/src/cmsio0.c
index af3249d..4adb1ea 100644
--- a/src/cmsio0.c
+++ b/src/cmsio0.c
@@ -1,3 +1,7 @@
+#ifdef FRCOV
+#include <stdio.h>
+extern short FIXREVERTER[];
+#endif
 //---------------------------------------------------------------------------------
 //
 //  Little Color Management System
@@ -78,8 +82,23 @@ cmsBool  NULLWrite(cmsIOHANDLER* iohandler, cmsUInt32Number size, const void *Pt
     FILENULL* ResData = (FILENULL*) iohandler ->stream;
 
     ResData ->Pointer += size;
-    if (ResData ->Pointer > iohandler->UsedSpace)
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[183]) {
+      if ((ResData -> Pointer > iohandler -> UsedSpace  ) && !(0))
+        fprintf(stderr, "triggered bug index 183\n");
+      else
+        fprintf(stderr, "reached bug index 183\n");
+    }
+    if ((!FIXREVERTER[183] && (ResData -> Pointer > iohandler -> UsedSpace  ))
+    #else
+    if (0
+    #endif
+    )
         iohandler->UsedSpace = ResData ->Pointer;
+        #ifdef FRCOV
+        }
+        #endif
 
     return TRUE;
 
@@ -103,10 +122,40 @@ cmsIOHANDLER*  CMSEXPORT cmsOpenIOhandlerFromNULL(cmsContext ContextID)
     FILENULL* fm = NULL;
 
     iohandler = (struct _cms_io_handler*) _cmsMallocZero(ContextID, sizeof(struct _cms_io_handler));
-    if (iohandler == NULL) return NULL;
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[184]) {
+      if ((iohandler == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 184\n");
+      else
+        fprintf(stderr, "reached bug index 184\n");
+    }
+    if ((!FIXREVERTER[184] && (iohandler == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) return NULL;
+    #ifdef FRCOV
+    }
+    #endif
 
     fm = (FILENULL*) _cmsMallocZero(ContextID, sizeof(FILENULL));
-    if (fm == NULL) goto Error;
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[185]) {
+      if ((fm == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 185\n");
+      else
+        fprintf(stderr, "reached bug index 185\n");
+    }
+    if ((!FIXREVERTER[185] && (fm == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) goto Error;
+    #ifdef FRCOV
+    }
+    #endif
 
     fm ->Pointer = 0;
 
@@ -171,10 +220,25 @@ cmsBool  MemorySeek(struct _cms_io_handler* iohandler, cmsUInt32Number offset)
 {
     FILEMEM* ResData = (FILEMEM*) iohandler ->stream;
 
-    if (offset > ResData ->Size) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[187]) {
+      if ((offset > ResData -> Size ) && !(0))
+        fprintf(stderr, "triggered bug index 187\n");
+      else
+        fprintf(stderr, "reached bug index 187\n");
+    }
+    if ((!FIXREVERTER[187] && (offset > ResData -> Size ))
+    #else
+    if (0
+    #endif
+    ) {
         cmsSignalError(iohandler ->ContextID, cmsERROR_SEEK,  "Too few data; probably corrupted profile");
         return FALSE;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
     ResData ->Pointer = offset;
     return TRUE;
@@ -186,7 +250,22 @@ cmsUInt32Number MemoryTell(struct _cms_io_handler* iohandler)
 {
     FILEMEM* ResData = (FILEMEM*) iohandler ->stream;
 
-    if (ResData == NULL) return 0;
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[188]) {
+      if ((ResData == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 188\n");
+      else
+        fprintf(stderr, "reached bug index 188\n");
+    }
+    if ((!FIXREVERTER[188] && (ResData == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) return 0;
+    #ifdef FRCOV
+    }
+    #endif
     return ResData -> Pointer;
 }
 
@@ -197,20 +276,65 @@ cmsBool MemoryWrite(struct _cms_io_handler* iohandler, cmsUInt32Number size, con
 {
     FILEMEM* ResData = (FILEMEM*) iohandler ->stream;
 
-    if (ResData == NULL) return FALSE; // Housekeeping
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[189]) {
+      if ((ResData == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 189\n");
+      else
+        fprintf(stderr, "reached bug index 189\n");
+    }
+    if ((!FIXREVERTER[189] && (ResData == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) return FALSE;
+    #ifdef FRCOV
+    }
+    #endif // Housekeeping
 
     // Check for available space. Clip.
     if (ResData->Pointer + size > ResData->Size) {
         size = ResData ->Size - ResData->Pointer;
     }
       
-    if (size == 0) return TRUE;     // Write zero bytes is ok, but does nothing
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[190]) {
+      if ((size == 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 190\n");
+      else
+        fprintf(stderr, "reached bug index 190\n");
+    }
+    if ((!FIXREVERTER[190] && (size == 0 ))
+    #else
+    if (0
+    #endif
+    ) return TRUE;
+    #ifdef FRCOV
+    }
+    #endif     // Write zero bytes is ok, but does nothing
 
     memmove(ResData ->Block + ResData ->Pointer, Ptr, size);
     ResData ->Pointer += size;
 
-    if (ResData ->Pointer > iohandler->UsedSpace)
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[191]) {
+      if ((ResData -> Pointer > iohandler -> UsedSpace  ) && !(0))
+        fprintf(stderr, "triggered bug index 191\n");
+      else
+        fprintf(stderr, "reached bug index 191\n");
+    }
+    if ((!FIXREVERTER[191] && (ResData -> Pointer > iohandler -> UsedSpace  ))
+    #else
+    if (0
+    #endif
+    )
         iohandler->UsedSpace = ResData ->Pointer;
+        #ifdef FRCOV
+        }
+        #endif
 
     return TRUE;
 }
@@ -243,18 +367,63 @@ cmsIOHANDLER* CMSEXPORT cmsOpenIOhandlerFromMem(cmsContext ContextID, void *Buff
     _cmsAssert(AccessMode != NULL);
 
     iohandler = (cmsIOHANDLER*) _cmsMallocZero(ContextID, sizeof(cmsIOHANDLER));
-    if (iohandler == NULL) return NULL;
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[192]) {
+      if ((iohandler == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 192\n");
+      else
+        fprintf(stderr, "reached bug index 192\n");
+    }
+    if ((!FIXREVERTER[192] && (iohandler == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) return NULL;
+    #ifdef FRCOV
+    }
+    #endif
 
     switch (*AccessMode) {
 
     case 'r':
         fm = (FILEMEM*) _cmsMallocZero(ContextID, sizeof(FILEMEM));
-        if (fm == NULL) goto Error;
-
-        if (Buffer == NULL) {
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[193]) {
+          if ((fm == (void *) 0 ) && !(0))
+            fprintf(stderr, "triggered bug index 193\n");
+          else
+            fprintf(stderr, "reached bug index 193\n");
+        }
+        if ((!FIXREVERTER[193] && (fm == (void *) 0 ))
+        #else
+        if (0
+        #endif
+        ) goto Error;
+        #ifdef FRCOV
+        }
+        #endif
+
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[194]) {
+          if ((Buffer == (void *) 0 ) && !(0))
+            fprintf(stderr, "triggered bug index 194\n");
+          else
+            fprintf(stderr, "reached bug index 194\n");
+        }
+        if ((!FIXREVERTER[194] && (Buffer == (void *) 0 ))
+        #else
+        if (0
+        #endif
+        ) {
             cmsSignalError(ContextID, cmsERROR_READ, "Couldn't read profile from NULL pointer");
             goto Error;
         }
+        #ifdef FRCOV
+        }
+        #endif
 
         fm ->Block = (cmsUInt8Number*) _cmsMalloc(ContextID, size);
         if (fm ->Block == NULL) {
@@ -275,7 +444,22 @@ cmsIOHANDLER* CMSEXPORT cmsOpenIOhandlerFromMem(cmsContext ContextID, void *Buff
 
     case 'w':
         fm = (FILEMEM*) _cmsMallocZero(ContextID, sizeof(FILEMEM));
-        if (fm == NULL) goto Error;
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[195]) {
+          if ((fm == (void *) 0 ) && !(0))
+            fprintf(stderr, "triggered bug index 195\n");
+          else
+            fprintf(stderr, "reached bug index 195\n");
+        }
+        if ((!FIXREVERTER[195] && (fm == (void *) 0 ))
+        #else
+        if (0
+        #endif
+        ) goto Error;
+        #ifdef FRCOV
+        }
+        #endif
 
         fm ->Block = (cmsUInt8Number*) Buffer;
         fm ->FreeBlockOnClose = FALSE;
@@ -316,10 +500,25 @@ cmsUInt32Number FileRead(cmsIOHANDLER* iohandler, void *Buffer, cmsUInt32Number
 {
     cmsUInt32Number nReaded = (cmsUInt32Number) fread(Buffer, size, count, (FILE*) iohandler->stream);
 
-    if (nReaded != count) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[196]) {
+      if ((nReaded != count ) && !(0))
+        fprintf(stderr, "triggered bug index 196\n");
+      else
+        fprintf(stderr, "reached bug index 196\n");
+    }
+    if ((!FIXREVERTER[196] && (nReaded != count ))
+    #else
+    if (0
+    #endif
+    ) {
             cmsSignalError(iohandler ->ContextID, cmsERROR_FILE, "Read error. Got %d bytes, block should be of %d bytes", nReaded * size, count * size);
             return 0;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
     return nReaded;
 }
@@ -354,7 +553,22 @@ cmsUInt32Number FileTell(cmsIOHANDLER* iohandler)
 static
 cmsBool  FileWrite(cmsIOHANDLER* iohandler, cmsUInt32Number size, const void* Buffer)
 {
-    if (size == 0) return TRUE;  // We allow to write 0 bytes, but nothing is written
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[197]) {
+      if ((size == 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 197\n");
+      else
+        fprintf(stderr, "reached bug index 197\n");
+    }
+    if ((!FIXREVERTER[197] && (size == 0 ))
+    #else
+    if (0
+    #endif
+    ) return TRUE;
+    #ifdef FRCOV
+    }
+    #endif  // We allow to write 0 bytes, but nothing is written
 
     iohandler->UsedSpace += size;
     return (fwrite(Buffer, size, 1, (FILE*)iohandler->stream) == 1);
@@ -380,17 +594,47 @@ cmsIOHANDLER* CMSEXPORT cmsOpenIOhandlerFromFile(cmsContext ContextID, const cha
     _cmsAssert(AccessMode != NULL);
 
     iohandler = (cmsIOHANDLER*) _cmsMallocZero(ContextID, sizeof(cmsIOHANDLER));
-    if (iohandler == NULL) return NULL;
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[198]) {
+      if ((iohandler == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 198\n");
+      else
+        fprintf(stderr, "reached bug index 198\n");
+    }
+    if ((!FIXREVERTER[198] && (iohandler == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) return NULL;
+    #ifdef FRCOV
+    }
+    #endif
 
     switch (*AccessMode) {
 
     case 'r':
         fm = fopen(FileName, "rb");
-        if (fm == NULL) {
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[199]) {
+          if ((fm == (void *) 0 ) && !(0))
+            fprintf(stderr, "triggered bug index 199\n");
+          else
+            fprintf(stderr, "reached bug index 199\n");
+        }
+        if ((!FIXREVERTER[199] && (fm == (void *) 0 ))
+        #else
+        if (0
+        #endif
+        ) {
             _cmsFree(ContextID, iohandler);
              cmsSignalError(ContextID, cmsERROR_FILE, "File '%s' not found", FileName);
             return NULL;
-        }                                     
+        }
+        #ifdef FRCOV
+        }
+        #endif                                     
         fileLen = cmsfilelength(fm);
         if (fileLen < 0)
         {
@@ -405,11 +649,26 @@ cmsIOHANDLER* CMSEXPORT cmsOpenIOhandlerFromFile(cmsContext ContextID, const cha
 
     case 'w':
         fm = fopen(FileName, "wb");
-        if (fm == NULL) {
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[200]) {
+          if ((fm == (void *) 0 ) && !(0))
+            fprintf(stderr, "triggered bug index 200\n");
+          else
+            fprintf(stderr, "reached bug index 200\n");
+        }
+        if ((!FIXREVERTER[200] && (fm == (void *) 0 ))
+        #else
+        if (0
+        #endif
+        ) {
             _cmsFree(ContextID, iohandler);
              cmsSignalError(ContextID, cmsERROR_FILE, "Couldn't create '%s'", FileName);
             return NULL;
         }
+        #ifdef FRCOV
+        }
+        #endif
         iohandler -> ReportedSize = 0;
         break;
 
@@ -490,7 +749,22 @@ cmsHPROFILE CMSEXPORT cmsCreateProfilePlaceholder(cmsContext ContextID)
 {
     time_t now = time(NULL);
     _cmsICCPROFILE* Icc = (_cmsICCPROFILE*) _cmsMallocZero(ContextID, sizeof(_cmsICCPROFILE));
-    if (Icc == NULL) return NULL;
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[204]) {
+      if ((Icc == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 204\n");
+      else
+        fprintf(stderr, "reached bug index 204\n");
+    }
+    if ((!FIXREVERTER[204] && (Icc == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) return NULL;
+    #ifdef FRCOV
+    }
+    #endif
 
     Icc ->ContextID = ContextID;
 
@@ -514,7 +788,22 @@ cmsContext CMSEXPORT cmsGetProfileContextID(cmsHPROFILE hProfile)
 {
      _cmsICCPROFILE* Icc = (_cmsICCPROFILE*) hProfile;
 
-    if (Icc == NULL) return NULL;
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[205]) {
+      if ((Icc == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 205\n");
+      else
+        fprintf(stderr, "reached bug index 205\n");
+    }
+    if ((!FIXREVERTER[205] && (Icc == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) return NULL;
+    #ifdef FRCOV
+    }
+    #endif
     return Icc -> ContextID;
 }
 
@@ -565,8 +854,23 @@ int _cmsSearchTag(_cmsICCPROFILE* Icc, cmsTagSignature sig, cmsBool lFollowLinks
 
         // Search for given tag in ICC profile directory
         n = SearchOneTag(Icc, sig);
-        if (n < 0)
-            return -1;        // Not found
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[209]) {
+          if ((n < 0 ) && !(0))
+            fprintf(stderr, "triggered bug index 209\n");
+          else
+            fprintf(stderr, "reached bug index 209\n");
+        }
+        if ((!FIXREVERTER[209] && (n < 0 ))
+        #else
+        if (0
+        #endif
+        )
+            return -1;
+            #ifdef FRCOV
+            }
+            #endif        // Not found
 
         if (!lFollowLinks)
             return n;         // Found, don't follow links
@@ -634,10 +938,25 @@ cmsBool _cmsNewTag(_cmsICCPROFILE* Icc, cmsTagSignature sig, int* NewPos)
 
         // No, make a new one
 
-        if (Icc -> TagCount >= MAX_TABLE_TAG) {
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[210]) {
+          if ((Icc -> TagCount >= 100 ) && !(0))
+            fprintf(stderr, "triggered bug index 210\n");
+          else
+            fprintf(stderr, "reached bug index 210\n");
+        }
+        if ((!FIXREVERTER[210] && (Icc -> TagCount >= 100 ))
+        #else
+        if (0
+        #endif
+        ) {
             cmsSignalError(Icc ->ContextID, cmsERROR_RANGE, "Too many tags (%d)", MAX_TABLE_TAG);
             return FALSE;
         }
+        #ifdef FRCOV
+        }
+        #endif
 
         *NewPos = Icc ->TagCount;
         Icc -> TagCount++;
@@ -734,11 +1053,26 @@ cmsBool _cmsReadHeader(_cmsICCPROFILE* Icc)
 
     // Read tag directory
     if (!_cmsReadUInt32Number(io, &TagCount)) return FALSE;
-    if (TagCount > MAX_TABLE_TAG) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[211]) {
+      if ((TagCount > 100 ) && !(0))
+        fprintf(stderr, "triggered bug index 211\n");
+      else
+        fprintf(stderr, "reached bug index 211\n");
+    }
+    if ((!FIXREVERTER[211] && (TagCount > 100 ))
+    #else
+    if (0
+    #endif
+    ) {
 
         cmsSignalError(Icc ->ContextID, cmsERROR_RANGE, "Too many tags (%d)", TagCount);
         return FALSE;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
 
     // Read tag directory
@@ -750,9 +1084,23 @@ cmsBool _cmsReadHeader(_cmsICCPROFILE* Icc)
         if (!_cmsReadUInt32Number(io, &Tag.size)) return FALSE;
 
         // Perform some sanity check. Offset + size should fall inside file.
-        if (Tag.offset + Tag.size > HeaderSize ||
-            Tag.offset + Tag.size < Tag.offset)
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[212]) {
+          if ((Tag . offset + Tag . size > HeaderSize || Tag . offset + Tag . size < Tag . offset ) && !(0))
+            fprintf(stderr, "triggered bug index 212\n");
+          else
+            fprintf(stderr, "reached bug index 212\n");
+        }
+        if ((!FIXREVERTER[212] && (Tag . offset + Tag . size > HeaderSize || Tag . offset + Tag . size < Tag . offset ))
+        #else
+        if (0
+        #endif
+        )
                   continue;
+                  #ifdef FRCOV
+                  }
+                  #endif
 
         Icc -> TagNames[Icc ->TagCount]   = Tag.sig;
         Icc -> TagOffsets[Icc ->TagCount] = Tag.offset;
@@ -996,11 +1344,28 @@ cmsUInt32Number BaseToBase(cmsUInt32Number in, int BaseIn, int BaseOut)
     int i, len;
     cmsUInt32Number out;
 
-    for (len=0; in > 0 && len < 100; len++) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[213])
+      fprintf(stderr, "reached bug index 213\n");
+    for (len = 0; (FIXREVERTER[213] && (in > 0 )) || (!FIXREVERTER[213] && (in > 0 && len < 100 ))
+    #else
+    for (len = 0; in > 0 
+    #endif
+    ; len++) {
+      
+    #ifdef FRCOV
+      if (!(len < 100 ))
+        fprintf(stderr, "triggered bug index 213\n");
+      #endif
+    
 
         Buff[len] = (char) (in % BaseIn);
         in /= BaseIn;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
     for (i=len-1, out=0; i >= 0; --i) {
         out = out * BaseOut + Buff[i];
@@ -1148,14 +1513,44 @@ cmsHPROFILE CMSEXPORT cmsOpenProfileFromMemTHR(cmsContext ContextID, const void*
     cmsHPROFILE hEmpty;
 
     hEmpty = cmsCreateProfilePlaceholder(ContextID);
-    if (hEmpty == NULL) return NULL;
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[220]) {
+      if ((hEmpty == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 220\n");
+      else
+        fprintf(stderr, "reached bug index 220\n");
+    }
+    if ((!FIXREVERTER[220] && (hEmpty == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) return NULL;
+    #ifdef FRCOV
+    }
+    #endif
 
     NewIcc = (_cmsICCPROFILE*) hEmpty;
 
     // Ok, in this case const void* is casted to void* just because open IO handler
     // shares read and writing modes. Don't abuse this feature!
     NewIcc ->IOhandler = cmsOpenIOhandlerFromMem(ContextID, (void*) MemPtr, dwSize, "r");
-    if (NewIcc ->IOhandler == NULL) goto Error;
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[221]) {
+      if ((NewIcc -> IOhandler == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 221\n");
+      else
+        fprintf(stderr, "reached bug index 221\n");
+    }
+    if ((!FIXREVERTER[221] && (NewIcc -> IOhandler == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) goto Error;
+    #ifdef FRCOV
+    }
+    #endif
 
     if (!_cmsReadHeader(NewIcc)) goto Error;
 
@@ -1212,7 +1607,22 @@ cmsBool SaveTags(_cmsICCPROFILE* Icc, _cmsICCPROFILE* FileOrig)
                 if (!FileOrig ->IOhandler->Seek(FileOrig ->IOhandler, TagOffset)) return FALSE;
 
                 Mem = _cmsMalloc(Icc ->ContextID, TagSize);
-                if (Mem == NULL) return FALSE;
+                
+                #ifdef FRCOV
+                {if (FIXREVERTER[222]) {
+                  if ((Mem == (void *) 0 ) && !(0))
+                    fprintf(stderr, "triggered bug index 222\n");
+                  else
+                    fprintf(stderr, "reached bug index 222\n");
+                }
+                if ((!FIXREVERTER[222] && (Mem == (void *) 0 ))
+                #else
+                if (0
+                #endif
+                ) return FALSE;
+                #ifdef FRCOV
+                }
+                #endif
 
                 if (FileOrig ->IOhandler->Read(FileOrig->IOhandler, Mem, TagSize, 1) != 1) return FALSE;
                 if (!io ->Write(io, TagSize, Mem)) return FALSE;
@@ -1239,7 +1649,22 @@ cmsBool SaveTags(_cmsICCPROFILE* Icc, _cmsICCPROFILE* FileOrig)
 
             // Search for support on this tag
             TagDescriptor = _cmsGetTagDescriptor(Icc-> ContextID, Icc -> TagNames[i]);
-            if (TagDescriptor == NULL) continue;                        // Unsupported, ignore it
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[223]) {
+              if ((TagDescriptor == (void *) 0 ) && !(0))
+                fprintf(stderr, "triggered bug index 223\n");
+              else
+                fprintf(stderr, "reached bug index 223\n");
+            }
+            if ((!FIXREVERTER[223] && (TagDescriptor == (void *) 0 ))
+            #else
+            if (0
+            #endif
+            ) continue;
+            #ifdef FRCOV
+            }
+            #endif                        // Unsupported, ignore it
            
             if (TagDescriptor ->DecideType != NULL) {
 
@@ -1252,10 +1677,25 @@ cmsBool SaveTags(_cmsICCPROFILE* Icc, _cmsICCPROFILE* FileOrig)
 
             TypeHandler =  _cmsGetTagTypeHandler(Icc->ContextID, Type);
 
-            if (TypeHandler == NULL) {
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[224]) {
+              if ((TypeHandler == (void *) 0 ) && !(0))
+                fprintf(stderr, "triggered bug index 224\n");
+              else
+                fprintf(stderr, "reached bug index 224\n");
+            }
+            if ((!FIXREVERTER[224] && (TypeHandler == (void *) 0 ))
+            #else
+            if (0
+            #endif
+            ) {
                 cmsSignalError(Icc ->ContextID, cmsERROR_INTERNAL, "(Internal) no handler for tag %x", Icc -> TagNames[i]);
                 continue;
             }
+            #ifdef FRCOV
+            }
+            #endif
 
             TypeBase = TypeHandler ->Signature;
             if (!_cmsWriteTypeBase(io, TypeBase))
@@ -1329,10 +1769,25 @@ cmsUInt32Number CMSEXPORT cmsSaveProfileToIOhandler(cmsHPROFILE hProfile, cmsIOH
 
     ContextID = cmsGetProfileContextID(hProfile);
     PrevIO = Icc ->IOhandler = cmsOpenIOhandlerFromNULL(ContextID);
-    if (PrevIO == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[225]) {
+      if ((PrevIO == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 225\n");
+      else
+        fprintf(stderr, "reached bug index 225\n");
+    }
+    if ((!FIXREVERTER[225] && (PrevIO == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         _cmsUnlockMutex(Icc->ContextID, Icc->UsrMutex);
         return 0;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
     // Pass #1 does compute offsets
 
@@ -1376,7 +1831,22 @@ cmsBool  CMSEXPORT cmsSaveProfileToFile(cmsHPROFILE hProfile, const char* FileNa
     cmsIOHANDLER* io = cmsOpenIOhandlerFromFile(ContextID, FileName, "w");
     cmsBool rc;
 
-    if (io == NULL) return FALSE;
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[226]) {
+      if ((io == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 226\n");
+      else
+        fprintf(stderr, "reached bug index 226\n");
+    }
+    if ((!FIXREVERTER[226] && (io == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) return FALSE;
+    #ifdef FRCOV
+    }
+    #endif
 
     rc = (cmsSaveProfileToIOhandler(hProfile, io) != 0);
     rc &= cmsCloseIOhandler(io);
@@ -1514,7 +1984,22 @@ void* CMSEXPORT cmsReadTag(cmsHPROFILE hProfile, cmsTagSignature sig)
     if (!_cmsLockMutex(Icc->ContextID, Icc ->UsrMutex)) return NULL;
 
     n = _cmsSearchTag(Icc, sig, TRUE);
-    if (n < 0) goto Error;               // Not found, return NULL
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[231]) {
+      if ((n < 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 231\n");
+      else
+        fprintf(stderr, "reached bug index 231\n");
+    }
+    if ((!FIXREVERTER[231] && (n < 0 ))
+    #else
+    if (0
+    #endif
+    ) goto Error;
+    #ifdef FRCOV
+    }
+    #endif               // Not found, return NULL
 
 
     // If the element is already in memory, return the pointer
@@ -1527,7 +2012,22 @@ void* CMSEXPORT cmsReadTag(cmsHPROFILE hProfile, cmsTagSignature sig)
         if (BaseType == 0) goto Error;
 
         TagDescriptor = _cmsGetTagDescriptor(Icc->ContextID, sig);
-        if (TagDescriptor == NULL) goto Error;
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[232]) {
+          if ((TagDescriptor == (void *) 0 ) && !(0))
+            fprintf(stderr, "triggered bug index 232\n");
+          else
+            fprintf(stderr, "reached bug index 232\n");
+        }
+        if ((!FIXREVERTER[232] && (TagDescriptor == (void *) 0 ))
+        #else
+        if (0
+        #endif
+        ) goto Error;
+        #ifdef FRCOV
+        }
+        #endif
 
         if (!IsTypeSupported(TagDescriptor, BaseType)) goto Error;
 
@@ -1541,7 +2041,22 @@ void* CMSEXPORT cmsReadTag(cmsHPROFILE hProfile, cmsTagSignature sig)
     Offset    = Icc -> TagOffsets[n];
     TagSize   = Icc -> TagSizes[n];
 
-    if (TagSize < 8) goto Error;
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[233]) {
+      if ((TagSize < 8 ) && !(0))
+        fprintf(stderr, "triggered bug index 233\n");
+      else
+        fprintf(stderr, "reached bug index 233\n");
+    }
+    if ((!FIXREVERTER[233] && (TagSize < 8 ))
+    #else
+    if (0
+    #endif
+    ) goto Error;
+    #ifdef FRCOV
+    }
+    #endif
 
     // Seek to its location
     if (!io -> Seek(io, Offset))
@@ -1570,7 +2085,22 @@ void* CMSEXPORT cmsReadTag(cmsHPROFILE hProfile, cmsTagSignature sig)
 
     // Get type handler
     TypeHandler = _cmsGetTagTypeHandler(Icc ->ContextID, BaseType);
-    if (TypeHandler == NULL) goto Error;
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[234]) {
+      if ((TypeHandler == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 234\n");
+      else
+        fprintf(stderr, "reached bug index 234\n");
+    }
+    if ((!FIXREVERTER[234] && (TypeHandler == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) goto Error;
+    #ifdef FRCOV
+    }
+    #endif
     LocalTypeHandler = *TypeHandler;
 
 
@@ -1625,7 +2155,22 @@ cmsTagTypeSignature _cmsGetTagTrueType(cmsHPROFILE hProfile, cmsTagSignature sig
 
     // Search for given tag in ICC profile directory
     n = _cmsSearchTag(Icc, sig, TRUE);
-    if (n < 0) return (cmsTagTypeSignature) 0;                // Not found, return NULL
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[235]) {
+      if ((n < 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 235\n");
+      else
+        fprintf(stderr, "reached bug index 235\n");
+    }
+    if ((!FIXREVERTER[235] && (n < 0 ))
+    #else
+    if (0
+    #endif
+    ) return (cmsTagTypeSignature) 0;
+    #ifdef FRCOV
+    }
+    #endif                // Not found, return NULL
 
     // Get the handler. The true type is there
     TypeHandler =  Icc -> TagTypeHandlers[n];
@@ -1649,7 +2194,19 @@ cmsBool CMSEXPORT cmsWriteTag(cmsHPROFILE hProfile, cmsTagSignature sig, const v
     if (!_cmsLockMutex(Icc->ContextID, Icc ->UsrMutex)) return FALSE;
 
     // To delete tags.
-    if (data == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[236]) {
+      if ((data == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 236\n");
+      else
+        fprintf(stderr, "reached bug index 236\n");
+    }
+    if ((!FIXREVERTER[236] && (data == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
 
          // Delete the tag
          i = _cmsSearchTag(Icc, sig, FALSE);
@@ -1664,6 +2221,9 @@ cmsBool CMSEXPORT cmsWriteTag(cmsHPROFILE hProfile, cmsTagSignature sig, const v
          // Didn't find the tag
         goto Error;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
     if (!_cmsNewTag(Icc, sig, &i)) goto Error;
 
@@ -1675,10 +2235,25 @@ cmsBool CMSEXPORT cmsWriteTag(cmsHPROFILE hProfile, cmsTagSignature sig, const v
 
     // Get information about the TAG.
     TagDescriptor = _cmsGetTagDescriptor(Icc-> ContextID, sig);
-    if (TagDescriptor == NULL){
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[237]) {
+      if ((TagDescriptor == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 237\n");
+      else
+        fprintf(stderr, "reached bug index 237\n");
+    }
+    if ((!FIXREVERTER[237] && (TagDescriptor == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ){
          cmsSignalError(Icc ->ContextID, cmsERROR_UNKNOWN_EXTENSION, "Unsupported tag '%x'", sig);
         goto Error;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
 
     // Now we need to know which type to use. It depends on the version.
diff --git a/src/cmsio1.c b/src/cmsio1.c
index 364741c..ef86369 100644
--- a/src/cmsio1.c
+++ b/src/cmsio1.c
@@ -1,3 +1,7 @@
+#ifdef FRCOV
+#include <stdio.h>
+extern short FIXREVERTER[];
+#endif
 //---------------------------------------------------------------------------------
 //
 //  Little Color Management System
@@ -70,10 +74,25 @@ cmsBool  _cmsReadMediaWhitePoint(cmsCIEXYZ* Dest, cmsHPROFILE hProfile)
     Tag = (cmsCIEXYZ*) cmsReadTag(hProfile, cmsSigMediaWhitePointTag);
 
     // If no wp, take D50
-    if (Tag == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[427]) {
+      if ((Tag == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 427\n");
+      else
+        fprintf(stderr, "reached bug index 427\n");
+    }
+    if ((!FIXREVERTER[427] && (Tag == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         *Dest = *cmsD50_XYZ();
         return TRUE;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
     // V2 display profiles should give D50
     if (cmsGetEncodedICCversion(hProfile) < 0x4000000) {
@@ -114,11 +133,26 @@ cmsBool  _cmsReadCHAD(cmsMAT3* Dest, cmsHPROFILE hProfile)
 
             cmsCIEXYZ* White = (cmsCIEXYZ*) cmsReadTag(hProfile, cmsSigMediaWhitePointTag);
 
-            if (White == NULL) {
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[429]) {
+              if ((White == (void *) 0 ) && !(0))
+                fprintf(stderr, "triggered bug index 429\n");
+              else
+                fprintf(stderr, "reached bug index 429\n");
+            }
+            if ((!FIXREVERTER[429] && (White == (void *) 0 ))
+            #else
+            if (0
+            #endif
+            ) {
 
                 _cmsMAT3identity(Dest);
                 return TRUE;
             }
+            #ifdef FRCOV
+            }
+            #endif
 
             return _cmsAdaptationMatrix(Dest, NULL, White, cmsD50_XYZ());
         }
@@ -140,8 +174,23 @@ cmsBool ReadICCMatrixRGB2XYZ(cmsMAT3* r, cmsHPROFILE hProfile)
     PtrGreen = (cmsCIEXYZ *) cmsReadTag(hProfile, cmsSigGreenColorantTag);
     PtrBlue  = (cmsCIEXYZ *) cmsReadTag(hProfile, cmsSigBlueColorantTag);
 
-    if (PtrRed == NULL || PtrGreen == NULL || PtrBlue == NULL)
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[431]) {
+      if ((PtrRed == (void *) 0 || PtrGreen == (void *) 0 || PtrBlue == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 431\n");
+      else
+        fprintf(stderr, "reached bug index 431\n");
+    }
+    if ((!FIXREVERTER[431] && (PtrRed == (void *) 0 || PtrGreen == (void *) 0 || PtrBlue == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    )
         return FALSE;
+        #ifdef FRCOV
+        }
+        #endif
 
     _cmsVEC3init(&r -> v[0], PtrRed -> X, PtrGreen -> X,  PtrBlue -> X);
     _cmsVEC3init(&r -> v[1], PtrRed -> Y, PtrGreen -> Y,  PtrBlue -> Y);
@@ -160,11 +209,41 @@ cmsPipeline* BuildGrayInputMatrixPipeline(cmsHPROFILE hProfile)
     cmsContext ContextID = cmsGetProfileContextID(hProfile);
 
     GrayTRC = (cmsToneCurve *) cmsReadTag(hProfile, cmsSigGrayTRCTag);
-    if (GrayTRC == NULL) return NULL;
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[432]) {
+      if ((GrayTRC == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 432\n");
+      else
+        fprintf(stderr, "reached bug index 432\n");
+    }
+    if ((!FIXREVERTER[432] && (GrayTRC == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) return NULL;
+    #ifdef FRCOV
+    }
+    #endif
 
     Lut = cmsPipelineAlloc(ContextID, 1, 3);
-    if (Lut == NULL)
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[433]) {
+      if ((Lut == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 433\n");
+      else
+        fprintf(stderr, "reached bug index 433\n");
+    }
+    if ((!FIXREVERTER[433] && (Lut == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    )
         goto Error;
+        #ifdef FRCOV
+        }
+        #endif
 
     if (cmsGetPCS(hProfile) == cmsSigLabData) {
 
@@ -175,8 +254,23 @@ cmsPipeline* BuildGrayInputMatrixPipeline(cmsHPROFILE hProfile)
 
         EmptyTab = cmsBuildTabulatedToneCurve16(ContextID, 2, Zero);
 
-        if (EmptyTab == NULL)
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[434]) {
+          if ((EmptyTab == (void *) 0 ) && !(0))
+            fprintf(stderr, "triggered bug index 434\n");
+          else
+            fprintf(stderr, "reached bug index 434\n");
+        }
+        if ((!FIXREVERTER[434] && (EmptyTab == (void *) 0 ))
+        #else
+        if (0
+        #endif
+        )
             goto Error;
+            #ifdef FRCOV
+            }
+            #endif
 
         LabCurves[0] = GrayTRC;
         LabCurves[1] = EmptyTab;
@@ -320,13 +414,43 @@ cmsPipeline* _cmsReadInputLUT(cmsHPROFILE hProfile, int Intent)
         cmsPipeline* Lut;
         cmsNAMEDCOLORLIST* nc = (cmsNAMEDCOLORLIST*) cmsReadTag(hProfile, cmsSigNamedColor2Tag);
 
-        if (nc == NULL) return NULL;
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[436]) {
+          if ((nc == (void *) 0 ) && !(0))
+            fprintf(stderr, "triggered bug index 436\n");
+          else
+            fprintf(stderr, "reached bug index 436\n");
+        }
+        if ((!FIXREVERTER[436] && (nc == (void *) 0 ))
+        #else
+        if (0
+        #endif
+        ) return NULL;
+        #ifdef FRCOV
+        }
+        #endif
 
         Lut = cmsPipelineAlloc(ContextID, 0, 0);
-        if (Lut == NULL) {
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[437]) {
+          if ((Lut == (void *) 0 ) && !(0))
+            fprintf(stderr, "triggered bug index 437\n");
+          else
+            fprintf(stderr, "reached bug index 437\n");
+        }
+        if ((!FIXREVERTER[437] && (Lut == (void *) 0 ))
+        #else
+        if (0
+        #endif
+        ) {
             cmsFreeNamedColorList(nc);
             return NULL;
         }
+        #ifdef FRCOV
+        }
+        #endif
 
         if (!cmsPipelineInsertStage(Lut, cmsAT_BEGIN, _cmsStageAllocNamedColor(nc, TRUE)) ||
             !cmsPipelineInsertStage(Lut, cmsAT_END, _cmsStageAllocLabV2ToV4(ContextID))) {
@@ -338,7 +462,22 @@ cmsPipeline* _cmsReadInputLUT(cmsHPROFILE hProfile, int Intent)
 
     // This is an attempt to reuse this function to retrieve the matrix-shaper as pipeline no
     // matter other LUT are present and have precedence. Intent = -1 means just this.
-    if (Intent >= INTENT_PERCEPTUAL && Intent <= INTENT_ABSOLUTE_COLORIMETRIC) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[439]) {
+      fprintf(stderr, "reached bug index 439\n");
+    }
+    if ((FIXREVERTER[439] && (Intent >= 0 )) || (!FIXREVERTER[439] && (Intent >= 0 && Intent <= 3 ))
+    #else
+    if (Intent >= 0 
+    #endif
+    ) {
+      
+    #ifdef FRCOV
+      if (!(Intent <= 3 ))
+        fprintf(stderr, "triggered bug index 439\n");
+      #endif
+    
 
         tag16 = Device2PCS16[Intent];
         tagFloat = Device2PCSFloat[Intent];
@@ -361,7 +500,22 @@ cmsPipeline* _cmsReadInputLUT(cmsHPROFILE hProfile, int Intent)
 
             // First read the tag
             cmsPipeline* Lut = (cmsPipeline*) cmsReadTag(hProfile, tag16);
-            if (Lut == NULL) return NULL;
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[438]) {
+              if ((Lut == (void *) 0 ) && !(0))
+                fprintf(stderr, "triggered bug index 438\n");
+              else
+                fprintf(stderr, "reached bug index 438\n");
+            }
+            if ((!FIXREVERTER[438] && (Lut == (void *) 0 ))
+            #else
+            if (0
+            #endif
+            ) return NULL;
+            #ifdef FRCOV
+            }
+            #endif
 
             // After reading it, we have now info about the original type
             OriginalType =  _cmsGetTagTrueType(hProfile, tag16);
@@ -388,6 +542,9 @@ Error:
             return NULL;
         }
     }
+    #ifdef FRCOV
+    }
+    #endif
 
     // Lut was not found, try to create a matrix-shaper
 
@@ -418,16 +575,61 @@ cmsPipeline* BuildGrayOutputPipeline(cmsHPROFILE hProfile)
     cmsContext ContextID = cmsGetProfileContextID(hProfile);
 
     GrayTRC = (cmsToneCurve *) cmsReadTag(hProfile, cmsSigGrayTRCTag);
-    if (GrayTRC == NULL) return NULL;
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[441]) {
+      if ((GrayTRC == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 441\n");
+      else
+        fprintf(stderr, "reached bug index 441\n");
+    }
+    if ((!FIXREVERTER[441] && (GrayTRC == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) return NULL;
+    #ifdef FRCOV
+    }
+    #endif
 
     RevGrayTRC = cmsReverseToneCurve(GrayTRC);
-    if (RevGrayTRC == NULL) return NULL;
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[442]) {
+      if ((RevGrayTRC == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 442\n");
+      else
+        fprintf(stderr, "reached bug index 442\n");
+    }
+    if ((!FIXREVERTER[442] && (RevGrayTRC == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) return NULL;
+    #ifdef FRCOV
+    }
+    #endif
 
     Lut = cmsPipelineAlloc(ContextID, 3, 1);
-    if (Lut == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[443]) {
+      if ((Lut == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 443\n");
+      else
+        fprintf(stderr, "reached bug index 443\n");
+    }
+    if ((!FIXREVERTER[443] && (Lut == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         cmsFreeToneCurve(RevGrayTRC);
         return NULL;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
     if (cmsGetPCS(hProfile) == cmsSigLabData) {
 
@@ -546,7 +748,22 @@ cmsPipeline* _cmsReadFloatOutputTag(cmsHPROFILE hProfile, cmsTagSignature tagFlo
     cmsColorSpaceSignature PCS = cmsGetPCS(hProfile);
     cmsColorSpaceSignature dataSpace = cmsGetColorSpace(hProfile);
     
-    if (Lut == NULL) return NULL;
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[444]) {
+      if ((Lut == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 444\n");
+      else
+        fprintf(stderr, "reached bug index 444\n");
+    }
+    if ((!FIXREVERTER[444] && (Lut == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) return NULL;
+    #ifdef FRCOV
+    }
+    #endif
     
     // If PCS is Lab or XYZ, the floating point tag is accepting data in the space encoding,
     // and since the formatter has already accommodated to 0..1.0, we should undo this change
@@ -590,7 +807,22 @@ cmsPipeline* _cmsReadOutputLUT(cmsHPROFILE hProfile, int Intent)
     cmsContext ContextID  = cmsGetProfileContextID(hProfile);
 
 
-    if (Intent >= INTENT_PERCEPTUAL && Intent <= INTENT_ABSOLUTE_COLORIMETRIC) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[447]) {
+      fprintf(stderr, "reached bug index 447\n");
+    }
+    if ((FIXREVERTER[447] && (Intent >= 0 )) || (!FIXREVERTER[447] && (Intent >= 0 && Intent <= 3 ))
+    #else
+    if (Intent >= 0 
+    #endif
+    ) {
+      
+    #ifdef FRCOV
+      if (!(Intent <= 3 ))
+        fprintf(stderr, "triggered bug index 447\n");
+      #endif
+    
 
         tag16 = PCS2Device16[Intent];
         tagFloat = PCS2DeviceFloat[Intent];
@@ -612,14 +844,44 @@ cmsPipeline* _cmsReadOutputLUT(cmsHPROFILE hProfile, int Intent)
 
             // First read the tag
             cmsPipeline* Lut = (cmsPipeline*) cmsReadTag(hProfile, tag16);
-            if (Lut == NULL) return NULL;
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[445]) {
+              if ((Lut == (void *) 0 ) && !(0))
+                fprintf(stderr, "triggered bug index 445\n");
+              else
+                fprintf(stderr, "reached bug index 445\n");
+            }
+            if ((!FIXREVERTER[445] && (Lut == (void *) 0 ))
+            #else
+            if (0
+            #endif
+            ) return NULL;
+            #ifdef FRCOV
+            }
+            #endif
 
             // After reading it, we have info about the original type
             OriginalType =  _cmsGetTagTrueType(hProfile, tag16);
 
             // The profile owns the Lut, so we need to copy it
             Lut = cmsPipelineDup(Lut);
-            if (Lut == NULL) return NULL;
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[446]) {
+              if ((Lut == (void *) 0 ) && !(0))
+                fprintf(stderr, "triggered bug index 446\n");
+              else
+                fprintf(stderr, "reached bug index 446\n");
+            }
+            if ((!FIXREVERTER[446] && (Lut == (void *) 0 ))
+            #else
+            if (0
+            #endif
+            ) return NULL;
+            #ifdef FRCOV
+            }
+            #endif
 
             // Now it is time for a controversial stuff. I found that for 3D LUTS using
             // Lab used as indexer space,  trilinear interpolation should be used
@@ -645,6 +907,9 @@ Error:
             return NULL;
         }
     }
+    #ifdef FRCOV
+    }
+    #endif
 
     // Lut not found, try to create a matrix-shaper
 
@@ -671,7 +936,22 @@ cmsPipeline* _cmsReadFloatDevicelinkTag(cmsHPROFILE hProfile, cmsTagSignature ta
     cmsColorSpaceSignature PCS = cmsGetPCS(hProfile);
     cmsColorSpaceSignature spc = cmsGetColorSpace(hProfile);
 
-    if (Lut == NULL) return NULL;
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[449]) {
+      if ((Lut == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 449\n");
+      else
+        fprintf(stderr, "reached bug index 449\n");
+    }
+    if ((!FIXREVERTER[449] && (Lut == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) return NULL;
+    #ifdef FRCOV
+    }
+    #endif
 
     if (spc == cmsSigLabData)
     {
@@ -714,8 +994,23 @@ cmsPipeline* _cmsReadDevicelinkLUT(cmsHPROFILE hProfile, int Intent)
     cmsContext ContextID = cmsGetProfileContextID(hProfile);
 
 
-    if (Intent < INTENT_PERCEPTUAL || Intent > INTENT_ABSOLUTE_COLORIMETRIC)
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[450]) {
+      if ((Intent < 0 || Intent > 3 ) && !(0))
+        fprintf(stderr, "triggered bug index 450\n");
+      else
+        fprintf(stderr, "reached bug index 450\n");
+    }
+    if ((!FIXREVERTER[450] && (Intent < 0 || Intent > 3 ))
+    #else
+    if (0
+    #endif
+    )
         return NULL;
+        #ifdef FRCOV
+        }
+        #endif
 
     tag16 = Device2PCS16[Intent];
     tagFloat = Device2PCSFloat[Intent];
@@ -725,11 +1020,41 @@ cmsPipeline* _cmsReadDevicelinkLUT(cmsHPROFILE hProfile, int Intent)
 
         cmsNAMEDCOLORLIST* nc = (cmsNAMEDCOLORLIST*)cmsReadTag(hProfile, cmsSigNamedColor2Tag);
 
-        if (nc == NULL) return NULL;
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[451]) {
+          if ((nc == (void *) 0 ) && !(0))
+            fprintf(stderr, "triggered bug index 451\n");
+          else
+            fprintf(stderr, "reached bug index 451\n");
+        }
+        if ((!FIXREVERTER[451] && (nc == (void *) 0 ))
+        #else
+        if (0
+        #endif
+        ) return NULL;
+        #ifdef FRCOV
+        }
+        #endif
 
         Lut = cmsPipelineAlloc(ContextID, 0, 0);
-        if (Lut == NULL)
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[452]) {
+          if ((Lut == (void *) 0 ) && !(0))
+            fprintf(stderr, "triggered bug index 452\n");
+          else
+            fprintf(stderr, "reached bug index 452\n");
+        }
+        if ((!FIXREVERTER[452] && (Lut == (void *) 0 ))
+        #else
+        if (0
+        #endif
+        )
             goto Error;
+            #ifdef FRCOV
+            }
+            #endif
 
         if (!cmsPipelineInsertStage(Lut, cmsAT_BEGIN, _cmsStageAllocNamedColor(nc, FALSE)))
             goto Error;
@@ -768,11 +1093,41 @@ cmsPipeline* _cmsReadDevicelinkLUT(cmsHPROFILE hProfile, int Intent)
 
     // Read the tag
     Lut = (cmsPipeline*)cmsReadTag(hProfile, tag16);
-    if (Lut == NULL) return NULL;
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[453]) {
+      if ((Lut == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 453\n");
+      else
+        fprintf(stderr, "reached bug index 453\n");
+    }
+    if ((!FIXREVERTER[453] && (Lut == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) return NULL;
+    #ifdef FRCOV
+    }
+    #endif
 
     // The profile owns the Lut, so we need to copy it
     Lut = cmsPipelineDup(Lut);
-    if (Lut == NULL) return NULL;
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[454]) {
+      if ((Lut == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 454\n");
+      else
+        fprintf(stderr, "reached bug index 454\n");
+    }
+    if ((!FIXREVERTER[454] && (Lut == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) return NULL;
+    #ifdef FRCOV
+    }
+    #endif
 
     // Now it is time for a controversial stuff. I found that for 3D LUTS using
     // Lab used as indexer space,  trilinear interpolation should be used
@@ -933,7 +1288,22 @@ static
 cmsMLU* GetMLUFromProfile(cmsHPROFILE h, cmsTagSignature sig)
 {
     cmsMLU* mlu = (cmsMLU*) cmsReadTag(h, sig);
-    if (mlu == NULL) return NULL;
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[459]) {
+      if ((mlu == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 459\n");
+      else
+        fprintf(stderr, "reached bug index 459\n");
+    }
+    if ((!FIXREVERTER[459] && (mlu == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) return NULL;
+    #ifdef FRCOV
+    }
+    #endif
 
     return cmsMLUdup(mlu);
 }
@@ -944,7 +1314,22 @@ cmsSEQ* _cmsCompileProfileSequence(cmsContext ContextID, cmsUInt32Number nProfil
     cmsUInt32Number i;
     cmsSEQ* seq = cmsAllocProfileSequenceDescription(ContextID, nProfiles);
 
-    if (seq == NULL) return NULL;
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[460]) {
+      if ((seq == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 460\n");
+      else
+        fprintf(stderr, "reached bug index 460\n");
+    }
+    if ((!FIXREVERTER[460] && (seq == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) return NULL;
+    #ifdef FRCOV
+    }
+    #endif
 
     for (i=0; i < nProfiles; i++) {
 
diff --git a/src/cmslut.c b/src/cmslut.c
index 16169f9..8ead0e0 100644
--- a/src/cmslut.c
+++ b/src/cmslut.c
@@ -1,3 +1,7 @@
+#ifdef FRCOV
+#include <stdio.h>
+extern short FIXREVERTER[];
+#endif
 //---------------------------------------------------------------------------------
 //
 //  Little Color Management System
@@ -39,7 +43,22 @@ cmsStage* CMSEXPORT _cmsStageAllocPlaceholder(cmsContext ContextID,
 {
     cmsStage* ph = (cmsStage*) _cmsMallocZero(ContextID, sizeof(cmsStage));
 
-    if (ph == NULL) return NULL;
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[567]) {
+      if ((ph == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 567\n");
+      else
+        fprintf(stderr, "reached bug index 567\n");
+    }
+    if ((!FIXREVERTER[567] && (ph == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) return NULL;
+    #ifdef FRCOV
+    }
+    #endif
 
 
     ph ->ContextID = ContextID;
@@ -174,9 +193,39 @@ void EvaluateCurves(const cmsFloat32Number In[],
     _cmsAssert(mpe != NULL);
 
     Data = (_cmsStageToneCurvesData*) mpe ->Data;
-    if (Data == NULL) return;
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[569]) {
+      if ((Data == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 569\n");
+      else
+        fprintf(stderr, "reached bug index 569\n");
+    }
+    if ((!FIXREVERTER[569] && (Data == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) return;
+    #ifdef FRCOV
+    }
+    #endif
 
-    if (Data ->TheCurves == NULL) return;
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[570]) {
+      if ((Data -> TheCurves == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 570\n");
+      else
+        fprintf(stderr, "reached bug index 570\n");
+    }
+    if ((!FIXREVERTER[570] && (Data -> TheCurves == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) return;
+    #ifdef FRCOV
+    }
+    #endif
 
     for (i=0; i < Data ->nCurves; i++) {
         Out[i] = cmsEvalToneCurveFloat(Data ->TheCurves[i], In[i]);
@@ -192,7 +241,22 @@ void CurveSetElemTypeFree(cmsStage* mpe)
     _cmsAssert(mpe != NULL);
 
     Data = (_cmsStageToneCurvesData*) mpe ->Data;
-    if (Data == NULL) return;
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[571]) {
+      if ((Data == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 571\n");
+      else
+        fprintf(stderr, "reached bug index 571\n");
+    }
+    if ((!FIXREVERTER[571] && (Data == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) return;
+    #ifdef FRCOV
+    }
+    #endif
 
     if (Data ->TheCurves != NULL) {
         for (i=0; i < Data ->nCurves; i++) {
@@ -213,12 +277,42 @@ void* CurveSetDup(cmsStage* mpe)
     cmsUInt32Number i;
 
     NewElem = (_cmsStageToneCurvesData*) _cmsMallocZero(mpe ->ContextID, sizeof(_cmsStageToneCurvesData));
-    if (NewElem == NULL) return NULL;
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[572]) {
+      if ((NewElem == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 572\n");
+      else
+        fprintf(stderr, "reached bug index 572\n");
+    }
+    if ((!FIXREVERTER[572] && (NewElem == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) return NULL;
+    #ifdef FRCOV
+    }
+    #endif
 
     NewElem ->nCurves   = Data ->nCurves;
     NewElem ->TheCurves = (cmsToneCurve**) _cmsCalloc(mpe ->ContextID, NewElem ->nCurves, sizeof(cmsToneCurve*));
 
-    if (NewElem ->TheCurves == NULL) goto Error;
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[573]) {
+      if ((NewElem -> TheCurves == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 573\n");
+      else
+        fprintf(stderr, "reached bug index 573\n");
+    }
+    if ((!FIXREVERTER[573] && (NewElem -> TheCurves == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) goto Error;
+    #ifdef FRCOV
+    }
+    #endif
 
     for (i=0; i < NewElem ->nCurves; i++) {
 
@@ -254,22 +348,67 @@ cmsStage* CMSEXPORT cmsStageAllocToneCurves(cmsContext ContextID, cmsUInt32Numbe
 
     NewMPE = _cmsStageAllocPlaceholder(ContextID, cmsSigCurveSetElemType, nChannels, nChannels,
                                      EvaluateCurves, CurveSetDup, CurveSetElemTypeFree, NULL );
-    if (NewMPE == NULL) return NULL;
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[574]) {
+      if ((NewMPE == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 574\n");
+      else
+        fprintf(stderr, "reached bug index 574\n");
+    }
+    if ((!FIXREVERTER[574] && (NewMPE == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) return NULL;
+    #ifdef FRCOV
+    }
+    #endif
 
     NewElem = (_cmsStageToneCurvesData*) _cmsMallocZero(ContextID, sizeof(_cmsStageToneCurvesData));
-    if (NewElem == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[575]) {
+      if ((NewElem == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 575\n");
+      else
+        fprintf(stderr, "reached bug index 575\n");
+    }
+    if ((!FIXREVERTER[575] && (NewElem == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         cmsStageFree(NewMPE);
         return NULL;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
     NewMPE ->Data  = (void*) NewElem;
 
     NewElem ->nCurves   = nChannels;
     NewElem ->TheCurves = (cmsToneCurve**) _cmsCalloc(ContextID, nChannels, sizeof(cmsToneCurve*));
-    if (NewElem ->TheCurves == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[576]) {
+      if ((NewElem -> TheCurves == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 576\n");
+      else
+        fprintf(stderr, "reached bug index 576\n");
+    }
+    if ((!FIXREVERTER[576] && (NewElem -> TheCurves == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         cmsStageFree(NewMPE);
         return NULL;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
     for (i=0; i < nChannels; i++) {
 
@@ -296,7 +435,22 @@ cmsStage* _cmsStageAllocIdentityCurves(cmsContext ContextID, int nChannels)
 {
     cmsStage* mpe = cmsStageAllocToneCurves(ContextID, nChannels, NULL);
 
-    if (mpe == NULL) return NULL;
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[577]) {
+      if ((mpe == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 577\n");
+      else
+        fprintf(stderr, "reached bug index 577\n");
+    }
+    if ((!FIXREVERTER[577] && (mpe == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) return NULL;
+    #ifdef FRCOV
+    }
+    #endif
     mpe ->Implements = cmsSigIdentityElemType;
     return mpe;
 }
@@ -345,7 +499,22 @@ void* MatrixElemDup(cmsStage* mpe)
     cmsUInt32Number sz;
 
     NewElem = (_cmsStageMatrixData*) _cmsMallocZero(mpe ->ContextID, sizeof(_cmsStageMatrixData));
-    if (NewElem == NULL) return NULL;
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[578]) {
+      if ((NewElem == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 578\n");
+      else
+        fprintf(stderr, "reached bug index 578\n");
+    }
+    if ((!FIXREVERTER[578] && (NewElem == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) return NULL;
+    #ifdef FRCOV
+    }
+    #endif
 
     sz = mpe ->InputChannels * mpe ->OutputChannels;
 
@@ -363,8 +532,23 @@ static
 void MatrixElemTypeFree(cmsStage* mpe)
 {
     _cmsStageMatrixData* Data = (_cmsStageMatrixData*) mpe ->Data;
-    if (Data == NULL)
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[579]) {
+      if ((Data == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 579\n");
+      else
+        fprintf(stderr, "reached bug index 579\n");
+    }
+    if ((!FIXREVERTER[579] && (Data == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    )
         return;
+        #ifdef FRCOV
+        }
+        #endif
     if (Data ->Double)
         _cmsFree(mpe ->ContextID, Data ->Double);
 
@@ -389,23 +573,83 @@ cmsStage*  CMSEXPORT cmsStageAllocMatrix(cmsContext ContextID, cmsUInt32Number R
     if (n == 0) return NULL;
     if (n >= UINT_MAX / Cols) return NULL;
     if (n >= UINT_MAX / Rows) return NULL;
-    if (n < Rows || n < Cols) return NULL;
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[581]) {
+      if ((n < Rows || n < Cols ) && !(0))
+        fprintf(stderr, "triggered bug index 581\n");
+      else
+        fprintf(stderr, "reached bug index 581\n");
+    }
+    if ((!FIXREVERTER[581] && (n < Rows || n < Cols ))
+    #else
+    if (0
+    #endif
+    ) return NULL;
+    #ifdef FRCOV
+    }
+    #endif
 
     NewMPE = _cmsStageAllocPlaceholder(ContextID, cmsSigMatrixElemType, Cols, Rows,
                                      EvaluateMatrix, MatrixElemDup, MatrixElemTypeFree, NULL );
-    if (NewMPE == NULL) return NULL;
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[582]) {
+      if ((NewMPE == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 582\n");
+      else
+        fprintf(stderr, "reached bug index 582\n");
+    }
+    if ((!FIXREVERTER[582] && (NewMPE == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) return NULL;
+    #ifdef FRCOV
+    }
+    #endif
 
 
     NewElem = (_cmsStageMatrixData*) _cmsMallocZero(ContextID, sizeof(_cmsStageMatrixData));
-    if (NewElem == NULL) return NULL;
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[583]) {
+      if ((NewElem == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 583\n");
+      else
+        fprintf(stderr, "reached bug index 583\n");
+    }
+    if ((!FIXREVERTER[583] && (NewElem == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) return NULL;
+    #ifdef FRCOV
+    }
+    #endif
 
 
     NewElem ->Double = (cmsFloat64Number*) _cmsCalloc(ContextID, n, sizeof(cmsFloat64Number));
 
-    if (NewElem->Double == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[584]) {
+      if ((NewElem -> Double == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 584\n");
+      else
+        fprintf(stderr, "reached bug index 584\n");
+    }
+    if ((!FIXREVERTER[584] && (NewElem -> Double == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         MatrixElemTypeFree(NewMPE);
         return NULL;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
     for (i=0; i < n; i++) {
         NewElem ->Double[i] = Matrix[i];
@@ -415,10 +659,25 @@ cmsStage*  CMSEXPORT cmsStageAllocMatrix(cmsContext ContextID, cmsUInt32Number R
     if (Offset != NULL) {
 
         NewElem ->Offset = (cmsFloat64Number*) _cmsCalloc(ContextID, Rows, sizeof(cmsFloat64Number));
-        if (NewElem->Offset == NULL) {
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[585]) {
+          if ((NewElem -> Offset == (void *) 0 ) && !(0))
+            fprintf(stderr, "triggered bug index 585\n");
+          else
+            fprintf(stderr, "reached bug index 585\n");
+        }
+        if ((!FIXREVERTER[585] && (NewElem -> Offset == (void *) 0 ))
+        #else
+        if (0
+        #endif
+        ) {
            MatrixElemTypeFree(NewMPE);
            return NULL;
         }
+        #ifdef FRCOV
+        }
+        #endif
 
         for (i=0; i < Rows; i++) {
                 NewElem ->Offset[i] = Offset[i];
@@ -473,7 +732,22 @@ cmsUInt32Number CubeSize(const cmsUInt32Number Dims[], cmsUInt32Number b)
     for (rv = 1; b > 0; b--) {
 
         dim = Dims[b-1];
-        if (dim == 0) return 0;  // Error
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[586]) {
+          if ((dim == 0 ) && !(0))
+            fprintf(stderr, "triggered bug index 586\n");
+          else
+            fprintf(stderr, "reached bug index 586\n");
+        }
+        if ((!FIXREVERTER[586] && (dim == 0 ))
+        #else
+        if (0
+        #endif
+        ) return 0;
+        #ifdef FRCOV
+        }
+        #endif  // Error
 
         rv *= dim;
 
@@ -492,7 +766,22 @@ void* CLUTElemDup(cmsStage* mpe)
 
 
     NewElem = (_cmsStageCLutData*) _cmsMallocZero(mpe ->ContextID, sizeof(_cmsStageCLutData));
-    if (NewElem == NULL) return NULL;
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[587]) {
+      if ((NewElem == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 587\n");
+      else
+        fprintf(stderr, "reached bug index 587\n");
+    }
+    if ((!FIXREVERTER[587] && (NewElem == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) return NULL;
+    #ifdef FRCOV
+    }
+    #endif
 
     NewElem ->nEntries       = Data ->nEntries;
     NewElem ->HasFloatValues = Data ->HasFloatValues;
@@ -534,7 +823,22 @@ void CLutElemTypeFree(cmsStage* mpe)
     _cmsStageCLutData* Data = (_cmsStageCLutData*) mpe ->Data;
 
     // Already empty
-    if (Data == NULL) return;
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[588]) {
+      if ((Data == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 588\n");
+      else
+        fprintf(stderr, "reached bug index 588\n");
+    }
+    if ((!FIXREVERTER[588] && (Data == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) return;
+    #ifdef FRCOV
+    }
+    #endif
 
     // This works for both types
     if (Data -> Tab.T)
@@ -559,21 +863,66 @@ cmsStage* CMSEXPORT cmsStageAllocCLut16bitGranular(cmsContext ContextID,
 
     _cmsAssert(clutPoints != NULL);
 
-    if (inputChan > MAX_INPUT_DIMENSIONS) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[589]) {
+      if ((inputChan > 8 ) && !(0))
+        fprintf(stderr, "triggered bug index 589\n");
+      else
+        fprintf(stderr, "reached bug index 589\n");
+    }
+    if ((!FIXREVERTER[589] && (inputChan > 8 ))
+    #else
+    if (0
+    #endif
+    ) {
         cmsSignalError(ContextID, cmsERROR_RANGE, "Too many input channels (%d channels, max=%d)", inputChan, MAX_INPUT_DIMENSIONS);
         return NULL;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
     NewMPE = _cmsStageAllocPlaceholder(ContextID, cmsSigCLutElemType, inputChan, outputChan,
                                      EvaluateCLUTfloatIn16, CLUTElemDup, CLutElemTypeFree, NULL );
 
-    if (NewMPE == NULL) return NULL;
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[590]) {
+      if ((NewMPE == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 590\n");
+      else
+        fprintf(stderr, "reached bug index 590\n");
+    }
+    if ((!FIXREVERTER[590] && (NewMPE == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) return NULL;
+    #ifdef FRCOV
+    }
+    #endif
 
     NewElem = (_cmsStageCLutData*) _cmsMallocZero(ContextID, sizeof(_cmsStageCLutData));
-    if (NewElem == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[591]) {
+      if ((NewElem == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 591\n");
+      else
+        fprintf(stderr, "reached bug index 591\n");
+    }
+    if ((!FIXREVERTER[591] && (NewElem == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         cmsStageFree(NewMPE);
         return NULL;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
     NewMPE ->Data  = (void*) NewElem;
 
@@ -599,10 +948,25 @@ cmsStage* CMSEXPORT cmsStageAllocCLut16bitGranular(cmsContext ContextID,
     }
 
     NewElem ->Params = _cmsComputeInterpParamsEx(ContextID, clutPoints, inputChan, outputChan, NewElem ->Tab.T, CMS_LERP_FLAGS_16BITS);
-    if (NewElem ->Params == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[593]) {
+      if ((NewElem -> Params == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 593\n");
+      else
+        fprintf(stderr, "reached bug index 593\n");
+    }
+    if ((!FIXREVERTER[593] && (NewElem -> Params == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         cmsStageFree(NewMPE);
         return NULL;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
     return NewMPE;
 }
@@ -650,21 +1014,66 @@ cmsStage* CMSEXPORT cmsStageAllocCLutFloatGranular(cmsContext ContextID, const c
 
     _cmsAssert(clutPoints != NULL);
 
-    if (inputChan > MAX_INPUT_DIMENSIONS) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[594]) {
+      if ((inputChan > 8 ) && !(0))
+        fprintf(stderr, "triggered bug index 594\n");
+      else
+        fprintf(stderr, "reached bug index 594\n");
+    }
+    if ((!FIXREVERTER[594] && (inputChan > 8 ))
+    #else
+    if (0
+    #endif
+    ) {
         cmsSignalError(ContextID, cmsERROR_RANGE, "Too many input channels (%d channels, max=%d)", inputChan, MAX_INPUT_DIMENSIONS);
         return NULL;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
     NewMPE = _cmsStageAllocPlaceholder(ContextID, cmsSigCLutElemType, inputChan, outputChan,
                                              EvaluateCLUTfloat, CLUTElemDup, CLutElemTypeFree, NULL);
-    if (NewMPE == NULL) return NULL;
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[595]) {
+      if ((NewMPE == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 595\n");
+      else
+        fprintf(stderr, "reached bug index 595\n");
+    }
+    if ((!FIXREVERTER[595] && (NewMPE == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) return NULL;
+    #ifdef FRCOV
+    }
+    #endif
 
 
     NewElem = (_cmsStageCLutData*) _cmsMallocZero(ContextID, sizeof(_cmsStageCLutData));
-    if (NewElem == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[596]) {
+      if ((NewElem == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 596\n");
+      else
+        fprintf(stderr, "reached bug index 596\n");
+    }
+    if ((!FIXREVERTER[596] && (NewElem == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         cmsStageFree(NewMPE);
         return NULL;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
     NewMPE ->Data  = (void*) NewElem;
 
@@ -690,10 +1099,25 @@ cmsStage* CMSEXPORT cmsStageAllocCLutFloatGranular(cmsContext ContextID, const c
     }
 
     NewElem ->Params = _cmsComputeInterpParamsEx(ContextID, clutPoints,  inputChan, outputChan, NewElem ->Tab.TFloat, CMS_LERP_FLAGS_FLOAT);
-    if (NewElem ->Params == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[598]) {
+      if ((NewElem -> Params == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 598\n");
+      else
+        fprintf(stderr, "reached bug index 598\n");
+    }
+    if ((!FIXREVERTER[598] && (NewElem -> Params == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         cmsStageFree(NewMPE);
         return NULL;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
     return NewMPE;
 }
@@ -722,7 +1146,22 @@ cmsStage* _cmsStageAllocIdentityCLut(cmsContext ContextID, int nChan)
         Dimensions[i] = 2;
 
     mpe = cmsStageAllocCLut16bitGranular(ContextID, Dimensions, nChan, nChan, NULL);
-    if (mpe == NULL) return NULL;
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[599]) {
+      if ((mpe == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 599\n");
+      else
+        fprintf(stderr, "reached bug index 599\n");
+    }
+    if ((!FIXREVERTER[599] && (mpe == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) return NULL;
+    #ifdef FRCOV
+    }
+    #endif
 
     if (!cmsStageSampleCLut16bit(mpe, IdentitySampler, &nChan, 0)) {
         cmsStageFree(mpe);
@@ -755,20 +1194,110 @@ cmsBool CMSEXPORT cmsStageSampleCLut16bit(cmsStage* mpe, cmsSAMPLER16 Sampler, v
     cmsUInt16Number In[MAX_INPUT_DIMENSIONS+1], Out[MAX_STAGE_CHANNELS];
     _cmsStageCLutData* clut;
 
-    if (mpe == NULL) return FALSE;
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[600]) {
+      if ((mpe == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 600\n");
+      else
+        fprintf(stderr, "reached bug index 600\n");
+    }
+    if ((!FIXREVERTER[600] && (mpe == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) return FALSE;
+    #ifdef FRCOV
+    }
+    #endif
 
     clut = (_cmsStageCLutData*) mpe->Data;
 
-    if (clut == NULL) return FALSE;
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[601]) {
+      if ((clut == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 601\n");
+      else
+        fprintf(stderr, "reached bug index 601\n");
+    }
+    if ((!FIXREVERTER[601] && (clut == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) return FALSE;
+    #ifdef FRCOV
+    }
+    #endif
 
     nSamples = clut->Params ->nSamples;
     nInputs  = clut->Params ->nInputs;
     nOutputs = clut->Params ->nOutputs;
 
-    if (nInputs <= 0) return FALSE;
-    if (nOutputs <= 0) return FALSE;
-    if (nInputs > MAX_INPUT_DIMENSIONS) return FALSE;
-    if (nOutputs >= MAX_STAGE_CHANNELS) return FALSE;
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[602]) {
+      if ((nInputs <= 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 602\n");
+      else
+        fprintf(stderr, "reached bug index 602\n");
+    }
+    if ((!FIXREVERTER[602] && (nInputs <= 0 ))
+    #else
+    if (0
+    #endif
+    ) return FALSE;
+    #ifdef FRCOV
+    }
+    #endif
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[603]) {
+      if ((nOutputs <= 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 603\n");
+      else
+        fprintf(stderr, "reached bug index 603\n");
+    }
+    if ((!FIXREVERTER[603] && (nOutputs <= 0 ))
+    #else
+    if (0
+    #endif
+    ) return FALSE;
+    #ifdef FRCOV
+    }
+    #endif
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[604]) {
+      if ((nInputs > 8 ) && !(0))
+        fprintf(stderr, "triggered bug index 604\n");
+      else
+        fprintf(stderr, "reached bug index 604\n");
+    }
+    if ((!FIXREVERTER[604] && (nInputs > 8 ))
+    #else
+    if (0
+    #endif
+    ) return FALSE;
+    #ifdef FRCOV
+    }
+    #endif
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[605]) {
+      if ((nOutputs >= 128 ) && !(0))
+        fprintf(stderr, "triggered bug index 605\n");
+      else
+        fprintf(stderr, "reached bug index 605\n");
+    }
+    if ((!FIXREVERTER[605] && (nOutputs >= 128 ))
+    #else
+    if (0
+    #endif
+    ) return FALSE;
+    #ifdef FRCOV
+    }
+    #endif
 
     memset(In, 0, sizeof(In));
     memset(Out, 0, sizeof(Out));
@@ -877,7 +1406,22 @@ cmsBool CMSEXPORT cmsSliceSpace16(cmsUInt32Number nInputs, const cmsUInt32Number
     int i, t, nTotalPoints, rest;
     cmsUInt16Number In[cmsMAXCHANNELS];
 
-    if (nInputs >= cmsMAXCHANNELS) return FALSE;
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[612]) {
+      if ((nInputs >= 16 ) && !(0))
+        fprintf(stderr, "triggered bug index 612\n");
+      else
+        fprintf(stderr, "reached bug index 612\n");
+    }
+    if ((!FIXREVERTER[612] && (nInputs >= 16 ))
+    #else
+    if (0
+    #endif
+    ) return FALSE;
+    #ifdef FRCOV
+    }
+    #endif
 
     nTotalPoints = CubeSize(clutPoints, nInputs);
     if (nTotalPoints == 0) return FALSE;
@@ -1025,7 +1569,22 @@ cmsStage* _cmsStageAllocLabV2ToV4(cmsContext ContextID)
 
     cmsStage *mpe = cmsStageAllocMatrix(ContextID, 3, 3, V2ToV4, NULL);
 
-    if (mpe == NULL) return mpe;
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[617]) {
+      if ((mpe == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 617\n");
+      else
+        fprintf(stderr, "reached bug index 617\n");
+    }
+    if ((!FIXREVERTER[617] && (mpe == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) return mpe;
+    #ifdef FRCOV
+    }
+    #endif
     mpe ->Implements = cmsSigLabV2toV4;
     return mpe;
 }
@@ -1041,7 +1600,22 @@ cmsStage* _cmsStageAllocLabV4ToV2(cmsContext ContextID)
 
      cmsStage *mpe = cmsStageAllocMatrix(ContextID, 3, 3, V4ToV2, NULL);
 
-    if (mpe == NULL) return mpe;
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[618]) {
+      if ((mpe == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 618\n");
+      else
+        fprintf(stderr, "reached bug index 618\n");
+    }
+    if ((!FIXREVERTER[618] && (mpe == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) return mpe;
+    #ifdef FRCOV
+    }
+    #endif
     mpe ->Implements = cmsSigLabV4toV2;
     return mpe;
 }
@@ -1068,7 +1642,22 @@ cmsStage* _cmsStageNormalizeFromLabFloat(cmsContext ContextID)
 
     cmsStage *mpe = cmsStageAllocMatrix(ContextID, 3, 3, a1, o1);
 
-    if (mpe == NULL) return mpe;
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[619]) {
+      if ((mpe == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 619\n");
+      else
+        fprintf(stderr, "reached bug index 619\n");
+    }
+    if ((!FIXREVERTER[619] && (mpe == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) return mpe;
+    #ifdef FRCOV
+    }
+    #endif
     mpe ->Implements = cmsSigLab2FloatPCS;
     return mpe;
 }
@@ -1086,7 +1675,22 @@ cmsStage* _cmsStageNormalizeFromXyzFloat(cmsContext ContextID)
 
     cmsStage *mpe =  cmsStageAllocMatrix(ContextID, 3, 3, a1, NULL);
 
-    if (mpe == NULL) return mpe;
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[620]) {
+      if ((mpe == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 620\n");
+      else
+        fprintf(stderr, "reached bug index 620\n");
+    }
+    if ((!FIXREVERTER[620] && (mpe == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) return mpe;
+    #ifdef FRCOV
+    }
+    #endif
     mpe ->Implements = cmsSigXYZ2FloatPCS;
     return mpe;
 }
@@ -1106,7 +1710,22 @@ cmsStage* _cmsStageNormalizeToLabFloat(cmsContext ContextID)
     };
 
     cmsStage *mpe =  cmsStageAllocMatrix(ContextID, 3, 3, a1, o1);
-    if (mpe == NULL) return mpe;
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[621]) {
+      if ((mpe == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 621\n");
+      else
+        fprintf(stderr, "reached bug index 621\n");
+    }
+    if ((!FIXREVERTER[621] && (mpe == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) return mpe;
+    #ifdef FRCOV
+    }
+    #endif
     mpe ->Implements = cmsSigFloatPCS2Lab;
     return mpe;
 }
@@ -1123,7 +1742,22 @@ cmsStage* _cmsStageNormalizeToXyzFloat(cmsContext ContextID)
 #undef n
 
     cmsStage *mpe = cmsStageAllocMatrix(ContextID, 3, 3, a1, NULL);
-    if (mpe == NULL) return mpe;
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[622]) {
+      if ((mpe == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 622\n");
+      else
+        fprintf(stderr, "reached bug index 622\n");
+    }
+    if ((!FIXREVERTER[622] && (mpe == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) return mpe;
+    #ifdef FRCOV
+    }
+    #endif
     mpe ->Implements = cmsSigFloatPCS2XYZ;
     return mpe;
 }
@@ -1239,7 +1873,22 @@ cmsStage* CMSEXPORT cmsStageDup(cmsStage* mpe)
 {
     cmsStage* NewMPE;
 
-    if (mpe == NULL) return NULL;
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[623]) {
+      if ((mpe == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 623\n");
+      else
+        fprintf(stderr, "reached bug index 623\n");
+    }
+    if ((!FIXREVERTER[623] && (mpe == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) return NULL;
+    #ifdef FRCOV
+    }
+    #endif
     NewMPE = _cmsStageAllocPlaceholder(mpe ->ContextID,
                                      mpe ->Type,
                                      mpe ->InputChannels,
@@ -1248,7 +1897,22 @@ cmsStage* CMSEXPORT cmsStageDup(cmsStage* mpe)
                                      mpe ->DupElemPtr,
                                      mpe ->FreePtr,
                                      NULL);
-    if (NewMPE == NULL) return NULL;
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[624]) {
+      if ((NewMPE == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 624\n");
+      else
+        fprintf(stderr, "reached bug index 624\n");
+    }
+    if ((!FIXREVERTER[624] && (NewMPE == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) return NULL;
+    #ifdef FRCOV
+    }
+    #endif
 
     NewMPE ->Implements = mpe ->Implements;
 
@@ -1256,11 +1920,26 @@ cmsStage* CMSEXPORT cmsStageDup(cmsStage* mpe)
 
         NewMPE ->Data = mpe ->DupElemPtr(mpe);
 
-        if (NewMPE->Data == NULL) {
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[625]) {
+          if ((NewMPE -> Data == (void *) 0 ) && !(0))
+            fprintf(stderr, "triggered bug index 625\n");
+          else
+            fprintf(stderr, "reached bug index 625\n");
+        }
+        if ((!FIXREVERTER[625] && (NewMPE -> Data == (void *) 0 ))
+        #else
+        if (0
+        #endif
+        ) {
 
             cmsStageFree(NewMPE);
             return NULL;
         }
+        #ifdef FRCOV
+        }
+        #endif
 
     } else {
 
@@ -1288,7 +1967,22 @@ cmsBool BlessLUT(cmsPipeline* lut)
         First  = cmsPipelineGetPtrToFirstStage(lut);
         Last   = cmsPipelineGetPtrToLastStage(lut);
 
-        if (First == NULL || Last == NULL) return FALSE;
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[626]) {
+          if ((First == (void *) 0 || Last == (void *) 0 ) && !(0))
+            fprintf(stderr, "triggered bug index 626\n");
+          else
+            fprintf(stderr, "reached bug index 626\n");
+        }
+        if ((!FIXREVERTER[626] && (First == (void *) 0 || Last == (void *) 0 ))
+        #else
+        if (0
+        #endif
+        ) return FALSE;
+        #ifdef FRCOV
+        }
+        #endif
 
         lut->InputChannels = First->InputChannels;
         lut->OutputChannels = Last->OutputChannels;
@@ -1299,8 +1993,23 @@ cmsBool BlessLUT(cmsPipeline* lut)
 
         while (next != NULL)
         {
-            if (next->InputChannels != prev->OutputChannels)
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[627]) {
+              if ((next -> InputChannels != prev -> OutputChannels ) && !(0))
+                fprintf(stderr, "triggered bug index 627\n");
+              else
+                fprintf(stderr, "reached bug index 627\n");
+            }
+            if ((!FIXREVERTER[627] && (next -> InputChannels != prev -> OutputChannels ))
+            #else
+            if (0
+            #endif
+            )
                 return FALSE;
+                #ifdef FRCOV
+                }
+                #endif
 
             next = next->Next;
             prev = prev->Next;
@@ -1367,11 +2076,40 @@ cmsPipeline* CMSEXPORT cmsPipelineAlloc(cmsContext ContextID, cmsUInt32Number In
        cmsPipeline* NewLUT;
 
        // A value of zero in channels is allowed as placeholder
-       if (InputChannels >= cmsMAXCHANNELS ||
-           OutputChannels >= cmsMAXCHANNELS) return NULL;
+       
+       #ifdef FRCOV
+       {if (FIXREVERTER[628]) {
+         if ((InputChannels >= 16 || OutputChannels >= 16 ) && !(0))
+           fprintf(stderr, "triggered bug index 628\n");
+         else
+           fprintf(stderr, "reached bug index 628\n");
+       }
+       if ((!FIXREVERTER[628] && (InputChannels >= 16 || OutputChannels >= 16 ))
+       #else
+       if (0
+       #endif
+       ) return NULL;
+           #ifdef FRCOV
+           }
+           #endif
 
        NewLUT = (cmsPipeline*) _cmsMallocZero(ContextID, sizeof(cmsPipeline));
-       if (NewLUT == NULL) return NULL;
+       
+       #ifdef FRCOV
+       {if (FIXREVERTER[629]) {
+         if ((NewLUT == (void *) 0 ) && !(0))
+           fprintf(stderr, "triggered bug index 629\n");
+         else
+           fprintf(stderr, "reached bug index 629\n");
+       }
+       if ((!FIXREVERTER[629] && (NewLUT == (void *) 0 ))
+       #else
+       if (0
+       #endif
+       ) return NULL;
+       #ifdef FRCOV
+       }
+       #endif
 
        NewLUT -> InputChannels  = InputChannels;
        NewLUT -> OutputChannels = OutputChannels;
@@ -1415,7 +2153,22 @@ void CMSEXPORT cmsPipelineFree(cmsPipeline* lut)
 {
     cmsStage *mpe, *Next;
 
-    if (lut == NULL) return;
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[630]) {
+      if ((lut == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 630\n");
+      else
+        fprintf(stderr, "reached bug index 630\n");
+    }
+    if ((!FIXREVERTER[630] && (lut == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) return;
+    #ifdef FRCOV
+    }
+    #endif
 
     for (mpe = lut ->Elements;
         mpe != NULL;
@@ -1458,7 +2211,22 @@ cmsPipeline* CMSEXPORT cmsPipelineDup(const cmsPipeline* lut)
     if (lut == NULL) return NULL;
 
     NewLUT = cmsPipelineAlloc(lut ->ContextID, lut ->InputChannels, lut ->OutputChannels);
-    if (NewLUT == NULL) return NULL;
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[632]) {
+      if ((NewLUT == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 632\n");
+      else
+        fprintf(stderr, "reached bug index 632\n");
+    }
+    if ((!FIXREVERTER[632] && (NewLUT == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) return NULL;
+    #ifdef FRCOV
+    }
+    #endif
 
     for (mpe = lut ->Elements;
          mpe != NULL;
@@ -1466,18 +2234,48 @@ cmsPipeline* CMSEXPORT cmsPipelineDup(const cmsPipeline* lut)
 
              NewMPE = cmsStageDup(mpe);
 
-             if (NewMPE == NULL) {
+             
+             #ifdef FRCOV
+             {if (FIXREVERTER[633]) {
+               if ((NewMPE == (void *) 0 ) && !(0))
+                 fprintf(stderr, "triggered bug index 633\n");
+               else
+                 fprintf(stderr, "reached bug index 633\n");
+             }
+             if ((!FIXREVERTER[633] && (NewMPE == (void *) 0 ))
+             #else
+             if (0
+             #endif
+             ) {
                  cmsPipelineFree(NewLUT);
                  return NULL;
              }
+             #ifdef FRCOV
+             }
+             #endif
 
              if (First) {
                  NewLUT ->Elements = NewMPE;
                  First = FALSE;
              }
              else {
-                if (Anterior != NULL) 
+                
+                #ifdef FRCOV
+                {if (FIXREVERTER[634]) {
+                  if ((Anterior != (void *) 0  ) && !(0))
+                    fprintf(stderr, "triggered bug index 634\n");
+                  else
+                    fprintf(stderr, "reached bug index 634\n");
+                }
+                if ((!FIXREVERTER[634] && (Anterior != (void *) 0  ))
+                #else
+                if (0
+                #endif
+                ) 
                     Anterior ->Next = NewMPE;
+                    #ifdef FRCOV
+                    }
+                    #endif
              }
 
             Anterior = NewMPE;
@@ -1488,8 +2286,23 @@ cmsPipeline* CMSEXPORT cmsPipelineDup(const cmsPipeline* lut)
     NewLUT ->DupDataFn   = lut ->DupDataFn;
     NewLUT ->FreeDataFn  = lut ->FreeDataFn;
 
-    if (NewLUT ->DupDataFn != NULL)
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[635]) {
+      if ((NewLUT -> DupDataFn != (void *) 0  ) && !(0))
+        fprintf(stderr, "triggered bug index 635\n");
+      else
+        fprintf(stderr, "reached bug index 635\n");
+    }
+    if ((!FIXREVERTER[635] && (NewLUT -> DupDataFn != (void *) 0  ))
+    #else
+    if (0
+    #endif
+    )
         NewLUT ->Data = NewLUT ->DupDataFn(lut ->ContextID, lut->Data);
+        #ifdef FRCOV
+        }
+        #endif
 
 
     NewLUT ->SaveAs8Bits    = lut ->SaveAs8Bits;
@@ -1508,8 +2321,23 @@ int CMSEXPORT cmsPipelineInsertStage(cmsPipeline* lut, cmsStageLoc loc, cmsStage
 {
     cmsStage* Anterior = NULL, *pt;
 
-    if (lut == NULL || mpe == NULL)
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[636]) {
+      if ((lut == (void *) 0 || mpe == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 636\n");
+      else
+        fprintf(stderr, "reached bug index 636\n");
+    }
+    if ((!FIXREVERTER[636] && (lut == (void *) 0 || mpe == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    )
         return FALSE;
+        #ifdef FRCOV
+        }
+        #endif
 
     switch (loc) {
 
@@ -1547,10 +2375,25 @@ void CMSEXPORT cmsPipelineUnlinkStage(cmsPipeline* lut, cmsStageLoc loc, cmsStag
 
 
     // If empty LUT, there is nothing to remove
-    if (lut ->Elements == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[637]) {
+      if ((lut -> Elements == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 637\n");
+      else
+        fprintf(stderr, "reached bug index 637\n");
+    }
+    if ((!FIXREVERTER[637] && (lut -> Elements == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         if (mpe) *mpe = NULL;
         return;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
     // On depending on the strategy...
     switch (loc) {
@@ -1751,7 +2594,22 @@ cmsBool CMSEXPORT cmsPipelineEvalReverseFloat(cmsFloat32Number Target[],
     
     // Only 3->3 and 4->3 are supported
     if (lut ->InputChannels != 3 && lut ->InputChannels != 4) return FALSE;
-    if (lut ->OutputChannels != 3) return FALSE;
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[638]) {
+      if ((lut -> OutputChannels != 3 ) && !(0))
+        fprintf(stderr, "triggered bug index 638\n");
+      else
+        fprintf(stderr, "reached bug index 638\n");
+    }
+    if ((!FIXREVERTER[638] && (lut -> OutputChannels != 3 ))
+    #else
+    if (0
+    #endif
+    ) return FALSE;
+    #ifdef FRCOV
+    }
+    #endif
    
     // Take the hint as starting point if specified
     if (Hint == NULL) {
diff --git a/src/cmsnamed.c b/src/cmsnamed.c
index 1b75181..6fb12ec 100644
--- a/src/cmsnamed.c
+++ b/src/cmsnamed.c
@@ -1,3 +1,7 @@
+#ifdef FRCOV
+#include <stdio.h>
+extern short FIXREVERTER[];
+#endif
 //---------------------------------------------------------------------------------
 //
 //  Little Color Management System
@@ -35,20 +39,65 @@ cmsMLU* CMSEXPORT cmsMLUalloc(cmsContext ContextID, cmsUInt32Number nItems)
     cmsMLU* mlu;
 
     // nItems should be positive if given
-    if (nItems <= 0) nItems = 2;
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[474]) {
+      if ((nItems <= 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 474\n");
+      else
+        fprintf(stderr, "reached bug index 474\n");
+    }
+    if ((!FIXREVERTER[474] && (nItems <= 0 ))
+    #else
+    if (0
+    #endif
+    ) nItems = 2;
+    #ifdef FRCOV
+    }
+    #endif
 
     // Create the container
     mlu = (cmsMLU*) _cmsMallocZero(ContextID, sizeof(cmsMLU));
-    if (mlu == NULL) return NULL;
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[475]) {
+      if ((mlu == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 475\n");
+      else
+        fprintf(stderr, "reached bug index 475\n");
+    }
+    if ((!FIXREVERTER[475] && (mlu == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) return NULL;
+    #ifdef FRCOV
+    }
+    #endif
 
     mlu ->ContextID = ContextID;
 
     // Create entry array
     mlu ->Entries = (_cmsMLUentry*) _cmsCalloc(ContextID, nItems, sizeof(_cmsMLUentry));
-    if (mlu ->Entries == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[476]) {
+      if ((mlu -> Entries == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 476\n");
+      else
+        fprintf(stderr, "reached bug index 476\n");
+    }
+    if ((!FIXREVERTER[476] && (mlu -> Entries == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         _cmsFree(ContextID, mlu);
         return NULL;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
     // Ok, keep indexes up to date
     mlu ->AllocatedEntries    = nItems;
@@ -66,7 +115,22 @@ cmsBool GrowMLUpool(cmsMLU* mlu)
     void *NewPtr;
 
     // Sanity check
-    if (mlu == NULL) return FALSE;
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[477]) {
+      if ((mlu == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 477\n");
+      else
+        fprintf(stderr, "reached bug index 477\n");
+    }
+    if ((!FIXREVERTER[477] && (mlu == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) return FALSE;
+    #ifdef FRCOV
+    }
+    #endif
 
     if (mlu ->PoolSize == 0)
         size = 256;
@@ -74,11 +138,41 @@ cmsBool GrowMLUpool(cmsMLU* mlu)
         size = mlu ->PoolSize * 2;
 
     // Check for overflow
-    if (size < mlu ->PoolSize) return FALSE;
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[478]) {
+      if ((size < mlu -> PoolSize ) && !(0))
+        fprintf(stderr, "triggered bug index 478\n");
+      else
+        fprintf(stderr, "reached bug index 478\n");
+    }
+    if ((!FIXREVERTER[478] && (size < mlu -> PoolSize ))
+    #else
+    if (0
+    #endif
+    ) return FALSE;
+    #ifdef FRCOV
+    }
+    #endif
 
     // Reallocate the pool
     NewPtr = _cmsRealloc(mlu ->ContextID, mlu ->MemPool, size);
-    if (NewPtr == NULL) return FALSE;
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[479]) {
+      if ((NewPtr == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 479\n");
+      else
+        fprintf(stderr, "reached bug index 479\n");
+    }
+    if ((!FIXREVERTER[479] && (NewPtr == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) return FALSE;
+    #ifdef FRCOV
+    }
+    #endif
 
 
     mlu ->MemPool  = NewPtr;
@@ -96,16 +190,61 @@ cmsBool GrowMLUtable(cmsMLU* mlu)
     _cmsMLUentry *NewPtr;
 
     // Sanity check
-    if (mlu == NULL) return FALSE;
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[480]) {
+      if ((mlu == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 480\n");
+      else
+        fprintf(stderr, "reached bug index 480\n");
+    }
+    if ((!FIXREVERTER[480] && (mlu == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) return FALSE;
+    #ifdef FRCOV
+    }
+    #endif
 
     AllocatedEntries = mlu ->AllocatedEntries * 2;
 
     // Check for overflow
-    if (AllocatedEntries / 2 != mlu ->AllocatedEntries) return FALSE;
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[481]) {
+      if ((AllocatedEntries / 2 != mlu -> AllocatedEntries ) && !(0))
+        fprintf(stderr, "triggered bug index 481\n");
+      else
+        fprintf(stderr, "reached bug index 481\n");
+    }
+    if ((!FIXREVERTER[481] && (AllocatedEntries / 2 != mlu -> AllocatedEntries ))
+    #else
+    if (0
+    #endif
+    ) return FALSE;
+    #ifdef FRCOV
+    }
+    #endif
 
     // Reallocate the memory
     NewPtr = (_cmsMLUentry*)_cmsRealloc(mlu ->ContextID, mlu ->Entries, AllocatedEntries*sizeof(_cmsMLUentry));
-    if (NewPtr == NULL) return FALSE;
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[482]) {
+      if ((NewPtr == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 482\n");
+      else
+        fprintf(stderr, "reached bug index 482\n");
+    }
+    if ((!FIXREVERTER[482] && (NewPtr == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) return FALSE;
+    #ifdef FRCOV
+    }
+    #endif
 
     mlu ->Entries          = NewPtr;
     mlu ->AllocatedEntries = AllocatedEntries;
@@ -121,7 +260,22 @@ int SearchMLUEntry(cmsMLU* mlu, cmsUInt16Number LanguageCode, cmsUInt16Number Co
     cmsUInt32Number i;
 
     // Sanity check
-    if (mlu == NULL) return -1;
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[483]) {
+      if ((mlu == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 483\n");
+      else
+        fprintf(stderr, "reached bug index 483\n");
+    }
+    if ((!FIXREVERTER[483] && (mlu == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) return -1;
+    #ifdef FRCOV
+    }
+    #endif
 
     // Iterate whole table
     for (i=0; i < mlu ->UsedEntries; i++) {
@@ -144,7 +298,22 @@ cmsBool AddMLUBlock(cmsMLU* mlu, cmsUInt32Number size, const wchar_t *Block,
     cmsUInt8Number* Ptr;
 
     // Sanity check
-    if (mlu == NULL) return FALSE;
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[484]) {
+      if ((mlu == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 484\n");
+      else
+        fprintf(stderr, "reached bug index 484\n");
+    }
+    if ((!FIXREVERTER[484] && (mlu == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) return FALSE;
+    #ifdef FRCOV
+    }
+    #endif
 
     // Is there any room available?
     if (mlu ->UsedEntries >= mlu ->AllocatedEntries) {
@@ -163,7 +332,22 @@ cmsBool AddMLUBlock(cmsMLU* mlu, cmsUInt32Number size, const wchar_t *Block,
     Offset = mlu ->PoolUsed;
 
     Ptr = (cmsUInt8Number*) mlu ->MemPool;
-    if (Ptr == NULL) return FALSE;
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[485]) {
+      if ((Ptr == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 485\n");
+      else
+        fprintf(stderr, "reached bug index 485\n");
+    }
+    if ((!FIXREVERTER[485] && (Ptr == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) return FALSE;
+    #ifdef FRCOV
+    }
+    #endif
 
     // Set the entry
     memmove(Ptr + Offset, Block, size);
@@ -216,10 +400,40 @@ cmsBool CMSEXPORT cmsMLUsetASCII(cmsMLU* mlu, const char LanguageCode[3], const
     cmsUInt16Number Lang  = strTo16(LanguageCode);
     cmsUInt16Number Cntry = strTo16(CountryCode);
 
-    if (mlu == NULL) return FALSE;
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[486]) {
+      if ((mlu == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 486\n");
+      else
+        fprintf(stderr, "reached bug index 486\n");
+    }
+    if ((!FIXREVERTER[486] && (mlu == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) return FALSE;
+    #ifdef FRCOV
+    }
+    #endif
 
     WStr = (wchar_t*) _cmsCalloc(mlu ->ContextID, len,  sizeof(wchar_t));
-    if (WStr == NULL) return FALSE;
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[487]) {
+      if ((WStr == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 487\n");
+      else
+        fprintf(stderr, "reached bug index 487\n");
+    }
+    if ((!FIXREVERTER[487] && (WStr == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) return FALSE;
+    #ifdef FRCOV
+    }
+    #endif
 
     for (i=0; i < len; i++)
         WStr[i] = (wchar_t) ASCIIString[i];
@@ -251,8 +465,38 @@ cmsBool  CMSEXPORT cmsMLUsetWide(cmsMLU* mlu, const char Language[3], const char
     cmsUInt16Number Cntry = strTo16(Country);
     cmsUInt32Number len;
 
-    if (mlu == NULL) return FALSE;
-    if (WideString == NULL) return FALSE;
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[488]) {
+      if ((mlu == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 488\n");
+      else
+        fprintf(stderr, "reached bug index 488\n");
+    }
+    if ((!FIXREVERTER[488] && (mlu == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) return FALSE;
+    #ifdef FRCOV
+    }
+    #endif
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[489]) {
+      if ((WideString == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 489\n");
+      else
+        fprintf(stderr, "reached bug index 489\n");
+    }
+    if ((!FIXREVERTER[489] && (WideString == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) return FALSE;
+    #ifdef FRCOV
+    }
+    #endif
 
     len = (cmsUInt32Number) (mywcslen(WideString)) * sizeof(wchar_t);
     return AddMLUBlock(mlu, len, WideString, Lang, Cntry);
@@ -264,17 +508,77 @@ cmsMLU* CMSEXPORT cmsMLUdup(const cmsMLU* mlu)
     cmsMLU* NewMlu = NULL;
 
     // Duplicating a NULL obtains a NULL
-    if (mlu == NULL) return NULL;
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[490]) {
+      if ((mlu == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 490\n");
+      else
+        fprintf(stderr, "reached bug index 490\n");
+    }
+    if ((!FIXREVERTER[490] && (mlu == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) return NULL;
+    #ifdef FRCOV
+    }
+    #endif
 
     NewMlu = cmsMLUalloc(mlu ->ContextID, mlu ->UsedEntries);
-    if (NewMlu == NULL) return NULL;
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[491]) {
+      if ((NewMlu == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 491\n");
+      else
+        fprintf(stderr, "reached bug index 491\n");
+    }
+    if ((!FIXREVERTER[491] && (NewMlu == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) return NULL;
+    #ifdef FRCOV
+    }
+    #endif
 
     // Should never happen
-    if (NewMlu ->AllocatedEntries < mlu ->UsedEntries)
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[492]) {
+      if ((NewMlu -> AllocatedEntries < mlu -> UsedEntries ) && !(0))
+        fprintf(stderr, "triggered bug index 492\n");
+      else
+        fprintf(stderr, "reached bug index 492\n");
+    }
+    if ((!FIXREVERTER[492] && (NewMlu -> AllocatedEntries < mlu -> UsedEntries ))
+    #else
+    if (0
+    #endif
+    )
         goto Error;
+        #ifdef FRCOV
+        }
+        #endif
 
     // Sanitize...
-    if (NewMlu ->Entries == NULL || mlu ->Entries == NULL)  goto Error;
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[493]) {
+      if ((NewMlu -> Entries == (void *) 0 || mlu -> Entries == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 493\n");
+      else
+        fprintf(stderr, "reached bug index 493\n");
+    }
+    if ((!FIXREVERTER[493] && (NewMlu -> Entries == (void *) 0 || mlu -> Entries == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    )  goto Error;
+    #ifdef FRCOV
+    }
+    #endif
 
     memmove(NewMlu ->Entries, mlu ->Entries, mlu ->UsedEntries * sizeof(_cmsMLUentry));
     NewMlu ->UsedEntries = mlu ->UsedEntries;
@@ -286,12 +590,42 @@ cmsMLU* CMSEXPORT cmsMLUdup(const cmsMLU* mlu)
     else {
         // It is not empty
         NewMlu ->MemPool = _cmsMalloc(mlu ->ContextID, mlu ->PoolUsed);
-        if (NewMlu ->MemPool == NULL) goto Error;
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[494]) {
+          if ((NewMlu -> MemPool == (void *) 0 ) && !(0))
+            fprintf(stderr, "triggered bug index 494\n");
+          else
+            fprintf(stderr, "reached bug index 494\n");
+        }
+        if ((!FIXREVERTER[494] && (NewMlu -> MemPool == (void *) 0 ))
+        #else
+        if (0
+        #endif
+        ) goto Error;
+        #ifdef FRCOV
+        }
+        #endif
     }
 
     NewMlu ->PoolSize = mlu ->PoolUsed;
 
-    if (NewMlu ->MemPool == NULL || mlu ->MemPool == NULL) goto Error;
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[495]) {
+      if ((NewMlu -> MemPool == (void *) 0 || mlu -> MemPool == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 495\n");
+      else
+        fprintf(stderr, "reached bug index 495\n");
+    }
+    if ((!FIXREVERTER[495] && (NewMlu -> MemPool == (void *) 0 || mlu -> MemPool == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) goto Error;
+    #ifdef FRCOV
+    }
+    #endif
 
     memmove(NewMlu ->MemPool, mlu->MemPool, mlu ->PoolUsed);
     NewMlu ->PoolUsed = mlu ->PoolUsed;
@@ -329,9 +663,39 @@ const wchar_t* _cmsMLUgetWide(const cmsMLU* mlu,
     cmsInt32Number Best = -1;
     _cmsMLUentry* v;
 
-    if (mlu == NULL) return NULL;
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[496]) {
+      if ((mlu == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 496\n");
+      else
+        fprintf(stderr, "reached bug index 496\n");
+    }
+    if ((!FIXREVERTER[496] && (mlu == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) return NULL;
+    #ifdef FRCOV
+    }
+    #endif
 
-    if (mlu -> AllocatedEntries <= 0) return NULL;
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[497]) {
+      if ((mlu -> AllocatedEntries <= 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 497\n");
+      else
+        fprintf(stderr, "reached bug index 497\n");
+    }
+    if ((!FIXREVERTER[497] && (mlu -> AllocatedEntries <= 0 ))
+    #else
+    if (0
+    #endif
+    ) return NULL;
+    #ifdef FRCOV
+    }
+    #endif
 
     for (i=0; i < mlu ->UsedEntries; i++) {
 
@@ -381,23 +745,98 @@ cmsUInt32Number CMSEXPORT cmsMLUgetASCII(const cmsMLU* mlu,
     cmsUInt16Number Cntry = strTo16(CountryCode);
 
     // Sanitize
-    if (mlu == NULL) return 0;
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[498]) {
+      if ((mlu == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 498\n");
+      else
+        fprintf(stderr, "reached bug index 498\n");
+    }
+    if ((!FIXREVERTER[498] && (mlu == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) return 0;
+    #ifdef FRCOV
+    }
+    #endif
 
     // Get WideChar
     Wide = _cmsMLUgetWide(mlu, &StrLen, Lang, Cntry, NULL, NULL);
-    if (Wide == NULL) return 0;
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[499]) {
+      if ((Wide == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 499\n");
+      else
+        fprintf(stderr, "reached bug index 499\n");
+    }
+    if ((!FIXREVERTER[499] && (Wide == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) return 0;
+    #ifdef FRCOV
+    }
+    #endif
 
     ASCIIlen = StrLen / sizeof(wchar_t);
 
     // Maybe we want only to know the len?
-    if (Buffer == NULL) return ASCIIlen + 1; // Note the zero at the end
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[500]) {
+      if ((Buffer == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 500\n");
+      else
+        fprintf(stderr, "reached bug index 500\n");
+    }
+    if ((!FIXREVERTER[500] && (Buffer == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) return ASCIIlen + 1;
+    #ifdef FRCOV
+    }
+    #endif // Note the zero at the end
 
     // No buffer size means no data
-    if (BufferSize <= 0) return 0;
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[501]) {
+      if ((BufferSize <= 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 501\n");
+      else
+        fprintf(stderr, "reached bug index 501\n");
+    }
+    if ((!FIXREVERTER[501] && (BufferSize <= 0 ))
+    #else
+    if (0
+    #endif
+    ) return 0;
+    #ifdef FRCOV
+    }
+    #endif
 
     // Some clipping may be required
-    if (BufferSize < ASCIIlen + 1)
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[502]) {
+      if ((BufferSize < ASCIIlen + 1 ) && !(0))
+        fprintf(stderr, "triggered bug index 502\n");
+      else
+        fprintf(stderr, "reached bug index 502\n");
+    }
+    if ((!FIXREVERTER[502] && (BufferSize < ASCIIlen + 1 ))
+    #else
+    if (0
+    #endif
+    )
         ASCIIlen = BufferSize - 1;
+        #ifdef FRCOV
+        }
+        #endif
 
     // Precess each character
     for (i=0; i < ASCIIlen; i++) {
@@ -425,16 +864,76 @@ cmsUInt32Number CMSEXPORT cmsMLUgetWide(const cmsMLU* mlu,
     cmsUInt16Number Cntry = strTo16(CountryCode);
 
     // Sanitize
-    if (mlu == NULL) return 0;
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[503]) {
+      if ((mlu == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 503\n");
+      else
+        fprintf(stderr, "reached bug index 503\n");
+    }
+    if ((!FIXREVERTER[503] && (mlu == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) return 0;
+    #ifdef FRCOV
+    }
+    #endif
 
     Wide = _cmsMLUgetWide(mlu, &StrLen, Lang, Cntry, NULL, NULL);
-    if (Wide == NULL) return 0;
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[504]) {
+      if ((Wide == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 504\n");
+      else
+        fprintf(stderr, "reached bug index 504\n");
+    }
+    if ((!FIXREVERTER[504] && (Wide == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) return 0;
+    #ifdef FRCOV
+    }
+    #endif
 
     // Maybe we want only to know the len?
-    if (Buffer == NULL) return StrLen + sizeof(wchar_t);
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[505]) {
+      if ((Buffer == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 505\n");
+      else
+        fprintf(stderr, "reached bug index 505\n");
+    }
+    if ((!FIXREVERTER[505] && (Buffer == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) return StrLen + sizeof(wchar_t);
+    #ifdef FRCOV
+    }
+    #endif
 
   // No buffer size means no data
-    if (BufferSize <= 0) return 0;
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[506]) {
+      if ((BufferSize <= 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 506\n");
+      else
+        fprintf(stderr, "reached bug index 506\n");
+    }
+    if ((!FIXREVERTER[506] && (BufferSize <= 0 ))
+    #else
+    if (0
+    #endif
+    ) return 0;
+    #ifdef FRCOV
+    }
+    #endif
 
     // Some clipping may be required
     if (BufferSize < StrLen + sizeof(wchar_t))
@@ -510,7 +1009,22 @@ cmsBool  GrowNamedColorList(cmsNAMEDCOLORLIST* v)
     cmsUInt32Number size;
     _cmsNAMEDCOLOR * NewPtr;
 
-    if (v == NULL) return FALSE;
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[510]) {
+      if ((v == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 510\n");
+      else
+        fprintf(stderr, "reached bug index 510\n");
+    }
+    if ((!FIXREVERTER[510] && (v == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) return FALSE;
+    #ifdef FRCOV
+    }
+    #endif
 
     if (v ->Allocated == 0)
         size = 64;   // Initial guess
@@ -518,15 +1032,45 @@ cmsBool  GrowNamedColorList(cmsNAMEDCOLORLIST* v)
         size = v ->Allocated * 2;
 
     // Keep a maximum color lists can grow, 100K entries seems reasonable
-    if (size > 1024 * 100) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[511]) {
+      if ((size > 1024 * 100 ) && !(0))
+        fprintf(stderr, "triggered bug index 511\n");
+      else
+        fprintf(stderr, "reached bug index 511\n");
+    }
+    if ((!FIXREVERTER[511] && (size > 1024 * 100 ))
+    #else
+    if (0
+    #endif
+    ) {
         _cmsFree(v->ContextID, (void*) v->List);
         v->List = NULL;
         return FALSE;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
     NewPtr = (_cmsNAMEDCOLOR*) _cmsRealloc(v ->ContextID, v ->List, size * sizeof(_cmsNAMEDCOLOR));
-    if (NewPtr == NULL)
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[512]) {
+      if ((NewPtr == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 512\n");
+      else
+        fprintf(stderr, "reached bug index 512\n");
+    }
+    if ((!FIXREVERTER[512] && (NewPtr == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    )
         return FALSE;
+        #ifdef FRCOV
+        }
+        #endif
 
     v ->List      = NewPtr;
     v ->Allocated = size;
@@ -538,7 +1082,22 @@ cmsNAMEDCOLORLIST* CMSEXPORT cmsAllocNamedColorList(cmsContext ContextID, cmsUIn
 {
     cmsNAMEDCOLORLIST* v = (cmsNAMEDCOLORLIST*) _cmsMallocZero(ContextID, sizeof(cmsNAMEDCOLORLIST));
 
-    if (v == NULL) return NULL;
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[513]) {
+      if ((v == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 513\n");
+      else
+        fprintf(stderr, "reached bug index 513\n");
+    }
+    if ((!FIXREVERTER[513] && (v == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) return NULL;
+    #ifdef FRCOV
+    }
+    #endif
 
     v ->List      = NULL;
     v ->nColors   = 0;
@@ -563,7 +1122,22 @@ cmsNAMEDCOLORLIST* CMSEXPORT cmsAllocNamedColorList(cmsContext ContextID, cmsUIn
 // Free a list
 void CMSEXPORT cmsFreeNamedColorList(cmsNAMEDCOLORLIST* v)
 {
-    if (v == NULL) return;
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[514]) {
+      if ((v == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 514\n");
+      else
+        fprintf(stderr, "reached bug index 514\n");
+    }
+    if ((!FIXREVERTER[514] && (v == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) return;
+    #ifdef FRCOV
+    }
+    #endif
     if (v ->List) _cmsFree(v ->ContextID, v ->List);
     _cmsFree(v ->ContextID, v);
 }
@@ -572,10 +1146,40 @@ cmsNAMEDCOLORLIST* CMSEXPORT cmsDupNamedColorList(const cmsNAMEDCOLORLIST* v)
 {
     cmsNAMEDCOLORLIST* NewNC;
 
-    if (v == NULL) return NULL;
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[515]) {
+      if ((v == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 515\n");
+      else
+        fprintf(stderr, "reached bug index 515\n");
+    }
+    if ((!FIXREVERTER[515] && (v == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) return NULL;
+    #ifdef FRCOV
+    }
+    #endif
 
     NewNC= cmsAllocNamedColorList(v ->ContextID, v -> nColors, v ->ColorantCount, v ->Prefix, v ->Suffix);
-    if (NewNC == NULL) return NULL;
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[516]) {
+      if ((NewNC == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 516\n");
+      else
+        fprintf(stderr, "reached bug index 516\n");
+    }
+    if ((!FIXREVERTER[516] && (NewNC == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) return NULL;
+    #ifdef FRCOV
+    }
+    #endif
 
     // For really large tables we need this
     while (NewNC ->Allocated < v ->Allocated){
@@ -598,7 +1202,22 @@ cmsBool  CMSEXPORT cmsAppendNamedColor(cmsNAMEDCOLORLIST* NamedColorList,
 {
     cmsUInt32Number i;
 
-    if (NamedColorList == NULL) return FALSE;
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[517]) {
+      if ((NamedColorList == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 517\n");
+      else
+        fprintf(stderr, "reached bug index 517\n");
+    }
+    if ((!FIXREVERTER[517] && (NamedColorList == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) return FALSE;
+    #ifdef FRCOV
+    }
+    #endif
 
     if (NamedColorList ->nColors + 1 > NamedColorList ->Allocated) {
         if (!GrowNamedColorList(NamedColorList)) return FALSE;
@@ -627,7 +1246,22 @@ cmsBool  CMSEXPORT cmsAppendNamedColor(cmsNAMEDCOLORLIST* NamedColorList,
 // Returns number of elements
 cmsUInt32Number CMSEXPORT cmsNamedColorCount(const cmsNAMEDCOLORLIST* NamedColorList)
 {
-     if (NamedColorList == NULL) return 0;
+     
+     #ifdef FRCOV
+     {if (FIXREVERTER[518]) {
+       if ((NamedColorList == (void *) 0 ) && !(0))
+         fprintf(stderr, "triggered bug index 518\n");
+       else
+         fprintf(stderr, "reached bug index 518\n");
+     }
+     if ((!FIXREVERTER[518] && (NamedColorList == (void *) 0 ))
+     #else
+     if (0
+     #endif
+     ) return 0;
+     #ifdef FRCOV
+     }
+     #endif
      return NamedColorList ->nColors;
 }
 
@@ -639,9 +1273,39 @@ cmsBool  CMSEXPORT cmsNamedColorInfo(const cmsNAMEDCOLORLIST* NamedColorList, cm
                                      cmsUInt16Number* PCS,
                                      cmsUInt16Number* Colorant)
 {
-    if (NamedColorList == NULL) return FALSE;
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[519]) {
+      if ((NamedColorList == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 519\n");
+      else
+        fprintf(stderr, "reached bug index 519\n");
+    }
+    if ((!FIXREVERTER[519] && (NamedColorList == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) return FALSE;
+    #ifdef FRCOV
+    }
+    #endif
 
-    if (nColor >= cmsNamedColorCount(NamedColorList)) return FALSE;
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[520]) {
+      if ((nColor >= cmsNamedColorCount ( NamedColorList ) ) && !(0))
+        fprintf(stderr, "triggered bug index 520\n");
+      else
+        fprintf(stderr, "reached bug index 520\n");
+    }
+    if ((!FIXREVERTER[520] && (nColor >= cmsNamedColorCount ( NamedColorList ) ))
+    #else
+    if (0
+    #endif
+    ) return FALSE;
+    #ifdef FRCOV
+    }
+    #endif
 
     if (Name) strcpy(Name, NamedColorList->List[nColor].Name);
     if (Prefix) strcpy(Prefix, NamedColorList->Prefix);
@@ -755,23 +1419,83 @@ cmsSEQ* CMSEXPORT cmsAllocProfileSequenceDescription(cmsContext ContextID, cmsUI
     cmsSEQ* Seq;
     cmsUInt32Number i;
 
-    if (n == 0) return NULL;
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[522]) {
+      if ((n == 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 522\n");
+      else
+        fprintf(stderr, "reached bug index 522\n");
+    }
+    if ((!FIXREVERTER[522] && (n == 0 ))
+    #else
+    if (0
+    #endif
+    ) return NULL;
+    #ifdef FRCOV
+    }
+    #endif
 
     // In a absolutely arbitrary way, I hereby decide to allow a maxim of 255 profiles linked
     // in a devicelink. It makes not sense anyway and may be used for exploits, so let's close the door!
-    if (n > 255) return NULL;
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[523]) {
+      if ((n > 255 ) && !(0))
+        fprintf(stderr, "triggered bug index 523\n");
+      else
+        fprintf(stderr, "reached bug index 523\n");
+    }
+    if ((!FIXREVERTER[523] && (n > 255 ))
+    #else
+    if (0
+    #endif
+    ) return NULL;
+    #ifdef FRCOV
+    }
+    #endif
 
     Seq = (cmsSEQ*) _cmsMallocZero(ContextID, sizeof(cmsSEQ));
-    if (Seq == NULL) return NULL;
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[524]) {
+      if ((Seq == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 524\n");
+      else
+        fprintf(stderr, "reached bug index 524\n");
+    }
+    if ((!FIXREVERTER[524] && (Seq == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) return NULL;
+    #ifdef FRCOV
+    }
+    #endif
 
     Seq -> ContextID = ContextID;
     Seq -> seq      = (cmsPSEQDESC*) _cmsCalloc(ContextID, n, sizeof(cmsPSEQDESC));
     Seq -> n        = n;
 
-    if (Seq -> seq == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[525]) {
+      if ((Seq -> seq == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 525\n");
+      else
+        fprintf(stderr, "reached bug index 525\n");
+    }
+    if ((!FIXREVERTER[525] && (Seq -> seq == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         _cmsFree(ContextID, Seq);
         return NULL;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
     for (i=0; i < n; i++) {
         Seq -> seq[i].Manufacturer = NULL;
@@ -801,15 +1525,60 @@ cmsSEQ* CMSEXPORT cmsDupProfileSequenceDescription(const cmsSEQ* pseq)
     cmsSEQ *NewSeq;
     cmsUInt32Number i;
 
-    if (pseq == NULL)
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[526]) {
+      if ((pseq == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 526\n");
+      else
+        fprintf(stderr, "reached bug index 526\n");
+    }
+    if ((!FIXREVERTER[526] && (pseq == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    )
         return NULL;
+        #ifdef FRCOV
+        }
+        #endif
 
     NewSeq = (cmsSEQ*) _cmsMalloc(pseq -> ContextID, sizeof(cmsSEQ));
-    if (NewSeq == NULL) return NULL;
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[527]) {
+      if ((NewSeq == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 527\n");
+      else
+        fprintf(stderr, "reached bug index 527\n");
+    }
+    if ((!FIXREVERTER[527] && (NewSeq == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) return NULL;
+    #ifdef FRCOV
+    }
+    #endif
 
 
     NewSeq -> seq      = (cmsPSEQDESC*) _cmsCalloc(pseq ->ContextID, pseq ->n, sizeof(cmsPSEQDESC));
-    if (NewSeq ->seq == NULL) goto Error;
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[528]) {
+      if ((NewSeq -> seq == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 528\n");
+      else
+        fprintf(stderr, "reached bug index 528\n");
+    }
+    if ((!FIXREVERTER[528] && (NewSeq -> seq == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) goto Error;
+    #ifdef FRCOV
+    }
+    #endif
 
     NewSeq -> ContextID = pseq ->ContextID;
     NewSeq -> n        = pseq ->n;
@@ -852,7 +1621,22 @@ typedef struct _cmsDICT_struct {
 cmsHANDLE CMSEXPORT cmsDictAlloc(cmsContext ContextID)
 {
     _cmsDICT* dict = (_cmsDICT*) _cmsMallocZero(ContextID, sizeof(_cmsDICT));
-    if (dict == NULL) return NULL;
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[529]) {
+      if ((dict == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 529\n");
+      else
+        fprintf(stderr, "reached bug index 529\n");
+    }
+    if ((!FIXREVERTER[529] && (dict == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) return NULL;
+    #ifdef FRCOV
+    }
+    #endif
 
     dict ->ContextID = ContextID;
     return (cmsHANDLE) dict;
@@ -891,7 +1675,22 @@ void CMSEXPORT cmsDictFree(cmsHANDLE hDict)
 static
 wchar_t* DupWcs(cmsContext ContextID, const wchar_t* ptr)
 {
-    if (ptr == NULL) return NULL;
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[530]) {
+      if ((ptr == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 530\n");
+      else
+        fprintf(stderr, "reached bug index 530\n");
+    }
+    if ((!FIXREVERTER[530] && (ptr == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) return NULL;
+    #ifdef FRCOV
+    }
+    #endif
     return (wchar_t*) _cmsDupMem(ContextID, ptr, (mywcslen(ptr) + 1) * sizeof(wchar_t));
 }
 
@@ -905,7 +1704,22 @@ cmsBool CMSEXPORT cmsDictAddEntry(cmsHANDLE hDict, const wchar_t* Name, const wc
     _cmsAssert(Name != NULL);
 
     entry = (cmsDICTentry*) _cmsMallocZero(dict ->ContextID, sizeof(cmsDICTentry));
-    if (entry == NULL) return FALSE;
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[531]) {
+      if ((entry == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 531\n");
+      else
+        fprintf(stderr, "reached bug index 531\n");
+    }
+    if ((!FIXREVERTER[531] && (entry == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) return FALSE;
+    #ifdef FRCOV
+    }
+    #endif
 
     entry ->DisplayName  = cmsMLUdup(DisplayName);
     entry ->DisplayValue = cmsMLUdup(DisplayValue);
@@ -929,7 +1743,22 @@ cmsHANDLE CMSEXPORT cmsDictDup(cmsHANDLE hDict)
     _cmsAssert(old_dict != NULL);
 
     hNew  = cmsDictAlloc(old_dict ->ContextID);
-    if (hNew == NULL) return NULL;
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[532]) {
+      if ((hNew == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 532\n");
+      else
+        fprintf(stderr, "reached bug index 532\n");
+    }
+    if ((!FIXREVERTER[532] && (hNew == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) return NULL;
+    #ifdef FRCOV
+    }
+    #endif
 
     // Walk the list freeing all nodes
     entry = old_dict ->head;
@@ -952,13 +1781,43 @@ const cmsDICTentry* CMSEXPORT cmsDictGetEntryList(cmsHANDLE hDict)
 {
     _cmsDICT* dict = (_cmsDICT*) hDict;
 
-    if (dict == NULL) return NULL;
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[533]) {
+      if ((dict == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 533\n");
+      else
+        fprintf(stderr, "reached bug index 533\n");
+    }
+    if ((!FIXREVERTER[533] && (dict == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) return NULL;
+    #ifdef FRCOV
+    }
+    #endif
     return dict ->head;
 }
 
 // Helper For external languages
 const cmsDICTentry* CMSEXPORT cmsDictNextEntry(const cmsDICTentry* e)
 {
-     if (e == NULL) return NULL;
+     
+     #ifdef FRCOV
+     {if (FIXREVERTER[534]) {
+       if ((e == (void *) 0 ) && !(0))
+         fprintf(stderr, "triggered bug index 534\n");
+       else
+         fprintf(stderr, "reached bug index 534\n");
+     }
+     if ((!FIXREVERTER[534] && (e == (void *) 0 ))
+     #else
+     if (0
+     #endif
+     ) return NULL;
+     #ifdef FRCOV
+     }
+     #endif
      return e ->Next;
 }
diff --git a/src/cmsopt.c b/src/cmsopt.c
index 8597702..b7b47f8 100644
--- a/src/cmsopt.c
+++ b/src/cmsopt.c
@@ -1,3 +1,7 @@
+#ifdef FRCOV
+#include <stdio.h>
+extern short FIXREVERTER[];
+#endif
 //---------------------------------------------------------------------------------
 //
 //  Little Color Management System
@@ -228,7 +232,22 @@ cmsBool _MultiplyMatrix(cmsPipeline* Lut)
 
                             // We can not get rid of full matrix                            
                             cmsStage* Multmat = cmsStageAllocMatrix(Lut->ContextID, 3, 3, (const cmsFloat64Number*) &res, NULL);
-                            if (Multmat == NULL) return FALSE;  // Should never happen
+                            
+                            #ifdef FRCOV
+                            {if (FIXREVERTER[535]) {
+                              if ((Multmat == (void *) 0 ) && !(0))
+                                fprintf(stderr, "triggered bug index 535\n");
+                              else
+                                fprintf(stderr, "reached bug index 535\n");
+                            }
+                            if ((!FIXREVERTER[535] && (Multmat == (void *) 0 ))
+                            #else
+                            if (0
+                            #endif
+                            ) return FALSE;
+                            #ifdef FRCOV
+                            }
+                            #endif  // Should never happen
 
                             // Recover the chain
                             Multmat->Next = chain;
@@ -338,7 +357,22 @@ void* Prelin16dup(cmsContext ContextID, const void* ptr)
     Prelin16Data* p16 = (Prelin16Data*) ptr;
     Prelin16Data* Duped = (Prelin16Data*) _cmsDupMem(ContextID, p16, sizeof(Prelin16Data));
 
-    if (Duped == NULL) return NULL;
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[536]) {
+      if ((Duped == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 536\n");
+      else
+        fprintf(stderr, "reached bug index 536\n");
+    }
+    if ((!FIXREVERTER[536] && (Duped == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) return NULL;
+    #ifdef FRCOV
+    }
+    #endif
 
     Duped->EvalCurveOut16 = (_cmsInterpFn16*) _cmsDupMem(ContextID, p16->EvalCurveOut16, p16->nOutputs * sizeof(_cmsInterpFn16));
     Duped->ParamsCurveOut16 = (cmsInterpParams**)_cmsDupMem(ContextID, p16->ParamsCurveOut16, p16->nOutputs * sizeof(cmsInterpParams*));
@@ -355,7 +389,22 @@ Prelin16Data* PrelinOpt16alloc(cmsContext ContextID,
 {
     int i;
     Prelin16Data* p16 = (Prelin16Data*)_cmsMallocZero(ContextID, sizeof(Prelin16Data));
-    if (p16 == NULL) return NULL;
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[537]) {
+      if ((p16 == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 537\n");
+      else
+        fprintf(stderr, "reached bug index 537\n");
+    }
+    if ((!FIXREVERTER[537] && (p16 == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) return NULL;
+    #ifdef FRCOV
+    }
+    #endif
 
     p16 ->nInputs = nInputs;
     p16 -> nOutputs = nOutputs;
@@ -438,7 +487,22 @@ cmsBool AllCurvesAreLinear(cmsStage* mpe)
     cmsUInt32Number i, n;
 
     Curves = _cmsStageGetPtrToCurveSet(mpe);
-    if (Curves == NULL) return FALSE;
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[538]) {
+      if ((Curves == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 538\n");
+      else
+        fprintf(stderr, "reached bug index 538\n");
+    }
+    if ((!FIXREVERTER[538] && (Curves == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) return FALSE;
+    #ifdef FRCOV
+    }
+    #endif
 
     n = cmsStageOutputChannels(mpe);
 
@@ -560,8 +624,38 @@ cmsBool FixWhiteMisalignment(cmsPipeline* Lut, cmsColorSpaceSignature EntryColor
         &WhitePointOut, NULL, &nOuts)) return FALSE;
 
     // It needs to be fixed?
-    if (Lut ->InputChannels != nIns) return FALSE;
-    if (Lut ->OutputChannels != nOuts) return FALSE;
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[539]) {
+      if ((Lut -> InputChannels != nIns ) && !(0))
+        fprintf(stderr, "triggered bug index 539\n");
+      else
+        fprintf(stderr, "reached bug index 539\n");
+    }
+    if ((!FIXREVERTER[539] && (Lut -> InputChannels != nIns ))
+    #else
+    if (0
+    #endif
+    ) return FALSE;
+    #ifdef FRCOV
+    }
+    #endif
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[540]) {
+      if ((Lut -> OutputChannels != nOuts ) && !(0))
+        fprintf(stderr, "triggered bug index 540\n");
+      else
+        fprintf(stderr, "reached bug index 540\n");
+    }
+    if ((!FIXREVERTER[540] && (Lut -> OutputChannels != nOuts ))
+    #else
+    if (0
+    #endif
+    ) return FALSE;
+    #ifdef FRCOV
+    }
+    #endif
 
     cmsPipelineEval16(WhitePointIn, ObtainedOut, Lut);
 
@@ -699,7 +793,22 @@ cmsBool OptimizeByResampling(cmsPipeline** Lut, cmsUInt32Number Intent, cmsUInt3
 
     // Allocate the CLUT
     CLUT = cmsStageAllocCLut16bit(Src ->ContextID, nGridPoints, Src ->InputChannels, Src->OutputChannels, NULL);
-    if (CLUT == NULL) goto Error;
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[542]) {
+      if ((CLUT == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 542\n");
+      else
+        fprintf(stderr, "reached bug index 542\n");
+    }
+    if ((!FIXREVERTER[542] && (CLUT == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) goto Error;
+    #ifdef FRCOV
+    }
+    #endif
 
     // Add the CLUT to the destination LUT
     if (!cmsPipelineInsertStage(Dest, cmsAT_END, CLUT)) {
@@ -849,7 +958,22 @@ Prelin8Data* PrelinOpt8alloc(cmsContext ContextID, const cmsInterpParams* p, cms
     Prelin8Data* p8;
 
     p8 = (Prelin8Data*)_cmsMallocZero(ContextID, sizeof(Prelin8Data));
-    if (p8 == NULL) return NULL;
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[543]) {
+      if ((p8 == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 543\n");
+      else
+        fprintf(stderr, "reached bug index 543\n");
+    }
+    if ((!FIXREVERTER[543] && (p8 == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) return NULL;
+    #ifdef FRCOV
+    }
+    #endif
 
     // Since this only works for 8 bit input, values comes always as x * 257,
     // we can safely take msb byte (x << 8 + x)
@@ -1144,14 +1268,44 @@ cmsBool OptimizeByComputingLinearization(cmsPipeline** Lut, cmsUInt32Number Inte
 
     // Now inset the reversed curves at the begin of transform
     LutPlusCurves = cmsPipelineDup(OriginalLut);
-    if (LutPlusCurves == NULL) goto Error;
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[548]) {
+      if ((LutPlusCurves == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 548\n");
+      else
+        fprintf(stderr, "reached bug index 548\n");
+    }
+    if ((!FIXREVERTER[548] && (LutPlusCurves == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) goto Error;
+    #ifdef FRCOV
+    }
+    #endif
 
     if (!cmsPipelineInsertStage(LutPlusCurves, cmsAT_BEGIN, cmsStageAllocToneCurves(OriginalLut ->ContextID, OriginalLut ->InputChannels, TransReverse)))
         goto Error;
 
     // Create the result LUT
     OptimizedLUT = cmsPipelineAlloc(OriginalLut ->ContextID, OriginalLut ->InputChannels, OriginalLut ->OutputChannels);
-    if (OptimizedLUT == NULL) goto Error;
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[549]) {
+      if ((OptimizedLUT == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 549\n");
+      else
+        fprintf(stderr, "reached bug index 549\n");
+    }
+    if ((!FIXREVERTER[549] && (OptimizedLUT == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) goto Error;
+    #ifdef FRCOV
+    }
+    #endif
 
     OptimizedPrelinMpe = cmsStageAllocToneCurves(OriginalLut ->ContextID, OriginalLut ->InputChannels, Trans);
 
@@ -1188,7 +1342,22 @@ cmsBool OptimizeByComputingLinearization(cmsPipeline** Lut, cmsUInt32Number Inte
         Prelin8Data* p8 = PrelinOpt8alloc(OptimizedLUT ->ContextID,
                                                 OptimizedPrelinCLUT ->Params,
                                                 OptimizedPrelinCurves);
-        if (p8 == NULL) return FALSE;
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[550]) {
+          if ((p8 == (void *) 0 ) && !(0))
+            fprintf(stderr, "triggered bug index 550\n");
+          else
+            fprintf(stderr, "reached bug index 550\n");
+        }
+        if ((!FIXREVERTER[550] && (p8 == (void *) 0 ))
+        #else
+        if (0
+        #endif
+        ) return FALSE;
+        #ifdef FRCOV
+        }
+        #endif
 
         _cmsPipelineSetOptimizationParameters(OptimizedLUT, PrelinEval8, (void*) p8, Prelin8free, Prelin8dup);
 
@@ -1198,7 +1367,22 @@ cmsBool OptimizeByComputingLinearization(cmsPipeline** Lut, cmsUInt32Number Inte
         Prelin16Data* p16 = PrelinOpt16alloc(OptimizedLUT ->ContextID,
             OptimizedPrelinCLUT ->Params,
             3, OptimizedPrelinCurves, 3, NULL);
-        if (p16 == NULL) return FALSE;
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[551]) {
+          if ((p16 == (void *) 0 ) && !(0))
+            fprintf(stderr, "triggered bug index 551\n");
+          else
+            fprintf(stderr, "reached bug index 551\n");
+        }
+        if ((!FIXREVERTER[551] && (p16 == (void *) 0 ))
+        #else
+        if (0
+        #endif
+        ) return FALSE;
+        #ifdef FRCOV
+        }
+        #endif
 
         _cmsPipelineSetOptimizationParameters(OptimizedLUT, PrelinEval16, (void*) p16, PrelinOpt16free, Prelin16dup);
 
@@ -1262,7 +1446,22 @@ void* CurvesDup(cmsContext ContextID, const void* ptr)
     Curves16Data* Data = (Curves16Data*)_cmsDupMem(ContextID, ptr, sizeof(Curves16Data));
     int i;
 
-    if (Data == NULL) return NULL;
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[552]) {
+      if ((Data == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 552\n");
+      else
+        fprintf(stderr, "reached bug index 552\n");
+    }
+    if ((!FIXREVERTER[552] && (Data == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) return NULL;
+    #ifdef FRCOV
+    }
+    #endif
 
     Data->Curves = (cmsUInt16Number**) _cmsDupMem(ContextID, Data->Curves, Data->nCurves * sizeof(cmsUInt16Number*));
 
@@ -1281,13 +1480,43 @@ Curves16Data* CurvesAlloc(cmsContext ContextID, int nCurves, int nElements, cmsT
     Curves16Data* c16;
 
     c16 = (Curves16Data*)_cmsMallocZero(ContextID, sizeof(Curves16Data));
-    if (c16 == NULL) return NULL;
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[553]) {
+      if ((c16 == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 553\n");
+      else
+        fprintf(stderr, "reached bug index 553\n");
+    }
+    if ((!FIXREVERTER[553] && (c16 == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) return NULL;
+    #ifdef FRCOV
+    }
+    #endif
 
     c16 ->nCurves = nCurves;
     c16 ->nElements = nElements;
 
     c16->Curves = (cmsUInt16Number**) _cmsCalloc(ContextID, nCurves, sizeof(cmsUInt16Number*));
-    if (c16 ->Curves == NULL) return NULL;
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[554]) {
+      if ((c16 -> Curves == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 554\n");
+      else
+        fprintf(stderr, "reached bug index 554\n");
+    }
+    if ((!FIXREVERTER[554] && (c16 -> Curves == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) return NULL;
+    #ifdef FRCOV
+    }
+    #endif
 
     for (i=0; i < nCurves; i++) {
 
@@ -1392,11 +1621,41 @@ cmsBool OptimizeByJoiningCurves(cmsPipeline** Lut, cmsUInt32Number Intent, cmsUI
 
     // Allocate an empty LUT
     Dest =  cmsPipelineAlloc(Src ->ContextID, Src ->InputChannels, Src ->OutputChannels);
-    if (Dest == NULL) return FALSE;
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[556]) {
+      if ((Dest == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 556\n");
+      else
+        fprintf(stderr, "reached bug index 556\n");
+    }
+    if ((!FIXREVERTER[556] && (Dest == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) return FALSE;
+    #ifdef FRCOV
+    }
+    #endif
 
     // Create target curves
     GammaTables = (cmsToneCurve**) _cmsCalloc(Src ->ContextID, Src ->InputChannels, sizeof(cmsToneCurve*));
-    if (GammaTables == NULL) goto Error;
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[557]) {
+      if ((GammaTables == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 557\n");
+      else
+        fprintf(stderr, "reached bug index 557\n");
+    }
+    if ((!FIXREVERTER[557] && (GammaTables == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) goto Error;
+    #ifdef FRCOV
+    }
+    #endif
 
     for (i=0; i < Src ->InputChannels; i++) {
         GammaTables[i] = cmsBuildTabulatedToneCurve16(Src ->ContextID, PRELINEARIZATION_POINTS, NULL);
@@ -1416,7 +1675,22 @@ cmsBool OptimizeByJoiningCurves(cmsPipeline** Lut, cmsUInt32Number Intent, cmsUI
     }
 
     ObtainedCurves = cmsStageAllocToneCurves(Src ->ContextID, Src ->InputChannels, GammaTables);
-    if (ObtainedCurves == NULL) goto Error;
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[558]) {
+      if ((ObtainedCurves == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 558\n");
+      else
+        fprintf(stderr, "reached bug index 558\n");
+    }
+    if ((!FIXREVERTER[558] && (ObtainedCurves == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) goto Error;
+    #ifdef FRCOV
+    }
+    #endif
 
     for (i=0; i < Src ->InputChannels; i++) {
         cmsFreeToneCurve(GammaTables[i]);
@@ -1440,7 +1714,22 @@ cmsBool OptimizeByJoiningCurves(cmsPipeline** Lut, cmsUInt32Number Intent, cmsUI
             _cmsStageToneCurvesData* Data = (_cmsStageToneCurvesData*) ObtainedCurves ->Data;
              Curves16Data* c16 = CurvesAlloc(Dest ->ContextID, Data ->nCurves, 256, Data ->TheCurves);
 
-             if (c16 == NULL) goto Error; 
+             
+             #ifdef FRCOV
+             {if (FIXREVERTER[559]) {
+               if ((c16 == (void *) 0 ) && !(0))
+                 fprintf(stderr, "triggered bug index 559\n");
+               else
+                 fprintf(stderr, "reached bug index 559\n");
+             }
+             if ((!FIXREVERTER[559] && (c16 == (void *) 0 ))
+             #else
+             if (0
+             #endif
+             ) goto Error;
+             #ifdef FRCOV
+             }
+             #endif 
              *dwFlags |= cmsFLAGS_NOCACHE;
             _cmsPipelineSetOptimizationParameters(Dest, FastEvaluateCurves8, c16, CurvesFree, CurvesDup);
 
@@ -1450,7 +1739,22 @@ cmsBool OptimizeByJoiningCurves(cmsPipeline** Lut, cmsUInt32Number Intent, cmsUI
             _cmsStageToneCurvesData* Data = (_cmsStageToneCurvesData*) cmsStageData(ObtainedCurves);
              Curves16Data* c16 = CurvesAlloc(Dest ->ContextID, Data ->nCurves, 65536, Data ->TheCurves);
 
-             if (c16 == NULL) goto Error; 
+             
+             #ifdef FRCOV
+             {if (FIXREVERTER[560]) {
+               if ((c16 == (void *) 0 ) && !(0))
+                 fprintf(stderr, "triggered bug index 560\n");
+               else
+                 fprintf(stderr, "reached bug index 560\n");
+             }
+             if ((!FIXREVERTER[560] && (c16 == (void *) 0 ))
+             #else
+             if (0
+             #endif
+             ) goto Error;
+             #ifdef FRCOV
+             }
+             #endif 
              *dwFlags |= cmsFLAGS_NOCACHE;
             _cmsPipelineSetOptimizationParameters(Dest, FastEvaluateCurves16, c16, CurvesFree, CurvesDup);
         }
@@ -1612,7 +1916,22 @@ cmsBool SetMatShaper(cmsPipeline* Dest, cmsToneCurve* Curve1[3], cmsMAT3* Mat, c
 
     // Allocate a big chuck of memory to store precomputed tables
     p = (MatShaper8Data*) _cmsMalloc(Dest ->ContextID, sizeof(MatShaper8Data));
-    if (p == NULL) return FALSE;
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[561]) {
+      if ((p == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 561\n");
+      else
+        fprintf(stderr, "reached bug index 561\n");
+    }
+    if ((!FIXREVERTER[561] && (p == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) return FALSE;
+    #ifdef FRCOV
+    }
+    #endif
 
     p -> ContextID = Dest -> ContextID;
 
diff --git a/src/cmspcs.c b/src/cmspcs.c
index 0cd8ecb..ac5c646 100644
--- a/src/cmspcs.c
+++ b/src/cmspcs.c
@@ -1,3 +1,7 @@
+#ifdef FRCOV
+#include <stdio.h>
+extern short FIXREVERTER[];
+#endif
 //---------------------------------------------------------------------------------
 //
 //  Little Color Management System
@@ -144,8 +148,23 @@ void CMSEXPORT cmsXYZ2Lab(const cmsCIEXYZ* WhitePoint, cmsCIELab* Lab, const cms
 {
     cmsFloat64Number fx, fy, fz;
 
-    if (WhitePoint == NULL)
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[246]) {
+      if ((WhitePoint == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 246\n");
+      else
+        fprintf(stderr, "reached bug index 246\n");
+    }
+    if ((!FIXREVERTER[246] && (WhitePoint == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    )
         WhitePoint = cmsD50_XYZ();
+        #ifdef FRCOV
+        }
+        #endif
 
     fx = f(xyz->X / WhitePoint->X);
     fy = f(xyz->Y / WhitePoint->Y);
@@ -162,8 +181,23 @@ void CMSEXPORT cmsLab2XYZ(const cmsCIEXYZ* WhitePoint, cmsCIEXYZ* xyz,  const cm
 {
     cmsFloat64Number x, y, z;
 
-    if (WhitePoint == NULL)
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[247]) {
+      if ((WhitePoint == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 247\n");
+      else
+        fprintf(stderr, "reached bug index 247\n");
+    }
+    if ((!FIXREVERTER[247] && (WhitePoint == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    )
         WhitePoint = cmsD50_XYZ();
+        #ifdef FRCOV
+        }
+        #endif
 
     y = (Lab-> L + 16.0) / 116.0;
     x = y + 0.002 * Lab -> a;
diff --git a/src/cmsplugin.c b/src/cmsplugin.c
index 164061f..b20431d 100644
--- a/src/cmsplugin.c
+++ b/src/cmsplugin.c
@@ -1,3 +1,7 @@
+#ifdef FRCOV
+#include <stdio.h>
+extern short FIXREVERTER[];
+#endif
 //---------------------------------------------------------------------------------
 //
 //  Little Color Management System
@@ -458,8 +462,38 @@ cmsBool CMSEXPORT _cmsReadAlignment(cmsIOHANDLER* io)
     At = io -> Tell(io);
     NextAligned = _cmsALIGNLONG(At);
     BytesToNextAlignedPos = NextAligned - At;
-    if (BytesToNextAlignedPos == 0) return TRUE;
-    if (BytesToNextAlignedPos > 4)  return FALSE;
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[166]) {
+      if ((BytesToNextAlignedPos == 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 166\n");
+      else
+        fprintf(stderr, "reached bug index 166\n");
+    }
+    if ((!FIXREVERTER[166] && (BytesToNextAlignedPos == 0 ))
+    #else
+    if (0
+    #endif
+    ) return TRUE;
+    #ifdef FRCOV
+    }
+    #endif
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[167]) {
+      if ((BytesToNextAlignedPos > 4 ) && !(0))
+        fprintf(stderr, "triggered bug index 167\n");
+      else
+        fprintf(stderr, "reached bug index 167\n");
+    }
+    if ((!FIXREVERTER[167] && (BytesToNextAlignedPos > 4 ))
+    #else
+    if (0
+    #endif
+    )  return FALSE;
+    #ifdef FRCOV
+    }
+    #endif
 
     return (io ->Read(io, Buffer, BytesToNextAlignedPos, 1) == 1);
 }
@@ -475,8 +509,38 @@ cmsBool CMSEXPORT _cmsWriteAlignment(cmsIOHANDLER* io)
     At = io -> Tell(io);
     NextAligned = _cmsALIGNLONG(At);
     BytesToNextAlignedPos = NextAligned - At;
-    if (BytesToNextAlignedPos == 0) return TRUE;
-    if (BytesToNextAlignedPos > 4)  return FALSE;
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[168]) {
+      if ((BytesToNextAlignedPos == 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 168\n");
+      else
+        fprintf(stderr, "reached bug index 168\n");
+    }
+    if ((!FIXREVERTER[168] && (BytesToNextAlignedPos == 0 ))
+    #else
+    if (0
+    #endif
+    ) return TRUE;
+    #ifdef FRCOV
+    }
+    #endif
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[169]) {
+      if ((BytesToNextAlignedPos > 4 ) && !(0))
+        fprintf(stderr, "triggered bug index 169\n");
+      else
+        fprintf(stderr, "reached bug index 169\n");
+    }
+    if ((!FIXREVERTER[169] && (BytesToNextAlignedPos > 4 ))
+    #else
+    if (0
+    #endif
+    )  return FALSE;
+    #ifdef FRCOV
+    }
+    #endif
 
     memset(Buffer, 0, BytesToNextAlignedPos);
     return io -> Write(io, BytesToNextAlignedPos, Buffer);
@@ -663,8 +727,23 @@ struct _cmsContext_struct* _cmsGetContext(cmsContext ContextID)
 
 
     // On 0, use global settings
-    if (id == NULL) 
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[174]) {
+      if ((id == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 174\n");
+      else
+        fprintf(stderr, "reached bug index 174\n");
+    }
+    if ((!FIXREVERTER[174] && (id == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) 
         return &globalContext;
+        #ifdef FRCOV
+        }
+        #endif
 
     // Search
     for (ctx = _cmsContextPoolHead;
diff --git a/src/cmssamp.c b/src/cmssamp.c
index a9997fa..2374af6 100644
--- a/src/cmssamp.c
+++ b/src/cmssamp.c
@@ -1,3 +1,7 @@
+#ifdef FRCOV
+#include <stdio.h>
+extern short FIXREVERTER[];
+#endif
 //---------------------------------------------------------------------------------
 //
 //  Little Color Management System
@@ -103,22 +107,52 @@ cmsBool  BlackPointAsDarkerColorant(cmsHPROFILE    hInput,
 
     // Lab will be used as the output space, but lab2 will avoid recursion
     hLab = cmsCreateLab2ProfileTHR(ContextID, NULL);
-    if (hLab == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[317]) {
+      if ((hLab == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 317\n");
+      else
+        fprintf(stderr, "reached bug index 317\n");
+    }
+    if ((!FIXREVERTER[317] && (hLab == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
        BlackPoint -> X = BlackPoint ->Y = BlackPoint -> Z = 0.0;
        return FALSE;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
     // Create the transform
     xform = cmsCreateTransformTHR(ContextID, hInput, dwFormat,
                                 hLab, TYPE_Lab_DBL, Intent, cmsFLAGS_NOOPTIMIZE|cmsFLAGS_NOCACHE);
     cmsCloseProfile(hLab);
 
-    if (xform == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[318]) {
+      if ((xform == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 318\n");
+      else
+        fprintf(stderr, "reached bug index 318\n");
+    }
+    if ((!FIXREVERTER[318] && (xform == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
 
         // Something went wrong. Get rid of open resources and return zero as black
         BlackPoint -> X = BlackPoint ->Y = BlackPoint -> Z = 0.0;
         return FALSE;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
     // Convert black to Lab
     cmsDoTransform(xform, Black, &Lab, 1);
@@ -159,10 +193,25 @@ cmsBool BlackPointUsingPerceptualBlack(cmsCIEXYZ* BlackPoint, cmsHPROFILE hProfi
     }
 
     hRoundTrip = CreateRoundtripXForm(hProfile, INTENT_PERCEPTUAL);
-    if (hRoundTrip == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[319]) {
+      if ((hRoundTrip == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 319\n");
+      else
+        fprintf(stderr, "reached bug index 319\n");
+    }
+    if ((!FIXREVERTER[319] && (hRoundTrip == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         BlackPoint -> X = BlackPoint ->Y = BlackPoint -> Z = 0.0;
         return FALSE;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
     LabIn.L = LabIn.a = LabIn.b = 0;
     cmsDoTransform(hRoundTrip, &LabIn, &LabOut, 1);
@@ -290,7 +339,22 @@ cmsFloat64Number RootOfLeastSquaresFitQuadraticCurve(int n, cmsFloat64Number x[]
     cmsMAT3 m;
     cmsVEC3 v, res;
 
-    if (n < 4) return 0;
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[320]) {
+      if ((n < 4 ) && !(0))
+        fprintf(stderr, "triggered bug index 320\n");
+      else
+        fprintf(stderr, "reached bug index 320\n");
+    }
+    if ((!FIXREVERTER[320] && (n < 4 ))
+    #else
+    if (0
+    #endif
+    ) return 0;
+    #ifdef FRCOV
+    }
+    #endif
 
     for (i=0; i < n; i++) {
 
@@ -434,7 +498,22 @@ cmsBool CMSEXPORT cmsDetectDestinationBlackPoint(cmsCIEXYZ* BlackPoint, cmsHPROF
 
     // Create a roundtrip. Define a Transform BT for all x in L*a*b*
     hRoundTrip = CreateRoundtripXForm(hProfile, Intent);
-    if (hRoundTrip == NULL)  return FALSE;
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[321]) {
+      if ((hRoundTrip == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 321\n");
+      else
+        fprintf(stderr, "reached bug index 321\n");
+    }
+    if ((!FIXREVERTER[321] && (hRoundTrip == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    )  return FALSE;
+    #ifdef FRCOV
+    }
+    #endif
 
     // Compute ramps
 
@@ -523,11 +602,26 @@ cmsBool CMSEXPORT cmsDetectDestinationBlackPoint(cmsCIEXYZ* BlackPoint, cmsHPROF
 
     
     // No suitable points
-    if (n < 3 ) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[322]) {
+      if ((n < 3 ) && !(0))
+        fprintf(stderr, "triggered bug index 322\n");
+      else
+        fprintf(stderr, "reached bug index 322\n");
+    }
+    if ((!FIXREVERTER[322] && (n < 3 ))
+    #else
+    if (0
+    #endif
+     ) {
         cmsDeleteTransform(hRoundTrip);
         BlackPoint -> X = BlackPoint ->Y = BlackPoint -> Z = 0.0;
         return FALSE;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
   
     // fit and get the vertex of quadratic curve
diff --git a/src/cmstypes.c b/src/cmstypes.c
index 09723f4..2ba8e89 100644
--- a/src/cmstypes.c
+++ b/src/cmstypes.c
@@ -1,3 +1,7 @@
+#ifdef FRCOV
+#include <stdio.h>
+extern short FIXREVERTER[];
+#endif
 //---------------------------------------------------------------------------------
 //
 //  Little Color Management System
@@ -181,10 +185,40 @@ cmsBool ReadPositionTable(struct _cms_typehandler_struct* self,
 
     // Let's take the offsets to each element
     ElementOffsets = (cmsUInt32Number *) _cmsCalloc(io ->ContextID, Count, sizeof(cmsUInt32Number));
-    if (ElementOffsets == NULL) goto Error;
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[3]) {
+      if ((ElementOffsets == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 3\n");
+      else
+        fprintf(stderr, "reached bug index 3\n");
+    }
+    if ((!FIXREVERTER[3] && (ElementOffsets == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) goto Error;
+    #ifdef FRCOV
+    }
+    #endif
 
     ElementSizes = (cmsUInt32Number *) _cmsCalloc(io ->ContextID, Count, sizeof(cmsUInt32Number));
-    if (ElementSizes == NULL) goto Error;
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[4]) {
+      if ((ElementSizes == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 4\n");
+      else
+        fprintf(stderr, "reached bug index 4\n");
+    }
+    if ((!FIXREVERTER[4] && (ElementSizes == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) goto Error;
+    #ifdef FRCOV
+    }
+    #endif
 
     for (i=0; i < Count; i++) {
 
@@ -230,10 +264,40 @@ cmsBool WritePositionTable(struct _cms_typehandler_struct* self,
 
      // Create table
     ElementOffsets = (cmsUInt32Number *) _cmsCalloc(io ->ContextID, Count, sizeof(cmsUInt32Number));
-    if (ElementOffsets == NULL) goto Error;
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[5]) {
+      if ((ElementOffsets == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 5\n");
+      else
+        fprintf(stderr, "reached bug index 5\n");
+    }
+    if ((!FIXREVERTER[5] && (ElementOffsets == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) goto Error;
+    #ifdef FRCOV
+    }
+    #endif
 
     ElementSizes = (cmsUInt32Number *) _cmsCalloc(io ->ContextID, Count, sizeof(cmsUInt32Number));
-    if (ElementSizes == NULL) goto Error;
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[6]) {
+      if ((ElementSizes == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 6\n");
+      else
+        fprintf(stderr, "reached bug index 6\n");
+    }
+    if ((!FIXREVERTER[6] && (ElementSizes == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) goto Error;
+    #ifdef FRCOV
+    }
+    #endif
 
     // Keep starting position of curve offsets
     DirectoryPos = io ->Tell(io);
@@ -296,7 +360,22 @@ void *Type_XYZ_Read(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsU
 
     *nItems = 0;
     xyz = (cmsCIEXYZ*) _cmsMallocZero(self ->ContextID, sizeof(cmsCIEXYZ));
-    if (xyz == NULL) return NULL;
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[7]) {
+      if ((xyz == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 7\n");
+      else
+        fprintf(stderr, "reached bug index 7\n");
+    }
+    if ((!FIXREVERTER[7] && (xyz == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) return NULL;
+    #ifdef FRCOV
+    }
+    #endif
 
     if (!_cmsReadXYZNumber(io, xyz)) {
         _cmsFree(self ->ContextID, xyz);
@@ -357,18 +436,66 @@ void *Type_Chromaticity_Read(struct _cms_typehandler_struct* self, cmsIOHANDLER*
 
     *nItems = 0;
     chrm =  (cmsCIExyYTRIPLE*) _cmsMallocZero(self ->ContextID, sizeof(cmsCIExyYTRIPLE));
-    if (chrm == NULL) return NULL;
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[8]) {
+      if ((chrm == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 8\n");
+      else
+        fprintf(stderr, "reached bug index 8\n");
+    }
+    if ((!FIXREVERTER[8] && (chrm == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) return NULL;
+    #ifdef FRCOV
+    }
+    #endif
 
     if (!_cmsReadUInt16Number(io, &nChans)) goto Error;
 
     // Let's recover from a bug introduced in early versions of lcms1
-    if (nChans == 0 && SizeOfTag == 32) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[9]) {
+      fprintf(stderr, "reached bug index 9\n");
+    }
+    if ((FIXREVERTER[9] && (SizeOfTag == 32 )) || (!FIXREVERTER[9] && (nChans == 0 && SizeOfTag == 32 ))
+    #else
+    if (SizeOfTag == 32 
+    #endif
+    ) {
+      
+    #ifdef FRCOV
+      if (!(nChans == 0 ))
+        fprintf(stderr, "triggered bug index 9\n");
+      #endif
+    
 
         if (!_cmsReadUInt16Number(io, NULL)) goto Error;
         if (!_cmsReadUInt16Number(io, &nChans)) goto Error;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
-    if (nChans != 3) goto Error;
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[10]) {
+      if ((nChans != 3 ) && !(0))
+        fprintf(stderr, "triggered bug index 10\n");
+      else
+        fprintf(stderr, "reached bug index 10\n");
+    }
+    if ((!FIXREVERTER[10] && (nChans != 3 ))
+    #else
+    if (0
+    #endif
+    ) goto Error;
+    #ifdef FRCOV
+    }
+    #endif
 
     if (!_cmsReadUInt16Number(io, &Table)) goto Error;
 
@@ -459,10 +586,40 @@ void *Type_ColorantOrderType_Read(struct _cms_typehandler_struct* self, cmsIOHAN
 
     *nItems = 0;
     if (!_cmsReadUInt32Number(io, &Count)) return NULL;
-    if (Count > cmsMAXCHANNELS) return NULL;
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[11]) {
+      if ((Count > 16 ) && !(0))
+        fprintf(stderr, "triggered bug index 11\n");
+      else
+        fprintf(stderr, "reached bug index 11\n");
+    }
+    if ((!FIXREVERTER[11] && (Count > 16 ))
+    #else
+    if (0
+    #endif
+    ) return NULL;
+    #ifdef FRCOV
+    }
+    #endif
 
     ColorantOrder = (cmsUInt8Number*) _cmsCalloc(self ->ContextID, cmsMAXCHANNELS, sizeof(cmsUInt8Number));
-    if (ColorantOrder == NULL) return NULL;
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[12]) {
+      if ((ColorantOrder == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 12\n");
+      else
+        fprintf(stderr, "reached bug index 12\n");
+    }
+    if ((!FIXREVERTER[12] && (ColorantOrder == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) return NULL;
+    #ifdef FRCOV
+    }
+    #endif
 
     // We use FF as end marker
     memset(ColorantOrder, 0xFF, cmsMAXCHANNELS * sizeof(cmsUInt8Number));
@@ -531,7 +688,22 @@ void *Type_S15Fixed16_Read(struct _cms_typehandler_struct* self, cmsIOHANDLER* i
     *nItems = 0;
     n = SizeOfTag / sizeof(cmsUInt32Number);
     array_double = (cmsFloat64Number*) _cmsCalloc(self ->ContextID, n, sizeof(cmsFloat64Number));
-    if (array_double == NULL) return NULL;
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[13]) {
+      if ((array_double == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 13\n");
+      else
+        fprintf(stderr, "reached bug index 13\n");
+    }
+    if ((!FIXREVERTER[13] && (array_double == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) return NULL;
+    #ifdef FRCOV
+    }
+    #endif
 
     for (i=0; i < n; i++) {
 
@@ -592,7 +764,22 @@ void *Type_U16Fixed16_Read(struct _cms_typehandler_struct* self, cmsIOHANDLER* i
     *nItems = 0;
     n = SizeOfTag / sizeof(cmsUInt32Number);
     array_double = (cmsFloat64Number*) _cmsCalloc(self ->ContextID, n, sizeof(cmsFloat64Number));
-    if (array_double == NULL) return NULL;
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[14]) {
+      if ((array_double == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 14\n");
+      else
+        fprintf(stderr, "reached bug index 14\n");
+    }
+    if ((!FIXREVERTER[14] && (array_double == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) return NULL;
+    #ifdef FRCOV
+    }
+    #endif
 
     for (i=0; i < n; i++) {
 
@@ -653,7 +840,22 @@ static
 void *Type_Signature_Read(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsUInt32Number* nItems, cmsUInt32Number SizeOfTag)
 {
     cmsSignature* SigPtr = (cmsSignature*) _cmsMalloc(self ->ContextID, sizeof(cmsSignature));
-    if (SigPtr == NULL) return NULL;
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[15]) {
+      if ((SigPtr == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 15\n");
+      else
+        fprintf(stderr, "reached bug index 15\n");
+    }
+    if ((!FIXREVERTER[15] && (SigPtr == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) return NULL;
+    #ifdef FRCOV
+    }
+    #endif
 
      if (!_cmsReadUInt32Number(io, SigPtr)) return NULL;
      *nItems = 1;
@@ -703,7 +905,22 @@ void *Type_Text_Read(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cms
 
     // Create a container
     mlu = cmsMLUalloc(self ->ContextID, 1);
-    if (mlu == NULL) return NULL;
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[16]) {
+      if ((mlu == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 16\n");
+      else
+        fprintf(stderr, "reached bug index 16\n");
+    }
+    if ((!FIXREVERTER[16] && (mlu == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) return NULL;
+    #ifdef FRCOV
+    }
+    #endif
 
     *nItems = 0;
 
@@ -711,7 +928,22 @@ void *Type_Text_Read(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cms
     if (SizeOfTag == UINT_MAX) goto Error;
 
     Text = (char*) _cmsMalloc(self ->ContextID, SizeOfTag + 1);
-    if (Text == NULL) goto Error;
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[17]) {
+      if ((Text == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 17\n");
+      else
+        fprintf(stderr, "reached bug index 17\n");
+    }
+    if ((!FIXREVERTER[17] && (Text == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) goto Error;
+    #ifdef FRCOV
+    }
+    #endif
 
     if (io -> Read(io, Text, sizeof(char), SizeOfTag) != SizeOfTag) goto Error;
 
@@ -745,11 +977,41 @@ cmsBool Type_Text_Write(struct _cms_typehandler_struct* self, cmsIOHANDLER* io,
 
     // Get the size of the string. Note there is an extra "\0" at the end
     size = cmsMLUgetASCII(mlu, cmsNoLanguage, cmsNoCountry, NULL, 0);
-    if (size == 0) return FALSE;       // Cannot be zero!
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[18]) {
+      if ((size == 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 18\n");
+      else
+        fprintf(stderr, "reached bug index 18\n");
+    }
+    if ((!FIXREVERTER[18] && (size == 0 ))
+    #else
+    if (0
+    #endif
+    ) return FALSE;
+    #ifdef FRCOV
+    }
+    #endif       // Cannot be zero!
 
     // Create memory
     Text = (char*) _cmsMalloc(self ->ContextID, size);
-    if (Text == NULL) return FALSE;
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[19]) {
+      if ((Text == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 19\n");
+      else
+        fprintf(stderr, "reached bug index 19\n");
+    }
+    if ((!FIXREVERTER[19] && (Text == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) return FALSE;
+    #ifdef FRCOV
+    }
+    #endif
 
     cmsMLUgetASCII(mlu, cmsNoLanguage, cmsNoCountry, Text, size);
 
@@ -810,10 +1072,40 @@ void *Type_Data_Read(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cms
     if (SizeOfTag < sizeof(cmsUInt32Number)) return NULL;
 
     LenOfData = SizeOfTag - sizeof(cmsUInt32Number);
-    if (LenOfData > INT_MAX) return NULL;
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[20]) {
+      if ((LenOfData > 2147483647 ) && !(0))
+        fprintf(stderr, "triggered bug index 20\n");
+      else
+        fprintf(stderr, "reached bug index 20\n");
+    }
+    if ((!FIXREVERTER[20] && (LenOfData > 2147483647 ))
+    #else
+    if (0
+    #endif
+    ) return NULL;
+    #ifdef FRCOV
+    }
+    #endif
 
     BinData = (cmsICCData*) _cmsMalloc(self ->ContextID, sizeof(cmsICCData) + LenOfData - 1);
-    if (BinData == NULL) return NULL;
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[21]) {
+      if ((BinData == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 21\n");
+      else
+        fprintf(stderr, "reached bug index 21\n");
+    }
+    if ((!FIXREVERTER[21] && (BinData == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) return NULL;
+    #ifdef FRCOV
+    }
+    #endif
 
     BinData ->len = LenOfData;
     if (!_cmsReadUInt32Number(io, &BinData->flag)) {
@@ -887,15 +1179,60 @@ void *Type_Text_Description_Read(struct _cms_typehandler_struct* self, cmsIOHAND
     SizeOfTag -= sizeof(cmsUInt32Number);
 
     // Check for size
-    if (SizeOfTag < AsciiCount) return NULL;
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[22]) {
+      if ((SizeOfTag < AsciiCount ) && !(0))
+        fprintf(stderr, "triggered bug index 22\n");
+      else
+        fprintf(stderr, "reached bug index 22\n");
+    }
+    if ((!FIXREVERTER[22] && (SizeOfTag < AsciiCount ))
+    #else
+    if (0
+    #endif
+    ) return NULL;
+    #ifdef FRCOV
+    }
+    #endif
 
     // All seems Ok, allocate the container
     mlu = cmsMLUalloc(self ->ContextID, 1);
-    if (mlu == NULL) return NULL;
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[23]) {
+      if ((mlu == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 23\n");
+      else
+        fprintf(stderr, "reached bug index 23\n");
+    }
+    if ((!FIXREVERTER[23] && (mlu == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) return NULL;
+    #ifdef FRCOV
+    }
+    #endif
 
     // As many memory as size of tag
     Text = (char*) _cmsMalloc(self ->ContextID, AsciiCount + 1);
-    if (Text == NULL) goto Error;
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[24]) {
+      if ((Text == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 24\n");
+      else
+        fprintf(stderr, "reached bug index 24\n");
+    }
+    if ((!FIXREVERTER[24] && (Text == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) goto Error;
+    #ifdef FRCOV
+    }
+    #endif
 
     // Read it
     if (io ->Read(io, Text, sizeof(char), AsciiCount) != AsciiCount) goto Error;
@@ -988,10 +1325,40 @@ cmsBool  Type_Text_Description_Write(struct _cms_typehandler_struct* self, cmsIO
     else {
         // Create independent buffers
         Text = (char*) _cmsCalloc(self ->ContextID, len, sizeof(char));
-        if (Text == NULL) goto Error;
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[25]) {
+          if ((Text == (void *) 0 ) && !(0))
+            fprintf(stderr, "triggered bug index 25\n");
+          else
+            fprintf(stderr, "reached bug index 25\n");
+        }
+        if ((!FIXREVERTER[25] && (Text == (void *) 0 ))
+        #else
+        if (0
+        #endif
+        ) goto Error;
+        #ifdef FRCOV
+        }
+        #endif
 
         Wide = (wchar_t*) _cmsCalloc(self ->ContextID, len, sizeof(wchar_t));
-        if (Wide == NULL) goto Error;
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[26]) {
+          if ((Wide == (void *) 0 ) && !(0))
+            fprintf(stderr, "triggered bug index 26\n");
+          else
+            fprintf(stderr, "reached bug index 26\n");
+        }
+        if ((!FIXREVERTER[26] && (Wide == (void *) 0 ))
+        #else
+        if (0
+        #endif
+        ) goto Error;
+        #ifdef FRCOV
+        }
+        #endif
 
         // Get both representations.
         cmsMLUgetASCII(mlu, cmsNoLanguage, cmsNoCountry,  Text, len * sizeof(char));
@@ -1116,8 +1483,23 @@ void *Type_Curve_Read(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cm
 
            default:  // Curve
 
-               if (Count > 0x7FFF)
-                   return NULL; // This is to prevent bad guys for doing bad things
+               
+               #ifdef FRCOV
+               {if (FIXREVERTER[27]) {
+                 if ((Count > 32767 ) && !(0))
+                   fprintf(stderr, "triggered bug index 27\n");
+                 else
+                   fprintf(stderr, "reached bug index 27\n");
+               }
+               if ((!FIXREVERTER[27] && (Count > 32767 ))
+               #else
+               if (0
+               #endif
+               )
+                   return NULL;
+                   #ifdef FRCOV
+                   }
+                   #endif // This is to prevent bad guys for doing bad things
 
                NewGamma = cmsBuildTabulatedToneCurve16(self ->ContextID, Count, NULL);
                if (!NewGamma) return NULL;
@@ -1192,7 +1574,22 @@ cmsTagTypeSignature DecideCurveType(cmsFloat64Number ICCVersion, const void *Dat
     cmsToneCurve* Curve = (cmsToneCurve*) Data;
 
     if (ICCVersion < 4.0) return cmsSigCurveType;
-    if (Curve ->nSegments != 1) return cmsSigCurveType;          // Only 1-segment curves can be saved as parametric
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[28]) {
+      if ((Curve -> nSegments != 1 ) && !(0))
+        fprintf(stderr, "triggered bug index 28\n");
+      else
+        fprintf(stderr, "reached bug index 28\n");
+    }
+    if ((!FIXREVERTER[28] && (Curve -> nSegments != 1 ))
+    #else
+    if (0
+    #endif
+    ) return cmsSigCurveType;
+    #ifdef FRCOV
+    }
+    #endif          // Only 1-segment curves can be saved as parametric
     if (Curve ->Segments[0].Type < 0) return cmsSigCurveType;    // Only non-inverted curves
     if (Curve ->Segments[0].Type > 5) return cmsSigCurveType;    // Only ICC parametric curves
 
@@ -1211,11 +1608,26 @@ void *Type_ParametricCurve_Read(struct _cms_typehandler_struct* self, cmsIOHANDL
     if (!_cmsReadUInt16Number(io, &Type)) return NULL;
     if (!_cmsReadUInt16Number(io, NULL)) return NULL;   // Reserved
 
-    if (Type > 4) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[29]) {
+      if ((Type > 4 ) && !(0))
+        fprintf(stderr, "triggered bug index 29\n");
+      else
+        fprintf(stderr, "reached bug index 29\n");
+    }
+    if ((!FIXREVERTER[29] && (Type > 4 ))
+    #else
+    if (0
+    #endif
+    ) {
 
         cmsSignalError(self->ContextID, cmsERROR_UNKNOWN_EXTENSION, "Unknown parametric curve type '%d'", Type);
         return NULL;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
     memset(Params, 0, sizeof(Params));
     n = ParamsByType[Type];
@@ -1243,16 +1655,46 @@ cmsBool  Type_ParametricCurve_Write(struct _cms_typehandler_struct* self, cmsIOH
 
     typen = Curve -> Segments[0].Type;
 
-    if (Curve ->nSegments > 1 || typen < 1) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[30]) {
+      if ((Curve -> nSegments > 1 || typen < 1 ) && !(0))
+        fprintf(stderr, "triggered bug index 30\n");
+      else
+        fprintf(stderr, "reached bug index 30\n");
+    }
+    if ((!FIXREVERTER[30] && (Curve -> nSegments > 1 || typen < 1 ))
+    #else
+    if (0
+    #endif
+    ) {
 
         cmsSignalError(self->ContextID, cmsERROR_UNKNOWN_EXTENSION, "Multisegment or Inverted parametric curves cannot be written");
         return FALSE;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
-    if (typen > 5) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[31]) {
+      if ((typen > 5 ) && !(0))
+        fprintf(stderr, "triggered bug index 31\n");
+      else
+        fprintf(stderr, "reached bug index 31\n");
+    }
+    if ((!FIXREVERTER[31] && (typen > 5 ))
+    #else
+    if (0
+    #endif
+    ) {
         cmsSignalError(self->ContextID, cmsERROR_UNKNOWN_EXTENSION, "Unsupported parametric curve");
         return FALSE;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
     nParams = ParamsByType[typen];
 
@@ -1312,7 +1754,22 @@ void *Type_DateTime_Read(struct _cms_typehandler_struct* self, cmsIOHANDLER* io,
 
     *nItems = 0;
     NewDateTime = (struct tm*) _cmsMalloc(self ->ContextID, sizeof(struct tm));
-    if (NewDateTime == NULL) return NULL;
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[32]) {
+      if ((NewDateTime == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 32\n");
+      else
+        fprintf(stderr, "reached bug index 32\n");
+    }
+    if ((!FIXREVERTER[32] && (NewDateTime == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) return NULL;
+    #ifdef FRCOV
+    }
+    #endif
 
     if (io->Read(io, &timestamp, sizeof(cmsDateTimeNumber), 1) != 1) return NULL;
 
@@ -1443,14 +1900,44 @@ void *Type_MLU_Read(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsU
     if (!_cmsReadUInt32Number(io, &Count)) return NULL;
     if (!_cmsReadUInt32Number(io, &RecLen)) return NULL;
 
-    if (RecLen != 12) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[33]) {
+      if ((RecLen != 12 ) && !(0))
+        fprintf(stderr, "triggered bug index 33\n");
+      else
+        fprintf(stderr, "reached bug index 33\n");
+    }
+    if ((!FIXREVERTER[33] && (RecLen != 12 ))
+    #else
+    if (0
+    #endif
+    ) {
 
         cmsSignalError(self->ContextID, cmsERROR_UNKNOWN_EXTENSION, "multiLocalizedUnicodeType of len != 12 is not supported.");
         return NULL;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
     mlu = cmsMLUalloc(self ->ContextID, Count);
-    if (mlu == NULL) return NULL;
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[34]) {
+      if ((mlu == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 34\n");
+      else
+        fprintf(stderr, "reached bug index 34\n");
+    }
+    if ((!FIXREVERTER[34] && (mlu == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) return NULL;
+    #ifdef FRCOV
+    }
+    #endif
 
     mlu ->UsedEntries = Count;
 
@@ -1467,8 +1954,38 @@ void *Type_MLU_Read(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsU
         if (!_cmsReadUInt32Number(io, &Offset)) goto Error;
 
         // Check for overflow
-        if (Offset < (SizeOfHeader + 8)) goto Error;
-        if ((Offset + Len) > SizeOfTag + 8) goto Error;
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[35]) {
+          if ((Offset < SizeOfHeader + 8 ) && !(0))
+            fprintf(stderr, "triggered bug index 35\n");
+          else
+            fprintf(stderr, "reached bug index 35\n");
+        }
+        if ((!FIXREVERTER[35] && (Offset < SizeOfHeader + 8 ))
+        #else
+        if (0
+        #endif
+        ) goto Error;
+        #ifdef FRCOV
+        }
+        #endif
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[36]) {
+          if ((Offset + Len > SizeOfTag + 8 ) && !(0))
+            fprintf(stderr, "triggered bug index 36\n");
+          else
+            fprintf(stderr, "reached bug index 36\n");
+        }
+        if ((!FIXREVERTER[36] && (Offset + Len > SizeOfTag + 8 ))
+        #else
+        if (0
+        #endif
+        ) goto Error;
+        #ifdef FRCOV
+        }
+        #endif
 
         // True begin of the string
         BeginOfThisString = Offset - SizeOfHeader - 8;
@@ -1479,8 +1996,23 @@ void *Type_MLU_Read(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsU
 
         // To guess maximum size, add offset + len
         EndOfThisString = BeginOfThisString + Len;
-        if (EndOfThisString > LargestPosition)
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[37]) {
+          if ((EndOfThisString > LargestPosition ) && !(0))
+            fprintf(stderr, "triggered bug index 37\n");
+          else
+            fprintf(stderr, "reached bug index 37\n");
+        }
+        if ((!FIXREVERTER[37] && (EndOfThisString > LargestPosition ))
+        #else
+        if (0
+        #endif
+        )
             LargestPosition = EndOfThisString;
+            #ifdef FRCOV
+            }
+            #endif
     }
 
     // Now read the remaining of tag and fill all strings. Subtract the directory
@@ -1494,7 +2026,22 @@ void *Type_MLU_Read(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsU
     else
     {
         Block = (wchar_t*) _cmsMalloc(self ->ContextID, SizeOfTag);
-        if (Block == NULL) goto Error;
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[38]) {
+          if ((Block == (void *) 0 ) && !(0))
+            fprintf(stderr, "triggered bug index 38\n");
+          else
+            fprintf(stderr, "reached bug index 38\n");
+        }
+        if ((!FIXREVERTER[38] && (Block == (void *) 0 ))
+        #else
+        if (0
+        #endif
+        ) goto Error;
+        #ifdef FRCOV
+        }
+        #endif
         NumOfWchar = SizeOfTag / sizeof(wchar_t);
         if (!_cmsReadWCharArray(io, NumOfWchar, Block)) goto Error;
     }
@@ -1519,13 +2066,28 @@ cmsBool  Type_MLU_Write(struct _cms_typehandler_struct* self, cmsIOHANDLER* io,
     cmsUInt32Number  Len, Offset;
     cmsUInt32Number i;
 
-    if (Ptr == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[39]) {
+      if ((Ptr == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 39\n");
+      else
+        fprintf(stderr, "reached bug index 39\n");
+    }
+    if ((!FIXREVERTER[39] && (Ptr == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
 
           // Empty placeholder
           if (!_cmsWriteUInt32Number(io, 0)) return FALSE;
           if (!_cmsWriteUInt32Number(io, 12)) return FALSE;
           return TRUE;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
     if (!_cmsWriteUInt32Number(io, mlu ->UsedEntries)) return FALSE;
     if (!_cmsWriteUInt32Number(io, 12)) return FALSE;
@@ -1633,13 +2195,58 @@ cmsBool  Read8bitTables(cmsContext ContextID, cmsIOHANDLER* io, cmsPipeline* lut
     int i, j;
     cmsToneCurve* Tables[cmsMAXCHANNELS];
 
-    if (nChannels > cmsMAXCHANNELS) return FALSE;
-    if (nChannels <= 0) return FALSE;
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[40]) {
+      if ((nChannels > 16 ) && !(0))
+        fprintf(stderr, "triggered bug index 40\n");
+      else
+        fprintf(stderr, "reached bug index 40\n");
+    }
+    if ((!FIXREVERTER[40] && (nChannels > 16 ))
+    #else
+    if (0
+    #endif
+    ) return FALSE;
+    #ifdef FRCOV
+    }
+    #endif
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[41]) {
+      if ((nChannels <= 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 41\n");
+      else
+        fprintf(stderr, "reached bug index 41\n");
+    }
+    if ((!FIXREVERTER[41] && (nChannels <= 0 ))
+    #else
+    if (0
+    #endif
+    ) return FALSE;
+    #ifdef FRCOV
+    }
+    #endif
 
     memset(Tables, 0, sizeof(Tables));
 
     Temp = (cmsUInt8Number*) _cmsMalloc(ContextID, 256);
-    if (Temp == NULL) return FALSE;
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[42]) {
+      if ((Temp == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 42\n");
+      else
+        fprintf(stderr, "reached bug index 42\n");
+    }
+    if ((!FIXREVERTER[42] && (Temp == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) return FALSE;
+    #ifdef FRCOV
+    }
+    #endif
 
     for (i=0; i < nChannels; i++) {
         Tables[i] = cmsBuildTabulatedToneCurve16(ContextID, 256, NULL);
@@ -1719,8 +2326,38 @@ cmsUInt32Number uipow(cmsUInt32Number n, cmsUInt32Number a, cmsUInt32Number b)
 {
     cmsUInt32Number rv = 1, rc;
 
-    if (a == 0) return 0;
-    if (n == 0) return 0;
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[43]) {
+      if ((a == 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 43\n");
+      else
+        fprintf(stderr, "reached bug index 43\n");
+    }
+    if ((!FIXREVERTER[43] && (a == 0 ))
+    #else
+    if (0
+    #endif
+    ) return 0;
+    #ifdef FRCOV
+    }
+    #endif
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[44]) {
+      if ((n == 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 44\n");
+      else
+        fprintf(stderr, "reached bug index 44\n");
+    }
+    if ((!FIXREVERTER[44] && (n == 0 ))
+    #else
+    if (0
+    #endif
+    ) return 0;
+    #ifdef FRCOV
+    }
+    #endif
 
     for (; b > 0; b--) {
 
@@ -1733,7 +2370,22 @@ cmsUInt32Number uipow(cmsUInt32Number n, cmsUInt32Number a, cmsUInt32Number b)
 
     rc = rv * n;
 
-    if (rv != rc / n) return (cmsUInt32Number) -1;
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[45]) {
+      if ((rv != rc / n ) && !(0))
+        fprintf(stderr, "triggered bug index 45\n");
+      else
+        fprintf(stderr, "reached bug index 45\n");
+    }
+    if ((!FIXREVERTER[45] && (rv != rc / n ))
+    #else
+    if (0
+    #endif
+    ) return (cmsUInt32Number) -1;
+    #ifdef FRCOV
+    }
+    #endif
     return rc;
 }
 
@@ -1768,7 +2420,22 @@ void *Type_LUT8_Read(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cms
 
    // Allocates an empty Pipeline
     NewLUT = cmsPipelineAlloc(self ->ContextID, InputChannels, OutputChannels);
-    if (NewLUT == NULL) goto Error;
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[46]) {
+      if ((NewLUT == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 46\n");
+      else
+        fprintf(stderr, "reached bug index 46\n");
+    }
+    if ((!FIXREVERTER[46] && (NewLUT == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) goto Error;
+    #ifdef FRCOV
+    }
+    #endif
 
     // Read the Matrix
     if (!_cmsRead15Fixed16Number(io,  &Matrix[0])) goto Error;
@@ -1800,13 +2467,43 @@ void *Type_LUT8_Read(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cms
         cmsUInt16Number *PtrW, *T;
        
         PtrW = T  = (cmsUInt16Number*) _cmsCalloc(self ->ContextID, nTabSize, sizeof(cmsUInt16Number));
-        if (T  == NULL) goto Error;
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[47]) {
+          if ((T == (void *) 0 ) && !(0))
+            fprintf(stderr, "triggered bug index 47\n");
+          else
+            fprintf(stderr, "reached bug index 47\n");
+        }
+        if ((!FIXREVERTER[47] && (T == (void *) 0 ))
+        #else
+        if (0
+        #endif
+        ) goto Error;
+        #ifdef FRCOV
+        }
+        #endif
 
         Temp = (cmsUInt8Number*) _cmsMalloc(self ->ContextID, nTabSize);
-        if (Temp == NULL) {
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[48]) {
+          if ((Temp == (void *) 0 ) && !(0))
+            fprintf(stderr, "triggered bug index 48\n");
+          else
+            fprintf(stderr, "reached bug index 48\n");
+        }
+        if ((!FIXREVERTER[48] && (Temp == (void *) 0 ))
+        #else
+        if (0
+        #endif
+        ) {
             _cmsFree(self ->ContextID, T);
             goto Error;
         }
+        #ifdef FRCOV
+        }
+        #endif
 
         if (io ->Read(io, Temp, nTabSize, 1) != 1) {
             _cmsFree(self ->ContextID, T);
@@ -1979,11 +2676,56 @@ cmsBool  Read16bitTables(cmsContext ContextID, cmsIOHANDLER* io, cmsPipeline* lu
     cmsToneCurve* Tables[cmsMAXCHANNELS];
 
     // Maybe an empty table? (this is a lcms extension)
-    if (nEntries <= 0) return TRUE;
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[49]) {
+      if ((nEntries <= 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 49\n");
+      else
+        fprintf(stderr, "reached bug index 49\n");
+    }
+    if ((!FIXREVERTER[49] && (nEntries <= 0 ))
+    #else
+    if (0
+    #endif
+    ) return TRUE;
+    #ifdef FRCOV
+    }
+    #endif
 
     // Check for malicious profiles
-    if (nEntries < 2) return FALSE;
-    if (nChannels > cmsMAXCHANNELS) return FALSE;
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[50]) {
+      if ((nEntries < 2 ) && !(0))
+        fprintf(stderr, "triggered bug index 50\n");
+      else
+        fprintf(stderr, "reached bug index 50\n");
+    }
+    if ((!FIXREVERTER[50] && (nEntries < 2 ))
+    #else
+    if (0
+    #endif
+    ) return FALSE;
+    #ifdef FRCOV
+    }
+    #endif
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[51]) {
+      if ((nChannels > 16 ) && !(0))
+        fprintf(stderr, "triggered bug index 51\n");
+      else
+        fprintf(stderr, "reached bug index 51\n");
+    }
+    if ((!FIXREVERTER[51] && (nChannels > 16 ))
+    #else
+    if (0
+    #endif
+    ) return FALSE;
+    #ifdef FRCOV
+    }
+    #endif
 
     // Init table to zero
     memset(Tables, 0, sizeof(Tables));
@@ -2063,7 +2805,22 @@ void *Type_LUT16_Read(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cm
 
     // Allocates an empty LUT
     NewLUT = cmsPipelineAlloc(self ->ContextID, InputChannels, OutputChannels);
-    if (NewLUT == NULL) goto Error;
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[52]) {
+      if ((NewLUT == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 52\n");
+      else
+        fprintf(stderr, "reached bug index 52\n");
+    }
+    if ((!FIXREVERTER[52] && (NewLUT == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) goto Error;
+    #ifdef FRCOV
+    }
+    #endif
 
     // Read the Matrix
     if (!_cmsRead15Fixed16Number(io,  &Matrix[0])) goto Error;
@@ -2087,7 +2844,22 @@ void *Type_LUT16_Read(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cm
     if (!_cmsReadUInt16Number(io, &InputEntries)) goto Error;
     if (!_cmsReadUInt16Number(io, &OutputEntries)) goto Error;
 
-    if (InputEntries > 0x7FFF || OutputEntries > 0x7FFF) goto Error;
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[53]) {
+      if ((InputEntries > 32767 || OutputEntries > 32767 ) && !(0))
+        fprintf(stderr, "triggered bug index 53\n");
+      else
+        fprintf(stderr, "reached bug index 53\n");
+    }
+    if ((!FIXREVERTER[53] && (InputEntries > 32767 || OutputEntries > 32767 ))
+    #else
+    if (0
+    #endif
+    ) goto Error;
+    #ifdef FRCOV
+    }
+    #endif
     if (CLUTpoints == 1) goto Error; // Impossible value, 0 for no CLUT and then 2 at least
 
     // Get input tables
@@ -2101,7 +2873,22 @@ void *Type_LUT16_Read(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cm
         cmsUInt16Number *T;
 
         T  = (cmsUInt16Number*) _cmsCalloc(self ->ContextID, nTabSize, sizeof(cmsUInt16Number));
-        if (T  == NULL) goto Error;
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[54]) {
+          if ((T == (void *) 0 ) && !(0))
+            fprintf(stderr, "triggered bug index 54\n");
+          else
+            fprintf(stderr, "reached bug index 54\n");
+        }
+        if ((!FIXREVERTER[54] && (T == (void *) 0 ))
+        #else
+        if (0
+        #endif
+        ) goto Error;
+        #ifdef FRCOV
+        }
+        #endif
 
         if (!_cmsReadUInt16Array(io, nTabSize, T)) {
             _cmsFree(self ->ContextID, T);
@@ -2352,7 +3139,22 @@ cmsStage* ReadCLUT(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsUI
     if (!_cmsReadUInt8Number(io, NULL)) return NULL;
 
     CLUT = cmsStageAllocCLut16bitGranular(self ->ContextID, GridPoints, InputChannels, OutputChannels, NULL);
-    if (CLUT == NULL) return NULL;
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[55]) {
+      if ((CLUT == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 55\n");
+      else
+        fprintf(stderr, "reached bug index 55\n");
+    }
+    if ((!FIXREVERTER[55] && (CLUT == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) return NULL;
+    #ifdef FRCOV
+    }
+    #endif
 
     Data = (_cmsStageCLutData*) CLUT ->Data;
 
@@ -2423,7 +3225,22 @@ cmsStage* ReadSetOfCurves(struct _cms_typehandler_struct* self, cmsIOHANDLER* io
     cmsUInt32Number i;
     cmsStage* Lin = NULL;
 
-    if (nCurves > cmsMAXCHANNELS) return FALSE;
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[56]) {
+      if ((nCurves > 16 ) && !(0))
+        fprintf(stderr, "triggered bug index 56\n");
+      else
+        fprintf(stderr, "reached bug index 56\n");
+    }
+    if ((!FIXREVERTER[56] && (nCurves > 16 ))
+    #else
+    if (0
+    #endif
+    ) return FALSE;
+    #ifdef FRCOV
+    }
+    #endif
 
     if (!io -> Seek(io, Offset)) return FALSE;
 
@@ -2501,7 +3318,22 @@ void* Type_LUTA2B_Read(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, c
 
     // Allocates an empty LUT
     NewLUT = cmsPipelineAlloc(self ->ContextID, inputChan, outputChan);
-    if (NewLUT == NULL) return NULL;
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[57]) {
+      if ((NewLUT == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 57\n");
+      else
+        fprintf(stderr, "reached bug index 57\n");
+    }
+    if ((!FIXREVERTER[57] && (NewLUT == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) return NULL;
+    #ifdef FRCOV
+    }
+    #endif
 
     if (offsetA!= 0) {
         if (!cmsPipelineInsertStage(NewLUT, cmsAT_END, ReadSetOfCurves(self, io, BaseOffset + offsetA, inputChan)))
@@ -2821,7 +3653,22 @@ void* Type_LUTB2A_Read(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, c
 
     // Allocates an empty LUT
     NewLUT = cmsPipelineAlloc(self ->ContextID, inputChan, outputChan);
-    if (NewLUT == NULL) return NULL;
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[58]) {
+      if ((NewLUT == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 58\n");
+      else
+        fprintf(stderr, "reached bug index 58\n");
+    }
+    if ((!FIXREVERTER[58] && (NewLUT == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) return NULL;
+    #ifdef FRCOV
+    }
+    #endif
 
     if (offsetB != 0) {
         if (!cmsPipelineInsertStage(NewLUT, cmsAT_END, ReadSetOfCurves(self, io, BaseOffset + offsetB, inputChan)))
@@ -2992,10 +3839,25 @@ void *Type_ColorantTable_Read(struct _cms_typehandler_struct* self, cmsIOHANDLER
 
     if (!_cmsReadUInt32Number(io, &Count)) return NULL;
 
-    if (Count > cmsMAXCHANNELS) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[59]) {
+      if ((Count > 16 ) && !(0))
+        fprintf(stderr, "triggered bug index 59\n");
+      else
+        fprintf(stderr, "reached bug index 59\n");
+    }
+    if ((!FIXREVERTER[59] && (Count > 16 ))
+    #else
+    if (0
+    #endif
+    ) {
         cmsSignalError(self->ContextID, cmsERROR_RANGE, "Too many colorants '%d'", Count);
         return NULL;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
     List = cmsAllocNamedColorList(self ->ContextID, Count, 0, "", "");
     for (i=0; i < Count; i++) {
@@ -3114,15 +3976,45 @@ void *Type_NamedColor_Read(struct _cms_typehandler_struct* self, cmsIOHANDLER* i
     prefix[31] = suffix[31] = 0;
 
     v = cmsAllocNamedColorList(self ->ContextID, count, nDeviceCoords, prefix, suffix);
-    if (v == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[60]) {
+      if ((v == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 60\n");
+      else
+        fprintf(stderr, "reached bug index 60\n");
+    }
+    if ((!FIXREVERTER[60] && (v == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         cmsSignalError(self->ContextID, cmsERROR_RANGE, "Too many named colors '%d'", count);
         return NULL;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
-    if (nDeviceCoords > cmsMAXCHANNELS) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[61]) {
+      if ((nDeviceCoords > 16 ) && !(0))
+        fprintf(stderr, "triggered bug index 61\n");
+      else
+        fprintf(stderr, "reached bug index 61\n");
+    }
+    if ((!FIXREVERTER[61] && (nDeviceCoords > 16 ))
+    #else
+    if (0
+    #endif
+    ) {
         cmsSignalError(self->ContextID, cmsERROR_RANGE, "Too many device coordinates '%d'", nDeviceCoords);
         goto Error;
     }
+    #ifdef FRCOV
+    }
+    #endif
     for (i=0; i < count; i++) {
 
         cmsUInt16Number PCS[3];
@@ -3274,7 +4166,22 @@ void *Type_ProfileSequenceDesc_Read(struct _cms_typehandler_struct* self, cmsIOH
 
 
     OutSeq = cmsAllocProfileSequenceDescription(self ->ContextID, Count);
-    if (OutSeq == NULL) return NULL;
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[62]) {
+      if ((OutSeq == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 62\n");
+      else
+        fprintf(stderr, "reached bug index 62\n");
+    }
+    if ((!FIXREVERTER[62] && (OutSeq == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) return NULL;
+    #ifdef FRCOV
+    }
+    #endif
 
     OutSeq ->n = Count;
 
@@ -3423,7 +4330,22 @@ void *Type_ProfileSequenceId_Read(struct _cms_typehandler_struct* self, cmsIOHAN
 
     // Allocate an empty structure
     OutSeq = cmsAllocProfileSequenceDescription(self ->ContextID, Count);
-    if (OutSeq == NULL) return NULL;
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[63]) {
+      if ((OutSeq == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 63\n");
+      else
+        fprintf(stderr, "reached bug index 63\n");
+    }
+    if ((!FIXREVERTER[63] && (OutSeq == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) return NULL;
+    #ifdef FRCOV
+    }
+    #endif
 
 
     // Read the position table
@@ -3515,7 +4437,22 @@ void *Type_UcrBg_Read(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cm
     char* ASCIIString;
 
     *nItems = 0;
-    if (n == NULL) return NULL;
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[64]) {
+      if ((n == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 64\n");
+      else
+        fprintf(stderr, "reached bug index 64\n");
+    }
+    if ((!FIXREVERTER[64] && (n == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) return NULL;
+    #ifdef FRCOV
+    }
+    #endif
 
     // First curve is Under color removal
     if (!_cmsReadUInt32Number(io, &CountUcr)) return NULL;
@@ -3523,7 +4460,22 @@ void *Type_UcrBg_Read(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cm
     SizeOfTag -= sizeof(cmsUInt32Number);
 
     n ->Ucr = cmsBuildTabulatedToneCurve16(self ->ContextID, CountUcr, NULL);
-    if (n ->Ucr == NULL) return NULL;
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[65]) {
+      if ((n -> Ucr == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 65\n");
+      else
+        fprintf(stderr, "reached bug index 65\n");
+    }
+    if ((!FIXREVERTER[65] && (n -> Ucr == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) return NULL;
+    #ifdef FRCOV
+    }
+    #endif
 
     if (!_cmsReadUInt16Array(io, CountUcr, n ->Ucr->Table16)) return NULL;
     if (SizeOfTag < sizeof(cmsUInt32Number)) return NULL;
@@ -3535,7 +4487,22 @@ void *Type_UcrBg_Read(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cm
     SizeOfTag -= sizeof(cmsUInt32Number);
 
     n ->Bg = cmsBuildTabulatedToneCurve16(self ->ContextID, CountBg, NULL);
-    if (n ->Bg == NULL) return NULL;
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[66]) {
+      if ((n -> Bg == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 66\n");
+      else
+        fprintf(stderr, "reached bug index 66\n");
+    }
+    if ((!FIXREVERTER[66] && (n -> Bg == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) return NULL;
+    #ifdef FRCOV
+    }
+    #endif
     if (!_cmsReadUInt16Array(io, CountBg, n ->Bg->Table16)) return NULL;
     if (SizeOfTag < CountBg * sizeof(cmsUInt16Number)) return NULL;
     SizeOfTag -= CountBg * sizeof(cmsUInt16Number);
@@ -3543,7 +4510,22 @@ void *Type_UcrBg_Read(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cm
 
     // Now comes the text. The length is specified by the tag size
     n ->Desc = cmsMLUalloc(self ->ContextID, 1);
-    if (n ->Desc == NULL) return NULL;
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[67]) {
+      if ((n -> Desc == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 67\n");
+      else
+        fprintf(stderr, "reached bug index 67\n");
+    }
+    if ((!FIXREVERTER[67] && (n -> Desc == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) return NULL;
+    #ifdef FRCOV
+    }
+    #endif
 
     ASCIIString = (char*) _cmsMalloc(self ->ContextID, SizeOfTag + 1);
     if (io ->Read(io, ASCIIString, sizeof(char), SizeOfTag) != SizeOfTag) return NULL;
@@ -3589,7 +4571,22 @@ void* Type_UcrBg_Dup(struct _cms_typehandler_struct* self, const void *Ptr, cmsU
     cmsUcrBg* Src = (cmsUcrBg*) Ptr;
     cmsUcrBg* NewUcrBg = (cmsUcrBg*) _cmsMallocZero(self ->ContextID, sizeof(cmsUcrBg));
 
-    if (NewUcrBg == NULL) return NULL;
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[68]) {
+      if ((NewUcrBg == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 68\n");
+      else
+        fprintf(stderr, "reached bug index 68\n");
+    }
+    if ((!FIXREVERTER[68] && (NewUcrBg == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) return NULL;
+    #ifdef FRCOV
+    }
+    #endif
 
     NewUcrBg ->Bg   = cmsDupToneCurve(Src ->Bg);
     NewUcrBg ->Ucr  = cmsDupToneCurve(Src ->Ucr);
@@ -3646,7 +4643,22 @@ cmsBool  ReadCountAndSting(struct _cms_typehandler_struct* self, cmsIOHANDLER* i
     if (*SizeOfTag < Count + sizeof(cmsUInt32Number)) return FALSE;
 
     Text     = (char*) _cmsMalloc(self ->ContextID, Count+1);
-    if (Text == NULL) return FALSE;
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[69]) {
+      if ((Text == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 69\n");
+      else
+        fprintf(stderr, "reached bug index 69\n");
+    }
+    if ((!FIXREVERTER[69] && (Text == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) return FALSE;
+    #ifdef FRCOV
+    }
+    #endif
 
     if (io ->Read(io, Text, sizeof(cmsUInt8Number), Count) != Count) {
         _cmsFree(self ->ContextID, Text);
@@ -3755,15 +4767,45 @@ void *Type_Screening_Read(struct _cms_typehandler_struct* self, cmsIOHANDLER* io
     cmsUInt32Number i;
 
     sc = (cmsScreening*) _cmsMallocZero(self ->ContextID, sizeof(cmsScreening));
-    if (sc == NULL) return NULL;
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[70]) {
+      if ((sc == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 70\n");
+      else
+        fprintf(stderr, "reached bug index 70\n");
+    }
+    if ((!FIXREVERTER[70] && (sc == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) return NULL;
+    #ifdef FRCOV
+    }
+    #endif
 
     *nItems = 0;
 
     if (!_cmsReadUInt32Number(io, &sc ->Flag)) goto Error;
     if (!_cmsReadUInt32Number(io, &sc ->nChannels)) goto Error;
 
-    if (sc ->nChannels > cmsMAXCHANNELS - 1)
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[71]) {
+      if ((sc -> nChannels > 16 - 1  ) && !(0))
+        fprintf(stderr, "triggered bug index 71\n");
+      else
+        fprintf(stderr, "reached bug index 71\n");
+    }
+    if ((!FIXREVERTER[71] && (sc -> nChannels > 16 - 1  ))
+    #else
+    if (0
+    #endif
+    )
         sc ->nChannels = cmsMAXCHANNELS - 1;
+        #ifdef FRCOV
+        }
+        #endif
 
     for (i=0; i < sc ->nChannels; i++) {
 
@@ -3839,7 +4881,22 @@ void *Type_ViewingConditions_Read(struct _cms_typehandler_struct* self, cmsIOHAN
     cmsICCViewingConditions* vc = NULL;
 
     vc = (cmsICCViewingConditions*) _cmsMallocZero(self ->ContextID, sizeof(cmsICCViewingConditions));
-    if (vc == NULL) return NULL;
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[72]) {
+      if ((vc == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 72\n");
+      else
+        fprintf(stderr, "reached bug index 72\n");
+    }
+    if ((!FIXREVERTER[72] && (vc == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) return NULL;
+    #ifdef FRCOV
+    }
+    #endif
 
     *nItems = 0;
 
@@ -3943,9 +5000,39 @@ cmsToneCurve* ReadSegmentedCurve(struct _cms_typehandler_struct* self, cmsIOHAND
      if (!_cmsReadUInt16Number(io, &nSegments)) return NULL;
      if (!_cmsReadUInt16Number(io, NULL)) return NULL;
 
-     if (nSegments < 1) return NULL;
+     
+     #ifdef FRCOV
+     {if (FIXREVERTER[73]) {
+       if ((nSegments < 1 ) && !(0))
+         fprintf(stderr, "triggered bug index 73\n");
+       else
+         fprintf(stderr, "reached bug index 73\n");
+     }
+     if ((!FIXREVERTER[73] && (nSegments < 1 ))
+     #else
+     if (0
+     #endif
+     ) return NULL;
+     #ifdef FRCOV
+     }
+     #endif
      Segments = (cmsCurveSegment*) _cmsCalloc(self ->ContextID, nSegments, sizeof(cmsCurveSegment));
-     if (Segments == NULL) return NULL;
+     
+     #ifdef FRCOV
+     {if (FIXREVERTER[74]) {
+       if ((Segments == (void *) 0 ) && !(0))
+         fprintf(stderr, "triggered bug index 74\n");
+       else
+         fprintf(stderr, "reached bug index 74\n");
+     }
+     if ((!FIXREVERTER[74] && (Segments == (void *) 0 ))
+     #else
+     if (0
+     #endif
+     ) return NULL;
+     #ifdef FRCOV
+     }
+     #endif
 
      // Read breakpoints
      for (i=0; i < (cmsUInt32Number) nSegments - 1; i++) {
@@ -3975,7 +5062,22 @@ cmsToneCurve* ReadSegmentedCurve(struct _cms_typehandler_struct* self, cmsIOHAND
                 if (!_cmsReadUInt16Number(io, NULL)) goto Error;
 
                 Segments[i].Type = Type + 6;
-                if (Type > 2) goto Error;
+                
+                #ifdef FRCOV
+                {if (FIXREVERTER[75]) {
+                  if ((Type > 2 ) && !(0))
+                    fprintf(stderr, "triggered bug index 75\n");
+                  else
+                    fprintf(stderr, "reached bug index 75\n");
+                }
+                if ((!FIXREVERTER[75] && (Type > 2 ))
+                #else
+                if (0
+                #endif
+                ) goto Error;
+                #ifdef FRCOV
+                }
+                #endif
 
                 for (j=0; j < ParamsByType[Type]; j++) {
 
@@ -4064,10 +5166,40 @@ void *Type_MPEcurve_Read(struct _cms_typehandler_struct* self, cmsIOHANDLER* io,
     if (!_cmsReadUInt16Number(io, &InputChans)) return NULL;
     if (!_cmsReadUInt16Number(io, &OutputChans)) return NULL;
 
-    if (InputChans != OutputChans) return NULL;
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[76]) {
+      if ((InputChans != OutputChans ) && !(0))
+        fprintf(stderr, "triggered bug index 76\n");
+      else
+        fprintf(stderr, "reached bug index 76\n");
+    }
+    if ((!FIXREVERTER[76] && (InputChans != OutputChans ))
+    #else
+    if (0
+    #endif
+    ) return NULL;
+    #ifdef FRCOV
+    }
+    #endif
 
     GammaTables = (cmsToneCurve**) _cmsCalloc(self ->ContextID, InputChans, sizeof(cmsToneCurve*));
-    if (GammaTables == NULL) return NULL;
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[77]) {
+      if ((GammaTables == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 77\n");
+      else
+        fprintf(stderr, "reached bug index 77\n");
+    }
+    if ((!FIXREVERTER[77] && (GammaTables == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) return NULL;
+    #ifdef FRCOV
+    }
+    #endif
 
     if (ReadPositionTable(self, io, InputChans, BaseOffset, GammaTables, ReadMPECurve)) {
 
@@ -4134,7 +5266,22 @@ cmsBool WriteSegmentedCurve(cmsIOHANDLER* io, cmsToneCurve* g)
 
             // We only allow 1, 2 and 3 as types
             Type = ActualSeg ->Type - 6;
-            if (Type > 2 || Type < 0) goto Error;
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[78]) {
+              if ((Type > 2 || Type < 0 ) && !(0))
+                fprintf(stderr, "triggered bug index 78\n");
+              else
+                fprintf(stderr, "reached bug index 78\n");
+            }
+            if ((!FIXREVERTER[78] && (Type > 2 || Type < 0 ))
+            #else
+            if (0
+            #endif
+            ) goto Error;
+            #ifdef FRCOV
+            }
+            #endif
 
             if (!_cmsWriteUInt16Number(io, (cmsUInt16Number) Type)) goto Error;
             if (!_cmsWriteUInt16Number(io, 0)) goto Error;
@@ -4215,20 +5362,80 @@ void *Type_MPEmatrix_Read(struct _cms_typehandler_struct* self, cmsIOHANDLER* io
 
     // Input and output chans may be ANY (up to 0xffff), 
     // but we choose to limit to 16 channels for now
-    if (InputChans >= cmsMAXCHANNELS) return NULL;
-    if (OutputChans >= cmsMAXCHANNELS) return NULL;
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[79]) {
+      if ((InputChans >= 16 ) && !(0))
+        fprintf(stderr, "triggered bug index 79\n");
+      else
+        fprintf(stderr, "reached bug index 79\n");
+    }
+    if ((!FIXREVERTER[79] && (InputChans >= 16 ))
+    #else
+    if (0
+    #endif
+    ) return NULL;
+    #ifdef FRCOV
+    }
+    #endif
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[80]) {
+      if ((OutputChans >= 16 ) && !(0))
+        fprintf(stderr, "triggered bug index 80\n");
+      else
+        fprintf(stderr, "reached bug index 80\n");
+    }
+    if ((!FIXREVERTER[80] && (OutputChans >= 16 ))
+    #else
+    if (0
+    #endif
+    ) return NULL;
+    #ifdef FRCOV
+    }
+    #endif
 
     nElems = InputChans * OutputChans;
 
     Matrix = (cmsFloat64Number*) _cmsCalloc(self ->ContextID, nElems, sizeof(cmsFloat64Number));
-    if (Matrix == NULL) return NULL;
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[81]) {
+      if ((Matrix == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 81\n");
+      else
+        fprintf(stderr, "reached bug index 81\n");
+    }
+    if ((!FIXREVERTER[81] && (Matrix == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) return NULL;
+    #ifdef FRCOV
+    }
+    #endif
 
     Offsets = (cmsFloat64Number*) _cmsCalloc(self ->ContextID, OutputChans, sizeof(cmsFloat64Number));
-    if (Offsets == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[82]) {
+      if ((Offsets == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 82\n");
+      else
+        fprintf(stderr, "reached bug index 82\n");
+    }
+    if ((!FIXREVERTER[82] && (Offsets == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
 
         _cmsFree(self ->ContextID, Matrix);
         return NULL;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
     for (i=0; i < nElems; i++) {
 
@@ -4315,8 +5522,38 @@ void *Type_MPEclut_Read(struct _cms_typehandler_struct* self, cmsIOHANDLER* io,
     if (!_cmsReadUInt16Number(io, &InputChans)) return NULL;
     if (!_cmsReadUInt16Number(io, &OutputChans)) return NULL;
 
-    if (InputChans == 0) goto Error;
-    if (OutputChans == 0) goto Error;
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[83]) {
+      if ((InputChans == 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 83\n");
+      else
+        fprintf(stderr, "reached bug index 83\n");
+    }
+    if ((!FIXREVERTER[83] && (InputChans == 0 ))
+    #else
+    if (0
+    #endif
+    ) goto Error;
+    #ifdef FRCOV
+    }
+    #endif
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[84]) {
+      if ((OutputChans == 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 84\n");
+      else
+        fprintf(stderr, "reached bug index 84\n");
+    }
+    if ((!FIXREVERTER[84] && (OutputChans == 0 ))
+    #else
+    if (0
+    #endif
+    ) goto Error;
+    #ifdef FRCOV
+    }
+    #endif
 
     if (io ->Read(io, Dimensions8, sizeof(cmsUInt8Number), 16) != 16)
         goto Error;
@@ -4331,7 +5568,22 @@ void *Type_MPEclut_Read(struct _cms_typehandler_struct* self, cmsIOHANDLER* io,
     
     // Allocate the true CLUT
     mpe = cmsStageAllocCLutFloatGranular(self ->ContextID, GridPoints, InputChans, OutputChans, NULL);
-    if (mpe == NULL) goto Error;
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[85]) {
+      if ((mpe == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 85\n");
+      else
+        fprintf(stderr, "reached bug index 85\n");
+    }
+    if ((!FIXREVERTER[85] && (mpe == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) goto Error;
+    #ifdef FRCOV
+    }
+    #endif
 
     // Read and sanitize the data
     clut = (_cmsStageCLutData*) mpe ->Data;
@@ -4361,10 +5613,40 @@ cmsBool  Type_MPEclut_Write(struct _cms_typehandler_struct* self, cmsIOHANDLER*
     _cmsStageCLutData* clut = (_cmsStageCLutData*) mpe ->Data;
 
     // Check for maximum number of channels supported by lcms
-    if (mpe -> InputChannels > MAX_INPUT_DIMENSIONS) return FALSE;
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[86]) {
+      if ((mpe -> InputChannels > 8 ) && !(0))
+        fprintf(stderr, "triggered bug index 86\n");
+      else
+        fprintf(stderr, "reached bug index 86\n");
+    }
+    if ((!FIXREVERTER[86] && (mpe -> InputChannels > 8 ))
+    #else
+    if (0
+    #endif
+    ) return FALSE;
+    #ifdef FRCOV
+    }
+    #endif
 
     // Only floats are supported in MPE
-    if (clut ->HasFloatValues == FALSE) return FALSE;
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[87]) {
+      if ((clut -> HasFloatValues == 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 87\n");
+      else
+        fprintf(stderr, "reached bug index 87\n");
+    }
+    if ((!FIXREVERTER[87] && (clut -> HasFloatValues == 0 ))
+    #else
+    if (0
+    #endif
+    ) return FALSE;
+    #ifdef FRCOV
+    }
+    #endif
 
     if (!_cmsWriteUInt16Number(io, (cmsUInt16Number) mpe ->InputChannels)) return FALSE;
     if (!_cmsWriteUInt16Number(io, (cmsUInt16Number) mpe ->OutputChannels)) return FALSE;
@@ -4467,19 +5749,78 @@ void *Type_MPE_Read(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsU
     if (!_cmsReadUInt16Number(io, &InputChans)) return NULL;
     if (!_cmsReadUInt16Number(io, &OutputChans)) return NULL;
 
-    if (InputChans == 0 || InputChans >= cmsMAXCHANNELS) return NULL;
-    if (OutputChans == 0 || OutputChans >= cmsMAXCHANNELS) return NULL;
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[88]) {
+      if ((InputChans == 0 || InputChans >= 16 ) && !(0))
+        fprintf(stderr, "triggered bug index 88\n");
+      else
+        fprintf(stderr, "reached bug index 88\n");
+    }
+    if ((!FIXREVERTER[88] && (InputChans == 0 || InputChans >= 16 ))
+    #else
+    if (0
+    #endif
+    ) return NULL;
+    #ifdef FRCOV
+    }
+    #endif
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[89]) {
+      if ((OutputChans == 0 || OutputChans >= 16 ) && !(0))
+        fprintf(stderr, "triggered bug index 89\n");
+      else
+        fprintf(stderr, "reached bug index 89\n");
+    }
+    if ((!FIXREVERTER[89] && (OutputChans == 0 || OutputChans >= 16 ))
+    #else
+    if (0
+    #endif
+    ) return NULL;
+    #ifdef FRCOV
+    }
+    #endif
 
     // Allocates an empty LUT
     NewLUT = cmsPipelineAlloc(self ->ContextID, InputChans, OutputChans);
-    if (NewLUT == NULL) return NULL;
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[90]) {
+      if ((NewLUT == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 90\n");
+      else
+        fprintf(stderr, "reached bug index 90\n");
+    }
+    if ((!FIXREVERTER[90] && (NewLUT == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) return NULL;
+    #ifdef FRCOV
+    }
+    #endif
 
     if (!_cmsReadUInt32Number(io, &ElementCount)) goto Error;    
     if (!ReadPositionTable(self, io, ElementCount, BaseOffset, NewLUT, ReadMPEElem)) goto Error;
 
     // Check channel count
-    if (InputChans != NewLUT->InputChannels ||
-        OutputChans != NewLUT->OutputChannels) goto Error;
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[91]) {
+      if ((InputChans != NewLUT -> InputChannels || OutputChans != NewLUT -> OutputChannels ) && !(0))
+        fprintf(stderr, "triggered bug index 91\n");
+      else
+        fprintf(stderr, "reached bug index 91\n");
+    }
+    if ((!FIXREVERTER[91] && (InputChans != NewLUT -> InputChannels || OutputChans != NewLUT -> OutputChannels ))
+    #else
+    if (0
+    #endif
+    ) goto Error;
+        #ifdef FRCOV
+        }
+        #endif
 
     // Success
     *nItems = 1;
@@ -4517,10 +5858,40 @@ cmsBool Type_MPE_Write(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, v
     ElemCount  = cmsPipelineStageCount(Lut);
 
     ElementOffsets = (cmsUInt32Number *) _cmsCalloc(self ->ContextID, ElemCount, sizeof(cmsUInt32Number));
-    if (ElementOffsets == NULL) goto Error;
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[92]) {
+      if ((ElementOffsets == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 92\n");
+      else
+        fprintf(stderr, "reached bug index 92\n");
+    }
+    if ((!FIXREVERTER[92] && (ElementOffsets == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) goto Error;
+    #ifdef FRCOV
+    }
+    #endif
 
     ElementSizes = (cmsUInt32Number *) _cmsCalloc(self ->ContextID, ElemCount, sizeof(cmsUInt32Number));
-    if (ElementSizes == NULL) goto Error;
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[93]) {
+      if ((ElementSizes == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 93\n");
+      else
+        fprintf(stderr, "reached bug index 93\n");
+    }
+    if ((!FIXREVERTER[93] && (ElementSizes == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) goto Error;
+    #ifdef FRCOV
+    }
+    #endif
 
     // Write the head
     if (!_cmsWriteUInt16Number(io, (cmsUInt16Number) inputChan)) goto Error;
@@ -4641,7 +6012,22 @@ void *Type_vcgt_Read(struct _cms_typehandler_struct* self,
 
     // Allocate space for the array
     Curves = ( cmsToneCurve**) _cmsCalloc(self ->ContextID, 3, sizeof(cmsToneCurve*));
-    if (Curves == NULL) return NULL;
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[94]) {
+      if ((Curves == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 94\n");
+      else
+        fprintf(stderr, "reached bug index 94\n");
+    }
+    if ((!FIXREVERTER[94] && (Curves == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) return NULL;
+    #ifdef FRCOV
+    }
+    #endif
 
     // There are two possible flavors
     switch (TagType) {
@@ -4654,10 +6040,25 @@ void *Type_vcgt_Read(struct _cms_typehandler_struct* self,
        // Check channel count, which should be 3 (we don't support monochrome this time)
        if (!_cmsReadUInt16Number(io, &nChannels)) goto Error;
 
-       if (nChannels != 3) {
+       
+       #ifdef FRCOV
+       {if (FIXREVERTER[95]) {
+         if ((nChannels != 3 ) && !(0))
+           fprintf(stderr, "triggered bug index 95\n");
+         else
+           fprintf(stderr, "reached bug index 95\n");
+       }
+       if ((!FIXREVERTER[95] && (nChannels != 3 ))
+       #else
+       if (0
+       #endif
+       ) {
            cmsSignalError(self->ContextID, cmsERROR_UNKNOWN_EXTENSION, "Unsupported number of channels for VCGT '%d'", nChannels);
            goto Error;
        }
+       #ifdef FRCOV
+       }
+       #endif
 
        // Get Table element count and bytes per element
        if (!_cmsReadUInt16Number(io, &nElems)) goto Error;
@@ -4822,7 +6223,22 @@ void* Type_vcgt_Dup(struct _cms_typehandler_struct* self, const void *Ptr, cmsUI
     cmsToneCurve** NewCurves;
 
     NewCurves = ( cmsToneCurve**) _cmsCalloc(self ->ContextID, 3, sizeof(cmsToneCurve*));
-    if (NewCurves == NULL) return NULL;
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[97]) {
+      if ((NewCurves == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 97\n");
+      else
+        fprintf(stderr, "reached bug index 97\n");
+    }
+    if ((!FIXREVERTER[97] && (NewCurves == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) return NULL;
+    #ifdef FRCOV
+    }
+    #endif
 
     NewCurves[0] = cmsDupToneCurve(OldCurves[0]);
     NewCurves[1] = cmsDupToneCurve(OldCurves[1]);
@@ -4863,14 +6279,44 @@ static
 cmsBool AllocElem(cmsContext ContextID, _cmsDICelem* e,  cmsUInt32Number Count)
 {
     e->Offsets = (cmsUInt32Number *) _cmsCalloc(ContextID, Count, sizeof(cmsUInt32Number));
-    if (e->Offsets == NULL) return FALSE;
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[98]) {
+      if ((e -> Offsets == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 98\n");
+      else
+        fprintf(stderr, "reached bug index 98\n");
+    }
+    if ((!FIXREVERTER[98] && (e -> Offsets == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) return FALSE;
+    #ifdef FRCOV
+    }
+    #endif
 
     e->Sizes = (cmsUInt32Number *) _cmsCalloc(ContextID, Count, sizeof(cmsUInt32Number));
-    if (e->Sizes == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[99]) {
+      if ((e -> Sizes == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 99\n");
+      else
+        fprintf(stderr, "reached bug index 99\n");
+    }
+    if ((!FIXREVERTER[99] && (e -> Sizes == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
 
         _cmsFree(ContextID, e -> Offsets);
         return FALSE;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
     e ->ContextID = ContextID;
     return TRUE;
@@ -5047,11 +6493,26 @@ cmsBool WriteOneWChar(cmsIOHANDLER* io,  _cmsDICelem* e, cmsUInt32Number i, cons
 
     e ->Offsets[i] = Before - BaseOffset;
 
-    if (wcstr == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[100]) {
+      if ((wcstr == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 100\n");
+      else
+        fprintf(stderr, "reached bug index 100\n");
+    }
+    if ((!FIXREVERTER[100] && (wcstr == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         e ->Sizes[i] = 0;
         e ->Offsets[i] = 0;
         return TRUE;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
     n = mywcslen(wcstr);
     if (!_cmsWriteWCharArray(io,  n, wcstr)) return FALSE;
@@ -5085,11 +6546,26 @@ cmsBool WriteOneMLUC(struct _cms_typehandler_struct* self, cmsIOHANDLER* io,  _c
 
      // Special case for undefined strings (see ICC Votable
      // Proposal Submission, Dictionary Type and Metadata TAG Definition)
-     if (mlu == NULL) {
+     
+     #ifdef FRCOV
+     {if (FIXREVERTER[101]) {
+       if ((mlu == (void *) 0 ) && !(0))
+         fprintf(stderr, "triggered bug index 101\n");
+       else
+         fprintf(stderr, "reached bug index 101\n");
+     }
+     if ((!FIXREVERTER[101] && (mlu == (void *) 0 ))
+     #else
+     if (0
+     #endif
+     ) {
         e ->Sizes[i] = 0;
         e ->Offsets[i] = 0;
         return TRUE;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
     Before = io ->Tell(io);
     e ->Offsets[i] = Before - BaseOffset;
@@ -5133,7 +6609,22 @@ void *Type_Dictionary_Read(struct _cms_typehandler_struct* self, cmsIOHANDLER* i
 
     // Creates an empty dictionary
     hDict = cmsDictAlloc(self -> ContextID);
-    if (hDict == NULL) return NULL;
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[102]) {
+      if ((hDict == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 102\n");
+      else
+        fprintf(stderr, "reached bug index 102\n");
+    }
+    if ((!FIXREVERTER[102] && (hDict == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) return NULL;
+    #ifdef FRCOV
+    }
+    #endif
 
     // On depending on record size, create column arrays
     if (!AllocArray(self -> ContextID, &a, Count, Length)) goto Error;
@@ -5194,7 +6685,22 @@ cmsBool Type_Dictionary_Write(struct _cms_typehandler_struct* self, cmsIOHANDLER
     cmsUInt32Number DirectoryPos, CurrentPos, BaseOffset;
    _cmsDICarray a;
 
-    if (hDict == NULL) return FALSE;
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[103]) {
+      if ((hDict == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 103\n");
+      else
+        fprintf(stderr, "reached bug index 103\n");
+    }
+    if ((!FIXREVERTER[103] && (hDict == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) return FALSE;
+    #ifdef FRCOV
+    }
+    #endif
 
     BaseOffset = io ->Tell(io) - sizeof(_cmsTagBase);
 
diff --git a/src/cmsvirt.c b/src/cmsvirt.c
index 1c282f2..b2080fb 100644
--- a/src/cmsvirt.c
+++ b/src/cmsvirt.c
@@ -1,3 +1,7 @@
+#ifdef FRCOV
+#include <stdio.h>
+extern short FIXREVERTER[];
+#endif
 //---------------------------------------------------------------------------------
 //
 //  Little Color Management System
@@ -39,7 +43,22 @@ cmsBool SetTextTags(cmsHPROFILE hProfile, const wchar_t* Description)
     DescriptionMLU  = cmsMLUalloc(ContextID, 1);
     CopyrightMLU    = cmsMLUalloc(ContextID, 1);
 
-    if (DescriptionMLU == NULL || CopyrightMLU == NULL) goto Error;
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[346]) {
+      if ((DescriptionMLU == (void *) 0 || CopyrightMLU == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 346\n");
+      else
+        fprintf(stderr, "reached bug index 346\n");
+    }
+    if ((!FIXREVERTER[346] && (DescriptionMLU == (void *) 0 || CopyrightMLU == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) goto Error;
+    #ifdef FRCOV
+    }
+    #endif
 
     if (!cmsMLUsetWide(DescriptionMLU,  "en", "US", Description)) goto Error;
     if (!cmsMLUsetWide(CopyrightMLU,    "en", "US", L"No copyright, use freely")) goto Error;
@@ -477,7 +496,22 @@ cmsHPROFILE CMSEXPORT cmsCreateLab2ProfileTHR(cmsContext ContextID, const cmsCIE
     cmsPipeline* LUT = NULL;
 
     hProfile = cmsCreateRGBProfileTHR(ContextID, WhitePoint == NULL ? cmsD50_xyY() : WhitePoint, NULL, NULL);
-    if (hProfile == NULL) return NULL;
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[351]) {
+      if ((hProfile == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 351\n");
+      else
+        fprintf(stderr, "reached bug index 351\n");
+    }
+    if ((!FIXREVERTER[351] && (hProfile == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) return NULL;
+    #ifdef FRCOV
+    }
+    #endif
 
     cmsSetProfileVersion(hProfile, 2.1);
 
@@ -489,7 +523,22 @@ cmsHPROFILE CMSEXPORT cmsCreateLab2ProfileTHR(cmsContext ContextID, const cmsCIE
 
     // An identity LUT is all we need
     LUT = cmsPipelineAlloc(ContextID, 3, 3);
-    if (LUT == NULL) goto Error;
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[352]) {
+      if ((LUT == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 352\n");
+      else
+        fprintf(stderr, "reached bug index 352\n");
+    }
+    if ((!FIXREVERTER[352] && (LUT == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) goto Error;
+    #ifdef FRCOV
+    }
+    #endif
 
     if (!cmsPipelineInsertStage(LUT, cmsAT_BEGIN, _cmsStageAllocIdentityCLut(ContextID, 3)))
         goto Error;
@@ -524,7 +573,22 @@ cmsHPROFILE CMSEXPORT cmsCreateLab4ProfileTHR(cmsContext ContextID, const cmsCIE
     cmsPipeline* LUT = NULL;
 
     hProfile = cmsCreateRGBProfileTHR(ContextID, WhitePoint == NULL ? cmsD50_xyY() : WhitePoint, NULL, NULL);
-    if (hProfile == NULL) return NULL;
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[353]) {
+      if ((hProfile == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 353\n");
+      else
+        fprintf(stderr, "reached bug index 353\n");
+    }
+    if ((!FIXREVERTER[353] && (hProfile == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) return NULL;
+    #ifdef FRCOV
+    }
+    #endif
 
     cmsSetProfileVersion(hProfile, 4.3);
 
@@ -536,7 +600,22 @@ cmsHPROFILE CMSEXPORT cmsCreateLab4ProfileTHR(cmsContext ContextID, const cmsCIE
 
     // An empty LUTs is all we need
     LUT = cmsPipelineAlloc(ContextID, 3, 3);
-    if (LUT == NULL) goto Error;
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[354]) {
+      if ((LUT == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 354\n");
+      else
+        fprintf(stderr, "reached bug index 354\n");
+    }
+    if ((!FIXREVERTER[354] && (LUT == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) goto Error;
+    #ifdef FRCOV
+    }
+    #endif
 
     if (!cmsPipelineInsertStage(LUT, cmsAT_BEGIN, _cmsStageAllocIdentityCurves(ContextID, 3)))
         goto Error;
@@ -657,7 +736,22 @@ cmsHPROFILE CMSEXPORT cmsCreate_sRGBProfileTHR(cmsContext ContextID)
 
        hsRGB = cmsCreateRGBProfileTHR(ContextID, &D65, &Rec709Primaries, Gamma22);
        cmsFreeToneCurve(Gamma22[0]);
-       if (hsRGB == NULL) return NULL;
+       
+       #ifdef FRCOV
+       {if (FIXREVERTER[357]) {
+         if ((hsRGB == (void *) 0 ) && !(0))
+           fprintf(stderr, "triggered bug index 357\n");
+         else
+           fprintf(stderr, "reached bug index 357\n");
+       }
+       if ((!FIXREVERTER[357] && (hsRGB == (void *) 0 ))
+       #else
+       if (0
+       #endif
+       ) return NULL;
+       #ifdef FRCOV
+       }
+       #endif
 
        if (!SetTextTags(hsRGB, L"sRGB built-in")) {
            cmsCloseProfile(hsRGB);
diff --git a/src/cmsxform.c b/src/cmsxform.c
index ff56d95..2d83f1b 100644
--- a/src/cmsxform.c
+++ b/src/cmsxform.c
@@ -1,3 +1,7 @@
+#ifdef FRCOV
+#include <stdio.h>
+extern short FIXREVERTER[];
+#endif
 //---------------------------------------------------------------------------------
 //
 //  Little Color Management System
@@ -827,12 +831,27 @@ _cmsTRANSFORM* AllocEmptyTransform(cmsContext ContextID, cmsPipeline* lut,
         p ->ToOutputFloat  = _cmsGetFormatter(ContextID, *OutputFormat, cmsFormatterOutput, CMS_PACK_FLAGS_FLOAT).FmtFloat;
         *dwFlags |= cmsFLAGS_CAN_CHANGE_FORMATTER;
 
-        if (p ->FromInputFloat == NULL || p ->ToOutputFloat == NULL) {
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[327]) {
+          if ((p -> FromInputFloat == (void *) 0 || p -> ToOutputFloat == (void *) 0 ) && !(0))
+            fprintf(stderr, "triggered bug index 327\n");
+          else
+            fprintf(stderr, "reached bug index 327\n");
+        }
+        if ((!FIXREVERTER[327] && (p -> FromInputFloat == (void *) 0 || p -> ToOutputFloat == (void *) 0 ))
+        #else
+        if (0
+        #endif
+        ) {
 
             cmsSignalError(ContextID, cmsERROR_UNKNOWN_EXTENSION, "Unsupported raster format");
             cmsDeleteTransform(p);
             return NULL;
         }
+        #ifdef FRCOV
+        }
+        #endif
 
         if (*dwFlags & cmsFLAGS_NULLTRANSFORM) {
 
@@ -857,12 +876,27 @@ _cmsTRANSFORM* AllocEmptyTransform(cmsContext ContextID, cmsPipeline* lut,
             p ->FromInput = _cmsGetFormatter(ContextID, *InputFormat,  cmsFormatterInput, CMS_PACK_FLAGS_16BITS).Fmt16;
             p ->ToOutput  = _cmsGetFormatter(ContextID, *OutputFormat, cmsFormatterOutput, CMS_PACK_FLAGS_16BITS).Fmt16;
 
-            if (p ->FromInput == NULL || p ->ToOutput == NULL) {
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[328]) {
+              if ((p -> FromInput == (void *) 0 || p -> ToOutput == (void *) 0 ) && !(0))
+                fprintf(stderr, "triggered bug index 328\n");
+              else
+                fprintf(stderr, "reached bug index 328\n");
+            }
+            if ((!FIXREVERTER[328] && (p -> FromInput == (void *) 0 || p -> ToOutput == (void *) 0 ))
+            #else
+            if (0
+            #endif
+            ) {
 
                 cmsSignalError(ContextID, cmsERROR_UNKNOWN_EXTENSION, "Unsupported raster format");
                 cmsDeleteTransform(p);
                 return NULL;
             }
+            #ifdef FRCOV
+            }
+            #endif
 
             BytesPerPixelInput = T_BYTES(p ->InputFormat);
             if (BytesPerPixelInput == 0 || BytesPerPixelInput >= 2)
@@ -921,7 +955,22 @@ cmsBool GetXFormColorSpaces(int nProfiles, cmsHPROFILE hProfiles[], cmsColorSpac
         int lIsInput = (PostColorSpace != cmsSigXYZData) &&
                        (PostColorSpace != cmsSigLabData);
 
-        if (hProfile == NULL) return FALSE;
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[330]) {
+          if ((hProfile == (void *) 0 ) && !(0))
+            fprintf(stderr, "triggered bug index 330\n");
+          else
+            fprintf(stderr, "reached bug index 330\n");
+        }
+        if ((!FIXREVERTER[330] && (hProfile == (void *) 0 ))
+        #else
+        if (0
+        #endif
+        ) return FALSE;
+        #ifdef FRCOV
+        }
+        #endif
 
         cls = cmsGetDeviceClass(hProfile);
 
@@ -1073,9 +1122,24 @@ cmsHTRANSFORM CMSEXPORT cmsCreateExtendedTransform(cmsContext ContextID,
 
     // All seems ok
     xform = AllocEmptyTransform(ContextID, Lut, LastIntent, &InputFormat, &OutputFormat, &dwFlags);
-    if (xform == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[334]) {
+      if ((xform == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 334\n");
+      else
+        fprintf(stderr, "reached bug index 334\n");
+    }
+    if ((!FIXREVERTER[334] && (xform == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         return NULL;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
     // Keep values
     xform ->EntryColorSpace = EntryColorSpace;
@@ -1160,10 +1224,25 @@ cmsHTRANSFORM CMSEXPORT cmsCreateMultiprofileTransformTHR(cmsContext ContextID,
     cmsUInt32Number Intents[256];
     cmsFloat64Number AdaptationStates[256];
 
-    if (nProfiles <= 0 || nProfiles > 255) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[335]) {
+      if ((nProfiles <= 0 || nProfiles > 255 ) && !(0))
+        fprintf(stderr, "triggered bug index 335\n");
+      else
+        fprintf(stderr, "reached bug index 335\n");
+    }
+    if ((!FIXREVERTER[335] && (nProfiles <= 0 || nProfiles > 255 ))
+    #else
+    if (0
+    #endif
+    ) {
          cmsSignalError(ContextID, cmsERROR_RANGE, "Wrong number of profiles. 1..255 expected, %d found.", nProfiles);
         return NULL;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
     for (i=0; i < nProfiles; i++) {
         BPC[i] = dwFlags & cmsFLAGS_BLACKPOINTCOMPENSATION ? TRUE : FALSE;
diff --git a/testbed/Makefile.in b/testbed/Makefile.in
index 27196eb..2b2c8df 100644
--- a/testbed/Makefile.in
+++ b/testbed/Makefile.in
@@ -1,7 +1,7 @@
-# Makefile.in generated by automake 1.14.1 from Makefile.am.
+# Makefile.in generated by automake 1.16.1 from Makefile.am.
 # @configure_input@
 
-# Copyright (C) 1994-2013 Free Software Foundation, Inc.
+# Copyright (C) 1994-2018 Free Software Foundation, Inc.
 
 # This Makefile.in is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
@@ -18,7 +18,17 @@
 # Makefile for building testcms
 #
 VPATH = @srcdir@
-am__is_gnu_make = test -n '$(MAKEFILE_LIST)' && test -n '$(MAKELEVEL)'
+am__is_gnu_make = { \
+  if test -z '$(MAKELEVEL)'; then \
+    false; \
+  elif test -n '$(MAKE_HOST)'; then \
+    true; \
+  elif test -n '$(MAKE_VERSION)' && test -n '$(CURDIR)'; then \
+    true; \
+  else \
+    false; \
+  fi; \
+}
 am__make_running_with_option = \
   case $${target_option-} in \
       ?) ;; \
@@ -83,15 +93,19 @@ build_triplet = @build@
 host_triplet = @host@
 check_PROGRAMS = testcms$(EXEEXT)
 subdir = testbed
-DIST_COMMON = $(srcdir)/Makefile.in $(srcdir)/Makefile.am \
-	$(top_srcdir)/depcomp
 ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
 am__aclocal_m4_deps = $(top_srcdir)/m4/acx_pthread.m4 \
+	$(top_srcdir)/m4/ax_append_compile_flags.m4 \
+	$(top_srcdir)/m4/ax_append_flag.m4 \
+	$(top_srcdir)/m4/ax_check_compile_flag.m4 \
+	$(top_srcdir)/m4/ax_gcc_func_attribute.m4 \
+	$(top_srcdir)/m4/ax_require_defined.m4 \
 	$(top_srcdir)/m4/libtool.m4 $(top_srcdir)/m4/ltoptions.m4 \
 	$(top_srcdir)/m4/ltsugar.m4 $(top_srcdir)/m4/ltversion.m4 \
 	$(top_srcdir)/m4/lt~obsolete.m4 $(top_srcdir)/configure.ac
 am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
 	$(ACLOCAL_M4)
+DIST_COMMON = $(srcdir)/Makefile.am $(am__DIST_COMMON)
 mkinstalldirs = $(install_sh) -d
 CONFIG_CLEAN_FILES =
 CONFIG_CLEAN_VPATH_FILES =
@@ -120,7 +134,9 @@ am__v_at_0 = @
 am__v_at_1 = 
 DEFAULT_INCLUDES = -I.@am__isrc@
 depcomp = $(SHELL) $(top_srcdir)/depcomp
-am__depfiles_maybe = depfiles
+am__maybe_remake_depfiles = depfiles
+am__depfiles_remade = ./$(DEPDIR)/testcms2.Po \
+	./$(DEPDIR)/testplugin.Po ./$(DEPDIR)/zoo_icc.Po
 am__mv = mv -f
 COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \
 	$(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
@@ -166,6 +182,7 @@ am__define_uniq_tagged_files = \
   done | $(am__uniquify_input)`
 ETAGS = etags
 CTAGS = ctags
+am__DIST_COMMON = $(srcdir)/Makefile.in $(top_srcdir)/depcomp
 DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
 ACLOCAL = @ACLOCAL@
 AMTAR = @AMTAR@
@@ -298,6 +315,7 @@ pdfdir = @pdfdir@
 prefix = @prefix@
 program_transform_name = @program_transform_name@
 psdir = @psdir@
+runstatedir = @runstatedir@
 sbindir = @sbindir@
 sharedstatedir = @sharedstatedir@
 srcdir = @srcdir@
@@ -312,8 +330,12 @@ AUTOMAKE_OPTIONS = 1.7 foreign
 AM_CPPFLAGS = -I$(top_builddir)/include -I$(top_srcdir)/include -I$(top_srcdir)/src
 
 # CFLAGS = --pedantic -Wall -std=c99 -O2
+
+# The testsuite binary is statically linked. This is necessary as it uses some
+# of the internal funtions that are not necessarily exported by the shared
+# library.
 testcms_LDADD = $(top_builddir)/src/liblcms2.la 
-testcms_LDFLAGS = @LDFLAGS@
+testcms_LDFLAGS = -static @LDFLAGS@
 testcms_SOURCES = testcms2.c testplugin.c zoo_icc.c testcms2.h
 EXTRA_DIST = test1.icc bad.icc toosmall.icc test2.icc \
              test3.icc test4.icc \
@@ -335,14 +357,13 @@ $(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ $(srcdir)/Makefile.am  $(am__confi
 	echo ' cd $(top_srcdir) && $(AUTOMAKE) --foreign testbed/Makefile'; \
 	$(am__cd) $(top_srcdir) && \
 	  $(AUTOMAKE) --foreign testbed/Makefile
-.PRECIOUS: Makefile
 Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
 	@case '$?' in \
 	  *config.status*) \
 	    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \
 	  *) \
-	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \
-	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \
+	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__maybe_remake_depfiles)'; \
+	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__maybe_remake_depfiles);; \
 	esac;
 
 $(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
@@ -373,9 +394,15 @@ mostlyclean-compile:
 distclean-compile:
 	-rm -f *.tab.c
 
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/testcms2.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/testplugin.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/zoo_icc.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/testcms2.Po@am__quote@ # am--include-marker
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/testplugin.Po@am__quote@ # am--include-marker
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/zoo_icc.Po@am__quote@ # am--include-marker
+
+$(am__depfiles_remade):
+	@$(MKDIR_P) $(@D)
+	@echo '# dummy' >$@-t && $(am__mv) $@-t $@
+
+am--depfiles: $(am__depfiles_remade)
 
 .c.o:
 @am__fastdepCC_TRUE@	$(AM_V_CC)depbase=`echo $@ | sed 's|[^/]*$$|$(DEPDIR)/&|;s|\.o$$||'`;\
@@ -459,7 +486,10 @@ cscopelist-am: $(am__tagged_files)
 distclean-tags:
 	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
 
-distdir: $(DISTFILES)
+distdir: $(BUILT_SOURCES)
+	$(MAKE) $(AM_MAKEFLAGS) distdir-am
+
+distdir-am: $(DISTFILES)
 	@srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
 	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
 	list='$(DISTFILES)'; \
@@ -530,7 +560,9 @@ clean-am: clean-checkPROGRAMS clean-generic clean-libtool \
 	mostlyclean-am
 
 distclean: distclean-am
-	-rm -rf ./$(DEPDIR)
+		-rm -f ./$(DEPDIR)/testcms2.Po
+	-rm -f ./$(DEPDIR)/testplugin.Po
+	-rm -f ./$(DEPDIR)/zoo_icc.Po
 	-rm -f Makefile
 distclean-am: clean-am distclean-compile distclean-generic \
 	distclean-tags
@@ -576,7 +608,9 @@ install-ps-am:
 installcheck-am:
 
 maintainer-clean: maintainer-clean-am
-	-rm -rf ./$(DEPDIR)
+		-rm -f ./$(DEPDIR)/testcms2.Po
+	-rm -f ./$(DEPDIR)/testplugin.Po
+	-rm -f ./$(DEPDIR)/zoo_icc.Po
 	-rm -f Makefile
 maintainer-clean-am: distclean-am maintainer-clean-generic
 
@@ -597,7 +631,7 @@ uninstall-am:
 
 .MAKE: check-am install-am install-strip
 
-.PHONY: CTAGS GTAGS TAGS all all-am check check-am clean \
+.PHONY: CTAGS GTAGS TAGS all all-am am--depfiles check check-am clean \
 	clean-checkPROGRAMS clean-generic clean-libtool cscopelist-am \
 	ctags ctags-am distclean distclean-compile distclean-generic \
 	distclean-libtool distclean-tags distdir dvi dvi-am html \
@@ -611,6 +645,8 @@ uninstall-am:
 	mostlyclean-generic mostlyclean-libtool pdf pdf-am ps ps-am \
 	tags tags-am uninstall uninstall-am
 
+.PRECIOUS: Makefile
+
 
 check:
 	if [ $(top_srcdir) != $(top_builddir) ]; then \
diff --git a/utils/jpgicc/Makefile.in b/utils/jpgicc/Makefile.in
index e498808..568e90e 100644
--- a/utils/jpgicc/Makefile.in
+++ b/utils/jpgicc/Makefile.in
@@ -1,7 +1,7 @@
-# Makefile.in generated by automake 1.14.1 from Makefile.am.
+# Makefile.in generated by automake 1.16.1 from Makefile.am.
 # @configure_input@
 
-# Copyright (C) 1994-2013 Free Software Foundation, Inc.
+# Copyright (C) 1994-2018 Free Software Foundation, Inc.
 
 # This Makefile.in is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
@@ -20,7 +20,17 @@
 # Bugs introduced by Marti Maria on October 2004
 
 VPATH = @srcdir@
-am__is_gnu_make = test -n '$(MAKEFILE_LIST)' && test -n '$(MAKELEVEL)'
+am__is_gnu_make = { \
+  if test -z '$(MAKELEVEL)'; then \
+    false; \
+  elif test -n '$(MAKE_HOST)'; then \
+    true; \
+  elif test -n '$(MAKE_VERSION)' && test -n '$(CURDIR)'; then \
+    true; \
+  else \
+    false; \
+  fi; \
+}
 am__make_running_with_option = \
   case $${target_option-} in \
       ?) ;; \
@@ -85,14 +95,19 @@ build_triplet = @build@
 host_triplet = @host@
 @HasJPEG_TRUE@bin_PROGRAMS = jpgicc$(EXEEXT)
 subdir = utils/jpgicc
-DIST_COMMON = $(srcdir)/Makefile.in $(srcdir)/Makefile.am
 ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
 am__aclocal_m4_deps = $(top_srcdir)/m4/acx_pthread.m4 \
+	$(top_srcdir)/m4/ax_append_compile_flags.m4 \
+	$(top_srcdir)/m4/ax_append_flag.m4 \
+	$(top_srcdir)/m4/ax_check_compile_flag.m4 \
+	$(top_srcdir)/m4/ax_gcc_func_attribute.m4 \
+	$(top_srcdir)/m4/ax_require_defined.m4 \
 	$(top_srcdir)/m4/libtool.m4 $(top_srcdir)/m4/ltoptions.m4 \
 	$(top_srcdir)/m4/ltsugar.m4 $(top_srcdir)/m4/ltversion.m4 \
 	$(top_srcdir)/m4/lt~obsolete.m4 $(top_srcdir)/configure.ac
 am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
 	$(ACLOCAL_M4)
+DIST_COMMON = $(srcdir)/Makefile.am $(am__DIST_COMMON)
 mkinstalldirs = $(install_sh) -d
 CONFIG_CLEAN_FILES =
 CONFIG_CLEAN_VPATH_FILES =
@@ -124,7 +139,7 @@ am__v_at_0 = @
 am__v_at_1 = 
 DEFAULT_INCLUDES = -I.@am__isrc@
 depcomp =
-am__depfiles_maybe =
+am__maybe_remake_depfiles =
 COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \
 	$(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
 LTCOMPILE = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \
@@ -199,6 +214,7 @@ am__define_uniq_tagged_files = \
   done | $(am__uniquify_input)`
 ETAGS = etags
 CTAGS = ctags
+am__DIST_COMMON = $(srcdir)/Makefile.in
 DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
 ACLOCAL = @ACLOCAL@
 AMTAR = @AMTAR@
@@ -331,6 +347,7 @@ pdfdir = @pdfdir@
 prefix = @prefix@
 program_transform_name = @program_transform_name@
 psdir = @psdir@
+runstatedir = @runstatedir@
 sbindir = @sbindir@
 sharedstatedir = @sharedstatedir@
 srcdir = @srcdir@
@@ -366,14 +383,13 @@ $(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ $(srcdir)/Makefile.am  $(am__confi
 	echo ' cd $(top_srcdir) && $(AUTOMAKE) --foreign utils/jpgicc/Makefile'; \
 	$(am__cd) $(top_srcdir) && \
 	  $(AUTOMAKE) --foreign utils/jpgicc/Makefile
-.PRECIOUS: Makefile
 Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
 	@case '$?' in \
 	  *config.status*) \
 	    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \
 	  *) \
-	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \
-	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \
+	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__maybe_remake_depfiles)'; \
+	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__maybe_remake_depfiles);; \
 	esac;
 
 $(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
@@ -560,7 +576,10 @@ cscopelist-am: $(am__tagged_files)
 distclean-tags:
 	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
 
-distdir: $(DISTFILES)
+distdir: $(BUILT_SOURCES)
+	$(MAKE) $(AM_MAKEFLAGS) distdir-am
+
+distdir-am: $(DISTFILES)
 	@srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
 	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
 	list='$(DISTFILES)'; \
@@ -715,6 +734,8 @@ uninstall-man: uninstall-man1
 	pdf pdf-am ps ps-am tags tags-am uninstall uninstall-am \
 	uninstall-binPROGRAMS uninstall-man uninstall-man1
 
+.PRECIOUS: Makefile
+
 
 # Tell versions [3.59,3.63) of GNU make to not export all variables.
 # Otherwise a system limit (for SysV at least) may be exceeded.
diff --git a/utils/linkicc/Makefile.in b/utils/linkicc/Makefile.in
index 768d52b..7329a52 100644
--- a/utils/linkicc/Makefile.in
+++ b/utils/linkicc/Makefile.in
@@ -1,7 +1,7 @@
-# Makefile.in generated by automake 1.14.1 from Makefile.am.
+# Makefile.in generated by automake 1.16.1 from Makefile.am.
 # @configure_input@
 
-# Copyright (C) 1994-2013 Free Software Foundation, Inc.
+# Copyright (C) 1994-2018 Free Software Foundation, Inc.
 
 # This Makefile.in is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
@@ -20,7 +20,17 @@
 # Additions and bugs by Marti Maria 
 
 VPATH = @srcdir@
-am__is_gnu_make = test -n '$(MAKEFILE_LIST)' && test -n '$(MAKELEVEL)'
+am__is_gnu_make = { \
+  if test -z '$(MAKELEVEL)'; then \
+    false; \
+  elif test -n '$(MAKE_HOST)'; then \
+    true; \
+  elif test -n '$(MAKE_VERSION)' && test -n '$(CURDIR)'; then \
+    true; \
+  else \
+    false; \
+  fi; \
+}
 am__make_running_with_option = \
   case $${target_option-} in \
       ?) ;; \
@@ -85,14 +95,19 @@ build_triplet = @build@
 host_triplet = @host@
 bin_PROGRAMS = linkicc$(EXEEXT)
 subdir = utils/linkicc
-DIST_COMMON = $(srcdir)/Makefile.in $(srcdir)/Makefile.am
 ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
 am__aclocal_m4_deps = $(top_srcdir)/m4/acx_pthread.m4 \
+	$(top_srcdir)/m4/ax_append_compile_flags.m4 \
+	$(top_srcdir)/m4/ax_append_flag.m4 \
+	$(top_srcdir)/m4/ax_check_compile_flag.m4 \
+	$(top_srcdir)/m4/ax_gcc_func_attribute.m4 \
+	$(top_srcdir)/m4/ax_require_defined.m4 \
 	$(top_srcdir)/m4/libtool.m4 $(top_srcdir)/m4/ltoptions.m4 \
 	$(top_srcdir)/m4/ltsugar.m4 $(top_srcdir)/m4/ltversion.m4 \
 	$(top_srcdir)/m4/lt~obsolete.m4 $(top_srcdir)/configure.ac
 am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
 	$(ACLOCAL_M4)
+DIST_COMMON = $(srcdir)/Makefile.am $(am__DIST_COMMON)
 mkinstalldirs = $(install_sh) -d
 CONFIG_CLEAN_FILES =
 CONFIG_CLEAN_VPATH_FILES =
@@ -124,7 +139,7 @@ am__v_at_0 = @
 am__v_at_1 = 
 DEFAULT_INCLUDES = -I.@am__isrc@
 depcomp =
-am__depfiles_maybe =
+am__maybe_remake_depfiles =
 COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \
 	$(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
 LTCOMPILE = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \
@@ -169,6 +184,7 @@ am__define_uniq_tagged_files = \
   done | $(am__uniquify_input)`
 ETAGS = etags
 CTAGS = ctags
+am__DIST_COMMON = $(srcdir)/Makefile.in
 DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
 ACLOCAL = @ACLOCAL@
 AMTAR = @AMTAR@
@@ -301,6 +317,7 @@ pdfdir = @pdfdir@
 prefix = @prefix@
 program_transform_name = @program_transform_name@
 psdir = @psdir@
+runstatedir = @runstatedir@
 sbindir = @sbindir@
 sharedstatedir = @sharedstatedir@
 srcdir = @srcdir@
@@ -336,14 +353,13 @@ $(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ $(srcdir)/Makefile.am  $(am__confi
 	echo ' cd $(top_srcdir) && $(AUTOMAKE) --foreign utils/linkicc/Makefile'; \
 	$(am__cd) $(top_srcdir) && \
 	  $(AUTOMAKE) --foreign utils/linkicc/Makefile
-.PRECIOUS: Makefile
 Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
 	@case '$?' in \
 	  *config.status*) \
 	    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \
 	  *) \
-	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \
-	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \
+	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__maybe_remake_depfiles)'; \
+	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__maybe_remake_depfiles);; \
 	esac;
 
 $(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
@@ -487,7 +503,10 @@ cscopelist-am: $(am__tagged_files)
 distclean-tags:
 	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
 
-distdir: $(DISTFILES)
+distdir: $(BUILT_SOURCES)
+	$(MAKE) $(AM_MAKEFLAGS) distdir-am
+
+distdir-am: $(DISTFILES)
 	@srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
 	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
 	list='$(DISTFILES)'; \
@@ -639,6 +658,8 @@ uninstall-am: uninstall-binPROGRAMS
 	mostlyclean-generic mostlyclean-libtool pdf pdf-am ps ps-am \
 	tags tags-am uninstall uninstall-am uninstall-binPROGRAMS
 
+.PRECIOUS: Makefile
+
 
 # Tell versions [3.59,3.63) of GNU make to not export all variables.
 # Otherwise a system limit (for SysV at least) may be exceeded.
diff --git a/utils/psicc/Makefile.in b/utils/psicc/Makefile.in
index e7101a7..f3811ad 100644
--- a/utils/psicc/Makefile.in
+++ b/utils/psicc/Makefile.in
@@ -1,7 +1,7 @@
-# Makefile.in generated by automake 1.14.1 from Makefile.am.
+# Makefile.in generated by automake 1.16.1 from Makefile.am.
 # @configure_input@
 
-# Copyright (C) 1994-2013 Free Software Foundation, Inc.
+# Copyright (C) 1994-2018 Free Software Foundation, Inc.
 
 # This Makefile.in is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
@@ -20,7 +20,17 @@
 # Additions and bugs by Marti Maria 
 
 VPATH = @srcdir@
-am__is_gnu_make = test -n '$(MAKEFILE_LIST)' && test -n '$(MAKELEVEL)'
+am__is_gnu_make = { \
+  if test -z '$(MAKELEVEL)'; then \
+    false; \
+  elif test -n '$(MAKE_HOST)'; then \
+    true; \
+  elif test -n '$(MAKE_VERSION)' && test -n '$(CURDIR)'; then \
+    true; \
+  else \
+    false; \
+  fi; \
+}
 am__make_running_with_option = \
   case $${target_option-} in \
       ?) ;; \
@@ -85,14 +95,19 @@ build_triplet = @build@
 host_triplet = @host@
 bin_PROGRAMS = psicc$(EXEEXT)
 subdir = utils/psicc
-DIST_COMMON = $(srcdir)/Makefile.in $(srcdir)/Makefile.am
 ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
 am__aclocal_m4_deps = $(top_srcdir)/m4/acx_pthread.m4 \
+	$(top_srcdir)/m4/ax_append_compile_flags.m4 \
+	$(top_srcdir)/m4/ax_append_flag.m4 \
+	$(top_srcdir)/m4/ax_check_compile_flag.m4 \
+	$(top_srcdir)/m4/ax_gcc_func_attribute.m4 \
+	$(top_srcdir)/m4/ax_require_defined.m4 \
 	$(top_srcdir)/m4/libtool.m4 $(top_srcdir)/m4/ltoptions.m4 \
 	$(top_srcdir)/m4/ltsugar.m4 $(top_srcdir)/m4/ltversion.m4 \
 	$(top_srcdir)/m4/lt~obsolete.m4 $(top_srcdir)/configure.ac
 am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
 	$(ACLOCAL_M4)
+DIST_COMMON = $(srcdir)/Makefile.am $(am__DIST_COMMON)
 mkinstalldirs = $(install_sh) -d
 CONFIG_CLEAN_FILES =
 CONFIG_CLEAN_VPATH_FILES =
@@ -124,7 +139,7 @@ am__v_at_0 = @
 am__v_at_1 = 
 DEFAULT_INCLUDES = -I.@am__isrc@
 depcomp =
-am__depfiles_maybe =
+am__maybe_remake_depfiles =
 COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \
 	$(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
 LTCOMPILE = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \
@@ -169,6 +184,7 @@ am__define_uniq_tagged_files = \
   done | $(am__uniquify_input)`
 ETAGS = etags
 CTAGS = ctags
+am__DIST_COMMON = $(srcdir)/Makefile.in
 DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
 ACLOCAL = @ACLOCAL@
 AMTAR = @AMTAR@
@@ -301,6 +317,7 @@ pdfdir = @pdfdir@
 prefix = @prefix@
 program_transform_name = @program_transform_name@
 psdir = @psdir@
+runstatedir = @runstatedir@
 sbindir = @sbindir@
 sharedstatedir = @sharedstatedir@
 srcdir = @srcdir@
@@ -336,14 +353,13 @@ $(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ $(srcdir)/Makefile.am  $(am__confi
 	echo ' cd $(top_srcdir) && $(AUTOMAKE) --foreign utils/psicc/Makefile'; \
 	$(am__cd) $(top_srcdir) && \
 	  $(AUTOMAKE) --foreign utils/psicc/Makefile
-.PRECIOUS: Makefile
 Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
 	@case '$?' in \
 	  *config.status*) \
 	    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \
 	  *) \
-	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \
-	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \
+	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__maybe_remake_depfiles)'; \
+	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__maybe_remake_depfiles);; \
 	esac;
 
 $(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
@@ -487,7 +503,10 @@ cscopelist-am: $(am__tagged_files)
 distclean-tags:
 	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
 
-distdir: $(DISTFILES)
+distdir: $(BUILT_SOURCES)
+	$(MAKE) $(AM_MAKEFLAGS) distdir-am
+
+distdir-am: $(DISTFILES)
 	@srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
 	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
 	list='$(DISTFILES)'; \
@@ -639,6 +658,8 @@ uninstall-am: uninstall-binPROGRAMS
 	mostlyclean-generic mostlyclean-libtool pdf pdf-am ps ps-am \
 	tags tags-am uninstall uninstall-am uninstall-binPROGRAMS
 
+.PRECIOUS: Makefile
+
 
 # Tell versions [3.59,3.63) of GNU make to not export all variables.
 # Otherwise a system limit (for SysV at least) may be exceeded.
diff --git a/utils/tificc/Makefile.in b/utils/tificc/Makefile.in
index f0ca903..8c83abf 100644
--- a/utils/tificc/Makefile.in
+++ b/utils/tificc/Makefile.in
@@ -1,7 +1,7 @@
-# Makefile.in generated by automake 1.14.1 from Makefile.am.
+# Makefile.in generated by automake 1.16.1 from Makefile.am.
 # @configure_input@
 
-# Copyright (C) 1994-2013 Free Software Foundation, Inc.
+# Copyright (C) 1994-2018 Free Software Foundation, Inc.
 
 # This Makefile.in is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
@@ -20,7 +20,17 @@
 # bugs introduced by Marti Maria 
 
 VPATH = @srcdir@
-am__is_gnu_make = test -n '$(MAKEFILE_LIST)' && test -n '$(MAKELEVEL)'
+am__is_gnu_make = { \
+  if test -z '$(MAKELEVEL)'; then \
+    false; \
+  elif test -n '$(MAKE_HOST)'; then \
+    true; \
+  elif test -n '$(MAKE_VERSION)' && test -n '$(CURDIR)'; then \
+    true; \
+  else \
+    false; \
+  fi; \
+}
 am__make_running_with_option = \
   case $${target_option-} in \
       ?) ;; \
@@ -85,14 +95,19 @@ build_triplet = @build@
 host_triplet = @host@
 @HasTIFF_TRUE@bin_PROGRAMS = tificc$(EXEEXT)
 subdir = utils/tificc
-DIST_COMMON = $(srcdir)/Makefile.in $(srcdir)/Makefile.am
 ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
 am__aclocal_m4_deps = $(top_srcdir)/m4/acx_pthread.m4 \
+	$(top_srcdir)/m4/ax_append_compile_flags.m4 \
+	$(top_srcdir)/m4/ax_append_flag.m4 \
+	$(top_srcdir)/m4/ax_check_compile_flag.m4 \
+	$(top_srcdir)/m4/ax_gcc_func_attribute.m4 \
+	$(top_srcdir)/m4/ax_require_defined.m4 \
 	$(top_srcdir)/m4/libtool.m4 $(top_srcdir)/m4/ltoptions.m4 \
 	$(top_srcdir)/m4/ltsugar.m4 $(top_srcdir)/m4/ltversion.m4 \
 	$(top_srcdir)/m4/lt~obsolete.m4 $(top_srcdir)/configure.ac
 am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
 	$(ACLOCAL_M4)
+DIST_COMMON = $(srcdir)/Makefile.am $(am__DIST_COMMON)
 mkinstalldirs = $(install_sh) -d
 CONFIG_CLEAN_FILES =
 CONFIG_CLEAN_VPATH_FILES =
@@ -124,7 +139,7 @@ am__v_at_0 = @
 am__v_at_1 = 
 DEFAULT_INCLUDES = -I.@am__isrc@
 depcomp =
-am__depfiles_maybe =
+am__maybe_remake_depfiles =
 COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \
 	$(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
 LTCOMPILE = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \
@@ -199,6 +214,7 @@ am__define_uniq_tagged_files = \
   done | $(am__uniquify_input)`
 ETAGS = etags
 CTAGS = ctags
+am__DIST_COMMON = $(srcdir)/Makefile.in
 DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
 ACLOCAL = @ACLOCAL@
 AMTAR = @AMTAR@
@@ -331,6 +347,7 @@ pdfdir = @pdfdir@
 prefix = @prefix@
 program_transform_name = @program_transform_name@
 psdir = @psdir@
+runstatedir = @runstatedir@
 sbindir = @sbindir@
 sharedstatedir = @sharedstatedir@
 srcdir = @srcdir@
@@ -366,14 +383,13 @@ $(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ $(srcdir)/Makefile.am  $(am__confi
 	echo ' cd $(top_srcdir) && $(AUTOMAKE) --foreign utils/tificc/Makefile'; \
 	$(am__cd) $(top_srcdir) && \
 	  $(AUTOMAKE) --foreign utils/tificc/Makefile
-.PRECIOUS: Makefile
 Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
 	@case '$?' in \
 	  *config.status*) \
 	    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \
 	  *) \
-	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \
-	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \
+	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__maybe_remake_depfiles)'; \
+	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__maybe_remake_depfiles);; \
 	esac;
 
 $(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
@@ -560,7 +576,10 @@ cscopelist-am: $(am__tagged_files)
 distclean-tags:
 	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
 
-distdir: $(DISTFILES)
+distdir: $(BUILT_SOURCES)
+	$(MAKE) $(AM_MAKEFLAGS) distdir-am
+
+distdir-am: $(DISTFILES)
 	@srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
 	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
 	list='$(DISTFILES)'; \
@@ -715,6 +734,8 @@ uninstall-man: uninstall-man1
 	pdf pdf-am ps ps-am tags tags-am uninstall uninstall-am \
 	uninstall-binPROGRAMS uninstall-man uninstall-man1
 
+.PRECIOUS: Makefile
+
 
 # Tell versions [3.59,3.63) of GNU make to not export all variables.
 # Otherwise a system limit (for SysV at least) may be exceeded.
diff --git a/utils/transicc/Makefile.in b/utils/transicc/Makefile.in
index 9c0fc00..cec8fe9 100644
--- a/utils/transicc/Makefile.in
+++ b/utils/transicc/Makefile.in
@@ -1,7 +1,7 @@
-# Makefile.in generated by automake 1.14.1 from Makefile.am.
+# Makefile.in generated by automake 1.16.1 from Makefile.am.
 # @configure_input@
 
-# Copyright (C) 1994-2013 Free Software Foundation, Inc.
+# Copyright (C) 1994-2018 Free Software Foundation, Inc.
 
 # This Makefile.in is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
@@ -20,7 +20,17 @@
 # Additions and bugs by Marti Maria 
 
 VPATH = @srcdir@
-am__is_gnu_make = test -n '$(MAKEFILE_LIST)' && test -n '$(MAKELEVEL)'
+am__is_gnu_make = { \
+  if test -z '$(MAKELEVEL)'; then \
+    false; \
+  elif test -n '$(MAKE_HOST)'; then \
+    true; \
+  elif test -n '$(MAKE_VERSION)' && test -n '$(CURDIR)'; then \
+    true; \
+  else \
+    false; \
+  fi; \
+}
 am__make_running_with_option = \
   case $${target_option-} in \
       ?) ;; \
@@ -85,14 +95,19 @@ build_triplet = @build@
 host_triplet = @host@
 bin_PROGRAMS = transicc$(EXEEXT)
 subdir = utils/transicc
-DIST_COMMON = $(srcdir)/Makefile.in $(srcdir)/Makefile.am
 ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
 am__aclocal_m4_deps = $(top_srcdir)/m4/acx_pthread.m4 \
+	$(top_srcdir)/m4/ax_append_compile_flags.m4 \
+	$(top_srcdir)/m4/ax_append_flag.m4 \
+	$(top_srcdir)/m4/ax_check_compile_flag.m4 \
+	$(top_srcdir)/m4/ax_gcc_func_attribute.m4 \
+	$(top_srcdir)/m4/ax_require_defined.m4 \
 	$(top_srcdir)/m4/libtool.m4 $(top_srcdir)/m4/ltoptions.m4 \
 	$(top_srcdir)/m4/ltsugar.m4 $(top_srcdir)/m4/ltversion.m4 \
 	$(top_srcdir)/m4/lt~obsolete.m4 $(top_srcdir)/configure.ac
 am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
 	$(ACLOCAL_M4)
+DIST_COMMON = $(srcdir)/Makefile.am $(am__DIST_COMMON)
 mkinstalldirs = $(install_sh) -d
 CONFIG_CLEAN_FILES =
 CONFIG_CLEAN_VPATH_FILES =
@@ -124,7 +139,7 @@ am__v_at_0 = @
 am__v_at_1 = 
 DEFAULT_INCLUDES = -I.@am__isrc@
 depcomp =
-am__depfiles_maybe =
+am__maybe_remake_depfiles =
 COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \
 	$(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
 LTCOMPILE = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \
@@ -169,6 +184,7 @@ am__define_uniq_tagged_files = \
   done | $(am__uniquify_input)`
 ETAGS = etags
 CTAGS = ctags
+am__DIST_COMMON = $(srcdir)/Makefile.in
 DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
 ACLOCAL = @ACLOCAL@
 AMTAR = @AMTAR@
@@ -301,6 +317,7 @@ pdfdir = @pdfdir@
 prefix = @prefix@
 program_transform_name = @program_transform_name@
 psdir = @psdir@
+runstatedir = @runstatedir@
 sbindir = @sbindir@
 sharedstatedir = @sharedstatedir@
 srcdir = @srcdir@
@@ -336,14 +353,13 @@ $(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ $(srcdir)/Makefile.am  $(am__confi
 	echo ' cd $(top_srcdir) && $(AUTOMAKE) --foreign utils/transicc/Makefile'; \
 	$(am__cd) $(top_srcdir) && \
 	  $(AUTOMAKE) --foreign utils/transicc/Makefile
-.PRECIOUS: Makefile
 Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
 	@case '$?' in \
 	  *config.status*) \
 	    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \
 	  *) \
-	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \
-	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \
+	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__maybe_remake_depfiles)'; \
+	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__maybe_remake_depfiles);; \
 	esac;
 
 $(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
@@ -487,7 +503,10 @@ cscopelist-am: $(am__tagged_files)
 distclean-tags:
 	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
 
-distdir: $(DISTFILES)
+distdir: $(BUILT_SOURCES)
+	$(MAKE) $(AM_MAKEFLAGS) distdir-am
+
+distdir-am: $(DISTFILES)
 	@srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
 	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
 	list='$(DISTFILES)'; \
@@ -639,6 +658,8 @@ uninstall-am: uninstall-binPROGRAMS
 	mostlyclean-generic mostlyclean-libtool pdf pdf-am ps ps-am \
 	tags tags-am uninstall uninstall-am uninstall-binPROGRAMS
 
+.PRECIOUS: Makefile
+
 
 # Tell versions [3.59,3.63) of GNU make to not export all variables.
 # Otherwise a system limit (for SysV at least) may be exceeded.
