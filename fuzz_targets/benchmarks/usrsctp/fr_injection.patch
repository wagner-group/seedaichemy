diff --git a/.gitignore b/.gitignore
old mode 100644
new mode 100755
diff --git a/CMakeLists.txt b/CMakeLists.txt
old mode 100644
new mode 100755
diff --git a/LICENSE.md b/LICENSE.md
old mode 100644
new mode 100755
diff --git a/Makefile.am b/Makefile.am
old mode 100644
new mode 100755
diff --git a/Makefile.nmake b/Makefile.nmake
old mode 100644
new mode 100755
diff --git a/Manual.md b/Manual.md
old mode 100644
new mode 100755
diff --git a/Manual.tex b/Manual.tex
old mode 100644
new mode 100755
diff --git a/README.md b/README.md
old mode 100644
new mode 100755
diff --git a/configure.ac b/configure.ac
old mode 100644
new mode 100755
diff --git a/fuzzer/CMakeLists.txt b/fuzzer/CMakeLists.txt
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/crash-0a63175dc6b51474dc08197431ec36d11db5e77b b/fuzzer/CORPUS_CONNECT/crash-0a63175dc6b51474dc08197431ec36d11db5e77b
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/crash-27ffd53d682a7908bf7569e32d904f049066b5d6 b/fuzzer/CORPUS_CONNECT/crash-27ffd53d682a7908bf7569e32d904f049066b5d6
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/data-1.bin b/fuzzer/CORPUS_CONNECT/data-1.bin
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/init-ack-1.bin b/fuzzer/CORPUS_CONNECT/init-ack-1.bin
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/leak-00bd871f5ce0596083fe8642c803c97f424b0c70 b/fuzzer/CORPUS_CONNECT/leak-00bd871f5ce0596083fe8642c803c97f424b0c70
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/shutdown-1.bin b/fuzzer/CORPUS_CONNECT/shutdown-1.bin
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/shutdown-ack-1.bin b/fuzzer/CORPUS_CONNECT/shutdown-ack-1.bin
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/shutdown-complete-1.bin b/fuzzer/CORPUS_CONNECT/shutdown-complete-1.bin
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/timeout-00b96dd43f1251438bb44daa0a5a24ae4df5bce5 b/fuzzer/CORPUS_CONNECT/timeout-00b96dd43f1251438bb44daa0a5a24ae4df5bce5
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-0-000000 b/fuzzer/CORPUS_CONNECT/tsctp-0-000000
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-0-000001 b/fuzzer/CORPUS_CONNECT/tsctp-0-000001
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-0-000002 b/fuzzer/CORPUS_CONNECT/tsctp-0-000002
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-0-000003 b/fuzzer/CORPUS_CONNECT/tsctp-0-000003
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-0-000004 b/fuzzer/CORPUS_CONNECT/tsctp-0-000004
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-0-000005 b/fuzzer/CORPUS_CONNECT/tsctp-0-000005
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-0-000006 b/fuzzer/CORPUS_CONNECT/tsctp-0-000006
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-0-000007 b/fuzzer/CORPUS_CONNECT/tsctp-0-000007
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-0-000008 b/fuzzer/CORPUS_CONNECT/tsctp-0-000008
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-0-000009 b/fuzzer/CORPUS_CONNECT/tsctp-0-000009
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-0-000010 b/fuzzer/CORPUS_CONNECT/tsctp-0-000010
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-0-000011 b/fuzzer/CORPUS_CONNECT/tsctp-0-000011
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-0-000012 b/fuzzer/CORPUS_CONNECT/tsctp-0-000012
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-0-000013 b/fuzzer/CORPUS_CONNECT/tsctp-0-000013
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-0-000014 b/fuzzer/CORPUS_CONNECT/tsctp-0-000014
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-0-000015 b/fuzzer/CORPUS_CONNECT/tsctp-0-000015
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-0-000016 b/fuzzer/CORPUS_CONNECT/tsctp-0-000016
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-0-000017 b/fuzzer/CORPUS_CONNECT/tsctp-0-000017
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-0-000018 b/fuzzer/CORPUS_CONNECT/tsctp-0-000018
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-0-000019 b/fuzzer/CORPUS_CONNECT/tsctp-0-000019
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-0-000020 b/fuzzer/CORPUS_CONNECT/tsctp-0-000020
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-0-000021 b/fuzzer/CORPUS_CONNECT/tsctp-0-000021
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-0-000022 b/fuzzer/CORPUS_CONNECT/tsctp-0-000022
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-0-000023 b/fuzzer/CORPUS_CONNECT/tsctp-0-000023
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-0-000024 b/fuzzer/CORPUS_CONNECT/tsctp-0-000024
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-0-000025 b/fuzzer/CORPUS_CONNECT/tsctp-0-000025
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-0-000026 b/fuzzer/CORPUS_CONNECT/tsctp-0-000026
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-0-000027 b/fuzzer/CORPUS_CONNECT/tsctp-0-000027
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-0-000028 b/fuzzer/CORPUS_CONNECT/tsctp-0-000028
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-0-000029 b/fuzzer/CORPUS_CONNECT/tsctp-0-000029
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-0-000030 b/fuzzer/CORPUS_CONNECT/tsctp-0-000030
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-0-000031 b/fuzzer/CORPUS_CONNECT/tsctp-0-000031
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-0-000032 b/fuzzer/CORPUS_CONNECT/tsctp-0-000032
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-0-000033 b/fuzzer/CORPUS_CONNECT/tsctp-0-000033
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-0-000034 b/fuzzer/CORPUS_CONNECT/tsctp-0-000034
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-0-000035 b/fuzzer/CORPUS_CONNECT/tsctp-0-000035
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-0-000036 b/fuzzer/CORPUS_CONNECT/tsctp-0-000036
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-0-000037 b/fuzzer/CORPUS_CONNECT/tsctp-0-000037
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-0-000038 b/fuzzer/CORPUS_CONNECT/tsctp-0-000038
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-0-000039 b/fuzzer/CORPUS_CONNECT/tsctp-0-000039
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-0-000040 b/fuzzer/CORPUS_CONNECT/tsctp-0-000040
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-0-000041 b/fuzzer/CORPUS_CONNECT/tsctp-0-000041
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-0-000042 b/fuzzer/CORPUS_CONNECT/tsctp-0-000042
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-0-000043 b/fuzzer/CORPUS_CONNECT/tsctp-0-000043
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-0-000044 b/fuzzer/CORPUS_CONNECT/tsctp-0-000044
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-0-000045 b/fuzzer/CORPUS_CONNECT/tsctp-0-000045
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-0-000046 b/fuzzer/CORPUS_CONNECT/tsctp-0-000046
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-0-000047 b/fuzzer/CORPUS_CONNECT/tsctp-0-000047
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-0-000048 b/fuzzer/CORPUS_CONNECT/tsctp-0-000048
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-0-000049 b/fuzzer/CORPUS_CONNECT/tsctp-0-000049
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-0-000050 b/fuzzer/CORPUS_CONNECT/tsctp-0-000050
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-0-000051 b/fuzzer/CORPUS_CONNECT/tsctp-0-000051
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-0-000052 b/fuzzer/CORPUS_CONNECT/tsctp-0-000052
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-0-000053 b/fuzzer/CORPUS_CONNECT/tsctp-0-000053
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-0-000054 b/fuzzer/CORPUS_CONNECT/tsctp-0-000054
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-0-000055 b/fuzzer/CORPUS_CONNECT/tsctp-0-000055
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-0-000056 b/fuzzer/CORPUS_CONNECT/tsctp-0-000056
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-0-000057 b/fuzzer/CORPUS_CONNECT/tsctp-0-000057
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-0-000058 b/fuzzer/CORPUS_CONNECT/tsctp-0-000058
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-0-000059 b/fuzzer/CORPUS_CONNECT/tsctp-0-000059
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-0-000060 b/fuzzer/CORPUS_CONNECT/tsctp-0-000060
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-0-000061 b/fuzzer/CORPUS_CONNECT/tsctp-0-000061
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-0-000062 b/fuzzer/CORPUS_CONNECT/tsctp-0-000062
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-0-000063 b/fuzzer/CORPUS_CONNECT/tsctp-0-000063
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-0-000064 b/fuzzer/CORPUS_CONNECT/tsctp-0-000064
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-0-000065 b/fuzzer/CORPUS_CONNECT/tsctp-0-000065
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-0-000066 b/fuzzer/CORPUS_CONNECT/tsctp-0-000066
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-0-000067 b/fuzzer/CORPUS_CONNECT/tsctp-0-000067
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-0-000068 b/fuzzer/CORPUS_CONNECT/tsctp-0-000068
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-0-000069 b/fuzzer/CORPUS_CONNECT/tsctp-0-000069
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-0-000070 b/fuzzer/CORPUS_CONNECT/tsctp-0-000070
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-0-000071 b/fuzzer/CORPUS_CONNECT/tsctp-0-000071
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-0-000072 b/fuzzer/CORPUS_CONNECT/tsctp-0-000072
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-0-000073 b/fuzzer/CORPUS_CONNECT/tsctp-0-000073
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-0-000074 b/fuzzer/CORPUS_CONNECT/tsctp-0-000074
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-0-000075 b/fuzzer/CORPUS_CONNECT/tsctp-0-000075
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-0-000076 b/fuzzer/CORPUS_CONNECT/tsctp-0-000076
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-0-000077 b/fuzzer/CORPUS_CONNECT/tsctp-0-000077
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-0-000078 b/fuzzer/CORPUS_CONNECT/tsctp-0-000078
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-0-000079 b/fuzzer/CORPUS_CONNECT/tsctp-0-000079
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-0-000080 b/fuzzer/CORPUS_CONNECT/tsctp-0-000080
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-0-000081 b/fuzzer/CORPUS_CONNECT/tsctp-0-000081
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-0-000082 b/fuzzer/CORPUS_CONNECT/tsctp-0-000082
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-0-000083 b/fuzzer/CORPUS_CONNECT/tsctp-0-000083
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-0-000084 b/fuzzer/CORPUS_CONNECT/tsctp-0-000084
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-0-000085 b/fuzzer/CORPUS_CONNECT/tsctp-0-000085
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-0-000086 b/fuzzer/CORPUS_CONNECT/tsctp-0-000086
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-0-000087 b/fuzzer/CORPUS_CONNECT/tsctp-0-000087
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-0-000088 b/fuzzer/CORPUS_CONNECT/tsctp-0-000088
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-0-000089 b/fuzzer/CORPUS_CONNECT/tsctp-0-000089
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-0-000090 b/fuzzer/CORPUS_CONNECT/tsctp-0-000090
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-0-000091 b/fuzzer/CORPUS_CONNECT/tsctp-0-000091
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-0-000092 b/fuzzer/CORPUS_CONNECT/tsctp-0-000092
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-0-000093 b/fuzzer/CORPUS_CONNECT/tsctp-0-000093
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-0-000094 b/fuzzer/CORPUS_CONNECT/tsctp-0-000094
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-0-000095 b/fuzzer/CORPUS_CONNECT/tsctp-0-000095
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-0-000096 b/fuzzer/CORPUS_CONNECT/tsctp-0-000096
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-0-000097 b/fuzzer/CORPUS_CONNECT/tsctp-0-000097
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-0-000098 b/fuzzer/CORPUS_CONNECT/tsctp-0-000098
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-0-000099 b/fuzzer/CORPUS_CONNECT/tsctp-0-000099
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-0-000100 b/fuzzer/CORPUS_CONNECT/tsctp-0-000100
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-0-000101 b/fuzzer/CORPUS_CONNECT/tsctp-0-000101
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-0-000102 b/fuzzer/CORPUS_CONNECT/tsctp-0-000102
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-0-000103 b/fuzzer/CORPUS_CONNECT/tsctp-0-000103
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-0-000104 b/fuzzer/CORPUS_CONNECT/tsctp-0-000104
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-0-000105 b/fuzzer/CORPUS_CONNECT/tsctp-0-000105
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-0-000106 b/fuzzer/CORPUS_CONNECT/tsctp-0-000106
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-0-000107 b/fuzzer/CORPUS_CONNECT/tsctp-0-000107
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-0-000108 b/fuzzer/CORPUS_CONNECT/tsctp-0-000108
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-0-000109 b/fuzzer/CORPUS_CONNECT/tsctp-0-000109
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-0-000110 b/fuzzer/CORPUS_CONNECT/tsctp-0-000110
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-0-000111 b/fuzzer/CORPUS_CONNECT/tsctp-0-000111
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-0-000112 b/fuzzer/CORPUS_CONNECT/tsctp-0-000112
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-0-000113 b/fuzzer/CORPUS_CONNECT/tsctp-0-000113
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-0-000114 b/fuzzer/CORPUS_CONNECT/tsctp-0-000114
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-0-000115 b/fuzzer/CORPUS_CONNECT/tsctp-0-000115
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-0-000116 b/fuzzer/CORPUS_CONNECT/tsctp-0-000116
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-0-000117 b/fuzzer/CORPUS_CONNECT/tsctp-0-000117
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-000000 b/fuzzer/CORPUS_CONNECT/tsctp-000000
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-000001 b/fuzzer/CORPUS_CONNECT/tsctp-000001
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-000002 b/fuzzer/CORPUS_CONNECT/tsctp-000002
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-000003 b/fuzzer/CORPUS_CONNECT/tsctp-000003
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-000004 b/fuzzer/CORPUS_CONNECT/tsctp-000004
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-000005 b/fuzzer/CORPUS_CONNECT/tsctp-000005
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-000006 b/fuzzer/CORPUS_CONNECT/tsctp-000006
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-000007 b/fuzzer/CORPUS_CONNECT/tsctp-000007
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-000008 b/fuzzer/CORPUS_CONNECT/tsctp-000008
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-000009 b/fuzzer/CORPUS_CONNECT/tsctp-000009
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-000010 b/fuzzer/CORPUS_CONNECT/tsctp-000010
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-000011 b/fuzzer/CORPUS_CONNECT/tsctp-000011
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-000012 b/fuzzer/CORPUS_CONNECT/tsctp-000012
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-000013 b/fuzzer/CORPUS_CONNECT/tsctp-000013
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-000014 b/fuzzer/CORPUS_CONNECT/tsctp-000014
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-000015 b/fuzzer/CORPUS_CONNECT/tsctp-000015
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-000016 b/fuzzer/CORPUS_CONNECT/tsctp-000016
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-000017 b/fuzzer/CORPUS_CONNECT/tsctp-000017
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-000018 b/fuzzer/CORPUS_CONNECT/tsctp-000018
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-000019 b/fuzzer/CORPUS_CONNECT/tsctp-000019
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-000020 b/fuzzer/CORPUS_CONNECT/tsctp-000020
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-000021 b/fuzzer/CORPUS_CONNECT/tsctp-000021
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-000022 b/fuzzer/CORPUS_CONNECT/tsctp-000022
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-000023 b/fuzzer/CORPUS_CONNECT/tsctp-000023
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-000024 b/fuzzer/CORPUS_CONNECT/tsctp-000024
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-000025 b/fuzzer/CORPUS_CONNECT/tsctp-000025
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-000026 b/fuzzer/CORPUS_CONNECT/tsctp-000026
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-000027 b/fuzzer/CORPUS_CONNECT/tsctp-000027
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-000028 b/fuzzer/CORPUS_CONNECT/tsctp-000028
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_LISTEN/init-1.bin b/fuzzer/CORPUS_LISTEN/init-1.bin
old mode 100644
new mode 100755
diff --git a/fuzzer/fuzzer_connect.c b/fuzzer/fuzzer_connect.c
old mode 100644
new mode 100755
index 87b6ebbf..c6a4fd20
--- a/fuzzer/fuzzer_connect.c
+++ b/fuzzer/fuzzer_connect.c
@@ -1,3 +1,7 @@
+#ifdef FRCOV
+#define FIXREVERTER_SIZE 780
+short FIXREVERTER[FIXREVERTER_SIZE];
+#endif
 /*
  * Copyright (C) 2017-2019 Felix Weinrank
  *
@@ -148,9 +152,43 @@ initialize_fuzzer(void) {
 }
 
 
+
+#ifdef FRCOV
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#endif
 int
 LLVMFuzzerTestOneInput(const uint8_t* data, size_t data_size)
 {
+	
+	#ifdef FRCOV
+	char *fixReverterEnv = getenv("FIXREVERTER");
+	char *fixReverterToken = strtok(fixReverterEnv, " ");
+	if (fixReverterToken == NULL) {
+	  for (int i = 0; i < FIXREVERTER_SIZE; i++)
+	    FIXREVERTER[i] = 1;
+	} else if (!strcmp("on", fixReverterToken)) {
+	  for (int i = 0; i < FIXREVERTER_SIZE; i++)
+	    FIXREVERTER[i] = 0;
+	  fixReverterToken = strtok(NULL, " ");
+	  while (fixReverterToken != NULL) {
+	    FIXREVERTER[atoi(fixReverterToken)] = 1;
+	    fixReverterToken = strtok(NULL, " ");
+	  }
+	} else if (!strcmp("off", fixReverterToken)) {
+	  for (int i = 0; i < FIXREVERTER_SIZE; i++)
+	    FIXREVERTER[i] = 1;
+	  fixReverterToken = strtok(NULL, " ");
+	  while (fixReverterToken != NULL) {
+	    FIXREVERTER[atoi(fixReverterToken)] = 0;
+	    fixReverterToken = strtok(NULL, " ");
+	  }
+	} else {
+	  fprintf(stderr, "[FIXREVERTER] - first token must be on or off\n");
+	  exit(0);
+	}
+	#endif
 	static int initialized;
 	char *fuzzed_packet_buffer;
 	struct sockaddr_in bind4;
diff --git a/fuzzer/fuzzer_listen.c b/fuzzer/fuzzer_listen.c
old mode 100644
new mode 100755
diff --git a/gen-def.py b/gen-def.py
old mode 100644
new mode 100755
diff --git a/meson.build b/meson.build
old mode 100644
new mode 100755
diff --git a/meson_options.txt b/meson_options.txt
old mode 100644
new mode 100755
diff --git a/programs/CMakeLists.txt b/programs/CMakeLists.txt
old mode 100644
new mode 100755
diff --git a/programs/Makefile.am b/programs/Makefile.am
old mode 100644
new mode 100755
diff --git a/programs/Makefile.nmake b/programs/Makefile.nmake
old mode 100644
new mode 100755
diff --git a/programs/chargen_server_upcall.c b/programs/chargen_server_upcall.c
old mode 100644
new mode 100755
diff --git a/programs/client.c b/programs/client.c
old mode 100644
new mode 100755
diff --git a/programs/client_upcall.c b/programs/client_upcall.c
old mode 100644
new mode 100755
diff --git a/programs/daytime_server.c b/programs/daytime_server.c
old mode 100644
new mode 100755
diff --git a/programs/daytime_server_upcall.c b/programs/daytime_server_upcall.c
old mode 100644
new mode 100755
diff --git a/programs/discard_server.c b/programs/discard_server.c
old mode 100644
new mode 100755
diff --git a/programs/discard_server_upcall.c b/programs/discard_server_upcall.c
old mode 100644
new mode 100755
diff --git a/programs/echo_server.c b/programs/echo_server.c
old mode 100644
new mode 100755
diff --git a/programs/echo_server_upcall.c b/programs/echo_server_upcall.c
old mode 100644
new mode 100755
diff --git a/programs/ekr_client.c b/programs/ekr_client.c
old mode 100644
new mode 100755
diff --git a/programs/ekr_loop.c b/programs/ekr_loop.c
old mode 100644
new mode 100755
diff --git a/programs/ekr_loop_offload.c b/programs/ekr_loop_offload.c
old mode 100644
new mode 100755
diff --git a/programs/ekr_loop_upcall.c b/programs/ekr_loop_upcall.c
old mode 100644
new mode 100755
diff --git a/programs/ekr_peer.c b/programs/ekr_peer.c
old mode 100644
new mode 100755
diff --git a/programs/ekr_server.c b/programs/ekr_server.c
old mode 100644
new mode 100755
diff --git a/programs/http_client.c b/programs/http_client.c
old mode 100644
new mode 100755
diff --git a/programs/http_client_upcall.c b/programs/http_client_upcall.c
old mode 100644
new mode 100755
diff --git a/programs/meson.build b/programs/meson.build
old mode 100644
new mode 100755
diff --git a/programs/programs_helper.c b/programs/programs_helper.c
old mode 100644
new mode 100755
diff --git a/programs/programs_helper.h b/programs/programs_helper.h
old mode 100644
new mode 100755
diff --git a/programs/rtcweb.c b/programs/rtcweb.c
old mode 100644
new mode 100755
diff --git a/programs/st_client.c b/programs/st_client.c
old mode 100644
new mode 100755
diff --git a/programs/test_libmgmt.c b/programs/test_libmgmt.c
old mode 100644
new mode 100755
diff --git a/programs/test_timer.c b/programs/test_timer.c
old mode 100644
new mode 100755
diff --git a/programs/tsctp.c b/programs/tsctp.c
old mode 100644
new mode 100755
diff --git a/programs/tsctp_upcall.c b/programs/tsctp_upcall.c
old mode 100644
new mode 100755
diff --git a/usrsctp.pc.in b/usrsctp.pc.in
old mode 100644
new mode 100755
diff --git a/usrsctplib/CMakeLists.txt b/usrsctplib/CMakeLists.txt
old mode 100644
new mode 100755
diff --git a/usrsctplib/Makefile.am b/usrsctplib/Makefile.am
old mode 100644
new mode 100755
diff --git a/usrsctplib/Makefile.nmake b/usrsctplib/Makefile.nmake
old mode 100644
new mode 100755
diff --git a/usrsctplib/meson.build b/usrsctplib/meson.build
old mode 100644
new mode 100755
diff --git a/usrsctplib/netinet/meson.build b/usrsctplib/netinet/meson.build
old mode 100644
new mode 100755
diff --git a/usrsctplib/netinet/sctp_asconf.c b/usrsctplib/netinet/sctp_asconf.c
index ededbed8..5b4d04fa 100755
--- a/usrsctplib/netinet/sctp_asconf.c
+++ b/usrsctplib/netinet/sctp_asconf.c
@@ -1,3 +1,7 @@
+#ifdef FRCOV
+#include <stdio.h>
+extern short FIXREVERTER[];
+#endif
 /*-
  * SPDX-License-Identifier: BSD-3-Clause
  *
@@ -88,11 +92,26 @@ sctp_asconf_success_response(uint32_t id)
 
 	m_reply = sctp_get_mbuf_for_msg(sizeof(struct sctp_asconf_paramhdr),
 					0, M_NOWAIT, 1, MT_DATA);
-	if (m_reply == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[1]) {
+	  if ((m_reply == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 1\n");
+	  else
+	    fprintf(stderr, "reached bug index 1\n");
+	}
+	if ((!FIXREVERTER[1] && (m_reply == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		SCTPDBG(SCTP_DEBUG_ASCONF1,
 			"asconf_success_response: couldn't get mbuf!\n");
 		return (NULL);
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	aph = mtod(m_reply, struct sctp_asconf_paramhdr *);
 	aph->correlation_id = id;
 	aph->ph.param_type = htons(SCTP_SUCCESS_REPORT);
@@ -131,11 +150,26 @@ sctp_asconf_error_response(uint32_t id, uint16_t cause, uint8_t *error_tlv,
 		return (NULL);
 	}
 	m_reply = sctp_get_mbuf_for_msg(buf_len, 0, M_NOWAIT, 1, MT_DATA);
-	if (m_reply == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[2]) {
+	  if ((m_reply == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 2\n");
+	  else
+	    fprintf(stderr, "reached bug index 2\n");
+	}
+	if ((!FIXREVERTER[2] && (m_reply == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		SCTPDBG(SCTP_DEBUG_ASCONF1,
 			"asconf_error_response: couldn't get mbuf!\n");
 		return (NULL);
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	aph = mtod(m_reply, struct sctp_asconf_paramhdr *);
 	aph->ph.param_type = htons(SCTP_ERROR_CAUSE_IND);
 	aph->ph.param_length = htons(param_length);
@@ -296,10 +330,25 @@ sctp_asconf_del_remote_addrs_except(struct sctp_tcb *stcb, struct sockaddr *src)
 
 	/* make sure the source address exists as a destination net */
 	src_net = sctp_findnet(stcb, src);
-	if (src_net == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[3]) {
+	  if ((src_net == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 3\n");
+	  else
+	    fprintf(stderr, "reached bug index 3\n");
+	}
+	if ((!FIXREVERTER[3] && (src_net == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		/* not found */
 		return (-1);
 	}
+	#ifdef FRCOV
+	}
+	#endif
 
 	/* delete all destination addresses except the source */
 	TAILQ_FOREACH_SAFE(net, &stcb->asoc.nets, sctp_next, nnet) {
@@ -657,11 +706,26 @@ sctp_handle_asconf(struct mbuf *m, unsigned int offset,
 			"handle_asconf: got duplicate serial number = %xh\n",
 			serial_num);
 		return;
-	} else if (serial_num != (asoc->asconf_seq_in + 1)) {
+	} else 
+	#ifdef FRCOV
+	{if (FIXREVERTER[4]) {
+	  if ((serial_num != asoc -> asconf_seq_in + 1 ) && !(0))
+	    fprintf(stderr, "triggered bug index 4\n");
+	  else
+	    fprintf(stderr, "reached bug index 4\n");
+	}
+	if ((!FIXREVERTER[4] && (serial_num != asoc -> asconf_seq_in + 1 ))
+	#else
+	if (0
+	#endif
+	) {
 		SCTPDBG(SCTP_DEBUG_ASCONF1, "handle_asconf: incorrect serial number = %xh (expected next = %xh)\n",
 			serial_num, asoc->asconf_seq_in + 1);
 		return;
 	}
+	#ifdef FRCOV
+	}
+	#endif
 
 	/* it's the expected "next" sequence number, so process it */
 	asoc->asconf_seq_in = serial_num;	/* update sequence */
@@ -676,8 +740,23 @@ sctp_handle_asconf(struct mbuf *m, unsigned int offset,
 		SCTPDBG(SCTP_DEBUG_ASCONF1,"handle_asconf: Now processing first ASCONF. Try to delete old cache\n");
 
 		TAILQ_FOREACH_SAFE(ack, &asoc->asconf_ack_sent, next, ack_next) {
-			if (ack->serial_number == serial_num)
+			
+			#ifdef FRCOV
+			{if (FIXREVERTER[5]) {
+			  if ((ack -> serial_number == serial_num ) && !(0))
+			    fprintf(stderr, "triggered bug index 5\n");
+			  else
+			    fprintf(stderr, "reached bug index 5\n");
+			}
+			if ((!FIXREVERTER[5] && (ack -> serial_number == serial_num ))
+			#else
+			if (0
+			#endif
+			)
 				break;
+				#ifdef FRCOV
+				}
+				#endif
 			SCTPDBG(SCTP_DEBUG_ASCONF1,"handle_asconf: delete old(%u) < first(%u)\n",
 			    ack->serial_number, serial_num);
 			TAILQ_REMOVE(&asoc->asconf_ack_sent, ack, next);
@@ -690,11 +769,26 @@ sctp_handle_asconf(struct mbuf *m, unsigned int offset,
 
 	m_ack = sctp_get_mbuf_for_msg(sizeof(struct sctp_asconf_ack_chunk), 0,
 				      M_NOWAIT, 1, MT_DATA);
-	if (m_ack == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[6]) {
+	  if ((m_ack == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 6\n");
+	  else
+	    fprintf(stderr, "reached bug index 6\n");
+	}
+	if ((!FIXREVERTER[6] && (m_ack == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		SCTPDBG(SCTP_DEBUG_ASCONF1,
 			"handle_asconf: couldn't get mbuf!\n");
 		return;
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	m_tail = m_ack;		/* current reply chain's tail */
 
 	/* fill in ASCONF-ACK header */
@@ -709,21 +803,51 @@ sctp_handle_asconf(struct mbuf *m, unsigned int offset,
 	/* skip the lookup address parameter */
 	offset += sizeof(struct sctp_asconf_chunk);
 	p_addr = (struct sctp_ipv6addr_param *)sctp_m_getptr(m, offset, sizeof(struct sctp_paramhdr), (uint8_t *)&aparam_buf);
-	if (p_addr == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[7]) {
+	  if ((p_addr == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 7\n");
+	  else
+	    fprintf(stderr, "reached bug index 7\n");
+	}
+	if ((!FIXREVERTER[7] && (p_addr == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		SCTPDBG(SCTP_DEBUG_ASCONF1,
 			"handle_asconf: couldn't get lookup addr!\n");
 		/* respond with a missing/invalid mandatory parameter error */
 		sctp_m_freem(m_ack);
 		return;
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	/* skip lookup addr */
 	offset += SCTP_SIZE32(ntohs(p_addr->ph.param_length));
 	/* get pointer to first asconf param in ASCONF */
 	aph = (struct sctp_asconf_paramhdr *)sctp_m_getptr(m, offset, sizeof(struct sctp_asconf_paramhdr), (uint8_t *)&aparam_buf);
-	if (aph == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[8]) {
+	  if ((aph == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 8\n");
+	  else
+	    fprintf(stderr, "reached bug index 8\n");
+	}
+	if ((!FIXREVERTER[8] && (aph == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		SCTPDBG(SCTP_DEBUG_ASCONF1, "Empty ASCONF received?\n");
 		goto send_reply;
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	/* process through all parameters */
 	cnt = 0;
 	while (aph != NULL) {
@@ -731,18 +855,48 @@ sctp_handle_asconf(struct mbuf *m, unsigned int offset,
 
 		param_type = ntohs(aph->ph.param_type);
 		param_length = ntohs(aph->ph.param_length);
-		if (offset + param_length > asconf_limit) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[9]) {
+		  if ((offset + param_length > asconf_limit ) && !(0))
+		    fprintf(stderr, "triggered bug index 9\n");
+		  else
+		    fprintf(stderr, "reached bug index 9\n");
+		}
+		if ((!FIXREVERTER[9] && (offset + param_length > asconf_limit ))
+		#else
+		if (0
+		#endif
+		) {
 			/* parameter goes beyond end of chunk! */
 			sctp_m_freem(m_ack);
 			return;
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		m_result = NULL;
 
-		if (param_length > sizeof(aparam_buf)) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[10]) {
+		  if ((param_length > sizeof ( aparam_buf ) ) && !(0))
+		    fprintf(stderr, "triggered bug index 10\n");
+		  else
+		    fprintf(stderr, "reached bug index 10\n");
+		}
+		if ((!FIXREVERTER[10] && (param_length > sizeof ( aparam_buf ) ))
+		#else
+		if (0
+		#endif
+		) {
 			SCTPDBG(SCTP_DEBUG_ASCONF1, "handle_asconf: param length (%u) larger than buffer size!\n", param_length);
 			sctp_m_freem(m_ack);
 			return;
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		if (param_length <= sizeof(struct sctp_paramhdr)) {
 			SCTPDBG(SCTP_DEBUG_ASCONF1, "handle_asconf: param length (%u) too short\n", param_length);
 			sctp_m_freem(m_ack);
@@ -750,11 +904,26 @@ sctp_handle_asconf(struct mbuf *m, unsigned int offset,
 		}
 		/* get the entire parameter */
 		aph = (struct sctp_asconf_paramhdr *)sctp_m_getptr(m, offset, param_length, aparam_buf);
-		if (aph == NULL) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[11]) {
+		  if ((aph == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 11\n");
+		  else
+		    fprintf(stderr, "reached bug index 11\n");
+		}
+		if ((!FIXREVERTER[11] && (aph == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		) {
 			SCTPDBG(SCTP_DEBUG_ASCONF1, "handle_asconf: couldn't get entire param\n");
 			sctp_m_freem(m_ack);
 			return;
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		switch (param_type) {
 		case SCTP_ADD_IP_ADDRESS:
 			m_result = sctp_process_asconf_add_ip(src, aph, stcb,
@@ -808,10 +977,25 @@ sctp_handle_asconf(struct mbuf *m, unsigned int offset,
 		}
 		offset += SCTP_SIZE32(param_length);
 		/* update remaining ASCONF message length to process */
-		if (offset >= asconf_limit) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[12]) {
+		  if ((offset >= asconf_limit ) && !(0))
+		    fprintf(stderr, "triggered bug index 12\n");
+		  else
+		    fprintf(stderr, "reached bug index 12\n");
+		}
+		if ((!FIXREVERTER[12] && (offset >= asconf_limit ))
+		#else
+		if (0
+		#endif
+		) {
 			/* no more data in the mbuf chain */
 			break;
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		/* get pointer to next asconf param */
 		aph = (struct sctp_asconf_paramhdr *)sctp_m_getptr(m, offset,
 		    sizeof(struct sctp_asconf_paramhdr),
@@ -828,10 +1012,25 @@ sctp_handle_asconf(struct mbuf *m, unsigned int offset,
 	/* save the ASCONF-ACK reply */
 	ack = SCTP_ZONE_GET(SCTP_BASE_INFO(ipi_zone_asconf_ack),
 	    struct sctp_asconf_ack);
-	if (ack == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[13]) {
+	  if ((ack == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 13\n");
+	  else
+	    fprintf(stderr, "reached bug index 13\n");
+	}
+	if ((!FIXREVERTER[13] && (ack == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		sctp_m_freem(m_ack);
 		return;
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	ack->serial_number = serial_num;
 	ack->last_sent_to = NULL;
 	ack->data = m_ack;
@@ -1283,11 +1482,26 @@ sctp_asconf_queue_mgmt(struct sctp_tcb *stcb, struct sctp_ifa *ifa,
 	/* adding new request to the queue */
 	SCTP_MALLOC(aa, struct sctp_asconf_addr *, sizeof(*aa),
 		    SCTP_M_ASC_ADDR);
-	if (aa == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[16]) {
+	  if ((aa == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 16\n");
+	  else
+	    fprintf(stderr, "reached bug index 16\n");
+	}
+	if ((!FIXREVERTER[16] && (aa == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		/* didn't get memory */
 		SCTPDBG(SCTP_DEBUG_ASCONF1, "asconf_queue_mgmt: failed to get memory!\n");
 		return (-1);
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	aa->special_del = 0;
 	/* fill in asconf address parameter fields */
 	/* top level elements are "networked" during send */
@@ -1462,9 +1676,24 @@ sctp_asconf_queue_sa_delete(struct sctp_tcb *stcb, struct sockaddr *sa)
 	struct sctp_ifa *ifa;
 	struct sctp_asconf_addr *aa, *aa_next;
 
-	if (stcb == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[17]) {
+	  if ((stcb == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 17\n");
+	  else
+	    fprintf(stderr, "reached bug index 17\n");
+	}
+	if ((!FIXREVERTER[17] && (stcb == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		return (-1);
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	/* see if peer supports ASCONF */
 	if (stcb->asoc.asconf_supported == 0) {
 		return (-1);
@@ -1497,12 +1726,27 @@ sctp_asconf_queue_sa_delete(struct sctp_tcb *stcb, struct sockaddr *sa)
 	/* adding new request to the queue */
 	SCTP_MALLOC(aa, struct sctp_asconf_addr *, sizeof(*aa),
 		    SCTP_M_ASC_ADDR);
-	if (aa == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[18]) {
+	  if ((aa == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 18\n");
+	  else
+	    fprintf(stderr, "reached bug index 18\n");
+	}
+	if ((!FIXREVERTER[18] && (aa == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		/* didn't get memory */
 		SCTPDBG(SCTP_DEBUG_ASCONF1,
 			"sctp_asconf_queue_sa_delete: failed to get memory!\n");
 		return (-1);
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	aa->special_del = 0;
 	/* fill in asconf address parameter fields */
 	/* top level elements are "networked" during send */
@@ -1730,12 +1974,27 @@ sctp_handle_asconf_ack(struct mbuf *m, int offset,
 		*abort_no_unlock = 1;
 		return;
 	}
-	if (serial_num != asoc->asconf_seq_out_acked + 1) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[19]) {
+	  if ((serial_num != asoc -> asconf_seq_out_acked + 1 ) && !(0))
+	    fprintf(stderr, "triggered bug index 19\n");
+	  else
+	    fprintf(stderr, "reached bug index 19\n");
+	}
+	if ((!FIXREVERTER[19] && (serial_num != asoc -> asconf_seq_out_acked + 1 ))
+	#else
+	if (0
+	#endif
+	) {
 		/* got a duplicate/unexpected ASCONF-ACK */
 		SCTPDBG(SCTP_DEBUG_ASCONF1, "handle_asconf_ack: got duplicate/unexpected serial number = %xh (expected = %xh)\n",
 			serial_num, asoc->asconf_seq_out_acked + 1);
 		return;
 	}
+	#ifdef FRCOV
+	}
+	#endif
 
 	if (serial_num == asoc->asconf_seq_out - 1) {
 		/* stop our timer */
@@ -1754,33 +2013,93 @@ sctp_handle_asconf_ack(struct mbuf *m, int offset,
 		/* get pointer to next asconf parameter */
 		aph = (struct sctp_asconf_paramhdr *)sctp_m_getptr(m, offset,
 		    sizeof(struct sctp_asconf_paramhdr), aparam_buf);
-		if (aph == NULL) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[20]) {
+		  if ((aph == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 20\n");
+		  else
+		    fprintf(stderr, "reached bug index 20\n");
+		}
+		if ((!FIXREVERTER[20] && (aph == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		) {
 			/* can't get an asconf paramhdr */
 			sctp_asconf_ack_clear(stcb);
 			return;
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		param_type = ntohs(aph->ph.param_type);
 		param_length = ntohs(aph->ph.param_length);
-		if (param_length > ack_length) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[21]) {
+		  if ((param_length > ack_length ) && !(0))
+		    fprintf(stderr, "triggered bug index 21\n");
+		  else
+		    fprintf(stderr, "reached bug index 21\n");
+		}
+		if ((!FIXREVERTER[21] && (param_length > ack_length ))
+		#else
+		if (0
+		#endif
+		) {
 			sctp_asconf_ack_clear(stcb);
 			return;
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		if (param_length < sizeof(struct sctp_paramhdr)) {
 			sctp_asconf_ack_clear(stcb);
 			return;
 		}
 		/* get the complete parameter... */
-		if (param_length > sizeof(aparam_buf)) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[22]) {
+		  if ((param_length > sizeof ( aparam_buf ) ) && !(0))
+		    fprintf(stderr, "triggered bug index 22\n");
+		  else
+		    fprintf(stderr, "reached bug index 22\n");
+		}
+		if ((!FIXREVERTER[22] && (param_length > sizeof ( aparam_buf ) ))
+		#else
+		if (0
+		#endif
+		) {
 			SCTPDBG(SCTP_DEBUG_ASCONF1,
 				"param length (%u) larger than buffer size!\n", param_length);
 			sctp_asconf_ack_clear(stcb);
 			return;
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		aph = (struct sctp_asconf_paramhdr *)sctp_m_getptr(m, offset, param_length, aparam_buf);
-		if (aph == NULL) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[23]) {
+		  if ((aph == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 23\n");
+		  else
+		    fprintf(stderr, "reached bug index 23\n");
+		}
+		if ((!FIXREVERTER[23] && (aph == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		) {
 			sctp_asconf_ack_clear(stcb);
 			return;
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		/* correlation_id is transparent to peer, no ntohl needed */
 		id = aph->correlation_id;
 
@@ -1789,10 +2108,25 @@ sctp_handle_asconf_ack(struct mbuf *m, int offset,
 			last_error_id = id;
 			/* find the corresponding asconf param in our queue */
 			ap = sctp_asconf_find_param(stcb, id);
-			if (ap == NULL) {
+			
+			#ifdef FRCOV
+			{if (FIXREVERTER[24]) {
+			  if ((ap == (void *) 0 ) && !(0))
+			    fprintf(stderr, "triggered bug index 24\n");
+			  else
+			    fprintf(stderr, "reached bug index 24\n");
+			}
+			if ((!FIXREVERTER[24] && (ap == (void *) 0 ))
+			#else
+			if (0
+			#endif
+			) {
 				/* hmm... can't find this in our queue! */
 				break;
 			}
+			#ifdef FRCOV
+			}
+			#endif
 			/* process the parameter, failed flag */
 			sctp_asconf_process_param_ack(stcb, ap, 0);
 			/* process the error response */
@@ -1801,10 +2135,25 @@ sctp_handle_asconf_ack(struct mbuf *m, int offset,
 		case SCTP_SUCCESS_REPORT:
 			/* find the corresponding asconf param in our queue */
 			ap = sctp_asconf_find_param(stcb, id);
-			if (ap == NULL) {
+			
+			#ifdef FRCOV
+			{if (FIXREVERTER[25]) {
+			  if ((ap == (void *) 0 ) && !(0))
+			    fprintf(stderr, "triggered bug index 25\n");
+			  else
+			    fprintf(stderr, "reached bug index 25\n");
+			}
+			if ((!FIXREVERTER[25] && (ap == (void *) 0 ))
+			#else
+			if (0
+			#endif
+			) {
 				/* hmm... can't find this in our queue! */
 				break;
 			}
+			#ifdef FRCOV
+			}
+			#endif
 			/* process the parameter, success flag */
 			sctp_asconf_process_param_ack(stcb, ap, 1);
 			break;
@@ -1876,10 +2225,25 @@ sctp_is_scopeid_in_nets(struct sctp_tcb *stcb, struct sockaddr *sa)
 	struct sockaddr_in6 *sin6, *net6;
 	struct sctp_nets *net;
 
-	if (sa->sa_family != AF_INET6) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[27]) {
+	  if ((sa -> sa_family != 10 ) && !(0))
+	    fprintf(stderr, "triggered bug index 27\n");
+	  else
+	    fprintf(stderr, "reached bug index 27\n");
+	}
+	if ((!FIXREVERTER[27] && (sa -> sa_family != 10 ))
+	#else
+	if (0
+	#endif
+	) {
 		/* wrong family */
 		return (0);
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	sin6 = (struct sockaddr_in6 *)sa;
 	if (IN6_IS_ADDR_LINKLOCAL(&sin6->sin6_addr) == 0) {
 		/* not link local address */
@@ -2332,10 +2696,25 @@ sctp_set_primary_ip_address_sa(struct sctp_tcb *stcb, struct sockaddr *sa)
 	/* find the ifa for the desired set primary */
 	vrf_id = stcb->asoc.vrf_id;
 	ifa = sctp_find_ifa_by_addr(sa, vrf_id, SCTP_ADDR_NOT_LOCKED);
-	if (ifa == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[31]) {
+	  if ((ifa == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 31\n");
+	  else
+	    fprintf(stderr, "reached bug index 31\n");
+	}
+	if ((!FIXREVERTER[31] && (ifa == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		/* Invalid address */
 		return (-1);
 	}
+	#ifdef FRCOV
+	}
+	#endif
 
 	/* queue an ASCONF:SET_PRIM_ADDR to be sent */
 	if (!sctp_asconf_queue_add(stcb, ifa, SCTP_SET_PRIM_ADDR)) {
@@ -2378,49 +2757,139 @@ sctp_is_addr_pending(struct sctp_tcb *stcb, struct sctp_ifa *sctp_ifa)
 	add_cnt = del_cnt = 0;
 	last_param_type = 0;
 	TAILQ_FOREACH_SAFE(chk, &stcb->asoc.asconf_send_queue, sctp_next, nchk) {
-		if (chk->data == NULL) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[32]) {
+		  if ((chk -> data == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 32\n");
+		  else
+		    fprintf(stderr, "reached bug index 32\n");
+		}
+		if ((!FIXREVERTER[32] && (chk -> data == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		) {
 			SCTPDBG(SCTP_DEBUG_ASCONF1, "is_addr_pending: No mbuf data?\n");
 			continue;
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		offset = 0;
 		acp = mtod(chk->data, struct sctp_asconf_chunk *);
 		offset += sizeof(struct sctp_asconf_chunk);
 		asconf_limit = ntohs(acp->ch.chunk_length);
 		ph = (struct sctp_paramhdr *)sctp_m_getptr(chk->data, offset, sizeof(struct sctp_paramhdr), aparam_buf);
-		if (ph == NULL) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[33]) {
+		  if ((ph == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 33\n");
+		  else
+		    fprintf(stderr, "reached bug index 33\n");
+		}
+		if ((!FIXREVERTER[33] && (ph == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		) {
 			SCTPDBG(SCTP_DEBUG_ASCONF1, "is_addr_pending: couldn't get lookup addr!\n");
 			continue;
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		offset += ntohs(ph->param_length);
 
 		aph = (struct sctp_asconf_paramhdr *)sctp_m_getptr(chk->data, offset, sizeof(struct sctp_asconf_paramhdr), aparam_buf);
-		if (aph == NULL) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[34]) {
+		  if ((aph == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 34\n");
+		  else
+		    fprintf(stderr, "reached bug index 34\n");
+		}
+		if ((!FIXREVERTER[34] && (aph == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		) {
 			SCTPDBG(SCTP_DEBUG_ASCONF1, "is_addr_pending: Empty ASCONF will be sent?\n");
 			continue;
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		while (aph != NULL) {
 			unsigned int param_length, param_type;
 
 			param_type = ntohs(aph->ph.param_type);
 			param_length = ntohs(aph->ph.param_length);
-			if (offset + param_length > asconf_limit) {
+			
+			#ifdef FRCOV
+			{if (FIXREVERTER[35]) {
+			  if ((offset + param_length > asconf_limit ) && !(0))
+			    fprintf(stderr, "triggered bug index 35\n");
+			  else
+			    fprintf(stderr, "reached bug index 35\n");
+			}
+			if ((!FIXREVERTER[35] && (offset + param_length > asconf_limit ))
+			#else
+			if (0
+			#endif
+			) {
 				/* parameter goes beyond end of chunk! */
 				break;
 			}
-			if (param_length > sizeof(aparam_buf)) {
+			#ifdef FRCOV
+			}
+			#endif
+			
+			#ifdef FRCOV
+			{if (FIXREVERTER[36]) {
+			  if ((param_length > sizeof ( aparam_buf ) ) && !(0))
+			    fprintf(stderr, "triggered bug index 36\n");
+			  else
+			    fprintf(stderr, "reached bug index 36\n");
+			}
+			if ((!FIXREVERTER[36] && (param_length > sizeof ( aparam_buf ) ))
+			#else
+			if (0
+			#endif
+			) {
 				SCTPDBG(SCTP_DEBUG_ASCONF1, "is_addr_pending: param length (%u) larger than buffer size!\n", param_length);
 				break;
 			}
+			#ifdef FRCOV
+			}
+			#endif
 			if (param_length <= sizeof(struct sctp_paramhdr)) {
 				SCTPDBG(SCTP_DEBUG_ASCONF1, "is_addr_pending: param length(%u) too short\n", param_length);
 				break;
 			}
 
 			aph = (struct sctp_asconf_paramhdr *)sctp_m_getptr(chk->data, offset, param_length, aparam_buf);
-			if (aph == NULL) {
+			
+			#ifdef FRCOV
+			{if (FIXREVERTER[37]) {
+			  if ((aph == (void *) 0 ) && !(0))
+			    fprintf(stderr, "triggered bug index 37\n");
+			  else
+			    fprintf(stderr, "reached bug index 37\n");
+			}
+			if ((!FIXREVERTER[37] && (aph == (void *) 0 ))
+			#else
+			if (0
+			#endif
+			) {
 				SCTPDBG(SCTP_DEBUG_ASCONF1, "is_addr_pending: couldn't get entire param\n");
 				break;
 			}
+			#ifdef FRCOV
+			}
+			#endif
 
 			ph = (struct sctp_paramhdr *)(aph + 1);
 			if (sctp_addr_match(ph, &sctp_ifa->address.sa) != 0) {
@@ -2438,10 +2907,25 @@ sctp_is_addr_pending(struct sctp_tcb *stcb, struct sctp_ifa *sctp_ifa)
 			}
 
 			offset += SCTP_SIZE32(param_length);
-			if (offset >= asconf_limit) {
+			
+			#ifdef FRCOV
+			{if (FIXREVERTER[38]) {
+			  if ((offset >= asconf_limit ) && !(0))
+			    fprintf(stderr, "triggered bug index 38\n");
+			  else
+			    fprintf(stderr, "reached bug index 38\n");
+			}
+			if ((!FIXREVERTER[38] && (offset >= asconf_limit ))
+			#else
+			if (0
+			#endif
+			) {
 				/* no more data in the mbuf chain */
 				break;
 			}
+			#ifdef FRCOV
+			}
+			#endif
 			/* get pointer to next asconf param */
 			aph = (struct sctp_asconf_paramhdr *)sctp_m_getptr(chk->data, offset, sizeof(struct sctp_asconf_paramhdr), aparam_buf);
 		}
@@ -2465,11 +2949,26 @@ sctp_find_valid_localaddr(struct sctp_tcb *stcb, int addr_locked)
 	if (addr_locked == SCTP_ADDR_NOT_LOCKED)
 		SCTP_IPI_ADDR_RLOCK();
 	vrf = sctp_find_vrf(stcb->asoc.vrf_id);
-	if (vrf == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[39]) {
+	  if ((vrf == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 39\n");
+	  else
+	    fprintf(stderr, "reached bug index 39\n");
+	}
+	if ((!FIXREVERTER[39] && (vrf == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		if (addr_locked == SCTP_ADDR_NOT_LOCKED)
 			SCTP_IPI_ADDR_RUNLOCK();
 		return (NULL);
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	LIST_FOREACH(sctp_ifn, &vrf->ifnlist, next_ifn) {
 		if (stcb->asoc.scope.loopback_scope == 0 &&
 		    SCTP_IFN_IS_IFT_LOOP(sctp_ifn)) {
@@ -2562,9 +3061,24 @@ sctp_find_valid_localaddr_ep(struct sctp_tcb *stcb)
 	struct sctp_laddr *laddr;
 
 	LIST_FOREACH(laddr, &stcb->sctp_ep->sctp_addr_list, sctp_nxt_addr) {
-		if (laddr->ifa == NULL) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[40]) {
+		  if ((laddr -> ifa == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 40\n");
+		  else
+		    fprintf(stderr, "reached bug index 40\n");
+		}
+		if ((!FIXREVERTER[40] && (laddr -> ifa == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		) {
 			continue;
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		/* is the address restricted ? */
 		if (sctp_is_addr_restricted(stcb, laddr->ifa) &&
 		    (!sctp_is_addr_pending(stcb, laddr->ifa)))
@@ -2599,8 +3113,23 @@ sctp_compose_asconf(struct sctp_tcb *stcb, int *retlen, int addr_locked)
 		if (aa->sent == 0)
 			break;
 	}
-	if (aa == NULL)
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[41]) {
+	  if ((aa == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 41\n");
+	  else
+	    fprintf(stderr, "reached bug index 41\n");
+	}
+	if ((!FIXREVERTER[41] && (aa == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	)
 		return (NULL);
+		#ifdef FRCOV
+		}
+		#endif
 
 	/*
 	 * get a chunk header mbuf and a cluster for the asconf params since
@@ -2608,20 +3137,50 @@ sctp_compose_asconf(struct sctp_tcb *stcb, int *retlen, int addr_locked)
 	 * the fly
 	 */
 	m_asconf_chk = sctp_get_mbuf_for_msg(sizeof(struct sctp_asconf_chunk), 0, M_NOWAIT, 1, MT_DATA);
-	if (m_asconf_chk == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[42]) {
+	  if ((m_asconf_chk == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 42\n");
+	  else
+	    fprintf(stderr, "reached bug index 42\n");
+	}
+	if ((!FIXREVERTER[42] && (m_asconf_chk == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		/* no mbuf's */
 		SCTPDBG(SCTP_DEBUG_ASCONF1,
 			"compose_asconf: couldn't get chunk mbuf!\n");
 		return (NULL);
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	m_asconf = sctp_get_mbuf_for_msg(MCLBYTES, 0, M_NOWAIT, 1, MT_DATA);
-	if (m_asconf == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[43]) {
+	  if ((m_asconf == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 43\n");
+	  else
+	    fprintf(stderr, "reached bug index 43\n");
+	}
+	if ((!FIXREVERTER[43] && (m_asconf == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		/* no mbuf's */
 		SCTPDBG(SCTP_DEBUG_ASCONF1,
 			"compose_asconf: couldn't get mbuf!\n");
 		sctp_m_freem(m_asconf_chk);
 		return (NULL);
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	SCTP_BUF_LEN(m_asconf_chk) = sizeof(struct sctp_asconf_chunk);
 	SCTP_BUF_LEN(m_asconf) = 0;
 	acp = mtod(m_asconf_chk, struct sctp_asconf_chunk *);
@@ -2794,8 +3353,23 @@ sctp_process_initack_addresses(struct sctp_tcb *stcb, struct mbuf *m,
 #endif
 
 	SCTPDBG(SCTP_DEBUG_ASCONF2, "processing init-ack addresses\n");
-	if (stcb == NULL) /* Un-needed check for SA */
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[44]) {
+	  if ((stcb == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 44\n");
+	  else
+	    fprintf(stderr, "reached bug index 44\n");
+	}
+	if ((!FIXREVERTER[44] && (stcb == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) /* Un-needed check for SA */
 		return;
+		#ifdef FRCOV
+		}
+		#endif
 
 	/* convert to upper bound */
 	length += offset;
@@ -2977,9 +3551,24 @@ sctp_addr_in_initack(struct mbuf *m, uint32_t offset, uint32_t length, struct so
 				      sctp_m_getptr(m, offset,
 				                    sizeof(struct sctp_ipv6addr_param),
 				                    (uint8_t *)&addr6_store);
-				if (a6p == NULL) {
+				
+				#ifdef FRCOV
+				{if (FIXREVERTER[45]) {
+				  if ((a6p == (void *) 0 ) && !(0))
+				    fprintf(stderr, "triggered bug index 45\n");
+				  else
+				    fprintf(stderr, "reached bug index 45\n");
+				}
+				if ((!FIXREVERTER[45] && (a6p == (void *) 0 ))
+				#else
+				if (0
+				#endif
+				) {
 					return (0);
 				}
+				#ifdef FRCOV
+				}
+				#endif
 				sin6 = (struct sockaddr_in6 *)sa;
 #ifdef SCTP_EMBEDDED_V6_SCOPE
 				if (IN6_IS_SCOPE_LINKLOCAL(&sin6->sin6_addr)) {
@@ -3009,9 +3598,24 @@ sctp_addr_in_initack(struct mbuf *m, uint32_t offset, uint32_t length, struct so
 				      sctp_m_getptr(m, offset,
 				                    sizeof(struct sctp_ipv4addr_param),
 				                    (uint8_t *)&addr4_store);
-				if (a4p == NULL) {
+				
+				#ifdef FRCOV
+				{if (FIXREVERTER[46]) {
+				  if ((a4p == (void *) 0 ) && !(0))
+				    fprintf(stderr, "triggered bug index 46\n");
+				  else
+				    fprintf(stderr, "reached bug index 46\n");
+				}
+				if ((!FIXREVERTER[46] && (a4p == (void *) 0 ))
+				#else
+				if (0
+				#endif
+				) {
 					return (0);
 				}
+				#ifdef FRCOV
+				}
+				#endif
 				sin = (struct sockaddr_in *)sa;
 				if (sin->sin_addr.s_addr == a4p->addr) {
 					/* found it */
@@ -3050,15 +3654,45 @@ sctp_check_address_list_ep(struct sctp_tcb *stcb, struct mbuf *m, int offset,
 	/* go through the endpoint list */
 	LIST_FOREACH(laddr, &stcb->sctp_ep->sctp_addr_list, sctp_nxt_addr) {
 		/* be paranoid and validate the laddr */
-		if (laddr->ifa == NULL) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[47]) {
+		  if ((laddr -> ifa == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 47\n");
+		  else
+		    fprintf(stderr, "reached bug index 47\n");
+		}
+		if ((!FIXREVERTER[47] && (laddr -> ifa == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		) {
 			SCTPDBG(SCTP_DEBUG_ASCONF1,
 				"check_addr_list_ep: laddr->ifa is NULL");
 			continue;
 		}
-		if (laddr->ifa == NULL) {
+		#ifdef FRCOV
+		}
+		#endif
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[48]) {
+		  if ((laddr -> ifa == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 48\n");
+		  else
+		    fprintf(stderr, "reached bug index 48\n");
+		}
+		if ((!FIXREVERTER[48] && (laddr -> ifa == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		) {
 			SCTPDBG(SCTP_DEBUG_ASCONF1, "check_addr_list_ep: laddr->ifa->ifa_addr is NULL");
 			continue;
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		/* do i have it implicitly? */
 		if (sctp_cmpaddr(&laddr->ifa->address.sa, init_addr)) {
 			continue;
@@ -3100,10 +3734,25 @@ sctp_check_address_list_all(struct sctp_tcb *stcb, struct mbuf *m, int offset,
 	}
 	SCTP_IPI_ADDR_RLOCK();
 	vrf = sctp_find_vrf(vrf_id);
-	if (vrf == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[49]) {
+	  if ((vrf == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 49\n");
+	  else
+	    fprintf(stderr, "reached bug index 49\n");
+	}
+	if ((!FIXREVERTER[49] && (vrf == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		SCTP_IPI_ADDR_RUNLOCK();
 		return;
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	/* go through all our known interfaces */
 	LIST_FOREACH(sctp_ifn, &vrf->ifnlist, next_ifn) {
 		if (loopback_scope == 0 && SCTP_IFN_IS_IFT_LOOP(sctp_ifn)) {
@@ -3231,11 +3880,26 @@ sctp_addr_mgmt_ep_sa(struct sctp_inpcb *inp, struct sockaddr *sa,
 		if (type == SCTP_ADD_IP_ADDRESS) {
 			sctp_add_local_addr_ep(inp, ifa, type);
 		} else if (type == SCTP_DEL_IP_ADDRESS) {
-			if (inp->laddr_count < 2) {
+			
+			#ifdef FRCOV
+			{if (FIXREVERTER[50]) {
+			  if ((inp -> laddr_count < 2 ) && !(0))
+			    fprintf(stderr, "triggered bug index 50\n");
+			  else
+			    fprintf(stderr, "reached bug index 50\n");
+			}
+			if ((!FIXREVERTER[50] && (inp -> laddr_count < 2 ))
+			#else
+			if (0
+			#endif
+			) {
 				/* can't delete the last local address */
 				SCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_ASCONF, EINVAL);
 				return (EINVAL);
 			}
+			#ifdef FRCOV
+			}
+			#endif
 			LIST_FOREACH(laddr, &inp->sctp_addr_list,
 				     sctp_nxt_addr) {
 				if (ifa == laddr->ifa) {
@@ -3264,16 +3928,46 @@ sctp_addr_mgmt_ep_sa(struct sctp_inpcb *inp, struct sockaddr *sa,
 			SCTP_MALLOC(asc, struct sctp_asconf_iterator *,
 			            sizeof(struct sctp_asconf_iterator),
 			            SCTP_M_ASC_IT);
-			if (asc == NULL) {
+			
+			#ifdef FRCOV
+			{if (FIXREVERTER[51]) {
+			  if ((asc == (void *) 0 ) && !(0))
+			    fprintf(stderr, "triggered bug index 51\n");
+			  else
+			    fprintf(stderr, "reached bug index 51\n");
+			}
+			if ((!FIXREVERTER[51] && (asc == (void *) 0 ))
+			#else
+			if (0
+			#endif
+			) {
 				SCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_ASCONF, ENOMEM);
 				return (ENOMEM);
 			}
+			#ifdef FRCOV
+			}
+			#endif
 			wi = SCTP_ZONE_GET(SCTP_BASE_INFO(ipi_zone_laddr), struct sctp_laddr);
-			if (wi == NULL) {
+			
+			#ifdef FRCOV
+			{if (FIXREVERTER[52]) {
+			  if ((wi == (void *) 0 ) && !(0))
+			    fprintf(stderr, "triggered bug index 52\n");
+			  else
+			    fprintf(stderr, "reached bug index 52\n");
+			}
+			if ((!FIXREVERTER[52] && (wi == (void *) 0 ))
+			#else
+			if (0
+			#endif
+			) {
 				SCTP_FREE(asc, SCTP_M_ASC_IT);
 				SCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_ASCONF, ENOMEM);
 				return (ENOMEM);
 			}
+			#ifdef FRCOV
+			}
+			#endif
 			LIST_INIT(&asc->list_of_work);
 			asc->cnt = 1;
 			SCTP_INCR_LADDR_COUNT();
@@ -3317,14 +4011,44 @@ sctp_asconf_send_nat_state_update(struct sctp_tcb *stcb,
 #ifdef INET6
 	struct sockaddr_in6 *to6;
 #endif
-	if (net == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[53]) {
+	  if ((net == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 53\n");
+	  else
+	    fprintf(stderr, "reached bug index 53\n");
+	}
+	if ((!FIXREVERTER[53] && (net == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		SCTPDBG(SCTP_DEBUG_ASCONF1, "sctp_asconf_send_nat_state_update: Missing net\n");
 		return;
 	}
-	if (stcb == NULL) {
+	#ifdef FRCOV
+	}
+	#endif
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[54]) {
+	  if ((stcb == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 54\n");
+	  else
+	    fprintf(stderr, "reached bug index 54\n");
+	}
+	if ((!FIXREVERTER[54] && (stcb == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		SCTPDBG(SCTP_DEBUG_ASCONF1, "sctp_asconf_send_nat_state_update: Missing stcb\n");
 		return;
 	}
+	#ifdef FRCOV
+	}
+	#endif
   /* Need to have in the asconf:
    * - vtagparam(my_vtag/peer_vtag)
    * - add(0.0.0.0)
@@ -3333,12 +4057,27 @@ sctp_asconf_send_nat_state_update(struct sctp_tcb *stcb,
    */
 	SCTP_MALLOC(aa, struct sctp_asconf_addr *, sizeof(*aa),
 	            SCTP_M_ASC_ADDR);
-	if (aa == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[55]) {
+	  if ((aa == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 55\n");
+	  else
+	    fprintf(stderr, "reached bug index 55\n");
+	}
+	if ((!FIXREVERTER[55] && (aa == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		/* didn't get memory */
 		SCTPDBG(SCTP_DEBUG_ASCONF1,
 		        "sctp_asconf_send_nat_state_update: failed to get memory!\n");
 		return;
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	aa->special_del = 0;
 	/* fill in asconf address parameter fields */
 	/* top level elements are "networked" during send */
@@ -3353,12 +4092,27 @@ sctp_asconf_send_nat_state_update(struct sctp_tcb *stcb,
 
 	SCTP_MALLOC(aa, struct sctp_asconf_addr *, sizeof(*aa),
 	            SCTP_M_ASC_ADDR);
-	if (aa == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[56]) {
+	  if ((aa == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 56\n");
+	  else
+	    fprintf(stderr, "reached bug index 56\n");
+	}
+	if ((!FIXREVERTER[56] && (aa == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		/* didn't get memory */
 		SCTPDBG(SCTP_DEBUG_ASCONF1,
 		        "sctp_asconf_send_nat_state_update: failed to get memory!\n");
 		return;
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	memset(aa, 0, sizeof(struct sctp_asconf_addr));
 	/* fill in asconf address parameter fields */
 	/* ADD(0.0.0.0) */
@@ -3391,12 +4145,27 @@ sctp_asconf_send_nat_state_update(struct sctp_tcb *stcb,
 	}
 	SCTP_MALLOC(aa, struct sctp_asconf_addr *, sizeof(*aa),
 	            SCTP_M_ASC_ADDR);
-	if (aa == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[57]) {
+	  if ((aa == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 57\n");
+	  else
+	    fprintf(stderr, "reached bug index 57\n");
+	}
+	if ((!FIXREVERTER[57] && (aa == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		/* didn't get memory */
 		SCTPDBG(SCTP_DEBUG_ASCONF1,
 		        "sctp_asconf_send_nat_state_update: failed to get memory!\n");
 		return;
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	memset(aa, 0, sizeof(struct sctp_asconf_addr));
 	/* fill in asconf address parameter fields */
 	/* ADD(0.0.0.0) */
@@ -3435,9 +4204,24 @@ sctp_asconf_send_nat_state_update(struct sctp_tcb *stcb,
 
 		vrf_id = stcb->sctp_ep->def_vrf_id;
 		vrf = sctp_find_vrf(vrf_id);
-		if (vrf == NULL) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[58]) {
+		  if ((vrf == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 58\n");
+		  else
+		    fprintf(stderr, "reached bug index 58\n");
+		}
+		if ((!FIXREVERTER[58] && (vrf == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		) {
 			goto skip_rest;
 		}
+		#ifdef FRCOV
+		}
+		#endif
 
 		SCTP_IPI_ADDR_RLOCK();
 		LIST_FOREACH(sctp_ifnp, &vrf->ifnlist, next_ifn) {
@@ -3488,20 +4272,50 @@ sctp_asconf_send_nat_state_update(struct sctp_tcb *stcb,
 		struct sctp_laddr *laddr;
 
 		LIST_FOREACH(laddr, &stcb->sctp_ep->sctp_addr_list, sctp_nxt_addr) {
-			if (laddr->ifa == NULL) {
+			
+			#ifdef FRCOV
+			{if (FIXREVERTER[59]) {
+			  if ((laddr -> ifa == (void *) 0 ) && !(0))
+			    fprintf(stderr, "triggered bug index 59\n");
+			  else
+			    fprintf(stderr, "reached bug index 59\n");
+			}
+			if ((!FIXREVERTER[59] && (laddr -> ifa == (void *) 0 ))
+			#else
+			if (0
+			#endif
+			) {
 				continue;
 			}
+			#ifdef FRCOV
+			}
+			#endif
 			if (laddr->ifa->localifa_flags & SCTP_BEING_DELETED)
 				/* Address being deleted by the system, dont
 				 * list.
 				 */
 				continue;
-			if (laddr->action == SCTP_DEL_IP_ADDRESS) {
+			
+			#ifdef FRCOV
+			{if (FIXREVERTER[60]) {
+			  if ((laddr -> action == 49154 ) && !(0))
+			    fprintf(stderr, "triggered bug index 60\n");
+			  else
+			    fprintf(stderr, "reached bug index 60\n");
+			}
+			if ((!FIXREVERTER[60] && (laddr -> action == 49154 ))
+			#else
+			if (0
+			#endif
+			) {
 				/* Address being deleted on this ep
 				 * don't list.
 				 */
 				continue;
 			}
+			#ifdef FRCOV
+			}
+			#endif
 			sctp_ifap = laddr->ifa;
 			switch (sctp_ifap->address.sa.sa_family) {
 #ifdef INET
diff --git a/usrsctplib/netinet/sctp_auth.c b/usrsctplib/netinet/sctp_auth.c
index 604e6c7d..de10f78f 100755
--- a/usrsctplib/netinet/sctp_auth.c
+++ b/usrsctplib/netinet/sctp_auth.c
@@ -1,3 +1,7 @@
+#ifdef FRCOV
+#include <stdio.h>
+extern short FIXREVERTER[];
+#endif
 /*-
  * SPDX-License-Identifier: BSD-3-Clause
  *
@@ -88,13 +92,43 @@ sctp_copy_chunklist(sctp_auth_chklist_t *list)
 {
 	sctp_auth_chklist_t *new_list;
 
-	if (list == NULL)
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[526]) {
+	  if ((list == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 526\n");
+	  else
+	    fprintf(stderr, "reached bug index 526\n");
+	}
+	if ((!FIXREVERTER[526] && (list == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	)
 		return (NULL);
+		#ifdef FRCOV
+		}
+		#endif
 
 	/* get a new list */
 	new_list = sctp_alloc_chunklist();
-	if (new_list == NULL)
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[527]) {
+	  if ((new_list == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 527\n");
+	  else
+	    fprintf(stderr, "reached bug index 527\n");
+	}
+	if ((!FIXREVERTER[527] && (new_list == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	)
 		return (NULL);
+		#ifdef FRCOV
+		}
+		#endif
 	/* copy it */
 	memcpy(new_list, list, sizeof(*new_list));
 
@@ -108,8 +142,23 @@ sctp_copy_chunklist(sctp_auth_chklist_t *list)
 int
 sctp_auth_add_chunk(uint8_t chunk, sctp_auth_chklist_t *list)
 {
-	if (list == NULL)
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[528]) {
+	  if ((list == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 528\n");
+	  else
+	    fprintf(stderr, "reached bug index 528\n");
+	}
+	if ((!FIXREVERTER[528] && (list == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	)
 		return (-1);
+		#ifdef FRCOV
+		}
+		#endif
 
 	/* is chunk restricted? */
 	if ((chunk == SCTP_INITIATION) ||
@@ -134,8 +183,23 @@ sctp_auth_add_chunk(uint8_t chunk, sctp_auth_chklist_t *list)
 int
 sctp_auth_delete_chunk(uint8_t chunk, sctp_auth_chklist_t *list)
 {
-	if (list == NULL)
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[529]) {
+	  if ((list == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 529\n");
+	  else
+	    fprintf(stderr, "reached bug index 529\n");
+	}
+	if ((!FIXREVERTER[529] && (list == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	)
 		return (-1);
+		#ifdef FRCOV
+		}
+		#endif
 
 	if (list->chunks[chunk] == 1) {
 		list->chunks[chunk] = 0;
@@ -165,8 +229,23 @@ sctp_serialize_auth_chunks(const sctp_auth_chklist_t *list, uint8_t *ptr)
 {
 	int i, count = 0;
 
-	if (list == NULL)
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[530]) {
+	  if ((list == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 530\n");
+	  else
+	    fprintf(stderr, "reached bug index 530\n");
+	}
+	if ((!FIXREVERTER[530] && (list == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	)
 		return (0);
+		#ifdef FRCOV
+		}
+		#endif
 
 	for (i = 0; i < 256; i++) {
 		if (list->chunks[i] != 0) {
@@ -252,10 +331,25 @@ sctp_alloc_key(uint32_t keylen)
 
 	SCTP_MALLOC(new_key, sctp_key_t *, sizeof(*new_key) + keylen,
 		    SCTP_M_AUTH_KY);
-	if (new_key == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[533]) {
+	  if ((new_key == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 533\n");
+	  else
+	    fprintf(stderr, "reached bug index 533\n");
+	}
+	if ((!FIXREVERTER[533] && (new_key == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		/* out of memory */
 		return (NULL);
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	new_key->keylen = keylen;
 	return (new_key);
 }
@@ -338,10 +432,25 @@ sctp_set_key(uint8_t *key, uint32_t keylen)
 	sctp_key_t *new_key;
 
 	new_key = sctp_alloc_key(keylen);
-	if (new_key == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[537]) {
+	  if ((new_key == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 537\n");
+	  else
+	    fprintf(stderr, "reached bug index 537\n");
+	}
+	if ((!FIXREVERTER[537] && (new_key == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		/* out of memory */
 		return (NULL);
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	memcpy(new_key->key, key, keylen);
 	return (new_key);
 }
@@ -416,10 +525,25 @@ sctp_compute_hashkey(sctp_key_t *key1, sctp_key_t *key2, sctp_key_t *shared)
 	if (keylen > 0) {
 		/* get space for the new key */
 		new_key = sctp_alloc_key(keylen);
-		if (new_key == NULL) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[539]) {
+		  if ((new_key == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 539\n");
+		  else
+		    fprintf(stderr, "reached bug index 539\n");
+		}
+		if ((!FIXREVERTER[539] && (new_key == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		) {
 			/* out of memory */
 			return (NULL);
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		new_key->keylen = keylen;
 		key_ptr = new_key->key;
 	} else {
@@ -466,10 +590,25 @@ sctp_alloc_sharedkey(void)
 
 	SCTP_MALLOC(new_key, sctp_sharedkey_t *, sizeof(*new_key),
 		    SCTP_M_AUTH_KY);
-	if (new_key == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[540]) {
+	  if ((new_key == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 540\n");
+	  else
+	    fprintf(stderr, "reached bug index 540\n");
+	}
+	if ((!FIXREVERTER[540] && (new_key == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		/* out of memory */
 		return (NULL);
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	new_key->keyid = 0;
 	new_key->key = NULL;
 	new_key->refcount = 1;
@@ -480,8 +619,23 @@ sctp_alloc_sharedkey(void)
 void
 sctp_free_sharedkey(sctp_sharedkey_t *skey)
 {
-	if (skey == NULL)
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[541]) {
+	  if ((skey == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 541\n");
+	  else
+	    fprintf(stderr, "reached bug index 541\n");
+	}
+	if ((!FIXREVERTER[541] && (skey == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	)
 		return;
+		#ifdef FRCOV
+		}
+		#endif
 
 	if (SCTP_DECREMENT_AND_CHECK_REFCOUNT(&skey->refcount)) {
 		if (skey->key != NULL)
@@ -496,8 +650,23 @@ sctp_find_sharedkey(struct sctp_keyhead *shared_keys, uint16_t key_id)
 	sctp_sharedkey_t *skey;
 
 	LIST_FOREACH(skey, shared_keys, next) {
-		if (skey->keyid == key_id)
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[542]) {
+		  if ((skey -> keyid == key_id ) && !(0))
+		    fprintf(stderr, "triggered bug index 542\n");
+		  else
+		    fprintf(stderr, "reached bug index 542\n");
+		}
+		if ((!FIXREVERTER[542] && (skey -> keyid == key_id ))
+		#else
+		if (0
+		#endif
+		)
 			return (skey);
+			#ifdef FRCOV
+			}
+			#endif
 	}
 	return (NULL);
 }
@@ -508,8 +677,23 @@ sctp_insert_sharedkey(struct sctp_keyhead *shared_keys,
 {
 	sctp_sharedkey_t *skey;
 
-	if ((shared_keys == NULL) || (new_skey == NULL))
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[543]) {
+	  if ((shared_keys == (void *) 0 || new_skey == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 543\n");
+	  else
+	    fprintf(stderr, "reached bug index 543\n");
+	}
+	if ((!FIXREVERTER[543] && (shared_keys == (void *) 0 || new_skey == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	)
 		return (EINVAL);
+		#ifdef FRCOV
+		}
+		#endif
 
 	/* insert into an empty list? */
 	if (LIST_EMPTY(shared_keys)) {
@@ -602,11 +786,41 @@ sctp_copy_sharedkey(const sctp_sharedkey_t *skey)
 {
 	sctp_sharedkey_t *new_skey;
 
-	if (skey == NULL)
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[545]) {
+	  if ((skey == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 545\n");
+	  else
+	    fprintf(stderr, "reached bug index 545\n");
+	}
+	if ((!FIXREVERTER[545] && (skey == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	)
 		return (NULL);
+		#ifdef FRCOV
+		}
+		#endif
 	new_skey = sctp_alloc_sharedkey();
-	if (new_skey == NULL)
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[546]) {
+	  if ((new_skey == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 546\n");
+	  else
+	    fprintf(stderr, "reached bug index 546\n");
+	}
+	if ((!FIXREVERTER[546] && (new_skey == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	)
 		return (NULL);
+		#ifdef FRCOV
+		}
+		#endif
 	if (skey->key != NULL)
 		new_skey->key = sctp_set_key(skey->key->key, skey->key->keylen);
 	else
@@ -621,8 +835,23 @@ sctp_copy_skeylist(const struct sctp_keyhead *src, struct sctp_keyhead *dest)
 	sctp_sharedkey_t *skey, *new_skey;
 	int count = 0;
 
-	if ((src == NULL) || (dest == NULL))
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[547]) {
+	  if ((src == (void *) 0 || dest == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 547\n");
+	  else
+	    fprintf(stderr, "reached bug index 547\n");
+	}
+	if ((!FIXREVERTER[547] && (src == (void *) 0 || dest == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	)
 		return (0);
+		#ifdef FRCOV
+		}
+		#endif
 	LIST_FOREACH(skey, src, next) {
 		new_skey = sctp_copy_sharedkey(skey);
 		if (new_skey != NULL) {
@@ -646,10 +875,25 @@ sctp_alloc_hmaclist(uint16_t num_hmacs)
 	alloc_size = sizeof(*new_list) + num_hmacs * sizeof(new_list->hmac[0]);
 	SCTP_MALLOC(new_list, sctp_hmaclist_t *, alloc_size,
 		    SCTP_M_AUTH_HL);
-	if (new_list == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[548]) {
+	  if ((new_list == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 548\n");
+	  else
+	    fprintf(stderr, "reached bug index 548\n");
+	}
+	if ((!FIXREVERTER[548] && (new_list == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		/* out of memory */
 		return (NULL);
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	new_list->max_algo = num_hmacs;
 	new_list->num_algo = 0;
 	return (new_list);
@@ -668,21 +912,66 @@ int
 sctp_auth_add_hmacid(sctp_hmaclist_t *list, uint16_t hmac_id)
 {
 	int i;
-	if (list == NULL)
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[549]) {
+	  if ((list == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 549\n");
+	  else
+	    fprintf(stderr, "reached bug index 549\n");
+	}
+	if ((!FIXREVERTER[549] && (list == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	)
 		return (-1);
-	if (list->num_algo == list->max_algo) {
+		#ifdef FRCOV
+		}
+		#endif
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[550]) {
+	  if ((list -> num_algo == list -> max_algo ) && !(0))
+	    fprintf(stderr, "triggered bug index 550\n");
+	  else
+	    fprintf(stderr, "reached bug index 550\n");
+	}
+	if ((!FIXREVERTER[550] && (list -> num_algo == list -> max_algo ))
+	#else
+	if (0
+	#endif
+	) {
 		SCTPDBG(SCTP_DEBUG_AUTH1,
 			"SCTP: HMAC id list full, ignoring add %u\n", hmac_id);
 		return (-1);
 	}
+	#ifdef FRCOV
+	}
+	#endif
 #if defined(SCTP_SUPPORT_HMAC_SHA256)
 	if ((hmac_id != SCTP_AUTH_HMAC_ID_SHA1) &&
 	    (hmac_id != SCTP_AUTH_HMAC_ID_SHA256)) {
 #else
-	if (hmac_id != SCTP_AUTH_HMAC_ID_SHA1) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[551]) {
+	  if ((hmac_id != 1 ) && !(0))
+	    fprintf(stderr, "triggered bug index 551\n");
+	  else
+	    fprintf(stderr, "reached bug index 551\n");
+	}
+	if ((!FIXREVERTER[551] && (hmac_id != 1 ))
+	#else
+	if (0
+	#endif
+	) {
 #endif
 		return (-1);
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	/* Now is it already in the list */
 	for (i = 0; i < list->num_algo; i++) {
 		if (list->hmac[i] == hmac_id) {
@@ -701,12 +990,42 @@ sctp_copy_hmaclist(sctp_hmaclist_t *list)
 	sctp_hmaclist_t *new_list;
 	int i;
 
-	if (list == NULL)
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[552]) {
+	  if ((list == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 552\n");
+	  else
+	    fprintf(stderr, "reached bug index 552\n");
+	}
+	if ((!FIXREVERTER[552] && (list == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	)
 		return (NULL);
+		#ifdef FRCOV
+		}
+		#endif
 	/* get a new list */
 	new_list = sctp_alloc_hmaclist(list->max_algo);
-	if (new_list == NULL)
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[553]) {
+	  if ((new_list == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 553\n");
+	  else
+	    fprintf(stderr, "reached bug index 553\n");
+	}
+	if ((!FIXREVERTER[553] && (new_list == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	)
 		return (NULL);
+		#ifdef FRCOV
+		}
+		#endif
 	/* copy it */
 	new_list->max_algo = list->max_algo;
 	new_list->num_algo = list->num_algo;
@@ -725,8 +1044,23 @@ sctp_default_supported_hmaclist(void)
 #else
 	new_list = sctp_alloc_hmaclist(1);
 #endif
-	if (new_list == NULL)
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[554]) {
+	  if ((new_list == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 554\n");
+	  else
+	    fprintf(stderr, "reached bug index 554\n");
+	}
+	if ((!FIXREVERTER[554] && (new_list == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	)
 		return (NULL);
+		#ifdef FRCOV
+		}
+		#endif
 #if defined(SCTP_SUPPORT_HMAC_SHA256)
 	/* We prefer SHA256, so list it first */
 	(void)sctp_auth_add_hmacid(new_list, SCTP_AUTH_HMAC_ID_SHA256);
@@ -744,8 +1078,23 @@ sctp_negotiate_hmacid(sctp_hmaclist_t *peer, sctp_hmaclist_t *local)
 {
 	int i, j;
 
-	if ((local == NULL) || (peer == NULL))
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[555]) {
+	  if ((local == (void *) 0 || peer == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 555\n");
+	  else
+	    fprintf(stderr, "reached bug index 555\n");
+	}
+	if ((!FIXREVERTER[555] && (local == (void *) 0 || peer == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	)
 		return (SCTP_AUTH_HMAC_ID_RSVD);
+		#ifdef FRCOV
+		}
+		#endif
 
 	for (i = 0; i < peer->num_algo; i++) {
 		for (j = 0; j < local->num_algo; j++) {
@@ -772,8 +1121,23 @@ sctp_serialize_hmaclist(sctp_hmaclist_t *list, uint8_t *ptr)
 	int i;
 	uint16_t hmac_id;
 
-	if (list == NULL)
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[556]) {
+	  if ((list == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 556\n");
+	  else
+	    fprintf(stderr, "reached bug index 556\n");
+	}
+	if ((!FIXREVERTER[556] && (list == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	)
 		return (0);
+		#ifdef FRCOV
+		}
+		#endif
 
 	for (i = 0; i < list->num_algo; i++) {
 		hmac_id = htons(list->hmac[i]);
@@ -815,8 +1179,23 @@ sctp_alloc_authinfo(void)
 void
 sctp_free_authinfo(sctp_authinfo_t *authinfo)
 {
-	if (authinfo == NULL)
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[558]) {
+	  if ((authinfo == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 558\n");
+	  else
+	    fprintf(stderr, "reached bug index 558\n");
+	}
+	if ((!FIXREVERTER[558] && (authinfo == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	)
 		return;
+		#ifdef FRCOV
+		}
+		#endif
 
 	if (authinfo->random != NULL)
 		sctp_free_key(authinfo->random);
@@ -958,15 +1337,44 @@ sctp_hmac(uint16_t hmac_algo, uint8_t *key, uint32_t keylen,
 	uint32_t i;
 
 	/* sanity check the material and length */
-	if ((key == NULL) || (keylen == 0) || (text == NULL) ||
-	    (textlen == 0) || (digest == NULL)) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[559]) {
+	  if ((key == (void *) 0 || keylen == 0 || text == (void *) 0 || textlen == 0 || digest == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 559\n");
+	  else
+	    fprintf(stderr, "reached bug index 559\n");
+	}
+	if ((!FIXREVERTER[559] && (key == (void *) 0 || keylen == 0 || text == (void *) 0 || textlen == 0 || digest == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		/* can't do HMAC with empty key or text or digest store */
 		return (0);
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	/* validate the hmac algo and get the digest length */
 	digestlen = sctp_get_hmac_digest_len(hmac_algo);
-	if (digestlen == 0)
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[560]) {
+	  if ((digestlen == 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 560\n");
+	  else
+	    fprintf(stderr, "reached bug index 560\n");
+	}
+	if ((!FIXREVERTER[560] && (digestlen == 0 ))
+	#else
+	if (0
+	#endif
+	)
 		return (0);
+		#ifdef FRCOV
+		}
+		#endif
 
 	/* hash the key if it is longer than the hash block size */
 	blocklen = sctp_get_hmac_block_len(hmac_algo);
@@ -1019,14 +1427,44 @@ sctp_hmac_m(uint16_t hmac_algo, uint8_t *key, uint32_t keylen,
 	struct mbuf *m_tmp;
 
 	/* sanity check the material and length */
-	if ((key == NULL) || (keylen == 0) || (m == NULL) || (digest == NULL)) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[561]) {
+	  if ((key == (void *) 0 || keylen == 0 || m == (void *) 0 || digest == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 561\n");
+	  else
+	    fprintf(stderr, "reached bug index 561\n");
+	}
+	if ((!FIXREVERTER[561] && (key == (void *) 0 || keylen == 0 || m == (void *) 0 || digest == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		/* can't do HMAC with empty key or text or digest store */
 		return (0);
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	/* validate the hmac algo and get the digest length */
 	digestlen = sctp_get_hmac_digest_len(hmac_algo);
-	if (digestlen == 0)
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[562]) {
+	  if ((digestlen == 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 562\n");
+	  else
+	    fprintf(stderr, "reached bug index 562\n");
+	}
+	if ((!FIXREVERTER[562] && (digestlen == 0 ))
+	#else
+	if (0
+	#endif
+	)
 		return (0);
+		#ifdef FRCOV
+		}
+		#endif
 
 	/* hash the key if it is longer than the hash block size */
 	blocklen = sctp_get_hmac_block_len(hmac_algo);
@@ -1133,14 +1571,44 @@ sctp_compute_hmac_m(uint16_t hmac_algo, sctp_key_t *key, struct mbuf *m,
 	uint8_t temp[SCTP_AUTH_DIGEST_LEN_MAX];
 
 	/* sanity check */
-	if ((key == NULL) || (m == NULL) || (digest == NULL)) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[565]) {
+	  if ((key == (void *) 0 || m == (void *) 0 || digest == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 565\n");
+	  else
+	    fprintf(stderr, "reached bug index 565\n");
+	}
+	if ((!FIXREVERTER[565] && (key == (void *) 0 || m == (void *) 0 || digest == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		/* can't do HMAC with empty key or text or digest store */
 		return (0);
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	/* validate the hmac algo and get the digest length */
 	digestlen = sctp_get_hmac_digest_len(hmac_algo);
-	if (digestlen == 0)
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[566]) {
+	  if ((digestlen == 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 566\n");
+	  else
+	    fprintf(stderr, "reached bug index 566\n");
+	}
+	if ((!FIXREVERTER[566] && (digestlen == 0 ))
+	#else
+	if (0
+	#endif
+	)
 		return (0);
+		#ifdef FRCOV
+		}
+		#endif
 
 	/* hash the key if it is longer than the hash block size */
 	blocklen = sctp_get_hmac_block_len(hmac_algo);
@@ -1160,8 +1628,23 @@ sctp_auth_is_supported_hmac(sctp_hmaclist_t *list, uint16_t id)
 {
 	int i;
 
-	if ((list == NULL) || (id == SCTP_AUTH_HMAC_ID_RSVD))
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[567]) {
+	  if ((list == (void *) 0 ) && !(id == 0 ))
+	    fprintf(stderr, "triggered bug index 567\n");
+	  else
+	    fprintf(stderr, "reached bug index 567\n");
+	}
+	if ((FIXREVERTER[567] && (id == 0 )) || (!FIXREVERTER[567] && (list == (void *) 0 || id == 0 ))
+	#else
+	if (id == 0 
+	#endif
+	)
 		return (0);
+		#ifdef FRCOV
+		}
+		#endif
 
 	for (i = 0; i < list->num_algo; i++)
 		if (list->hmac[i] == id)
@@ -1180,8 +1663,23 @@ sctp_auth_is_supported_hmac(sctp_hmaclist_t *list, uint16_t id)
 void
 sctp_clear_cachedkeys(struct sctp_tcb *stcb, uint16_t keyid)
 {
-	if (stcb == NULL)
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[568]) {
+	  if ((stcb == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 568\n");
+	  else
+	    fprintf(stderr, "reached bug index 568\n");
+	}
+	if ((!FIXREVERTER[568] && (stcb == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	)
 		return;
+		#ifdef FRCOV
+		}
+		#endif
 
 	if (keyid == stcb->asoc.authinfo.assoc_keyid) {
 		sctp_free_key(stcb->asoc.authinfo.assoc_key);
@@ -1203,8 +1701,23 @@ sctp_clear_cachedkeys_ep(struct sctp_inpcb *inp, uint16_t keyid)
 {
 	struct sctp_tcb *stcb;
 
-	if (inp == NULL)
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[569]) {
+	  if ((inp == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 569\n");
+	  else
+	    fprintf(stderr, "reached bug index 569\n");
+	}
+	if ((!FIXREVERTER[569] && (inp == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	)
 		return;
+		#ifdef FRCOV
+		}
+		#endif
 
 	/* clear the cached keys on all assocs on this instance */
 	LIST_FOREACH(stcb, &inp->sctp_asoc_list, sctp_tcblist) {
@@ -1223,8 +1736,23 @@ sctp_delete_sharedkey(struct sctp_tcb *stcb, uint16_t keyid)
 {
 	sctp_sharedkey_t *skey;
 
-	if (stcb == NULL)
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[570]) {
+	  if ((stcb == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 570\n");
+	  else
+	    fprintf(stderr, "reached bug index 570\n");
+	}
+	if ((!FIXREVERTER[570] && (stcb == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	)
 		return (-1);
+		#ifdef FRCOV
+		}
+		#endif
 
 	/* is the keyid the assoc active sending key */
 	if (keyid == stcb->asoc.authinfo.active_keyid)
@@ -1232,12 +1760,42 @@ sctp_delete_sharedkey(struct sctp_tcb *stcb, uint16_t keyid)
 
 	/* does the key exist? */
 	skey = sctp_find_sharedkey(&stcb->asoc.shared_keys, keyid);
-	if (skey == NULL)
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[571]) {
+	  if ((skey == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 571\n");
+	  else
+	    fprintf(stderr, "reached bug index 571\n");
+	}
+	if ((!FIXREVERTER[571] && (skey == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	)
 		return (-1);
+		#ifdef FRCOV
+		}
+		#endif
 
 	/* are there other refcount holders on the key? */
-	if (skey->refcount > 1)
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[572]) {
+	  if ((skey -> refcount > 1 ) && !(0))
+	    fprintf(stderr, "triggered bug index 572\n");
+	  else
+	    fprintf(stderr, "reached bug index 572\n");
+	}
+	if ((!FIXREVERTER[572] && (skey -> refcount > 1 ))
+	#else
+	if (0
+	#endif
+	)
 		return (-1);
+		#ifdef FRCOV
+		}
+		#endif
 
 	/* remove it */
 	LIST_REMOVE(skey, next);
@@ -1257,8 +1815,23 @@ sctp_delete_sharedkey_ep(struct sctp_inpcb *inp, uint16_t keyid)
 {
 	sctp_sharedkey_t *skey;
 
-	if (inp == NULL)
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[573]) {
+	  if ((inp == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 573\n");
+	  else
+	    fprintf(stderr, "reached bug index 573\n");
+	}
+	if ((!FIXREVERTER[573] && (inp == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	)
 		return (-1);
+		#ifdef FRCOV
+		}
+		#endif
 
 	/* is the keyid the active sending key on the endpoint */
 	if (keyid == inp->sctp_ep.default_keyid)
@@ -1266,8 +1839,23 @@ sctp_delete_sharedkey_ep(struct sctp_inpcb *inp, uint16_t keyid)
 
 	/* does the key exist? */
 	skey = sctp_find_sharedkey(&inp->sctp_ep.shared_keys, keyid);
-	if (skey == NULL)
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[574]) {
+	  if ((skey == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 574\n");
+	  else
+	    fprintf(stderr, "reached bug index 574\n");
+	}
+	if ((!FIXREVERTER[574] && (skey == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	)
 		return (-1);
+		#ifdef FRCOV
+		}
+		#endif
 
 	/* endpoint keys are not refcounted */
 
@@ -1291,10 +1879,25 @@ sctp_auth_setactivekey(struct sctp_tcb *stcb, uint16_t keyid)
 
 	/* find the key on the assoc */
 	skey = sctp_find_sharedkey(&stcb->asoc.shared_keys, keyid);
-	if (skey == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[575]) {
+	  if ((skey == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 575\n");
+	  else
+	    fprintf(stderr, "reached bug index 575\n");
+	}
+	if ((!FIXREVERTER[575] && (skey == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		/* that key doesn't exist */
 		return (-1);
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	if ((skey->deactivated) && (skey->refcount > 1)) {
 		/* can't reactivate a deactivated key with other refcounts */
 		return (-1);
@@ -1319,10 +1922,25 @@ sctp_auth_setactivekey_ep(struct sctp_inpcb *inp, uint16_t keyid)
 
 	/* find the key */
 	skey = sctp_find_sharedkey(&inp->sctp_ep.shared_keys, keyid);
-	if (skey == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[576]) {
+	  if ((skey == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 576\n");
+	  else
+	    fprintf(stderr, "reached bug index 576\n");
+	}
+	if ((!FIXREVERTER[576] && (skey == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		/* that key doesn't exist */
 		return (-1);
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	inp->sctp_ep.default_keyid = keyid;
 	return (0);
 }
@@ -1336,8 +1954,23 @@ sctp_deact_sharedkey(struct sctp_tcb *stcb, uint16_t keyid)
 {
 	sctp_sharedkey_t *skey;
 
-	if (stcb == NULL)
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[577]) {
+	  if ((stcb == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 577\n");
+	  else
+	    fprintf(stderr, "reached bug index 577\n");
+	}
+	if ((!FIXREVERTER[577] && (stcb == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	)
 		return (-1);
+		#ifdef FRCOV
+		}
+		#endif
 
 	/* is the keyid the assoc active sending key */
 	if (keyid == stcb->asoc.authinfo.active_keyid)
@@ -1345,8 +1978,23 @@ sctp_deact_sharedkey(struct sctp_tcb *stcb, uint16_t keyid)
 
 	/* does the key exist? */
 	skey = sctp_find_sharedkey(&stcb->asoc.shared_keys, keyid);
-	if (skey == NULL)
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[578]) {
+	  if ((skey == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 578\n");
+	  else
+	    fprintf(stderr, "reached bug index 578\n");
+	}
+	if ((!FIXREVERTER[578] && (skey == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	)
 		return (-1);
+		#ifdef FRCOV
+		}
+		#endif
 
 	/* are there other refcount holders on the key? */
 	if (skey->refcount == 1) {
@@ -1370,8 +2018,23 @@ sctp_deact_sharedkey_ep(struct sctp_inpcb *inp, uint16_t keyid)
 {
 	sctp_sharedkey_t *skey;
 
-	if (inp == NULL)
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[579]) {
+	  if ((inp == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 579\n");
+	  else
+	    fprintf(stderr, "reached bug index 579\n");
+	}
+	if ((!FIXREVERTER[579] && (inp == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	)
 		return (-1);
+		#ifdef FRCOV
+		}
+		#endif
 
 	/* is the keyid the active sending key on the endpoint */
 	if (keyid == inp->sctp_ep.default_keyid)
@@ -1379,8 +2042,23 @@ sctp_deact_sharedkey_ep(struct sctp_inpcb *inp, uint16_t keyid)
 
 	/* does the key exist? */
 	skey = sctp_find_sharedkey(&inp->sctp_ep.shared_keys, keyid);
-	if (skey == NULL)
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[580]) {
+	  if ((skey == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 580\n");
+	  else
+	    fprintf(stderr, "reached bug index 580\n");
+	}
+	if ((!FIXREVERTER[580] && (skey == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	)
 		return (-1);
+		#ifdef FRCOV
+		}
+		#endif
 
 	/* endpoint keys are not refcounted */
 
@@ -1421,16 +2099,61 @@ sctp_auth_get_cookie_params(struct sctp_tcb *stcb, struct mbuf *m,
 		ptype = ntohs(phdr->param_type);
 		plen = ntohs(phdr->param_length);
 
-		if ((plen == 0) || (offset + plen > length))
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[581]) {
+		  if ((plen == 0 || offset + plen > length ) && !(0))
+		    fprintf(stderr, "triggered bug index 581\n");
+		  else
+		    fprintf(stderr, "reached bug index 581\n");
+		}
+		if ((!FIXREVERTER[581] && (plen == 0 || offset + plen > length ))
+		#else
+		if (0
+		#endif
+		)
 			break;
+			#ifdef FRCOV
+			}
+			#endif
 
 		if (ptype == SCTP_RANDOM) {
-			if (plen > sizeof(random_store))
+			
+			#ifdef FRCOV
+			{if (FIXREVERTER[582]) {
+			  if ((plen > sizeof ( random_store ) ) && !(0))
+			    fprintf(stderr, "triggered bug index 582\n");
+			  else
+			    fprintf(stderr, "reached bug index 582\n");
+			}
+			if ((!FIXREVERTER[582] && (plen > sizeof ( random_store ) ))
+			#else
+			if (0
+			#endif
+			)
 				break;
+				#ifdef FRCOV
+				}
+				#endif
 			phdr = sctp_get_next_param(m, offset,
 			    (struct sctp_paramhdr *)random_store, plen);
-			if (phdr == NULL)
+			
+			#ifdef FRCOV
+			{if (FIXREVERTER[583]) {
+			  if ((phdr == (void *) 0 ) && !(0))
+			    fprintf(stderr, "triggered bug index 583\n");
+			  else
+			    fprintf(stderr, "reached bug index 583\n");
+			}
+			if ((!FIXREVERTER[583] && (phdr == (void *) 0 ))
+			#else
+			if (0
+			#endif
+			)
 				return;
+				#ifdef FRCOV
+				}
+				#endif
 			/* save the random and length for the key */
 			p_random = (struct sctp_auth_random *)phdr;
 			random_len = plen - sizeof(*p_random);
@@ -1438,12 +2161,42 @@ sctp_auth_get_cookie_params(struct sctp_tcb *stcb, struct mbuf *m,
 			uint16_t num_hmacs;
 			uint16_t i;
 
-			if (plen > sizeof(hmacs_store))
+			
+			#ifdef FRCOV
+			{if (FIXREVERTER[584]) {
+			  if ((plen > sizeof ( hmacs_store ) ) && !(0))
+			    fprintf(stderr, "triggered bug index 584\n");
+			  else
+			    fprintf(stderr, "reached bug index 584\n");
+			}
+			if ((!FIXREVERTER[584] && (plen > sizeof ( hmacs_store ) ))
+			#else
+			if (0
+			#endif
+			)
 				break;
+				#ifdef FRCOV
+				}
+				#endif
 			phdr = sctp_get_next_param(m, offset,
 			    (struct sctp_paramhdr *)hmacs_store, plen);
-			if (phdr == NULL)
+			
+			#ifdef FRCOV
+			{if (FIXREVERTER[585]) {
+			  if ((phdr == (void *) 0 ) && !(0))
+			    fprintf(stderr, "triggered bug index 585\n");
+			  else
+			    fprintf(stderr, "reached bug index 585\n");
+			}
+			if ((!FIXREVERTER[585] && (phdr == (void *) 0 ))
+			#else
+			if (0
+			#endif
+			)
 				return;
+				#ifdef FRCOV
+				}
+				#endif
 			/* save the hmacs list and num for the key */
 			hmacs = (struct sctp_auth_hmac_algo *)phdr;
 			hmacs_len = plen - sizeof(*hmacs);
@@ -1460,12 +2213,42 @@ sctp_auth_get_cookie_params(struct sctp_tcb *stcb, struct mbuf *m,
 		} else if (ptype == SCTP_CHUNK_LIST) {
 			int i;
 
-			if (plen > sizeof(chunks_store))
+			
+			#ifdef FRCOV
+			{if (FIXREVERTER[586]) {
+			  if ((plen > sizeof ( chunks_store ) ) && !(0))
+			    fprintf(stderr, "triggered bug index 586\n");
+			  else
+			    fprintf(stderr, "reached bug index 586\n");
+			}
+			if ((!FIXREVERTER[586] && (plen > sizeof ( chunks_store ) ))
+			#else
+			if (0
+			#endif
+			)
 				break;
+				#ifdef FRCOV
+				}
+				#endif
 			phdr = sctp_get_next_param(m, offset,
 			    (struct sctp_paramhdr *)chunks_store, plen);
-			if (phdr == NULL)
+			
+			#ifdef FRCOV
+			{if (FIXREVERTER[587]) {
+			  if ((phdr == (void *) 0 ) && !(0))
+			    fprintf(stderr, "triggered bug index 587\n");
+			  else
+			    fprintf(stderr, "reached bug index 587\n");
+			}
+			if ((!FIXREVERTER[587] && (phdr == (void *) 0 ))
+			#else
+			if (0
+			#endif
+			)
 				return;
+				#ifdef FRCOV
+				}
+				#endif
 			chunks = (struct sctp_auth_chunk_list *)phdr;
 			num_chunks = plen - sizeof(*chunks);
 			/* save chunks list and num for the key */
@@ -1541,8 +2324,23 @@ sctp_fill_hmac_digest_m(struct mbuf *m, uint32_t auth_offset,
 	sctp_sharedkey_t *skey;
 	sctp_key_t *key;
 
-	if ((stcb == NULL) || (auth == NULL))
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[588]) {
+	  if ((stcb == (void *) 0 || auth == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 588\n");
+	  else
+	    fprintf(stderr, "reached bug index 588\n");
+	}
+	if ((!FIXREVERTER[588] && (stcb == (void *) 0 || auth == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	)
 		return;
+		#ifdef FRCOV
+		}
+		#endif
 
 	/* zero the digest + chunk padding */
 	digestlen = sctp_get_hmac_digest_len(stcb->asoc.peer_hmac_id);
@@ -1591,8 +2389,23 @@ sctp_zero_m(struct mbuf *m, uint32_t m_offset, uint32_t size)
 	uint8_t *data;
 
 	/* sanity check */
-	if (m == NULL)
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[589]) {
+	  if ((m == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 589\n");
+	  else
+	    fprintf(stderr, "reached bug index 589\n");
+	}
+	if ((!FIXREVERTER[589] && (m == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	)
 		return;
+		#ifdef FRCOV
+		}
+		#endif
 
 	/* find the correct starting mbuf and offset (get start position) */
 	m_tmp = m;
@@ -1601,7 +2414,21 @@ sctp_zero_m(struct mbuf *m, uint32_t m_offset, uint32_t size)
 		m_tmp = SCTP_BUF_NEXT(m_tmp);
 	}
 	/* now use the rest of the mbuf chain */
-	while ((m_tmp != NULL) && (size > 0)) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[590])
+	  fprintf(stderr, "reached bug index 590\n");
+	while ((FIXREVERTER[590] && (size > 0 )) || (!FIXREVERTER[590] && (m_tmp != (void *) 0 && size > 0 ))
+	#else
+	while (size > 0 
+	#endif
+	) {
+	  
+	#ifdef FRCOV
+	  if (!(m_tmp != (void *) 0 ))
+	    fprintf(stderr, "triggered bug index 590\n");
+	  #endif
+	
 		data = mtod(m_tmp, uint8_t *) + m_offset;
 		if (size > (uint32_t)(SCTP_BUF_LEN(m_tmp) - m_offset)) {
 			memset(data, 0, SCTP_BUF_LEN(m_tmp) - m_offset);
@@ -1614,6 +2441,9 @@ sctp_zero_m(struct mbuf *m, uint32_t m_offset, uint32_t size)
 		m_offset = 0;
 		m_tmp = SCTP_BUF_NEXT(m_tmp);
 	}
+	#ifdef FRCOV
+	}
+	#endif
 }
 
 /*-
@@ -1685,13 +2515,28 @@ sctp_handle_auth(struct sctp_tcb *stcb, struct sctp_auth_chunk *auth,
 		skey = sctp_find_sharedkey(&stcb->asoc.shared_keys,
 					   shared_key_id);
 		/* if the shared key isn't found, discard the chunk */
-		if (skey == NULL) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[591]) {
+		  if ((skey == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 591\n");
+		  else
+		    fprintf(stderr, "reached bug index 591\n");
+		}
+		if ((!FIXREVERTER[591] && (skey == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		) {
 			SCTP_STAT_INCR(sctps_recvivalkeyid);
 			SCTPDBG(SCTP_DEBUG_AUTH1,
 				"SCTP Auth: unknown key id %u\n",
 				shared_key_id);
 			return (-1);
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		/* generate a notification if this is a new key id */
 		if (stcb->asoc.authinfo.recv_keyid != shared_key_id)
 			/*
@@ -1774,9 +2619,24 @@ sctp_notify_authentication(struct sctp_tcb *stcb, uint32_t indication,
 
 	m_notify = sctp_get_mbuf_for_msg(sizeof(struct sctp_authkey_event),
 					  0, M_NOWAIT, 1, MT_HEADER);
-	if (m_notify == NULL)
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[592]) {
+	  if ((m_notify == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 592\n");
+	  else
+	    fprintf(stderr, "reached bug index 592\n");
+	}
+	if ((!FIXREVERTER[592] && (m_notify == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	)
 		/* no space left */
 		return;
+		#ifdef FRCOV
+		}
+		#endif
 
 	SCTP_BUF_LEN(m_notify) = 0;
 	auth = mtod(m_notify, struct sctp_authkey_event *);
@@ -1795,11 +2655,26 @@ sctp_notify_authentication(struct sctp_tcb *stcb, uint32_t indication,
 	/* append to socket */
 	control = sctp_build_readq_entry(stcb, stcb->asoc.primary_destination,
 	    0, 0, stcb->asoc.context, 0, 0, 0, m_notify);
-	if (control == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[593]) {
+	  if ((control == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 593\n");
+	  else
+	    fprintf(stderr, "reached bug index 593\n");
+	}
+	if ((!FIXREVERTER[593] && (control == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		/* no memory */
 		sctp_m_freem(m_notify);
 		return;
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	control->length = SCTP_BUF_LEN(m_notify);
 	control->spec_flags = M_NOTIFICATION;
 	/* not that we need this */
@@ -1831,9 +2706,24 @@ sctp_validate_init_auth_params(struct mbuf *m, int offset, int limit)
 		ptype = ntohs(phdr->param_type);
 		plen = ntohs(phdr->param_length);
 
-		if (offset + plen > limit) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[594]) {
+		  if ((offset + plen > limit ) && !(0))
+		    fprintf(stderr, "triggered bug index 594\n");
+		  else
+		    fprintf(stderr, "reached bug index 594\n");
+		}
+		if ((!FIXREVERTER[594] && (offset + plen > limit ))
+		#else
+		if (0
+		#endif
+		) {
 			break;
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		if (plen < sizeof(struct sctp_paramhdr)) {
 			break;
 		}
@@ -1843,15 +2733,45 @@ sctp_validate_init_auth_params(struct mbuf *m, int offset, int limit)
 			uint8_t local_store[SCTP_SMALL_CHUNK_STORE];
 			int num_ent, i;
 
-			if (plen > sizeof(local_store)) {
+			
+			#ifdef FRCOV
+			{if (FIXREVERTER[595]) {
+			  if ((plen > sizeof ( local_store ) ) && !(0))
+			    fprintf(stderr, "triggered bug index 595\n");
+			  else
+			    fprintf(stderr, "reached bug index 595\n");
+			}
+			if ((!FIXREVERTER[595] && (plen > sizeof ( local_store ) ))
+			#else
+			if (0
+			#endif
+			) {
 				break;
 			}
+			#ifdef FRCOV
+			}
+			#endif
 			phdr = sctp_get_next_param(m, offset,
 			                           (struct sctp_paramhdr *)&local_store,
 			                           plen);
-			if (phdr == NULL) {
+			
+			#ifdef FRCOV
+			{if (FIXREVERTER[596]) {
+			  if ((phdr == (void *) 0 ) && !(0))
+			    fprintf(stderr, "triggered bug index 596\n");
+			  else
+			    fprintf(stderr, "reached bug index 596\n");
+			}
+			if ((!FIXREVERTER[596] && (phdr == (void *) 0 ))
+			#else
+			if (0
+			#endif
+			) {
 				return (-1);
 			}
+			#ifdef FRCOV
+			}
+			#endif
 			pr_supported = (struct sctp_supported_chunk_types_param *)phdr;
 			num_ent = plen - sizeof(struct sctp_paramhdr);
 			for (i = 0; i < num_ent; i++) {
@@ -1879,15 +2799,45 @@ sctp_validate_init_auth_params(struct mbuf *m, int offset, int limit)
 			uint8_t store[SCTP_PARAM_BUFFER_SIZE];
 			int num_hmacs;
 
-			if (plen > sizeof(store)) {
+			
+			#ifdef FRCOV
+			{if (FIXREVERTER[597]) {
+			  if ((plen > sizeof ( store ) ) && !(0))
+			    fprintf(stderr, "triggered bug index 597\n");
+			  else
+			    fprintf(stderr, "reached bug index 597\n");
+			}
+			if ((!FIXREVERTER[597] && (plen > sizeof ( store ) ))
+			#else
+			if (0
+			#endif
+			) {
 				break;
 			}
+			#ifdef FRCOV
+			}
+			#endif
 			phdr = sctp_get_next_param(m, offset,
 			                           (struct sctp_paramhdr *)store,
 			                           plen);
-			if (phdr == NULL) {
+			
+			#ifdef FRCOV
+			{if (FIXREVERTER[598]) {
+			  if ((phdr == (void *) 0 ) && !(0))
+			    fprintf(stderr, "triggered bug index 598\n");
+			  else
+			    fprintf(stderr, "reached bug index 598\n");
+			}
+			if ((!FIXREVERTER[598] && (phdr == (void *) 0 ))
+			#else
+			if (0
+			#endif
+			) {
 				return (-1);
 			}
+			#ifdef FRCOV
+			}
+			#endif
 			hmacs = (struct sctp_auth_hmac_algo *)phdr;
 			num_hmacs = (plen - sizeof(*hmacs)) / sizeof(hmacs->hmac_ids[0]);
 			/* validate the hmac list */
@@ -1902,15 +2852,45 @@ sctp_validate_init_auth_params(struct mbuf *m, int offset, int limit)
 			uint8_t chunks_store[SCTP_SMALL_CHUNK_STORE];
 			int i, num_chunks;
 
-			if (plen > sizeof(chunks_store)) {
+			
+			#ifdef FRCOV
+			{if (FIXREVERTER[599]) {
+			  if ((plen > sizeof ( chunks_store ) ) && !(0))
+			    fprintf(stderr, "triggered bug index 599\n");
+			  else
+			    fprintf(stderr, "reached bug index 599\n");
+			}
+			if ((!FIXREVERTER[599] && (plen > sizeof ( chunks_store ) ))
+			#else
+			if (0
+			#endif
+			) {
 				break;
 			}
+			#ifdef FRCOV
+			}
+			#endif
 			phdr = sctp_get_next_param(m, offset,
 						   (struct sctp_paramhdr *)chunks_store,
 						   plen);
-			if (phdr == NULL) {
+			
+			#ifdef FRCOV
+			{if (FIXREVERTER[600]) {
+			  if ((phdr == (void *) 0 ) && !(0))
+			    fprintf(stderr, "triggered bug index 600\n");
+			  else
+			    fprintf(stderr, "reached bug index 600\n");
+			}
+			if ((!FIXREVERTER[600] && (phdr == (void *) 0 ))
+			#else
+			if (0
+			#endif
+			) {
 				return (-1);
 			}
+			#ifdef FRCOV
+			}
+			#endif
 			/*-
 			 * Flip through the list and mark that the
 			 * peer supports asconf/asconf_ack.
@@ -1930,9 +2910,24 @@ sctp_validate_init_auth_params(struct mbuf *m, int offset, int limit)
 		}
 
 		offset += SCTP_SIZE32(plen);
-		if (offset >= limit) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[601]) {
+		  if ((offset >= limit ) && !(0))
+		    fprintf(stderr, "triggered bug index 601\n");
+		  else
+		    fprintf(stderr, "reached bug index 601\n");
+		}
+		if ((!FIXREVERTER[601] && (offset >= limit ))
+		#else
+		if (0
+		#endif
+		) {
 			break;
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		phdr = sctp_get_next_param(m, offset, &param_buf,
 		    sizeof(param_buf));
 	}
diff --git a/usrsctplib/netinet/sctp_bsd_addr.c b/usrsctplib/netinet/sctp_bsd_addr.c
index e053c4d8..45ba0374 100755
--- a/usrsctplib/netinet/sctp_bsd_addr.c
+++ b/usrsctplib/netinet/sctp_bsd_addr.c
@@ -1,3 +1,7 @@
+#ifdef FRCOV
+#include <stdio.h>
+extern short FIXREVERTER[];
+#endif
 /*-
  * SPDX-License-Identifier: BSD-3-Clause
  *
@@ -647,9 +651,24 @@ sctp_init_ifns_for_vrf(int vrfid)
 void
 sctp_init_vrf_list(int vrfid)
 {
-	if (vrfid > SCTP_MAX_VRF_ID)
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[317]) {
+	  if ((vrfid > 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 317\n");
+	  else
+	    fprintf(stderr, "reached bug index 317\n");
+	}
+	if ((!FIXREVERTER[317] && (vrfid > 0 ))
+	#else
+	if (0
+	#endif
+	)
 		/* can't do that */
 		return;
+		#ifdef FRCOV
+		}
+		#endif
 
 	/* Don't care about return here */
 	(void)sctp_allocate_vrf(vrfid);
@@ -799,10 +818,25 @@ sctp_get_mbuf_for_msg(unsigned int space_needed, int want_header,
 #else
 	m =  m_getm2(NULL, space_needed, how, type, want_header ? M_PKTHDR : 0);
 #endif
-	if (m == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[318]) {
+	  if ((m == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 318\n");
+	  else
+	    fprintf(stderr, "reached bug index 318\n");
+	}
+	if ((!FIXREVERTER[318] && (m == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		/* bad, no memory */
 		return (m);
 	}
+	#ifdef FRCOV
+	}
+	#endif
 #if !defined(__Userspace__)
 	if (allonebuf) {
 		if (SCTP_BUF_SIZE(m) < space_needed) {
diff --git a/usrsctplib/netinet/sctp_callout.c b/usrsctplib/netinet/sctp_callout.c
index 4ca094f0..f6849d4d 100755
--- a/usrsctplib/netinet/sctp_callout.c
+++ b/usrsctplib/netinet/sctp_callout.c
@@ -1,3 +1,7 @@
+#ifdef FRCOV
+#include <stdio.h>
+extern short FIXREVERTER[];
+#endif
 /*-
  * SPDX-License-Identifier: BSD-3-Clause
  *
@@ -110,8 +114,23 @@ sctp_os_timer_start(sctp_os_timer_t *c, int to_ticks, void (*ftn) (void *),
                     void *arg)
 {
 	/* paranoia */
-	if ((c == NULL) || (ftn == NULL))
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[368]) {
+	  if ((c == (void *) 0 || ftn == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 368\n");
+	  else
+	    fprintf(stderr, "reached bug index 368\n");
+	}
+	if ((!FIXREVERTER[368] && (c == (void *) 0 || ftn == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	)
 	    return;
+	    #ifdef FRCOV
+	    }
+	    #endif
 
 	SCTP_TIMERQ_LOCK();
 	/* check to see if we're rescheduling a timer */
@@ -147,8 +166,23 @@ sctp_os_timer_start(sctp_os_timer_t *c, int to_ticks, void (*ftn) (void *),
 	 * We could unlock/splx here and lock/spl at the TAILQ_INSERT_TAIL,
 	 * but there's no point since doing this setup doesn't take much time.
 	 */
-	if (to_ticks <= 0)
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[369]) {
+	  if ((to_ticks <= 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 369\n");
+	  else
+	    fprintf(stderr, "reached bug index 369\n");
+	}
+	if ((!FIXREVERTER[369] && (to_ticks <= 0 ))
+	#else
+	if (0
+	#endif
+	)
 		to_ticks = 1;
+		#ifdef FRCOV
+		}
+		#endif
 
 	c->c_arg = arg;
 	c->c_flags = (SCTP_CALLOUT_ACTIVE | SCTP_CALLOUT_PENDING);
diff --git a/usrsctplib/netinet/sctp_indata.c b/usrsctplib/netinet/sctp_indata.c
index 8b332355..35cb6eab 100755
--- a/usrsctplib/netinet/sctp_indata.c
+++ b/usrsctplib/netinet/sctp_indata.c
@@ -1,3 +1,7 @@
+#ifdef FRCOV
+#include <stdio.h>
+extern short FIXREVERTER[];
+#endif
 /*-
  * SPDX-License-Identifier: BSD-3-Clause
  *
@@ -93,9 +97,24 @@ sctp_calc_rwnd(struct sctp_tcb *stcb, struct sctp_association *asoc)
 	 * sctp_soreceive then we will fix this so that ONLY this
 	 * associations data is taken into account.
 	 */
-	if (stcb->sctp_socket == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[654]) {
+	  if ((stcb -> sctp_socket == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 654\n");
+	  else
+	    fprintf(stderr, "reached bug index 654\n");
+	}
+	if ((!FIXREVERTER[654] && (stcb -> sctp_socket == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		return (calc);
 	}
+	#ifdef FRCOV
+	}
+	#endif
 
 	KASSERT(asoc->cnt_on_reasm_queue > 0 || asoc->size_on_reasm_queue == 0,
 	        ("size_on_reasm_queue is %u", asoc->size_on_reasm_queue));
@@ -118,10 +137,25 @@ sctp_calc_rwnd(struct sctp_tcb *stcb, struct sctp_association *asoc)
 	                                         asoc->cnt_on_reasm_queue * MSIZE));
 	calc = sctp_sbspace_sub(calc, (uint32_t)(asoc->size_on_all_streams +
 	                                         asoc->cnt_on_all_streams * MSIZE));
-	if (calc == 0) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[655]) {
+	  if ((calc == 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 655\n");
+	  else
+	    fprintf(stderr, "reached bug index 655\n");
+	}
+	if ((!FIXREVERTER[655] && (calc == 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		/* out of space */
 		return (calc);
 	}
+	#ifdef FRCOV
+	}
+	#endif
 
 	/* what is the overhead of all these rwnd's */
 	calc = sctp_sbspace_sub(calc, stcb->asoc.my_rwnd_control_len);
@@ -150,9 +184,24 @@ sctp_build_readq_entry(struct sctp_tcb *stcb,
 	struct sctp_queued_to_read *read_queue_e = NULL;
 
 	sctp_alloc_a_readq(stcb, read_queue_e);
-	if (read_queue_e == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[656]) {
+	  if ((read_queue_e == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 656\n");
+	  else
+	    fprintf(stderr, "reached bug index 656\n");
+	}
+	if ((!FIXREVERTER[656] && (read_queue_e == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		goto failed_build;
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	memset(read_queue_e, 0, sizeof(struct sctp_queued_to_read));
 	read_queue_e->sinfo_stream = sid;
 	read_queue_e->sinfo_flags = (flags << 8);
@@ -842,9 +891,24 @@ restart:
 		if (chk->rec.data.fsn == fsn) {
 			/* Ok lets add it */
 			sctp_alloc_a_readq(stcb, nc);
-			if (nc == NULL) {
+			
+			#ifdef FRCOV
+			{if (FIXREVERTER[659]) {
+			  if ((nc == (void *) 0 ) && !(0))
+			    fprintf(stderr, "triggered bug index 659\n");
+			  else
+			    fprintf(stderr, "reached bug index 659\n");
+			}
+			if ((!FIXREVERTER[659] && (nc == (void *) 0 ))
+			#else
+			if (0
+			#endif
+			) {
 				break;
 			}
+			#ifdef FRCOV
+			}
+			#endif
 			memset(nc, 0, sizeof(struct sctp_queued_to_read));
 			TAILQ_REMOVE(&control->reasm, chk, sctp_next);
 			sctp_add_chk_to_control(control, strm, stcb, asoc, chk, SCTP_READ_LOCK_NOT_HELD);
@@ -1167,9 +1231,24 @@ done_un:
 		/* Can't add more */
 		return (0);
 	}
-	if (control == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[660]) {
+	  if ((control == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 660\n");
+	  else
+	    fprintf(stderr, "reached bug index 660\n");
+	}
+	if ((!FIXREVERTER[660] && (control == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		return (ret);
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	if (SCTP_MID_EQ(asoc->idata_supported, strm->last_mid_delivered, control->mid)) {
 		/* Ok the guy at the top was being partially delivered
 		 * completed, so we remove it. Note
@@ -1757,9 +1836,24 @@ sctp_process_a_data_chunk(struct sctp_tcb *stcb, struct sctp_association *asoc,
 	if (SCTP_BASE_SYSCTL(sctp_logging_level) & SCTP_MAP_LOGGING_ENABLE) {
 		sctp_log_map(tsn, asoc->cumulative_tsn, asoc->highest_tsn_inside_map, SCTP_MAP_TSN_ENTERS);
 	}
-	if (stcb == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[661]) {
+	  if ((stcb == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 661\n");
+	  else
+	    fprintf(stderr, "reached bug index 661\n");
+	}
+	if ((!FIXREVERTER[661] && (stcb == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		return (0);
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	SCTP_LTRACE_CHK(stcb->sctp_ep, stcb, chk_type, tsn);
 	if (SCTP_TSN_GE(asoc->cumulative_tsn, tsn)) {
 		/* It is a duplicate */
@@ -1974,9 +2068,24 @@ sctp_process_a_data_chunk(struct sctp_tcb *stcb, struct sctp_association *asoc,
 				return (0);
 			}
 		} else {
-			if (control == NULL) {
+			
+			#ifdef FRCOV
+			{if (FIXREVERTER[662]) {
+			  if ((control == (void *) 0 ) && !(0))
+			    fprintf(stderr, "triggered bug index 662\n");
+			  else
+			    fprintf(stderr, "reached bug index 662\n");
+			}
+			if ((!FIXREVERTER[662] && (control == (void *) 0 ))
+			#else
+			if (0
+			#endif
+			) {
 				goto dump_packet;
 			}
+			#ifdef FRCOV
+			}
+			#endif
 			if (SCTP_TSN_GT(fsn, control->top_fsn)) {
 				goto dump_packet;
 			}
@@ -2080,10 +2189,25 @@ sctp_process_a_data_chunk(struct sctp_tcb *stcb, struct sctp_association *asoc,
 			m_adj(dmbuf, -(l_len - the_len));
 		}
 	}
-	if (dmbuf == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[663]) {
+	  if ((dmbuf == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 663\n");
+	  else
+	    fprintf(stderr, "reached bug index 663\n");
+	}
+	if ((!FIXREVERTER[663] && (dmbuf == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		SCTP_STAT_INCR(sctps_nomem);
 		return (0);
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	/*
 	 * Now no matter what, we need a control, get one
 	 * if we don't have one (we may have gotten it
@@ -2096,10 +2220,25 @@ sctp_process_a_data_chunk(struct sctp_tcb *stcb, struct sctp_association *asoc,
 					   sid,
 					   chk_flags,
 					   NULL, fsn, mid);
-		if (control == NULL) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[664]) {
+		  if ((control == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 664\n");
+		  else
+		    fprintf(stderr, "reached bug index 664\n");
+		}
+		if ((!FIXREVERTER[664] && (control == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		) {
 			SCTP_STAT_INCR(sctps_nomem);
 			return (0);
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		if ((chk_flags & SCTP_DATA_NOT_FRAG) == SCTP_DATA_NOT_FRAG) {
 			struct mbuf *mm;
 
@@ -2161,7 +2300,19 @@ sctp_process_a_data_chunk(struct sctp_tcb *stcb, struct sctp_association *asoc,
 	/* Now will we need a chunk too? */
 	if ((chk_flags & SCTP_DATA_NOT_FRAG) != SCTP_DATA_NOT_FRAG) {
 		sctp_alloc_a_chunk(stcb, chk);
-		if (chk == NULL) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[665]) {
+		  if ((chk == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 665\n");
+		  else
+		    fprintf(stderr, "reached bug index 665\n");
+		}
+		if ((!FIXREVERTER[665] && (chk == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		) {
 			/* No memory so we drop the chunk */
 			SCTP_STAT_INCR(sctps_nomem);
 			if (last_chunk == 0) {
@@ -2170,6 +2321,9 @@ sctp_process_a_data_chunk(struct sctp_tcb *stcb, struct sctp_association *asoc,
 			}
 			return (0);
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		chk->rec.data.tsn = tsn;
 		chk->no_fr_allowed = 0;
 		chk->rec.data.fsn = fsn;
@@ -2729,9 +2883,24 @@ sctp_process_data(struct mbuf **mm, int iphlen, int *offset, int length,
 	ch = (struct sctp_chunkhdr *)sctp_m_getptr(m, *offset,
 	                                           sizeof(struct sctp_chunkhdr),
 	                                           (uint8_t *)&chunk_buf);
-	if (ch == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[666]) {
+	  if ((ch == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 666\n");
+	  else
+	    fprintf(stderr, "reached bug index 666\n");
+	}
+	if ((!FIXREVERTER[666] && (ch == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		return (1);
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	/*
 	 * process all DATA chunks...
 	 */
@@ -2917,11 +3086,26 @@ sctp_process_data(struct mbuf **mm, int iphlen, int *offset, int length,
 		ch = (struct sctp_chunkhdr *)sctp_m_getptr(m, *offset,
 		                                           sizeof(struct sctp_chunkhdr),
 		                                           (uint8_t *)&chunk_buf);
-		if (ch == NULL) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[667]) {
+		  if ((ch == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 667\n");
+		  else
+		    fprintf(stderr, "reached bug index 667\n");
+		}
+		if ((!FIXREVERTER[667] && (ch == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		) {
 			*offset = length;
 			stop_proc = 1;
 			continue;
 		}
+		#ifdef FRCOV
+		}
+		#endif
 	}
 	if (break_flag) {
 		/*
@@ -3218,16 +3402,46 @@ sctp_handle_segments(struct mbuf *m, int *offset, struct sctp_tcb *stcb, struct
 		frag = (struct sctp_gap_ack_block *)sctp_m_getptr(m, *offset,
 		                                                  sizeof(struct sctp_gap_ack_block), (uint8_t *) &block);
 		*offset += sizeof(block);
-		if (frag == NULL) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[669]) {
+		  if ((frag == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 669\n");
+		  else
+		    fprintf(stderr, "reached bug index 669\n");
+		}
+		if ((!FIXREVERTER[669] && (frag == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		) {
 			return (chunk_freed);
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		frag_strt = ntohs(frag->start);
 		frag_end = ntohs(frag->end);
 
-		if (frag_strt > frag_end) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[670]) {
+		  if ((frag_strt > frag_end ) && !(0))
+		    fprintf(stderr, "triggered bug index 670\n");
+		  else
+		    fprintf(stderr, "reached bug index 670\n");
+		}
+		if ((!FIXREVERTER[670] && (frag_strt > frag_end ))
+		#else
+		if (0
+		#endif
+		) {
 			/* This gap report is malformed, skip it. */
 			continue;
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		if (frag_strt <= prev_frag_end) {
 			/* This gap report is not in order, so restart. */
 			 tp1 = TAILQ_FIRST(&asoc->sent_queue);
@@ -3307,8 +3521,23 @@ sctp_check_for_revoked(struct sctp_tcb *stcb,
 				tp1->sent = SCTP_DATAGRAM_ACKED;
 			}
 		}
-		if (tp1->sent == SCTP_DATAGRAM_UNSENT)
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[671]) {
+		  if ((tp1 -> sent == 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 671\n");
+		  else
+		    fprintf(stderr, "reached bug index 671\n");
+		}
+		if ((!FIXREVERTER[671] && (tp1 -> sent == 0 ))
+		#else
+		if (0
+		#endif
+		)
 			break;
+			#ifdef FRCOV
+			}
+			#endif
 	}
 }
 
@@ -3388,7 +3617,19 @@ sctp_strike_gap_ack_chunks(struct sctp_tcb *stcb, struct sctp_association *asoc,
 			/* we are beyond the tsn in the sack  */
 			break;
 		}
-		if (tp1->sent >= SCTP_DATAGRAM_RESEND) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[672]) {
+		  if ((tp1 -> sent >= 4 ) && !(0))
+		    fprintf(stderr, "triggered bug index 672\n");
+		  else
+		    fprintf(stderr, "reached bug index 672\n");
+		}
+		if ((!FIXREVERTER[672] && (tp1 -> sent >= 4 ))
+		#else
+		if (0
+		#endif
+		) {
 			/* either a RESEND, ACKED, or MARKED */
 			/* skip */
 			if (tp1->sent == SCTP_FORWARD_TSN_SKIP) {
@@ -3397,6 +3638,9 @@ sctp_strike_gap_ack_chunks(struct sctp_tcb *stcb, struct sctp_association *asoc,
 			}
 			continue;
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		/*
 		 * CMT : SFR algo (covers part of DAC and HTNA as well)
 		 */
@@ -3855,8 +4099,23 @@ sctp_fs_audit(struct sctp_association *asoc)
 	entry_flight = asoc->total_flight;
 	entry_cnt = asoc->total_flight_count;
 #endif
-	if (asoc->pr_sctp_cnt >= asoc->sent_queue_cnt)
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[673]) {
+	  if ((asoc -> pr_sctp_cnt >= asoc -> sent_queue_cnt ) && !(0))
+	    fprintf(stderr, "triggered bug index 673\n");
+	  else
+	    fprintf(stderr, "reached bug index 673\n");
+	}
+	if ((!FIXREVERTER[673] && (asoc -> pr_sctp_cnt >= asoc -> sent_queue_cnt ))
+	#else
+	if (0
+	#endif
+	)
 		return (0);
+		#ifdef FRCOV
+		}
+		#endif
 
 	TAILQ_FOREACH(chk, &asoc->sent_queue, sctp_next) {
 		if (chk->sent < SCTP_DATAGRAM_RESEND) {
@@ -3898,7 +4157,19 @@ sctp_window_probe_recovery(struct sctp_tcb *stcb,
 			   struct sctp_tmit_chunk *tp1)
 {
 	tp1->window_probe = 0;
-	if ((tp1->sent >= SCTP_DATAGRAM_ACKED) || (tp1->data == NULL)) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[674]) {
+	  if ((tp1 -> sent >= 10010 || tp1 -> data == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 674\n");
+	  else
+	    fprintf(stderr, "reached bug index 674\n");
+	}
+	if ((!FIXREVERTER[674] && (tp1 -> sent >= 10010 || tp1 -> data == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		/* TSN's skipped we do NOT move back. */
 		sctp_misc_ints(SCTP_FLIGHT_LOG_DWN_WP_FWD,
 			       tp1->whoTo ? tp1->whoTo->flight_size : 0,
@@ -3907,6 +4178,9 @@ sctp_window_probe_recovery(struct sctp_tcb *stcb,
 			       tp1->rec.data.tsn);
 		return;
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	/* First setup this by shrinking flight */
 	if (stcb->asoc.cc_functions.sctp_cwnd_update_tsn_acknowledged) {
 		(*stcb->asoc.cc_functions.sctp_cwnd_update_tsn_acknowledged)(tp1->whoTo,
@@ -3966,9 +4240,24 @@ sctp_express_handle_sack(struct sctp_tcb *stcb, uint32_t cumack,
 			/* SWS sender side engages */
 			asoc->peers_rwnd = 0;
 		}
-		if (asoc->peers_rwnd > old_rwnd) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[675]) {
+		  if ((asoc -> peers_rwnd > old_rwnd ) && !(0))
+		    fprintf(stderr, "triggered bug index 675\n");
+		  else
+		    fprintf(stderr, "reached bug index 675\n");
+		}
+		if ((!FIXREVERTER[675] && (asoc -> peers_rwnd > old_rwnd ))
+		#else
+		if (0
+		#endif
+		) {
 			goto again;
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		return;
 	}
 
@@ -4202,7 +4491,22 @@ sctp_express_handle_sack(struct sctp_tcb *stcb, uint32_t cumack,
 	}
 
 	/* JRS - Use the congestion control given in the CC module */
-	if ((asoc->last_acked_seq != cumack) && (ecne_seen == 0)) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[676]) {
+	  fprintf(stderr, "reached bug index 676\n");
+	}
+	if ((FIXREVERTER[676] && (ecne_seen == 0 )) || (!FIXREVERTER[676] && (asoc -> last_acked_seq != cumack && ecne_seen == 0 ))
+	#else
+	if (ecne_seen == 0 
+	#endif
+	) {
+	  
+	#ifdef FRCOV
+	  if (!(asoc -> last_acked_seq != cumack ))
+	    fprintf(stderr, "triggered bug index 676\n");
+	  #endif
+	
 		TAILQ_FOREACH(net, &asoc->nets, sctp_next) {
 			if (net->net_ack2 > 0) {
 				/*
@@ -4245,6 +4549,9 @@ sctp_express_handle_sack(struct sctp_tcb *stcb, uint32_t cumack,
 		}
 		asoc->cc_functions.sctp_cwnd_update_after_sack(stcb, asoc, 1, 0, 0);
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	asoc->last_acked_seq = cumack;
 
 	if (TAILQ_EMPTY(&asoc->sent_queue)) {
@@ -4528,9 +4835,24 @@ sctp_handle_sack(struct mbuf *m, int offset_seg, int offset_dup,
 		for (i = 0; i < num_dup; i++) {
 			dupdata = (uint32_t *)sctp_m_getptr(m, offset_dup + i * sizeof(uint32_t),
 			                                    sizeof(uint32_t), (uint8_t *)&dblock);
-			if (dupdata == NULL) {
+			
+			#ifdef FRCOV
+			{if (FIXREVERTER[677]) {
+			  if ((dupdata == (void *) 0 ) && !(0))
+			    fprintf(stderr, "triggered bug index 677\n");
+			  else
+			    fprintf(stderr, "reached bug index 677\n");
+			}
+			if ((!FIXREVERTER[677] && (dupdata == (void *) 0 ))
+			#else
+			if (0
+			#endif
+			) {
 				break;
 			}
+			#ifdef FRCOV
+			}
+			#endif
 			sctp_log_fr(*dupdata, 0, 0, SCTP_FR_DUPED);
 		}
 	}
@@ -5473,10 +5795,25 @@ sctp_flush_reassm_for_str_seq(struct sctp_tcb *stcb,
 	 */
 	strm = &asoc->strmin[stream];
 	control = sctp_find_reasm_entry(strm, mid, ordered, asoc->idata_supported);
-	if (control == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[679]) {
+	  if ((control == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 679\n");
+	  else
+	    fprintf(stderr, "reached bug index 679\n");
+	}
+	if ((!FIXREVERTER[679] && (control == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		/* Not found */
 		return;
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	if (!asoc->idata_supported && !ordered && SCTP_TSN_GT(control->fsn_included, cumtsn)) {
 		return;
 	}
@@ -5684,9 +6021,24 @@ sctp_handle_forward_tsn(struct sctp_tcb *stcb,
 									    sizeof(struct sctp_strseq_mid),
 									    (uint8_t *)&strseqbuf_m);
 				offset += sizeof(struct sctp_strseq_mid);
-				if (stseq_m == NULL) {
+				
+				#ifdef FRCOV
+				{if (FIXREVERTER[680]) {
+				  if ((stseq_m == (void *) 0 ) && !(0))
+				    fprintf(stderr, "triggered bug index 680\n");
+				  else
+				    fprintf(stderr, "reached bug index 680\n");
+				}
+				if ((!FIXREVERTER[680] && (stseq_m == (void *) 0 ))
+				#else
+				if (0
+				#endif
+				) {
 					break;
 				}
+				#ifdef FRCOV
+				}
+				#endif
 				sid = ntohs(stseq_m->sid);
 				mid = ntohl(stseq_m->mid);
 				flags = ntohs(stseq_m->flags);
@@ -5700,9 +6052,24 @@ sctp_handle_forward_tsn(struct sctp_tcb *stcb,
 									    sizeof(struct sctp_strseq),
 									    (uint8_t *)&strseqbuf);
 				offset += sizeof(struct sctp_strseq);
-				if (stseq == NULL) {
+				
+				#ifdef FRCOV
+				{if (FIXREVERTER[681]) {
+				  if ((stseq == (void *) 0 ) && !(0))
+				    fprintf(stderr, "triggered bug index 681\n");
+				  else
+				    fprintf(stderr, "reached bug index 681\n");
+				}
+				if ((!FIXREVERTER[681] && (stseq == (void *) 0 ))
+				#else
+				if (0
+				#endif
+				) {
 					break;
 				}
+				#ifdef FRCOV
+				}
+				#endif
 				sid = ntohs(stseq->sid);
 				mid = (uint32_t)ntohs(stseq->ssn);
 				ordered = 1;
@@ -5716,18 +6083,50 @@ sctp_handle_forward_tsn(struct sctp_tcb *stcb,
 			 * where its not all delivered. If we find it we transmute the
 			 * read entry into a PDI_ABORTED.
 			 */
-			if (sid >= asoc->streamincnt) {
+			
+			#ifdef FRCOV
+			{if (FIXREVERTER[682]) {
+			  if ((sid >= asoc -> streamincnt ) && !(0))
+			    fprintf(stderr, "triggered bug index 682\n");
+			  else
+			    fprintf(stderr, "reached bug index 682\n");
+			}
+			if ((!FIXREVERTER[682] && (sid >= asoc -> streamincnt ))
+			#else
+			if (0
+			#endif
+			) {
 				/* screwed up streams, stop!  */
 				break;
 			}
-			if ((asoc->str_of_pdapi == sid) &&
-			    (asoc->ssn_of_pdapi == mid)) {
+			#ifdef FRCOV
+			}
+			#endif
+			
+			#ifdef FRCOV
+			{if (FIXREVERTER[683]) {
+			  fprintf(stderr, "reached bug index 683\n");
+			}
+			if ((FIXREVERTER[683] && (asoc -> str_of_pdapi == sid )) || (!FIXREVERTER[683] && (asoc -> str_of_pdapi == sid && asoc -> ssn_of_pdapi == mid ))
+			#else
+			if (asoc -> str_of_pdapi == sid 
+			#endif
+			) {
+			      
+			    #ifdef FRCOV
+			      if (!(asoc -> ssn_of_pdapi == mid ))
+			        fprintf(stderr, "triggered bug index 683\n");
+			      #endif
+			    
 				/* If this is the one we were partially delivering
 				 * now then we no longer are. Note this will change
 				 * with the reassembly re-write.
 				 */
 				asoc->fragmented_delivery_inprogress = 0;
 			}
+			#ifdef FRCOV
+			}
+			#endif
 			strm = &asoc->strmin[sid];
 			for (cur_mid = strm->last_mid_delivered; SCTP_MID_GE(asoc->idata_supported, mid, cur_mid); cur_mid++) {
 				sctp_flush_reassm_for_str_seq(stcb, asoc, sid, cur_mid, ordered, new_cum_tsn);
diff --git a/usrsctplib/netinet/sctp_input.c b/usrsctplib/netinet/sctp_input.c
index f958dc4b..f495b203 100755
--- a/usrsctplib/netinet/sctp_input.c
+++ b/usrsctplib/netinet/sctp_input.c
@@ -1,3 +1,7 @@
+#ifdef FRCOV
+#include <stdio.h>
+extern short FIXREVERTER[];
+#endif
 /*-
  * SPDX-License-Identifier: BSD-3-Clause
  *
@@ -263,9 +267,24 @@ sctp_is_there_unsent_data(struct sctp_tcb *stcb, int so_locked
 		for (i = 0; i < stcb->asoc.streamoutcnt; i++) {
 			/*sa_ignore FREED_MEMORY*/
 			sp = TAILQ_FIRST(&stcb->asoc.strmout[i].outqueue);
-			if (sp == NULL) {
+			
+			#ifdef FRCOV
+			{if (FIXREVERTER[602]) {
+			  if ((sp == (void *) 0 ) && !(0))
+			    fprintf(stderr, "triggered bug index 602\n");
+			  else
+			    fprintf(stderr, "reached bug index 602\n");
+			}
+			if ((!FIXREVERTER[602] && (sp == (void *) 0 ))
+			#else
+			if (0
+			#endif
+			) {
 				continue;
 			}
+			#ifdef FRCOV
+			}
+			#endif
 			if ((sp->msg_is_complete) &&
 			    (sp->length == 0)  &&
 			    (sp->sender_all_done)) {
@@ -430,11 +449,26 @@ sctp_process_init(struct sctp_init_chunk *cp, struct sctp_tcb *stcb)
 	}
 	SCTP_MALLOC(asoc->strmin, struct sctp_stream_in *, asoc->streamincnt *
 		    sizeof(struct sctp_stream_in), SCTP_M_STRMI);
-	if (asoc->strmin == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[604]) {
+	  if ((asoc -> strmin == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 604\n");
+	  else
+	    fprintf(stderr, "reached bug index 604\n");
+	}
+	if ((!FIXREVERTER[604] && (asoc -> strmin == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		/* we didn't get memory for the streams! */
 		SCTPDBG(SCTP_DEBUG_INPUT2, "process_init: couldn't get memory for the streams!\n");
 		return (-1);
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	for (i = 0; i < asoc->streamincnt; i++) {
 		asoc->strmin[i].sid = i;
 		asoc->strmin[i].last_mid_delivered = 0xffffffff;
@@ -678,10 +712,25 @@ sctp_handle_heartbeat_ack(struct sctp_heartbeat_chunk *cp,
 		return;
 	}
 	r_net = sctp_findnet(stcb, &store.sa);
-	if (r_net == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[606]) {
+	  if ((r_net == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 606\n");
+	  else
+	    fprintf(stderr, "reached bug index 606\n");
+	}
+	if ((!FIXREVERTER[606] && (r_net == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		SCTPDBG(SCTP_DEBUG_INPUT1, "Huh? I can't find the address I sent it to, discard\n");
 		return;
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	if ((r_net && (r_net->dest_state & SCTP_ADDR_UNCONFIRMED)) &&
 	    (r_net->heartbeat_random1 == cp->heartbeat.hb_info.random_value1) &&
 	    (r_net->heartbeat_random2 == cp->heartbeat.hb_info.random_value2)) {
@@ -857,8 +906,23 @@ sctp_handle_abort(struct sctp_abort_chunk *abort,
 	uint16_t error;
 
 	SCTPDBG(SCTP_DEBUG_INPUT2, "sctp_handle_abort: handling ABORT\n");
-	if (stcb == NULL)
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[607]) {
+	  if ((stcb == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 607\n");
+	  else
+	    fprintf(stderr, "reached bug index 607\n");
+	}
+	if ((!FIXREVERTER[607] && (stcb == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	)
 		return (0);
+		#ifdef FRCOV
+		}
+		#endif
 
 	len = ntohs(abort->ch.chunk_length);
 	if (len >= sizeof(struct sctp_chunkhdr) + sizeof(struct sctp_error_cause)) {
@@ -962,8 +1026,23 @@ sctp_handle_shutdown(struct sctp_shutdown_chunk *cp,
 
 	SCTPDBG(SCTP_DEBUG_INPUT2,
 		"sctp_handle_shutdown: handling SHUTDOWN\n");
-	if (stcb == NULL)
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[608]) {
+	  if ((stcb == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 608\n");
+	  else
+	    fprintf(stderr, "reached bug index 608\n");
+	}
+	if ((!FIXREVERTER[608] && (stcb == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	)
 		return;
+		#ifdef FRCOV
+		}
+		#endif
 	asoc = &stcb->asoc;
 	if ((SCTP_GET_STATE(stcb) == SCTP_STATE_COOKIE_WAIT) ||
 	    (SCTP_GET_STATE(stcb) == SCTP_STATE_COOKIE_ECHOED)) {
@@ -1089,8 +1168,23 @@ sctp_handle_shutdown_ack(struct sctp_shutdown_ack_chunk *cp SCTP_UNUSED,
 #endif
 	SCTPDBG(SCTP_DEBUG_INPUT2,
 		"sctp_handle_shutdown_ack: handling SHUTDOWN ACK\n");
-	if (stcb == NULL)
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[609]) {
+	  if ((stcb == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 609\n");
+	  else
+	    fprintf(stderr, "reached bug index 609\n");
+	}
+	if ((!FIXREVERTER[609] && (stcb == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	)
 		return;
+		#ifdef FRCOV
+		}
+		#endif
 
 	asoc = &stcb->asoc;
 	/* process according to association state */
@@ -1260,12 +1354,27 @@ sctp_handle_error(struct sctp_chunkhdr *ch,
 		/* Process an Error Cause */
 		cause_code = ntohs(cause->code);
 		cause_length = ntohs(cause->length);
-		if ((cause_length > remaining_length) || (cause_length == 0)) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[610]) {
+		  if ((cause_length > remaining_length || cause_length == 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 610\n");
+		  else
+		    fprintf(stderr, "reached bug index 610\n");
+		}
+		if ((!FIXREVERTER[610] && (cause_length > remaining_length || cause_length == 0 ))
+		#else
+		if (0
+		#endif
+		) {
 			/* Invalid cause length, possibly due to truncation. */
 			SCTPDBG(SCTP_DEBUG_INPUT1, "Bogus length in cause - bytes left: %u cause length: %u\n",
 				remaining_length, cause_length);
 			return (0);
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		if (code == 0) {
 			/* report the first error cause */
 			code = cause_code;
@@ -1310,8 +1419,19 @@ sctp_handle_error(struct sctp_chunkhdr *ch,
 					asoc->cookie_preserve_req = UINT32_MAX;
 				}
 				asoc->stale_cookie_count++;
-				if (asoc->stale_cookie_count >
-				    asoc->max_init_times) {
+				
+				#ifdef FRCOV
+				{if (FIXREVERTER[611]) {
+				  if ((asoc -> stale_cookie_count > asoc -> max_init_times ) && !(0))
+				    fprintf(stderr, "triggered bug index 611\n");
+				  else
+				    fprintf(stderr, "reached bug index 611\n");
+				}
+				if ((!FIXREVERTER[611] && (asoc -> stale_cookie_count > asoc -> max_init_times ))
+				#else
+				if (0
+				#endif
+				) {
 					sctp_abort_notification(stcb, 0, 0, NULL, SCTP_SO_NOT_LOCKED);
 					/* now free the asoc */
 #if defined(__APPLE__) || defined(SCTP_SO_LOCK_TESTING)
@@ -1329,6 +1449,9 @@ sctp_handle_error(struct sctp_chunkhdr *ch,
 #endif
 					return (-1);
 				}
+				#ifdef FRCOV
+				}
+				#endif
 				/* blast back to INIT state */
 				sctp_toss_old_cookies(stcb, &stcb->asoc);
 				SCTP_SET_STATE(stcb, SCTP_STATE_COOKIE_WAIT);
@@ -1426,11 +1549,26 @@ sctp_handle_init_ack(struct mbuf *m, int iphlen, int offset,
 	SCTPDBG(SCTP_DEBUG_INPUT2,
 		"sctp_handle_init_ack: handling INIT-ACK\n");
 
-	if (stcb == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[612]) {
+	  if ((stcb == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 612\n");
+	  else
+	    fprintf(stderr, "reached bug index 612\n");
+	}
+	if ((!FIXREVERTER[612] && (stcb == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		SCTPDBG(SCTP_DEBUG_INPUT2,
 			"sctp_handle_init_ack: TCB is null\n");
 		return (-1);
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	if (ntohs(cp->ch.chunk_length) < sizeof(struct sctp_init_ack_chunk)) {
 		/* Invalid length */
 		op_err = sctp_generate_cause(SCTP_CAUSE_INVALID_PARAM, "");
@@ -1643,10 +1781,25 @@ sctp_process_cookie_existing(struct mbuf *m, int iphlen, int offset,
 	init_cp = (struct sctp_init_chunk *)
 		sctp_m_getptr(m, init_offset, sizeof(struct sctp_init_chunk),
 			      (uint8_t *) & init_buf);
-	if (init_cp == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[613]) {
+	  if ((init_cp == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 613\n");
+	  else
+	    fprintf(stderr, "reached bug index 613\n");
+	}
+	if ((!FIXREVERTER[613] && (init_cp == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		/* could not pull a INIT chunk in cookie */
 		return (NULL);
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	if (init_cp->ch.chunk_type != SCTP_INITIATION) {
 		return (NULL);
 	}
@@ -1658,10 +1811,25 @@ sctp_process_cookie_existing(struct mbuf *m, int iphlen, int offset,
 	initack_cp = (struct sctp_init_ack_chunk *)
 		sctp_m_getptr(m, initack_offset, sizeof(struct sctp_init_ack_chunk),
 			      (uint8_t *) & initack_buf);
-	if (initack_cp == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[614]) {
+	  if ((initack_cp == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 614\n");
+	  else
+	    fprintf(stderr, "reached bug index 614\n");
+	}
+	if ((!FIXREVERTER[614] && (initack_cp == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		/* could not pull INIT-ACK chunk in cookie */
 		return (NULL);
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	if (initack_cp->ch.chunk_type != SCTP_INITIATION_ACK) {
 		return (NULL);
 	}
@@ -2192,12 +2360,27 @@ sctp_process_cookie_new(struct mbuf *m, int iphlen, int offset,
 	init_cp = (struct sctp_init_chunk *)
 	    sctp_m_getptr(m, init_offset, sizeof(struct sctp_init_chunk),
 	    (uint8_t *) & init_buf);
-	if (init_cp == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[618]) {
+	  if ((init_cp == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 618\n");
+	  else
+	    fprintf(stderr, "reached bug index 618\n");
+	}
+	if ((!FIXREVERTER[618] && (init_cp == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		/* could not pull a INIT chunk in cookie */
 		SCTPDBG(SCTP_DEBUG_INPUT1,
 			"process_cookie_new: could not pull INIT chunk hdr\n");
 		return (NULL);
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	if (init_cp->ch.chunk_type != SCTP_INITIATION) {
 		SCTPDBG(SCTP_DEBUG_INPUT1, "HUH? process_cookie_new: could not find INIT chunk!\n");
 		return (NULL);
@@ -2210,11 +2393,26 @@ sctp_process_cookie_new(struct mbuf *m, int iphlen, int offset,
 	initack_cp = (struct sctp_init_ack_chunk *)
 	    sctp_m_getptr(m, initack_offset, sizeof(struct sctp_init_ack_chunk),
 	    (uint8_t *) & initack_buf);
-	if (initack_cp == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[619]) {
+	  if ((initack_cp == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 619\n");
+	  else
+	    fprintf(stderr, "reached bug index 619\n");
+	}
+	if ((!FIXREVERTER[619] && (initack_cp == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		/* could not pull INIT-ACK chunk in cookie */
 		SCTPDBG(SCTP_DEBUG_INPUT1, "process_cookie_new: could not pull INIT-ACK chunk hdr\n");
 		return (NULL);
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	if (initack_cp->ch.chunk_type != SCTP_INITIATION_ACK) {
 		return (NULL);
 	}
@@ -2600,9 +2798,24 @@ sctp_handle_cookie_echo(struct mbuf *m, int iphlen, int offset,
 	SCTPDBG(SCTP_DEBUG_INPUT2,
 		"sctp_handle_cookie: handling COOKIE-ECHO\n");
 
-	if (inp_p == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[621]) {
+	  if ((inp_p == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 621\n");
+	  else
+	    fprintf(stderr, "reached bug index 621\n");
+	}
+	if ((!FIXREVERTER[621] && (inp_p == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		return (NULL);
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	cookie = &cp->cookie;
 	cookie_offset = offset + sizeof(struct sctp_chunkhdr);
 	cookie_len = ntohs(cp->ch.chunk_length);
@@ -2613,9 +2826,19 @@ sctp_handle_cookie_echo(struct mbuf *m, int iphlen, int offset,
 		/* cookie too small */
 		return (NULL);
 	}
-	if ((cookie->peerport != sh->src_port) ||
-	    (cookie->myport != sh->dest_port) ||
-	    (cookie->my_vtag != sh->v_tag)) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[622]) {
+	  if ((cookie -> peerport != sh -> src_port || cookie -> myport != sh -> dest_port || cookie -> my_vtag != sh -> v_tag ) && !(0))
+	    fprintf(stderr, "triggered bug index 622\n");
+	  else
+	    fprintf(stderr, "reached bug index 622\n");
+	}
+	if ((!FIXREVERTER[622] && (cookie -> peerport != sh -> src_port || cookie -> myport != sh -> dest_port || cookie -> my_vtag != sh -> v_tag ))
+	#else
+	if (0
+	#endif
+	) {
 		/*
 		 * invalid ports or bad tag.  Note that we always leave the
 		 * v_tag in the header in network order and when we stored
@@ -2625,16 +2848,34 @@ sctp_handle_cookie_echo(struct mbuf *m, int iphlen, int offset,
 		 */
 		return (NULL);
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	/*
 	 * split off the signature into its own mbuf (since it should not be
 	 * calculated in the sctp_hmac_m() call).
 	 */
 	sig_offset = offset + cookie_len - SCTP_SIGNATURE_SIZE;
 	m_sig = m_split(m, sig_offset, M_NOWAIT);
-	if (m_sig == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[623]) {
+	  if ((m_sig == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 623\n");
+	  else
+	    fprintf(stderr, "reached bug index 623\n");
+	}
+	if ((!FIXREVERTER[623] && (m_sig == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		/* out of memory or ?? */
 		return (NULL);
 	}
+	#ifdef FRCOV
+	}
+	#endif
 #ifdef SCTP_MBUF_LOGGING
 	if (SCTP_BASE_SYSCTL(sctp_logging_level) & SCTP_MBUF_LOGGING_ENABLE) {
 		sctp_log_mbc(m_sig, SCTP_MBUF_SPLIT);
@@ -2669,11 +2910,26 @@ sctp_handle_cookie_echo(struct mbuf *m, int iphlen, int offset,
 	/* get the signature */
 	SCTP_INP_RUNLOCK(l_inp);
 	sig = (uint8_t *) sctp_m_getptr(m_sig, 0, SCTP_SIGNATURE_SIZE, (uint8_t *) & tmp_sig);
-	if (sig == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[624]) {
+	  if ((sig == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 624\n");
+	  else
+	    fprintf(stderr, "reached bug index 624\n");
+	}
+	if ((!FIXREVERTER[624] && (sig == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		/* couldn't find signature */
 		sctp_m_freem(m_sig);
 		return (NULL);
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	/* compare the received digest with the computed digest */
 	if (timingsafe_bcmp(calc_sig, sig, SCTP_SIGNATURE_SIZE) != 0) {
 		/* try the old cookie? */
@@ -2734,10 +2990,25 @@ sctp_handle_cookie_echo(struct mbuf *m, int iphlen, int offset,
 
 		op_err = sctp_get_mbuf_for_msg(sizeof(struct sctp_error_stale_cookie),
 		                               0, M_NOWAIT, 1, MT_DATA);
-		if (op_err == NULL) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[625]) {
+		  if ((op_err == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 625\n");
+		  else
+		    fprintf(stderr, "reached bug index 625\n");
+		}
+		if ((!FIXREVERTER[625] && (op_err == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		) {
 			/* FOOBAR */
 			return (NULL);
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		/* Set the len */
 		SCTP_BUF_LEN(op_err) = sizeof(struct sctp_error_stale_cookie);
 		cause = mtod(op_err, struct sctp_error_stale_cookie *);
@@ -2928,7 +3199,19 @@ sctp_handle_cookie_echo(struct mbuf *m, int iphlen, int offset,
 			struct socket *so, *oso;
 			struct sctp_inpcb *inp;
 
-			if (notification == SCTP_NOTIFY_ASSOC_RESTART) {
+			
+			#ifdef FRCOV
+			{if (FIXREVERTER[626]) {
+			  if ((notification == 10 ) && !(0))
+			    fprintf(stderr, "triggered bug index 626\n");
+			  else
+			    fprintf(stderr, "reached bug index 626\n");
+			}
+			if ((!FIXREVERTER[626] && (notification == 10 ))
+			#else
+			if (0
+			#endif
+			) {
 				/*
 				 * For a restart we will keep the same
 				 * socket, no need to do anything. I THINK!!
@@ -2940,6 +3223,9 @@ sctp_handle_cookie_echo(struct mbuf *m, int iphlen, int offset,
 				}
 				return (m);
 			}
+			#ifdef FRCOV
+			}
+			#endif
 			oso = (*inp_p)->sctp_socket;
 #if (defined(__FreeBSD__) && __FreeBSD_version < 700000)
 			/*
@@ -3136,9 +3422,24 @@ sctp_handle_cookie_ack(struct sctp_cookie_ack_chunk *cp SCTP_UNUSED,
 
 	SCTPDBG(SCTP_DEBUG_INPUT2,
 		"sctp_handle_cookie_ack: handling COOKIE-ACK\n");
-	if ((stcb == NULL) || (net == NULL)) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[627]) {
+	  if ((stcb == (void *) 0 || net == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 627\n");
+	  else
+	    fprintf(stderr, "reached bug index 627\n");
+	}
+	if ((!FIXREVERTER[627] && (stcb == (void *) 0 || net == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		return;
 	}
+	#ifdef FRCOV
+	}
+	#endif
 
 	asoc = &stcb->asoc;
 	if (SCTP_BASE_SYSCTL(sctp_logging_level) & SCTP_THRESHOLD_LOGGING) {
@@ -3296,10 +3597,25 @@ sctp_handle_ecn_echo(struct sctp_ecne_chunk *cp,
 		 * may have it marked on the actual net.
 		 */
 		TAILQ_FOREACH(net, &stcb->asoc.nets, sctp_next) {
-			if (tsn == net->last_cwr_tsn) {
+			
+			#ifdef FRCOV
+			{if (FIXREVERTER[628]) {
+			  if ((tsn == net -> last_cwr_tsn ) && !(0))
+			    fprintf(stderr, "triggered bug index 628\n");
+			  else
+			    fprintf(stderr, "reached bug index 628\n");
+			}
+			if ((!FIXREVERTER[628] && (tsn == net -> last_cwr_tsn ))
+			#else
+			if (0
+			#endif
+			) {
 				/* Found him, send it off */
 				break;
 			}
+			#ifdef FRCOV
+			}
+			#endif
 		}
 		if (net == NULL) {
 			/*
@@ -3308,10 +3624,25 @@ sctp_handle_ecn_echo(struct sctp_ecne_chunk *cp,
 			 * ago and you lost the response.
 			 */
 			net = TAILQ_FIRST(&stcb->asoc.nets);
-			if (net == NULL) {
+			
+			#ifdef FRCOV
+			{if (FIXREVERTER[629]) {
+			  if ((net == (void *) 0 ) && !(0))
+			    fprintf(stderr, "triggered bug index 629\n");
+			  else
+			    fprintf(stderr, "reached bug index 629\n");
+			}
+			if ((!FIXREVERTER[629] && (net == (void *) 0 ))
+			#else
+			if (0
+			#endif
+			) {
 				/* TSNH */
 				return;
 			}
+			#ifdef FRCOV
+			}
+			#endif
 			override_bit = SCTP_CWR_REDUCE_OVERRIDE;
 		} else {
 			override_bit = 0;
@@ -3413,8 +3744,23 @@ sctp_handle_shutdown_complete(struct sctp_shutdown_complete_chunk *cp SCTP_UNUSE
 
 	SCTPDBG(SCTP_DEBUG_INPUT2,
 		"sctp_handle_shutdown_complete: handling SHUTDOWN-COMPLETE\n");
-	if (stcb == NULL)
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[631]) {
+	  if ((stcb == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 631\n");
+	  else
+	    fprintf(stderr, "reached bug index 631\n");
+	}
+	if ((!FIXREVERTER[631] && (stcb == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	)
 		return;
+		#ifdef FRCOV
+		}
+		#endif
 
 	/* process according to association state */
 	if (SCTP_GET_STATE(stcb) != SCTP_STATE_SHUTDOWN_ACK_SENT) {
@@ -3791,9 +4137,24 @@ sctp_find_stream_reset(struct sctp_tcb *stcb, uint32_t seq, struct sctp_tmit_chu
 		return (NULL);
 	}
 	chk = stcb->asoc.str_reset;
-	if (chk->data == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[632]) {
+	  if ((chk -> data == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 632\n");
+	  else
+	    fprintf(stderr, "reached bug index 632\n");
+	}
+	if ((!FIXREVERTER[632] && (chk -> data == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		return (NULL);
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	if (bchk) {
 		/* he wants a copy of the chk pointer */
 		*bchk = chk;
@@ -3825,9 +4186,24 @@ sctp_clean_up_stream_reset(struct sctp_tcb *stcb)
 
 	asoc = &stcb->asoc;
 	chk = asoc->str_reset;
-	if (chk == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[633]) {
+	  if ((chk == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 633\n");
+	  else
+	    fprintf(stderr, "reached bug index 633\n");
+	}
+	if ((!FIXREVERTER[633] && (chk == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		return;
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	asoc->str_reset = NULL;
 	sctp_timer_stop(SCTP_TIMER_TYPE_STRRESET, stcb->sctp_ep, stcb,
 	                chk->whoTo, SCTP_FROM_SCTP_INPUT + SCTP_LOC_28);
@@ -3948,10 +4324,25 @@ sctp_handle_stream_reset_response(struct sctp_tcb *stcb,
 				struct sctp_stream_reset_response_tsn *resp;
 				struct sctp_forward_tsn_chunk fwdtsn;
 				int abort_flag = 0;
-				if (respin == NULL) {
+				
+				#ifdef FRCOV
+				{if (FIXREVERTER[634]) {
+				  if ((respin == (void *) 0 ) && !(0))
+				    fprintf(stderr, "triggered bug index 634\n");
+				  else
+				    fprintf(stderr, "reached bug index 634\n");
+				}
+				if ((!FIXREVERTER[634] && (respin == (void *) 0 ))
+				#else
+				if (0
+				#endif
+				) {
 					/* huh ? */
 					return (0);
 				}
+				#ifdef FRCOV
+				}
+				#endif
 				if (ntohs(respin->ph.param_length) < sizeof(struct sctp_stream_reset_response_tsn)) {
 					return (0);
 				}
@@ -4179,12 +4570,27 @@ sctp_handle_str_reset_request_out(struct sctp_tcb *stcb,
 			siz = sizeof(struct sctp_stream_reset_list) + (number_entries * sizeof(uint16_t));
 			SCTP_MALLOC(liste, struct sctp_stream_reset_list *,
 				    siz, SCTP_M_STRESET);
-			if (liste == NULL) {
+			
+			#ifdef FRCOV
+			{if (FIXREVERTER[635]) {
+			  if ((liste == (void *) 0 ) && !(0))
+			    fprintf(stderr, "triggered bug index 635\n");
+			  else
+			    fprintf(stderr, "reached bug index 635\n");
+			}
+			if ((!FIXREVERTER[635] && (liste == (void *) 0 ))
+			#else
+			if (0
+			#endif
+			) {
 				/* gak out of memory */
 				asoc->last_reset_action[0] = SCTP_STREAM_RESET_RESULT_DENIED;
 				sctp_add_stream_reset_result(chk, seq, asoc->last_reset_action[0]);
 				return;
 			}
+			#ifdef FRCOV
+			}
+			#endif
 			liste->seq = seq;
 			liste->tsn = tsn;
 			liste->number_entries = number_entries;
@@ -4388,9 +4794,24 @@ sctp_handle_stream_reset(struct sctp_tcb *stcb, struct mbuf *m, int offset,
 
 	/* setup for adding the response */
 	sctp_alloc_a_chunk(stcb, chk);
-	if (chk == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[636]) {
+	  if ((chk == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 636\n");
+	  else
+	    fprintf(stderr, "reached bug index 636\n");
+	}
+	if ((!FIXREVERTER[636] && (chk == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		return (ret_code);
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	chk->copy_by_ref = 0;
 	chk->rec.chunk_id.id = SCTP_STREAM_RESET;
 	chk->rec.chunk_id.can_take_data = 0;
@@ -4424,10 +4845,25 @@ sctp_handle_stream_reset(struct sctp_tcb *stcb, struct mbuf *m, int offset,
 	offset += sizeof(struct sctp_chunkhdr);
 	while (remaining_length >= sizeof(struct sctp_paramhdr)) {
 		ph = (struct sctp_paramhdr *)sctp_m_getptr(m, offset, sizeof(pstore), (uint8_t *)&pstore);
-		if (ph == NULL) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[637]) {
+		  if ((ph == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 637\n");
+		  else
+		    fprintf(stderr, "reached bug index 637\n");
+		}
+		if ((!FIXREVERTER[637] && (ph == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		) {
 			/* TSNH */
 			break;
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		param_len = ntohs(ph->param_length);
 		if ((param_len > remaining_length) ||
 		    (param_len < (sizeof(struct sctp_paramhdr) + sizeof(uint32_t)))) {
@@ -4436,10 +4872,25 @@ sctp_handle_stream_reset(struct sctp_tcb *stcb, struct mbuf *m, int offset,
 		}
 		ph = (struct sctp_paramhdr *)sctp_m_getptr(m, offset, min(param_len, sizeof(cstore)),
 							   (uint8_t *)&cstore);
-		if (ph == NULL) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[638]) {
+		  if ((ph == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 638\n");
+		  else
+		    fprintf(stderr, "reached bug index 638\n");
+		}
+		if ((!FIXREVERTER[638] && (ph == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		) {
 			/* TSNH */
 			break;
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		ptype = ntohs(ph->param_type);
 		num_param++;
 		if (param_len > sizeof(cstore)) {
@@ -4585,11 +5036,26 @@ sctp_handle_packet_dropped(struct sctp_pktdrop_chunk *cp,
 		}
 		if (trunc_len == 0) {
 			/* we are supposed to have all of it */
-			if (at > chlen) {
+			
+			#ifdef FRCOV
+			{if (FIXREVERTER[641]) {
+			  if ((at > chlen ) && !(0))
+			    fprintf(stderr, "triggered bug index 641\n");
+			  else
+			    fprintf(stderr, "reached bug index 641\n");
+			}
+			if ((!FIXREVERTER[641] && (at > chlen ))
+			#else
+			if (0
+			#endif
+			) {
 				/* corrupt skip it */
 				SCTP_STAT_INCR(sctps_pdrpcrupt);
 				break;
 			}
+			#ifdef FRCOV
+			}
+			#endif
 		} else {
 			/* is there enough of it left ? */
 			if (desc.chunk_type == SCTP_DATA) {
@@ -4794,11 +5260,26 @@ sctp_process_control(struct mbuf *m, int iphlen, int *offset, int length,
 			ch = (struct sctp_chunkhdr *)sctp_m_getptr(m, *offset,
 								   sizeof(struct sctp_chunkhdr), chunk_buf);
 		}
-		if (ch == NULL) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[643]) {
+		  if ((ch == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 643\n");
+		  else
+		    fprintf(stderr, "reached bug index 643\n");
+		}
+		if ((!FIXREVERTER[643] && (ch == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		) {
 			/* Help */
 			*offset = length;
 			return (stcb);
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		if (ch->chunk_type == SCTP_COOKIE_ECHO) {
 			goto process_control_chunks;
 		}
@@ -4972,13 +5453,28 @@ sctp_process_control(struct mbuf *m, int iphlen, int *offset, int length,
 		ch = (struct sctp_chunkhdr *)sctp_m_getptr(m, *offset,
 		                                           contiguous,
 		                                           chunk_buf);
-		if (ch == NULL) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[644]) {
+		  if ((ch == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 644\n");
+		  else
+		    fprintf(stderr, "reached bug index 644\n");
+		}
+		if ((!FIXREVERTER[644] && (ch == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		) {
 			*offset = length;
 			if (stcb != NULL) {
 				SCTP_TCB_UNLOCK(stcb);
 			}
 			return (NULL);
 		}
+		#ifdef FRCOV
+		}
+		#endif
 
 		num_chunks++;
 		/* Save off the last place we got a control from */
@@ -5098,9 +5594,27 @@ sctp_process_control(struct mbuf *m, int iphlen, int *offset, int length,
 			 * Special case, I must call the output routine to
 			 * get the cookie echoed
 			 */
-			if ((stcb != NULL) && (ret == 0)) {
+			
+			#ifdef FRCOV
+			{if (FIXREVERTER[645]) {
+			  fprintf(stderr, "reached bug index 645\n");
+			}
+			if ((FIXREVERTER[645] && (ret == 0 )) || (!FIXREVERTER[645] && (stcb != (void *) 0 && ret == 0 ))
+			#else
+			if (ret == 0 
+			#endif
+			) {
+			  
+			#ifdef FRCOV
+			  if (!(stcb != (void *) 0 ))
+			    fprintf(stderr, "triggered bug index 645\n");
+			  #endif
+			
 				sctp_chunk_output(stcb->sctp_ep, stcb, SCTP_OUTPUT_FROM_CONTROL_PROC, SCTP_SO_NOT_LOCKED);
 			}
+			#ifdef FRCOV
+			}
+			#endif
 			return (stcb);
 			break;
 		case SCTP_SELECTIVE_ACK:
@@ -5115,11 +5629,26 @@ sctp_process_control(struct mbuf *m, int iphlen, int *offset, int length,
 			SCTPDBG(SCTP_DEBUG_INPUT3, "%s\n",
 				ch->chunk_type == SCTP_SELECTIVE_ACK ? "SCTP_SACK" : "SCTP_NR_SACK");
 			SCTP_STAT_INCR(sctps_recvsacks);
-			if (stcb == NULL) {
+			
+			#ifdef FRCOV
+			{if (FIXREVERTER[646]) {
+			  if ((stcb == (void *) 0 ) && !(0))
+			    fprintf(stderr, "triggered bug index 646\n");
+			  else
+			    fprintf(stderr, "reached bug index 646\n");
+			}
+			if ((!FIXREVERTER[646] && (stcb == (void *) 0 ))
+			#else
+			if (0
+			#endif
+			) {
 				SCTPDBG(SCTP_DEBUG_INDATA1, "No stcb when processing %s chunk\n",
 				        (ch->chunk_type == SCTP_SELECTIVE_ACK) ? "SCTP_SACK" : "SCTP_NR_SACK");
 				break;
 			}
+			#ifdef FRCOV
+			}
+			#endif
 			if (ch->chunk_type == SCTP_SELECTIVE_ACK) {
 				if (chk_length < sizeof(struct sctp_sack_chunk)) {
 					SCTPDBG(SCTP_DEBUG_INDATA1, "Bad size on SACK chunk, too small\n");
@@ -5607,7 +6136,19 @@ sctp_process_control(struct mbuf *m, int iphlen, int *offset, int length,
 			break;
 		case SCTP_AUTHENTICATION:
 			SCTPDBG(SCTP_DEBUG_INPUT3, "SCTP_AUTHENTICATION\n");
-			if (stcb == NULL) {
+			
+			#ifdef FRCOV
+			{if (FIXREVERTER[647]) {
+			  if ((stcb == (void *) 0 ) && !(0))
+			    fprintf(stderr, "triggered bug index 647\n");
+			  else
+			    fprintf(stderr, "reached bug index 647\n");
+			}
+			if ((!FIXREVERTER[647] && (stcb == (void *) 0 ))
+			#else
+			if (0
+			#endif
+			) {
 				/* save the first AUTH for later processing */
 				if (auth_skipped == 0) {
 					auth_offset = *offset;
@@ -5617,6 +6158,9 @@ sctp_process_control(struct mbuf *m, int iphlen, int *offset, int length,
 				/* skip this chunk (temporarily) */
 				goto next_chunk;
 			}
+			#ifdef FRCOV
+			}
+			#endif
 			if (stcb->asoc.auth_supported == 0) {
 				goto unknown_chunk;
 			}
@@ -5689,15 +6233,48 @@ sctp_process_control(struct mbuf *m, int iphlen, int *offset, int length,
 		}
 		ch = (struct sctp_chunkhdr *)sctp_m_getptr(m, *offset,
 							   sizeof(struct sctp_chunkhdr), chunk_buf);
-		if (ch == NULL) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[649]) {
+		  if ((ch == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 649\n");
+		  else
+		    fprintf(stderr, "reached bug index 649\n");
+		}
+		if ((!FIXREVERTER[649] && (ch == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		) {
 			*offset = length;
 			return (stcb);
 		}
+		#ifdef FRCOV
+		}
+		#endif
 	}			/* while */
 
-	if ((asconf_cnt > 0) && (stcb != NULL)) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[650]) {
+	  fprintf(stderr, "reached bug index 650\n");
+	}
+	if ((FIXREVERTER[650] && (asconf_cnt > 0 )) || (!FIXREVERTER[650] && (asconf_cnt > 0 && stcb != (void *) 0 ))
+	#else
+	if (asconf_cnt > 0 
+	#endif
+	) {
+	  
+	#ifdef FRCOV
+	  if (!(stcb != (void *) 0 ))
+	    fprintf(stderr, "triggered bug index 650\n");
+	  #endif
+	
 		sctp_send_asconf_ack(stcb);
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	return (stcb);
 }
 
@@ -5782,10 +6359,25 @@ sctp_common_input_processing(struct mbuf **mm, int iphlen, int offset, int lengt
 		}
 	}
 	/* Destination port of 0 is illegal, based on RFC4960. */
-	if (sh->dest_port == 0) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[651]) {
+	  if ((sh -> dest_port == 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 651\n");
+	  else
+	    fprintf(stderr, "reached bug index 651\n");
+	}
+	if ((!FIXREVERTER[651] && (sh -> dest_port == 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		SCTP_STAT_INCR(sctps_hdrops);
 		goto out;
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	stcb = sctp_findassociation_addr(m, offset, src, dst,
 	                                 sh, ch, &inp, &net, vrf_id);
 #if defined(INET) || defined(INET6)
@@ -5978,7 +6570,19 @@ sctp_common_input_processing(struct mbuf **mm, int iphlen, int offset, int lengt
 #if defined(__FreeBSD__)
 	SCTP_PROBE5(receive, NULL, stcb, m, stcb, sh);
 #endif
-	if (stcb == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[652]) {
+	  if ((stcb == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 652\n");
+	  else
+	    fprintf(stderr, "reached bug index 652\n");
+	}
+	if ((!FIXREVERTER[652] && (stcb == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		/*
 		 * no valid TCB for this packet, or we found it's a bad
 		 * packet while processing control, or we're done with this
@@ -5986,6 +6590,9 @@ sctp_common_input_processing(struct mbuf **mm, int iphlen, int offset, int lengt
 		 */
 		goto out;
 	}
+	#ifdef FRCOV
+	}
+	#endif
 #if defined(__Userspace__)
 	if ((upcall_socket == NULL) &&
 	    !(stcb->sctp_ep->sctp_flags & SCTP_PCB_FLAGS_SOCKET_GONE) &&
diff --git a/usrsctplib/netinet/sctp_output.c b/usrsctplib/netinet/sctp_output.c
index 7a123856..0f5c0554 100755
--- a/usrsctplib/netinet/sctp_output.c
+++ b/usrsctplib/netinet/sctp_output.c
@@ -1,3 +1,7 @@
+#ifdef FRCOV
+#include <stdio.h>
+extern short FIXREVERTER[];
+#endif
 /*-
  * SPDX-License-Identifier: BSD-3-Clause
  *
@@ -2077,20 +2081,50 @@ sctp_add_addresses_to_i_ia(struct sctp_inpcb *inp, struct sctp_tcb *stcb,
 	vrf_id = inp->def_vrf_id;
 	SCTP_IPI_ADDR_RLOCK();
 	vrf = sctp_find_vrf(vrf_id);
-	if (vrf == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[136]) {
+	  if ((vrf == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 136\n");
+	  else
+	    fprintf(stderr, "reached bug index 136\n");
+	}
+	if ((!FIXREVERTER[136] && (vrf == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		SCTP_IPI_ADDR_RUNLOCK();
 		return (m_at);
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	if (inp->sctp_flags & SCTP_PCB_FLAGS_BOUNDALL) {
 		struct sctp_ifa *sctp_ifap;
 		struct sctp_ifn *sctp_ifnp;
 
 		cnt = cnt_inits_to;
-		if (vrf->total_ifa_count > SCTP_COUNT_LIMIT) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[137]) {
+		  if ((vrf -> total_ifa_count > 40 ) && !(0))
+		    fprintf(stderr, "triggered bug index 137\n");
+		  else
+		    fprintf(stderr, "reached bug index 137\n");
+		}
+		if ((!FIXREVERTER[137] && (vrf -> total_ifa_count > 40 ))
+		#else
+		if (0
+		#endif
+		) {
 			limit_out = 1;
 			cnt = SCTP_ADDRESS_LIMIT;
 			goto skip_count;
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		LIST_FOREACH(sctp_ifnp, &vrf->ifnlist, next_ifn) {
 			if ((scope->loopback_scope == 0) &&
 			    SCTP_IFN_IS_IFT_LOOP(sctp_ifnp)) {
@@ -2209,20 +2243,50 @@ sctp_add_addresses_to_i_ia(struct sctp_inpcb *inp, struct sctp_tcb *stcb,
 		cnt = cnt_inits_to;
 		/* First, how many ? */
 		LIST_FOREACH(laddr, &inp->sctp_addr_list, sctp_nxt_addr) {
-			if (laddr->ifa == NULL) {
+			
+			#ifdef FRCOV
+			{if (FIXREVERTER[142]) {
+			  if ((laddr -> ifa == (void *) 0 ) && !(0))
+			    fprintf(stderr, "triggered bug index 142\n");
+			  else
+			    fprintf(stderr, "reached bug index 142\n");
+			}
+			if ((!FIXREVERTER[142] && (laddr -> ifa == (void *) 0 ))
+			#else
+			if (0
+			#endif
+			) {
 				continue;
 			}
+			#ifdef FRCOV
+			}
+			#endif
 			if (laddr->ifa->localifa_flags & SCTP_BEING_DELETED)
 				/* Address being deleted by the system, dont
 				 * list.
 				 */
 				continue;
-			if (laddr->action == SCTP_DEL_IP_ADDRESS) {
+			
+			#ifdef FRCOV
+			{if (FIXREVERTER[143]) {
+			  if ((laddr -> action == 49154 ) && !(0))
+			    fprintf(stderr, "triggered bug index 143\n");
+			  else
+			    fprintf(stderr, "reached bug index 143\n");
+			}
+			if ((!FIXREVERTER[143] && (laddr -> action == 49154 ))
+			#else
+			if (0
+			#endif
+			) {
 				/* Address being deleted on this ep
 				 * don't list.
 				 */
 				continue;
 			}
+			#ifdef FRCOV
+			}
+			#endif
 #if defined(__Userspace__)
 			if (laddr->ifa->address.sa.sa_family == AF_CONN) {
 				continue;
@@ -2242,9 +2306,24 @@ sctp_add_addresses_to_i_ia(struct sctp_inpcb *inp, struct sctp_tcb *stcb,
 		if (cnt > 1) {
 			cnt = cnt_inits_to;
 			LIST_FOREACH(laddr, &inp->sctp_addr_list, sctp_nxt_addr) {
-				if (laddr->ifa == NULL) {
+				
+				#ifdef FRCOV
+				{if (FIXREVERTER[144]) {
+				  if ((laddr -> ifa == (void *) 0 ) && !(0))
+				    fprintf(stderr, "triggered bug index 144\n");
+				  else
+				    fprintf(stderr, "reached bug index 144\n");
+				}
+				if ((!FIXREVERTER[144] && (laddr -> ifa == (void *) 0 ))
+				#else
+				if (0
+				#endif
+				) {
 					continue;
 				}
+				#ifdef FRCOV
+				}
+				#endif
 				if (laddr->ifa->localifa_flags & SCTP_BEING_DELETED) {
 					continue;
 				}
@@ -2466,16 +2545,46 @@ sctp_is_addr_restricted(struct sctp_tcb *stcb, struct sctp_ifa *ifa)
 {
 	struct sctp_laddr *laddr;
 
-	if (stcb == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[146]) {
+	  if ((stcb == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 146\n");
+	  else
+	    fprintf(stderr, "reached bug index 146\n");
+	}
+	if ((!FIXREVERTER[146] && (stcb == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		/* There are no restrictions, no TCB :-) */
 		return (0);
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	LIST_FOREACH(laddr, &stcb->asoc.sctp_restricted_addrs, sctp_nxt_addr) {
-		if (laddr->ifa == NULL) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[147]) {
+		  if ((laddr -> ifa == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 147\n");
+		  else
+		    fprintf(stderr, "reached bug index 147\n");
+		}
+		if ((!FIXREVERTER[147] && (laddr -> ifa == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		) {
 			SCTPDBG(SCTP_DEBUG_OUTPUT1, "%s: NULL ifa\n",
 				__func__);
 			continue;
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		if (laddr->ifa == ifa) {
 			/* Yes it is on the list */
 			return (1);
@@ -2490,14 +2599,44 @@ sctp_is_addr_in_ep(struct sctp_inpcb *inp, struct sctp_ifa *ifa)
 {
 	struct sctp_laddr *laddr;
 
-	if (ifa == NULL)
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[148]) {
+	  if ((ifa == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 148\n");
+	  else
+	    fprintf(stderr, "reached bug index 148\n");
+	}
+	if ((!FIXREVERTER[148] && (ifa == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	)
 		return (0);
+		#ifdef FRCOV
+		}
+		#endif
 	LIST_FOREACH(laddr, &inp->sctp_addr_list, sctp_nxt_addr) {
-		if (laddr->ifa == NULL) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[149]) {
+		  if ((laddr -> ifa == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 149\n");
+		  else
+		    fprintf(stderr, "reached bug index 149\n");
+		}
+		if ((!FIXREVERTER[149] && (laddr -> ifa == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		) {
 			SCTPDBG(SCTP_DEBUG_OUTPUT1, "%s: NULL ifa\n",
 				__func__);
 			continue;
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		if ((laddr->ifa == ifa) && laddr->action == 0)
 			/* same pointer */
 			return (1);
@@ -2525,8 +2664,23 @@ sctp_choose_boundspecific_inp(struct sctp_inpcb *inp,
 	uint32_t ifn_index;
 
 	vrf = sctp_find_vrf(vrf_id);
-	if (vrf == NULL)
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[150]) {
+	  if ((vrf == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 150\n");
+	  else
+	    fprintf(stderr, "reached bug index 150\n");
+	}
+	if ((!FIXREVERTER[150] && (vrf == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	)
 		return (NULL);
+		#ifdef FRCOV
+		}
+		#endif
 
 	ifn = SCTP_GET_IFN_VOID_FROM_ROUTE(ro);
 	ifn_index = SCTP_GET_IF_INDEX_FROM_ROUTE(ro);
@@ -2561,8 +2715,23 @@ sctp_choose_boundspecific_inp(struct sctp_inpcb *inp,
 			sifa = sctp_is_ifa_addr_preferred(sctp_ifa,
 							  dest_is_loop,
 							  dest_is_priv, fam);
-			if (sifa == NULL)
+			
+			#ifdef FRCOV
+			{if (FIXREVERTER[151]) {
+			  if ((sifa == (void *) 0 ) && !(0))
+			    fprintf(stderr, "triggered bug index 151\n");
+			  else
+			    fprintf(stderr, "reached bug index 151\n");
+			}
+			if ((!FIXREVERTER[151] && (sifa == (void *) 0 ))
+			#else
+			if (0
+			#endif
+			)
 				continue;
+				#ifdef FRCOV
+				}
+				#endif
 			if (sctp_is_addr_in_ep(inp, sifa)) {
 				atomic_add_int(&sifa->refcount, 1);
 				return (sifa);
@@ -2583,18 +2752,63 @@ sctp_choose_boundspecific_inp(struct sctp_inpcb *inp,
 	}
 	for (laddr = inp->next_addr_touse; laddr;
 	     laddr = LIST_NEXT(laddr, sctp_nxt_addr)) {
-		if (laddr->ifa == NULL) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[152]) {
+		  if ((laddr -> ifa == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 152\n");
+		  else
+		    fprintf(stderr, "reached bug index 152\n");
+		}
+		if ((!FIXREVERTER[152] && (laddr -> ifa == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		) {
 			/* address has been removed */
 			continue;
 		}
-		if (laddr->action == SCTP_DEL_IP_ADDRESS) {
+		#ifdef FRCOV
+		}
+		#endif
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[153]) {
+		  if ((laddr -> action == 49154 ) && !(0))
+		    fprintf(stderr, "triggered bug index 153\n");
+		  else
+		    fprintf(stderr, "reached bug index 153\n");
+		}
+		if ((!FIXREVERTER[153] && (laddr -> action == 49154 ))
+		#else
+		if (0
+		#endif
+		) {
 			/* address is being deleted */
 			continue;
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		sifa = sctp_is_ifa_addr_preferred(laddr->ifa, dest_is_loop,
 						  dest_is_priv, fam);
-		if (sifa == NULL)
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[154]) {
+		  if ((sifa == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 154\n");
+		  else
+		    fprintf(stderr, "reached bug index 154\n");
+		}
+		if ((!FIXREVERTER[154] && (sifa == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		)
 			continue;
+			#ifdef FRCOV
+			}
+			#endif
 		atomic_add_int(&sifa->refcount, 1);
 		return (sifa);
 	}
@@ -2614,18 +2828,63 @@ sctp_choose_boundspecific_inp(struct sctp_inpcb *inp,
 	/* ok, what about an acceptable address in the inp */
 	for (laddr = inp->next_addr_touse; laddr;
 	     laddr = LIST_NEXT(laddr, sctp_nxt_addr)) {
-		if (laddr->ifa == NULL) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[156]) {
+		  if ((laddr -> ifa == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 156\n");
+		  else
+		    fprintf(stderr, "reached bug index 156\n");
+		}
+		if ((!FIXREVERTER[156] && (laddr -> ifa == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		) {
 			/* address has been removed */
 			continue;
 		}
-		if (laddr->action == SCTP_DEL_IP_ADDRESS) {
+		#ifdef FRCOV
+		}
+		#endif
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[157]) {
+		  if ((laddr -> action == 49154 ) && !(0))
+		    fprintf(stderr, "triggered bug index 157\n");
+		  else
+		    fprintf(stderr, "reached bug index 157\n");
+		}
+		if ((!FIXREVERTER[157] && (laddr -> action == 49154 ))
+		#else
+		if (0
+		#endif
+		) {
 			/* address is being deleted */
 			continue;
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		sifa = sctp_is_ifa_addr_acceptable(laddr->ifa, dest_is_loop,
 						   dest_is_priv, fam);
-		if (sifa == NULL)
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[158]) {
+		  if ((sifa == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 158\n");
+		  else
+		    fprintf(stderr, "reached bug index 158\n");
+		}
+		if ((!FIXREVERTER[158] && (sifa == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		)
 			continue;
+			#ifdef FRCOV
+			}
+			#endif
 		atomic_add_int(&sifa->refcount, 1);
 		return (sifa);
 	}
@@ -2666,8 +2925,23 @@ sctp_choose_boundspecific_stcb(struct sctp_inpcb *inp,
 	 * want that one.
 	 */
 	vrf = sctp_find_vrf(vrf_id);
-	if (vrf == NULL)
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[160]) {
+	  if ((vrf == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 160\n");
+	  else
+	    fprintf(stderr, "reached bug index 160\n");
+	}
+	if ((!FIXREVERTER[160] && (vrf == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	)
 		return (NULL);
+		#ifdef FRCOV
+		}
+		#endif
 
 	ifn = SCTP_GET_IFN_VOID_FROM_ROUTE(ro);
 	ifn_index = SCTP_GET_IF_INDEX_FROM_ROUTE(ro);
@@ -2701,8 +2975,23 @@ sctp_choose_boundspecific_stcb(struct sctp_inpcb *inp,
 				continue;
 			if (sctp_is_addr_in_ep(inp, sctp_ifa)) {
 				sifa = sctp_is_ifa_addr_preferred(sctp_ifa, dest_is_loop, dest_is_priv, fam);
-				if (sifa == NULL)
+				
+				#ifdef FRCOV
+				{if (FIXREVERTER[161]) {
+				  if ((sifa == (void *) 0 ) && !(0))
+				    fprintf(stderr, "triggered bug index 161\n");
+				  else
+				    fprintf(stderr, "reached bug index 161\n");
+				}
+				if ((!FIXREVERTER[161] && (sifa == (void *) 0 ))
+				#else
+				if (0
+				#endif
+				)
 					continue;
+					#ifdef FRCOV
+					}
+					#endif
 				if (((non_asoc_addr_ok == 0) &&
 				     (sctp_is_addr_restricted(stcb, sifa))) ||
 				    (non_asoc_addr_ok &&
@@ -2737,8 +3026,23 @@ sctp_choose_boundspecific_stcb(struct sctp_inpcb *inp,
 				continue;
 			if (sctp_is_addr_in_ep(inp, sctp_ifa)) {
 				sifa= sctp_is_ifa_addr_acceptable(sctp_ifa, dest_is_loop, dest_is_priv,fam);
-				if (sifa == NULL)
+				
+				#ifdef FRCOV
+				{if (FIXREVERTER[162]) {
+				  if ((sifa == (void *) 0 ) && !(0))
+				    fprintf(stderr, "triggered bug index 162\n");
+				  else
+				    fprintf(stderr, "reached bug index 162\n");
+				}
+				if ((!FIXREVERTER[162] && (sifa == (void *) 0 ))
+				#else
+				if (0
+				#endif
+				)
 					continue;
+					#ifdef FRCOV
+					}
+					#endif
 				if (((non_asoc_addr_ok == 0) &&
 				     (sctp_is_addr_restricted(stcb, sifa))) ||
 				    (non_asoc_addr_ok &&
@@ -2767,17 +3071,62 @@ sctp_choose_boundspecific_stcb(struct sctp_inpcb *inp,
 	/* search beginning with the last used address */
 	for (laddr = stcb->asoc.last_used_address; laddr;
 	     laddr = LIST_NEXT(laddr, sctp_nxt_addr)) {
-		if (laddr->ifa == NULL) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[163]) {
+		  if ((laddr -> ifa == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 163\n");
+		  else
+		    fprintf(stderr, "reached bug index 163\n");
+		}
+		if ((!FIXREVERTER[163] && (laddr -> ifa == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		) {
 			/* address has been removed */
 			continue;
 		}
-		if (laddr->action == SCTP_DEL_IP_ADDRESS) {
+		#ifdef FRCOV
+		}
+		#endif
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[164]) {
+		  if ((laddr -> action == 49154 ) && !(0))
+		    fprintf(stderr, "triggered bug index 164\n");
+		  else
+		    fprintf(stderr, "reached bug index 164\n");
+		}
+		if ((!FIXREVERTER[164] && (laddr -> action == 49154 ))
+		#else
+		if (0
+		#endif
+		) {
 			/* address is being deleted */
 			continue;
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		sifa = sctp_is_ifa_addr_preferred(laddr->ifa, dest_is_loop, dest_is_priv, fam);
-		if (sifa == NULL)
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[165]) {
+		  if ((sifa == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 165\n");
+		  else
+		    fprintf(stderr, "reached bug index 165\n");
+		}
+		if ((!FIXREVERTER[165] && (sifa == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		)
 			continue;
+			#ifdef FRCOV
+			}
+			#endif
 		if (((non_asoc_addr_ok == 0) &&
 		     (sctp_is_addr_restricted(stcb, sifa))) ||
 		    (non_asoc_addr_ok &&
@@ -2805,18 +3154,63 @@ sctp_choose_boundspecific_stcb(struct sctp_inpcb *inp,
 	/* search beginning with the last used address */
 	for (laddr = stcb->asoc.last_used_address; laddr;
 	     laddr = LIST_NEXT(laddr, sctp_nxt_addr)) {
-		if (laddr->ifa == NULL) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[166]) {
+		  if ((laddr -> ifa == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 166\n");
+		  else
+		    fprintf(stderr, "reached bug index 166\n");
+		}
+		if ((!FIXREVERTER[166] && (laddr -> ifa == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		) {
 			/* address has been removed */
 			continue;
 		}
-		if (laddr->action == SCTP_DEL_IP_ADDRESS) {
+		#ifdef FRCOV
+		}
+		#endif
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[167]) {
+		  if ((laddr -> action == 49154 ) && !(0))
+		    fprintf(stderr, "triggered bug index 167\n");
+		  else
+		    fprintf(stderr, "reached bug index 167\n");
+		}
+		if ((!FIXREVERTER[167] && (laddr -> action == 49154 ))
+		#else
+		if (0
+		#endif
+		) {
 			/* address is being deleted */
 			continue;
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		sifa = sctp_is_ifa_addr_acceptable(laddr->ifa, dest_is_loop,
 						   dest_is_priv, fam);
-		if (sifa == NULL)
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[168]) {
+		  if ((sifa == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 168\n");
+		  else
+		    fprintf(stderr, "reached bug index 168\n");
+		}
+		if ((!FIXREVERTER[168] && (sifa == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		)
 			continue;
+			#ifdef FRCOV
+			}
+			#endif
 		if (((non_asoc_addr_ok == 0) &&
 		     (sctp_is_addr_restricted(stcb, sifa))) ||
 		    (non_asoc_addr_ok &&
@@ -2890,8 +3284,23 @@ sctp_select_nth_preferred_addr_from_ifn_boundall(struct sctp_ifn *ifn,
 			continue;
 		sifa = sctp_is_ifa_addr_preferred(ifa, dest_is_loop,
 						  dest_is_priv, fam);
-		if (sifa == NULL)
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[169]) {
+		  if ((sifa == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 169\n");
+		  else
+		    fprintf(stderr, "reached bug index 169\n");
+		}
+		if ((!FIXREVERTER[169] && (sifa == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		)
 			continue;
+			#ifdef FRCOV
+			}
+			#endif
 #ifdef INET6
 		if (fam == AF_INET6 &&
 		    dest_is_loop &&
@@ -3010,9 +3419,24 @@ sctp_count_num_preferred_boundall(struct sctp_ifn *ifn,
 		}
 		sifa = sctp_is_ifa_addr_preferred(ifa, dest_is_loop,
 						  dest_is_priv, fam);
-		if (sifa == NULL) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[171]) {
+		  if ((sifa == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 171\n");
+		  else
+		    fprintf(stderr, "reached bug index 171\n");
+		}
+		if ((!FIXREVERTER[171] && (sifa == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		) {
 			continue;
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		if (stcb) {
 			if (sctp_is_address_in_scope(ifa, &stcb->asoc.scope, 0) == 0) {
 				continue;
@@ -3070,18 +3494,48 @@ sctp_choose_boundall(struct sctp_inpcb *inp,
 	 * abort :-<.
 	 */
 	vrf = sctp_find_vrf(vrf_id);
-	if (vrf == NULL)
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[172]) {
+	  if ((vrf == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 172\n");
+	  else
+	    fprintf(stderr, "reached bug index 172\n");
+	}
+	if ((!FIXREVERTER[172] && (vrf == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	)
 		return (NULL);
+		#ifdef FRCOV
+		}
+		#endif
 
 	ifn = SCTP_GET_IFN_VOID_FROM_ROUTE(ro);
 	ifn_index = SCTP_GET_IF_INDEX_FROM_ROUTE(ro);
 	SCTPDBG(SCTP_DEBUG_OUTPUT2,"ifn from route:%p ifn_index:%d\n", ifn, ifn_index);
 	emit_ifn = looked_at = sctp_ifn = sctp_find_ifn(ifn, ifn_index);
-	if (sctp_ifn == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[173]) {
+	  if ((sctp_ifn == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 173\n");
+	  else
+	    fprintf(stderr, "reached bug index 173\n");
+	}
+	if ((!FIXREVERTER[173] && (sctp_ifn == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		/* ?? We don't have this guy ?? */
 		SCTPDBG(SCTP_DEBUG_OUTPUT2,"No ifn emit interface?\n");
 		goto bound_all_plan_b;
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	SCTPDBG(SCTP_DEBUG_OUTPUT2,"ifn_index:%d name:%s is emit interface\n",
 		ifn_index, sctp_ifn->ifn_name);
 
@@ -3171,8 +3625,23 @@ sctp_choose_boundall(struct sctp_inpcb *inp,
 		}
 		sifa = sctp_select_nth_preferred_addr_from_ifn_boundall(sctp_ifn, inp, stcb, non_asoc_addr_ok, dest_is_loop,
                                                                         dest_is_priv, cur_addr_num, fam, ro);
-		if (sifa == NULL)
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[176]) {
+		  if ((sifa == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 176\n");
+		  else
+		    fprintf(stderr, "reached bug index 176\n");
+		}
+		if ((!FIXREVERTER[176] && (sifa == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		)
 			continue;
+			#ifdef FRCOV
+			}
+			#endif
 		if (net) {
 			net->indx_of_eligible_next_to_use = cur_addr_num + 1;
 			SCTPDBG(SCTP_DEBUG_OUTPUT2, "we selected %d\n",
@@ -3191,10 +3660,25 @@ again_with_private_addresses_allowed:
 	/* plan_c: do we have an acceptable address on the emit interface */
 	sifa = NULL;
 	SCTPDBG(SCTP_DEBUG_OUTPUT2,"Trying Plan C: find acceptable on interface\n");
-	if (emit_ifn == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[177]) {
+	  if ((emit_ifn == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 177\n");
+	  else
+	    fprintf(stderr, "reached bug index 177\n");
+	}
+	if ((!FIXREVERTER[177] && (emit_ifn == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		SCTPDBG(SCTP_DEBUG_OUTPUT2,"Jump to Plan D - no emit_ifn\n");
 		goto plan_d;
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	LIST_FOREACH(sctp_ifa, &emit_ifn->ifalist, next_ifa) {
 		SCTPDBG(SCTP_DEBUG_OUTPUT2, "ifa:%p\n", (void *)sctp_ifa);
 #if defined(__FreeBSD__)
@@ -3222,10 +3706,25 @@ again_with_private_addresses_allowed:
 		}
 		sifa = sctp_is_ifa_addr_acceptable(sctp_ifa, dest_is_loop,
 						   dest_is_priv, fam);
-		if (sifa == NULL) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[178]) {
+		  if ((sifa == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 178\n");
+		  else
+		    fprintf(stderr, "reached bug index 178\n");
+		}
+		if ((!FIXREVERTER[178] && (sifa == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		) {
 			SCTPDBG(SCTP_DEBUG_OUTPUT2, "IFA not acceptable\n");
 			continue;
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		if (stcb) {
 			if (sctp_is_address_in_scope(sifa, &stcb->asoc.scope, 0) == 0) {
 				SCTPDBG(SCTP_DEBUG_OUTPUT2, "NOT in scope\n");
@@ -3285,8 +3784,23 @@ again_with_private_addresses_allowed:
 			sifa = sctp_is_ifa_addr_acceptable(sctp_ifa,
 							   dest_is_loop,
 							   dest_is_priv, fam);
-			if (sifa == NULL)
+			
+			#ifdef FRCOV
+			{if (FIXREVERTER[179]) {
+			  if ((sifa == (void *) 0 ) && !(0))
+			    fprintf(stderr, "triggered bug index 179\n");
+			  else
+			    fprintf(stderr, "reached bug index 179\n");
+			}
+			if ((!FIXREVERTER[179] && (sifa == (void *) 0 ))
+			#else
+			if (0
+			#endif
+			)
 				continue;
+				#ifdef FRCOV
+				}
+				#endif
 			if (stcb) {
 				if (sctp_is_address_in_scope(sifa, &stcb->asoc.scope, 0) == 0) {
 					sifa = NULL;
@@ -3353,9 +3867,24 @@ out:
 					tmp_sifa = sctp_is_ifa_addr_acceptable(sctp_ifa,
 					                                       dest_is_loop,
 					                                       dest_is_priv, fam);
-					if (tmp_sifa == NULL) {
+					
+					#ifdef FRCOV
+					{if (FIXREVERTER[180]) {
+					  if ((tmp_sifa == (void *) 0 ) && !(0))
+					    fprintf(stderr, "triggered bug index 180\n");
+					  else
+					    fprintf(stderr, "reached bug index 180\n");
+					}
+					if ((!FIXREVERTER[180] && (tmp_sifa == (void *) 0 ))
+					#else
+					if (0
+					#endif
+					) {
 						continue;
 					}
+					#ifdef FRCOV
+					}
+					#endif
 					if (tmp_sifa == sifa) {
 						continue;
 					}
@@ -3478,9 +4007,24 @@ sctp_source_address_selection(struct sctp_inpcb *inp,
 		 */
 		SCTP_RTALLOC(ro, vrf_id, inp->fibnum);
 	}
-	if (ro->ro_rt == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[181]) {
+	  if ((ro -> ro_rt == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 181\n");
+	  else
+	    fprintf(stderr, "reached bug index 181\n");
+	}
+	if ((!FIXREVERTER[181] && (ro -> ro_rt == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		return (NULL);
 	}
+	#ifdef FRCOV
+	}
+	#endif
 #if defined(__Userspace_os_Windows)
 	/* On Windows the sa_family is U_SHORT or ADDRESS_FAMILY */
 	fam = (sa_family_t)ro->ro_dst.sa_family;
@@ -3953,14 +4497,44 @@ sctp_add_cookie(struct mbuf *init, int init_offset,
 	mret = sctp_get_mbuf_for_msg((sizeof(struct sctp_state_cookie) +
 				      sizeof(struct sctp_paramhdr)), 0,
 				     M_NOWAIT, 1, MT_DATA);
-	if (mret == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[183]) {
+	  if ((mret == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 183\n");
+	  else
+	    fprintf(stderr, "reached bug index 183\n");
+	}
+	if ((!FIXREVERTER[183] && (mret == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		return (NULL);
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	copy_init = SCTP_M_COPYM(init, init_offset, M_COPYALL, M_NOWAIT);
-	if (copy_init == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[184]) {
+	  if ((copy_init == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 184\n");
+	  else
+	    fprintf(stderr, "reached bug index 184\n");
+	}
+	if ((!FIXREVERTER[184] && (copy_init == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		sctp_m_freem(mret);
 		return (NULL);
 	}
+	#ifdef FRCOV
+	}
+	#endif
 #ifdef SCTP_MBUF_LOGGING
 	if (SCTP_BASE_SYSCTL(sctp_logging_level) & SCTP_MBUF_LOGGING_ENABLE) {
 		sctp_log_mbc(copy_init, SCTP_MBUF_ICOPY);
@@ -3968,11 +4542,26 @@ sctp_add_cookie(struct mbuf *init, int init_offset,
 #endif
 	copy_initack = SCTP_M_COPYM(initack, initack_offset, M_COPYALL,
 	    M_NOWAIT);
-	if (copy_initack == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[185]) {
+	  if ((copy_initack == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 185\n");
+	  else
+	    fprintf(stderr, "reached bug index 185\n");
+	}
+	if ((!FIXREVERTER[185] && (copy_initack == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		sctp_m_freem(mret);
 		sctp_m_freem(copy_init);
 		return (NULL);
 	}
+	#ifdef FRCOV
+	}
+	#endif
 #ifdef SCTP_MBUF_LOGGING
 	if (SCTP_BASE_SYSCTL(sctp_logging_level) & SCTP_MBUF_LOGGING_ENABLE) {
 		sctp_log_mbc(copy_initack, SCTP_MBUF_ICOPY);
@@ -4012,11 +4601,26 @@ sctp_add_cookie(struct mbuf *init, int init_offset,
 		}
 	}
 	sig = sctp_get_mbuf_for_msg(SCTP_SECRET_SIZE, 0, M_NOWAIT, 1, MT_DATA);
-	if (sig == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[186]) {
+	  if ((sig == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 186\n");
+	  else
+	    fprintf(stderr, "reached bug index 186\n");
+	}
+	if ((!FIXREVERTER[186] && (sig == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		/* no space, so free the entire chain */
 		sctp_m_freem(mret);
 		return (NULL);
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	SCTP_BUF_LEN(sig) = 0;
 	SCTP_BUF_NEXT(m_at) = sig;
 	sig_offset = 0;
@@ -4170,9 +4774,27 @@ sctp_lowlevel_chunk_output(struct sctp_inpcb *inp,
 	}
 #endif
 	/* fill in the HMAC digest for any AUTH chunk in the packet */
-	if ((auth != NULL) && (stcb != NULL)) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[187]) {
+	  fprintf(stderr, "reached bug index 187\n");
+	}
+	if ((FIXREVERTER[187] && (auth != (void *) 0 )) || (!FIXREVERTER[187] && (auth != (void *) 0 && stcb != (void *) 0 ))
+	#else
+	if (auth != (void *) 0 
+	#endif
+	) {
+	  
+	#ifdef FRCOV
+	  if (!(stcb != (void *) 0 ))
+	    fprintf(stderr, "triggered bug index 187\n");
+	  #endif
+	
 		sctp_fill_hmac_digest_m(m, auth_offset, auth, stcb, auth_keyid);
 	}
+	#ifdef FRCOV
+	}
+	#endif
 
 	if (net) {
 		tos_value = net->dscp;
@@ -4195,11 +4817,26 @@ sctp_lowlevel_chunk_output(struct sctp_inpcb *inp,
 			len += sizeof(struct udphdr);
 		}
 		newm = sctp_get_mbuf_for_msg(len, 1, M_NOWAIT, 1, MT_DATA);
-		if (newm == NULL) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[188]) {
+		  if ((newm == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 188\n");
+		  else
+		    fprintf(stderr, "reached bug index 188\n");
+		}
+		if ((!FIXREVERTER[188] && (newm == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		) {
 			sctp_m_freem(m);
 			SCTP_LTRACE_ERR_RET(inp, stcb, NULL, SCTP_FROM_SCTP_OUTPUT, ENOMEM);
 			return (ENOMEM);
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		SCTP_ALIGN_TO_END(newm, len);
 		SCTP_BUF_LEN(newm) = len;
 		SCTP_BUF_NEXT(newm) = m;
@@ -4558,11 +5195,26 @@ sctp_lowlevel_chunk_output(struct sctp_inpcb *inp,
 			len += sizeof(struct udphdr);
 		}
 		newm = sctp_get_mbuf_for_msg(len, 1, M_NOWAIT, 1, MT_DATA);
-		if (newm == NULL) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[189]) {
+		  if ((newm == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 189\n");
+		  else
+		    fprintf(stderr, "reached bug index 189\n");
+		}
+		if ((!FIXREVERTER[189] && (newm == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		) {
 			sctp_m_freem(m);
 			SCTP_LTRACE_ERR_RET(inp, stcb, NULL, SCTP_FROM_SCTP_OUTPUT, ENOMEM);
 			return (ENOMEM);
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		SCTP_ALIGN_TO_END(newm, len);
 		SCTP_BUF_LEN(newm) = len;
 		SCTP_BUF_NEXT(newm) = m;
@@ -5007,11 +5659,26 @@ sctp_lowlevel_chunk_output(struct sctp_inpcb *inp,
 		sconn = (struct sockaddr_conn *)to;
 		len = sizeof(struct sctphdr);
 		newm = sctp_get_mbuf_for_msg(len, 1, M_NOWAIT, 1, MT_DATA);
-		if (newm == NULL) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[190]) {
+		  if ((newm == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 190\n");
+		  else
+		    fprintf(stderr, "reached bug index 190\n");
+		}
+		if ((!FIXREVERTER[190] && (newm == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		) {
 			sctp_m_freem(m);
 			SCTP_LTRACE_ERR_RET(inp, stcb, NULL, SCTP_FROM_SCTP_OUTPUT, ENOMEM);
 			return (ENOMEM);
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		SCTP_ALIGN_TO_END(newm, len);
 		SCTP_BUF_LEN(newm) = len;
 		SCTP_BUF_NEXT(newm) = m;
@@ -5086,10 +5753,25 @@ sctp_send_initiate(struct sctp_inpcb *inp, struct sctp_tcb *stcb, int so_locked
 	net = stcb->asoc.primary_destination;
 	if (net == NULL) {
 		net = TAILQ_FIRST(&stcb->asoc.nets);
-		if (net == NULL) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[191]) {
+		  if ((net == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 191\n");
+		  else
+		    fprintf(stderr, "reached bug index 191\n");
+		}
+		if ((!FIXREVERTER[191] && (net == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		) {
 			/* TSNH */
 			return;
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		/* we confirm any address we send an INIT to */
 		net->dest_state &= ~SCTP_ADDR_UNCONFIRMED;
 		(void)sctp_set_primary_addr(stcb, NULL, net);
@@ -5117,11 +5799,26 @@ sctp_send_initiate(struct sctp_inpcb *inp, struct sctp_tcb *stcb, int so_locked
 	sctp_timer_start(SCTP_TIMER_TYPE_INIT, inp, stcb, net);
 
 	m = sctp_get_mbuf_for_msg(MCLBYTES, 1, M_NOWAIT, 1, MT_DATA);
-	if (m == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[192]) {
+	  if ((m == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 192\n");
+	  else
+	    fprintf(stderr, "reached bug index 192\n");
+	}
+	if ((!FIXREVERTER[192] && (m == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		/* No memory, INIT timer will re-attempt. */
 		SCTPDBG(SCTP_DEBUG_OUTPUT4, "Sending INIT - mbuf?\n");
 		return;
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	chunk_len = (uint16_t)sizeof(struct sctp_init_chunk);
 	padding_len = 0;
 	/* Now lets put the chunk header in place */
@@ -5436,10 +6133,25 @@ sctp_arethere_unrecognized_parameters(struct mbuf *in_initpkt,
 			at += padded_size;
 			break;
 		case SCTP_SUPPORTED_ADDRTYPE:
-			if (padded_size > SCTP_MAX_ADDR_PARAMS_SIZE) {
+			
+			#ifdef FRCOV
+			{if (FIXREVERTER[193]) {
+			  if ((padded_size > 12 ) && !(0))
+			    fprintf(stderr, "triggered bug index 193\n");
+			  else
+			    fprintf(stderr, "reached bug index 193\n");
+			}
+			if ((!FIXREVERTER[193] && (padded_size > 12 ))
+			#else
+			if (0
+			#endif
+			) {
 				SCTPDBG(SCTP_DEBUG_OUTPUT1, "Invalid size - error supaddrtype %d\n", plen);
 				goto invalid_size;
 			}
+			#ifdef FRCOV
+			}
+			#endif
 			at += padded_size;
 			break;
 		case SCTP_RANDOM:
@@ -5826,9 +6538,24 @@ sctp_are_there_new_addresses(struct sctp_association *asoc,
 			}
 			phdr = sctp_get_next_param(in_initpkt, offset,
 			    (struct sctp_paramhdr *)&p4_buf, sizeof(p4_buf));
-			if (phdr == NULL) {
+			
+			#ifdef FRCOV
+			{if (FIXREVERTER[194]) {
+			  if ((phdr == (void *) 0 ) && !(0))
+			    fprintf(stderr, "triggered bug index 194\n");
+			  else
+			    fprintf(stderr, "reached bug index 194\n");
+			}
+			if ((!FIXREVERTER[194] && (phdr == (void *) 0 ))
+			#else
+			if (0
+			#endif
+			) {
 				return (1);
 			}
+			#ifdef FRCOV
+			}
+			#endif
 			if (asoc->scope.ipv4_addr_legal) {
 				p4 = (struct sctp_ipv4addr_param *)phdr;
 				sin4.sin_addr.s_addr = p4->addr;
@@ -5847,9 +6574,24 @@ sctp_are_there_new_addresses(struct sctp_association *asoc,
 			}
 			phdr = sctp_get_next_param(in_initpkt, offset,
 			    (struct sctp_paramhdr *)&p6_buf, sizeof(p6_buf));
-			if (phdr == NULL) {
+			
+			#ifdef FRCOV
+			{if (FIXREVERTER[195]) {
+			  if ((phdr == (void *) 0 ) && !(0))
+			    fprintf(stderr, "triggered bug index 195\n");
+			  else
+			    fprintf(stderr, "reached bug index 195\n");
+			}
+			if ((!FIXREVERTER[195] && (phdr == (void *) 0 ))
+			#else
+			if (0
+			#endif
+			) {
 				return (1);
 			}
+			#ifdef FRCOV
+			}
+			#endif
 			if (asoc->scope.ipv6_addr_legal) {
 				p6 = (struct sctp_ipv6addr_param *)phdr;
 				memcpy((caddr_t)&sin6.sin6_addr, p6->addr,
@@ -5868,9 +6610,24 @@ sctp_are_there_new_addresses(struct sctp_association *asoc,
 			fnd = 0;
 			TAILQ_FOREACH(net, &asoc->nets, sctp_next) {
 				sa = (struct sockaddr *)&net->ro._l_addr;
-				if (sa->sa_family != sa_touse->sa_family) {
+				
+				#ifdef FRCOV
+				{if (FIXREVERTER[196]) {
+				  if ((sa -> sa_family != sa_touse -> sa_family ) && !(0))
+				    fprintf(stderr, "triggered bug index 196\n");
+				  else
+				    fprintf(stderr, "reached bug index 196\n");
+				}
+				if ((!FIXREVERTER[196] && (sa -> sa_family != sa_touse -> sa_family ))
+				#else
+				if (0
+				#endif
+				) {
 					continue;
 				}
+				#ifdef FRCOV
+				}
+				#endif
 #ifdef INET
 				if (sa->sa_family == AF_INET) {
 					sa4 = (struct sockaddr_in *)sa;
@@ -6023,11 +6780,26 @@ sctp_send_initiate_ack(struct sctp_inpcb *inp, struct sctp_tcb *stcb,
 		return;
 	}
 	m = sctp_get_mbuf_for_msg(MCLBYTES, 0, M_NOWAIT, 1, MT_DATA);
-	if (m == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[197]) {
+	  if ((m == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 197\n");
+	  else
+	    fprintf(stderr, "reached bug index 197\n");
+	}
+	if ((!FIXREVERTER[197] && (m == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		/* No memory, INIT timer will re-attempt. */
 		sctp_m_freem(op_err);
 		return;
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	chunk_len = (uint16_t)sizeof(struct sctp_init_ack_chunk);
 	padding_len = 0;
 
@@ -6585,21 +7357,51 @@ sctp_send_initiate_ack(struct sctp_inpcb *inp, struct sctp_tcb *stcb,
 	}
 	if (padding_len > 0) {
 		m_last = sctp_add_pad_tombuf(m_last, padding_len);
-		if (m_last == NULL) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[198]) {
+		  if ((m_last == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 198\n");
+		  else
+		    fprintf(stderr, "reached bug index 198\n");
+		}
+		if ((!FIXREVERTER[198] && (m_last == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		) {
 			/* Houston we have a problem, no space */
 			sctp_m_freem(m);
 			return;
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		chunk_len += padding_len;
 		padding_len = 0;
 	}
 	/* Now we must build a cookie */
 	m_cookie = sctp_add_cookie(init_pkt, offset, m, 0, &stc, &signature);
-	if (m_cookie == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[199]) {
+	  if ((m_cookie == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 199\n");
+	  else
+	    fprintf(stderr, "reached bug index 199\n");
+	}
+	if ((!FIXREVERTER[199] && (m_cookie == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		/* memory problem */
 		sctp_m_freem(m);
 		return;
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	/* Now append the cookie to the end and update the space/size */
 	SCTP_BUF_NEXT(m_last) = m_cookie;
 	parameter_len = 0;
@@ -6888,11 +7690,26 @@ sctp_msg_append(struct sctp_tcb *stcb,
 		goto out_now;
 	}
 	sctp_alloc_a_strmoq(stcb, sp);
-	if (sp == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[202]) {
+	  if ((sp == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 202\n");
+	  else
+	    fprintf(stderr, "reached bug index 202\n");
+	}
+	if ((!FIXREVERTER[202] && (sp == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		SCTP_LTRACE_ERR_RET(NULL, stcb, NULL, SCTP_FROM_SCTP_OUTPUT, ENOMEM);
 		error = ENOMEM;
 		goto out_now;
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	sp->sinfo_flags = srcv->sinfo_flags;
 	sp->timetolive = srcv->sinfo_timetolive;
 	sp->ppid = srcv->sinfo_ppid;
@@ -6963,13 +7780,28 @@ sctp_copy_mbufchain(struct mbuf *clonechain,
 	caddr_t cp;
 	int len;
 
-	if (endofchain == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[203]) {
+	  if ((endofchain == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 203\n");
+	  else
+	    fprintf(stderr, "reached bug index 203\n");
+	}
+	if ((!FIXREVERTER[203] && (endofchain == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		/* error */
 	error_out:
 		if (outchain)
 			sctp_m_freem(outchain);
 		return (NULL);
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	if (can_take_mbuf) {
 		appendchain = clonechain;
 	} else {
@@ -6987,9 +7819,24 @@ sctp_copy_mbufchain(struct mbuf *clonechain,
 					/* This is the general case */
 				new_mbuf:
 					outchain = sctp_get_mbuf_for_msg(MCLBYTES, 0, M_NOWAIT, 1, MT_HEADER);
-					if (outchain == NULL) {
+					
+					#ifdef FRCOV
+					{if (FIXREVERTER[204]) {
+					  if ((outchain == (void *) 0 ) && !(0))
+					    fprintf(stderr, "triggered bug index 204\n");
+					  else
+					    fprintf(stderr, "reached bug index 204\n");
+					}
+					if ((!FIXREVERTER[204] && (outchain == (void *) 0 ))
+					#else
+					if (0
+					#endif
+					) {
 						goto error_out;
 					}
+					#ifdef FRCOV
+					}
+					#endif
 					SCTP_BUF_LEN(outchain) = 0;
 					*endofchain = outchain;
 					/* get the prepend space */
@@ -7035,10 +7882,25 @@ sctp_copy_mbufchain(struct mbuf *clonechain,
 					sizeofcpy -= len;
 				}
 				m = sctp_get_mbuf_for_msg(MCLBYTES, 0, M_NOWAIT, 1, MT_HEADER);
-				if (m == NULL) {
+				
+				#ifdef FRCOV
+				{if (FIXREVERTER[205]) {
+				  if ((m == (void *) 0 ) && !(0))
+				    fprintf(stderr, "triggered bug index 205\n");
+				  else
+				    fprintf(stderr, "reached bug index 205\n");
+				}
+				if ((!FIXREVERTER[205] && (m == (void *) 0 ))
+				#else
+				if (0
+				#endif
+				) {
 					/* We failed */
 					goto error_out;
 				}
+				#ifdef FRCOV
+				}
+				#endif
 				SCTP_BUF_NEXT((*endofchain)) = m;
 				*endofchain = m;
 				cp = mtod((*endofchain), caddr_t);
@@ -7056,12 +7918,27 @@ sctp_copy_mbufchain(struct mbuf *clonechain,
 #endif
 		}
 	}
-	if (appendchain == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[206]) {
+	  if ((appendchain == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 206\n");
+	  else
+	    fprintf(stderr, "reached bug index 206\n");
+	}
+	if ((!FIXREVERTER[206] && (appendchain == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		/* error */
 		if (outchain)
 			sctp_m_freem(outchain);
 		return (NULL);
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	if (outchain) {
 		/* tack on to the end */
 		if (*endofchain != NULL) {
@@ -7324,10 +8201,25 @@ sctp_copy_out_all(struct uio *uio, ssize_t len)
 	ssize_t left, willcpy, cancpy, error;
 
 	ret = sctp_get_mbuf_for_msg(MCLBYTES, 0, M_WAITOK, 1, MT_DATA);
-	if (ret == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[209]) {
+	  if ((ret == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 209\n");
+	  else
+	    fprintf(stderr, "reached bug index 209\n");
+	}
+	if ((!FIXREVERTER[209] && (ret == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		/* TSNH */
 		return (NULL);
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	left = len;
 	SCTP_BUF_LEN(ret) = 0;
 	/* save space for the data chunk header */
@@ -7377,18 +8269,48 @@ sctp_sendall(struct sctp_inpcb *inp, struct uio *uio, struct mbuf *m,
 	if (uio_resid(uio) > SCTP_MAX_SENDALL_LIMIT) {
 #endif
 #else
-	if (uio->uio_resid > SCTP_MAX_SENDALL_LIMIT) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[210]) {
+	  if ((uio -> uio_resid > 1024 ) && !(0))
+	    fprintf(stderr, "triggered bug index 210\n");
+	  else
+	    fprintf(stderr, "reached bug index 210\n");
+	}
+	if ((!FIXREVERTER[210] && (uio -> uio_resid > 1024 ))
+	#else
+	if (0
+	#endif
+	) {
 #endif
 		/* You must be less than the max! */
 		return (EMSGSIZE);
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	SCTP_MALLOC(ca, struct sctp_copy_all *, sizeof(struct sctp_copy_all),
 		    SCTP_M_COPYAL);
-	if (ca == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[211]) {
+	  if ((ca == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 211\n");
+	  else
+	    fprintf(stderr, "reached bug index 211\n");
+	}
+	if ((!FIXREVERTER[211] && (ca == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		sctp_m_freem(m);
 		SCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_OUTPUT, ENOMEM);
 		return (ENOMEM);
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	memset(ca, 0, sizeof(struct sctp_copy_all));
 
 	ca->inp = inp;
@@ -7418,11 +8340,26 @@ sctp_sendall(struct sctp_inpcb *inp, struct uio *uio, struct mbuf *m,
 #if defined(__APPLE__)
 		SCTP_SOCKET_LOCK(SCTP_INP_SO(inp), 0);
 #endif
-		if (ca->m == NULL) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[212]) {
+		  if ((ca -> m == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 212\n");
+		  else
+		    fprintf(stderr, "reached bug index 212\n");
+		}
+		if ((!FIXREVERTER[212] && (ca -> m == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		) {
 			SCTP_FREE(ca, SCTP_M_COPYAL);
 			SCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_OUTPUT, ENOMEM);
 			return (ENOMEM);
 		}
+		#ifdef FRCOV
+		}
+		#endif
 	} else {
 		/* Gather the length of the send */
 		struct mbuf *mat;
@@ -7534,10 +8471,25 @@ sctp_clean_up_datalist(struct sctp_tcb *stcb,
 			/* need to move back */
 		back_up_more:
 			tpp = TAILQ_PREV(tp1, sctpchunk_listhead, sctp_next);
-			if (tpp == NULL) {
+			
+			#ifdef FRCOV
+			{if (FIXREVERTER[213]) {
+			  if ((tpp == (void *) 0 ) && !(0))
+			    fprintf(stderr, "triggered bug index 213\n");
+			  else
+			    fprintf(stderr, "reached bug index 213\n");
+			}
+			if ((!FIXREVERTER[213] && (tpp == (void *) 0 ))
+			#else
+			if (0
+			#endif
+			) {
 				TAILQ_INSERT_BEFORE(tp1, data_list[i], sctp_next);
 				goto all_done;
 			}
+			#ifdef FRCOV
+			}
+			#endif
 			tp1 = tpp;
 			if (SCTP_TSN_GT(tp1->rec.data.tsn, data_list[i]->rec.data.tsn)) {
 				goto back_up_more;
@@ -8319,9 +9271,24 @@ sctp_move_chunks_from_net(struct sctp_tcb *stcb, struct sctp_nets *net)
 	struct sctp_stream_queue_pending *sp;
 	unsigned int i;
 
-	if (net == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[219]) {
+	  if ((net == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 219\n");
+	  else
+	    fprintf(stderr, "reached bug index 219\n");
+	}
+	if ((!FIXREVERTER[219] && (net == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		return;
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	asoc = &stcb->asoc;
 	for (i = 0; i < stcb->asoc.streamoutcnt; i++) {
 		TAILQ_FOREACH(sp, &stcb->asoc.strmout[i].outqueue, next) {
@@ -8461,7 +9428,19 @@ sctp_med_chunk_output(struct sctp_inpcb *inp,
 	if (no_data_chunks == 0) {
 		/* How many non-directed chunks are there? */
 		TAILQ_FOREACH(chk, &asoc->send_queue, sctp_next) {
-			if (chk->whoTo == NULL) {
+			
+			#ifdef FRCOV
+			{if (FIXREVERTER[220]) {
+			  if ((chk -> whoTo == (void *) 0 ) && !(0))
+			    fprintf(stderr, "triggered bug index 220\n");
+			  else
+			    fprintf(stderr, "reached bug index 220\n");
+			}
+			if ((!FIXREVERTER[220] && (chk -> whoTo == (void *) 0 ))
+			#else
+			if (0
+			#endif
+			) {
 				/* We already have non-directed
 				 * chunks on the queue, no need
 				 * to do a fill-up.
@@ -8469,6 +9448,9 @@ sctp_med_chunk_output(struct sctp_inpcb *inp,
 				skip_fill_up = 1;
 				break;
 			}
+			#ifdef FRCOV
+			}
+			#endif
 		}
 
 	}
@@ -8502,7 +9484,19 @@ sctp_med_chunk_output(struct sctp_inpcb *inp,
 			    (net->flight_size == 0)) {
 				(*stcb->asoc.cc_functions.sctp_cwnd_new_transmission_begins)(stcb, net);
 			}
-			if (net->flight_size >= net->cwnd) {
+			
+			#ifdef FRCOV
+			{if (FIXREVERTER[221]) {
+			  if ((net -> flight_size >= net -> cwnd ) && !(0))
+			    fprintf(stderr, "triggered bug index 221\n");
+			  else
+			    fprintf(stderr, "reached bug index 221\n");
+			}
+			if ((!FIXREVERTER[221] && (net -> flight_size >= net -> cwnd ))
+			#else
+			if (0
+			#endif
+			) {
 				/* skip this network, no room - can't fill */
 				if (SCTP_BASE_SYSCTL(sctp_logging_level) & SCTP_CWND_LOGGING_ENABLE) {
 					sctp_log_cwnd(stcb, net, 3,
@@ -8510,6 +9504,9 @@ sctp_med_chunk_output(struct sctp_inpcb *inp,
 				}
 				continue;
 			}
+			#ifdef FRCOV
+			}
+			#endif
 			if (SCTP_BASE_SYSCTL(sctp_logging_level) & SCTP_CWND_LOGGING_ENABLE) {
 				sctp_log_cwnd(stcb, net, 4, SCTP_CWND_LOG_FILL_OUTQ_CALLED);
 			}
@@ -8642,9 +9639,24 @@ again_one_more_time:
 					break;
 				}
 			}
-			if (chk->data == NULL) {
+			
+			#ifdef FRCOV
+			{if (FIXREVERTER[222]) {
+			  if ((chk -> data == (void *) 0 ) && !(0))
+			    fprintf(stderr, "triggered bug index 222\n");
+			  else
+			    fprintf(stderr, "reached bug index 222\n");
+			}
+			if ((!FIXREVERTER[222] && (chk -> data == (void *) 0 ))
+			#else
+			if (0
+			#endif
+			) {
 				break;
 			}
+			#ifdef FRCOV
+			}
+			#endif
 			if (chk->sent != SCTP_DATAGRAM_UNSENT &&
 			    chk->sent != SCTP_DATAGRAM_RESEND) {
 				break;
@@ -8694,11 +9706,26 @@ again_one_more_time:
 				outchain = sctp_copy_mbufchain(chk->data, outchain, &endoutchain,
 							       (int)chk->rec.chunk_id.can_take_data,
 							       chk->send_size, chk->copy_by_ref);
-				if (outchain == NULL) {
+				
+				#ifdef FRCOV
+				{if (FIXREVERTER[223]) {
+				  if ((outchain == (void *) 0 ) && !(0))
+				    fprintf(stderr, "triggered bug index 223\n");
+				  else
+				    fprintf(stderr, "reached bug index 223\n");
+				}
+				if ((!FIXREVERTER[223] && (outchain == (void *) 0 ))
+				#else
+				if (0
+				#endif
+				) {
 					*reason_code = 8;
 					SCTP_LTRACE_ERR_RET(inp, stcb, NULL, SCTP_FROM_SCTP_OUTPUT, ENOMEM);
 					return (ENOMEM);
 				}
+				#ifdef FRCOV
+				}
+				#endif
 				SCTP_STAT_INCR_COUNTER64(sctps_outcontrolchunks);
 				/* update our MTU size */
 				if (mtu > (chk->send_size + omtu))
@@ -8862,10 +9889,37 @@ again_one_more_time:
 				}
 			}
 		skip_net_check:
-			if (chk->data == NULL) {
+			
+			#ifdef FRCOV
+			{if (FIXREVERTER[225]) {
+			  if ((chk -> data == (void *) 0 ) && !(0))
+			    fprintf(stderr, "triggered bug index 225\n");
+			  else
+			    fprintf(stderr, "reached bug index 225\n");
+			}
+			if ((!FIXREVERTER[225] && (chk -> data == (void *) 0 ))
+			#else
+			if (0
+			#endif
+			) {
 				continue;
 			}
-			if (chk->sent != SCTP_DATAGRAM_UNSENT) {
+			#ifdef FRCOV
+			}
+			#endif
+			
+			#ifdef FRCOV
+			{if (FIXREVERTER[226]) {
+			  if ((chk -> sent != 0 ) && !(0))
+			    fprintf(stderr, "triggered bug index 226\n");
+			  else
+			    fprintf(stderr, "reached bug index 226\n");
+			}
+			if ((!FIXREVERTER[226] && (chk -> sent != 0 ))
+			#else
+			if (0
+			#endif
+			) {
 				/*
 				 * It must be unsent. Cookies and ASCONF's
 				 * hang around but there timers will force
@@ -8873,6 +9927,9 @@ again_one_more_time:
 				 */
 				continue;
 			}
+			#ifdef FRCOV
+			}
+			#endif
 			/*
 			 * if no AUTH is yet included and this chunk
 			 * requires it, make sure to account for it.  We
@@ -8918,11 +9975,26 @@ again_one_more_time:
 				outchain = sctp_copy_mbufchain(chk->data, outchain, &endoutchain,
 							       (int)chk->rec.chunk_id.can_take_data,
 							       chk->send_size, chk->copy_by_ref);
-				if (outchain == NULL) {
+				
+				#ifdef FRCOV
+				{if (FIXREVERTER[227]) {
+				  if ((outchain == (void *) 0 ) && !(0))
+				    fprintf(stderr, "triggered bug index 227\n");
+				  else
+				    fprintf(stderr, "reached bug index 227\n");
+				}
+				if ((!FIXREVERTER[227] && (outchain == (void *) 0 ))
+				#else
+				if (0
+				#endif
+				) {
 					*reason_code = 8;
 					SCTP_LTRACE_ERR_RET(inp, stcb, NULL, SCTP_FROM_SCTP_OUTPUT, ENOMEM);
 					return (ENOMEM);
 				}
+				#ifdef FRCOV
+				}
+				#endif
 				SCTP_STAT_INCR_COUNTER64(sctps_outcontrolchunks);
 				/* update our MTU size */
 				if (mtu > (chk->send_size + omtu))
@@ -9102,9 +10174,24 @@ again_one_more_time:
 		    (net->dest_state & SCTP_ADDR_PF)) {
 			goto no_data_fill;
 		}
-		if (net->flight_size >= net->cwnd) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[229]) {
+		  if ((net -> flight_size >= net -> cwnd ) && !(0))
+		    fprintf(stderr, "triggered bug index 229\n");
+		  else
+		    fprintf(stderr, "reached bug index 229\n");
+		}
+		if ((!FIXREVERTER[229] && (net -> flight_size >= net -> cwnd ))
+		#else
+		if (0
+		#endif
+		) {
 			goto no_data_fill;
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		if ((asoc->sctp_cmt_on_off > 0) &&
 		    (SCTP_BASE_SYSCTL(sctp_buffer_splitting) & SCTP_RECV_BUFFER_SPLITTING) &&
 		    (net->flight_size > max_rwnd_per_dest)) {
@@ -9178,11 +10265,26 @@ again_one_more_time:
 					*reason_code = 1;
 					break;
 				}
-				if (net->flight_size >= net->cwnd) {
+				
+				#ifdef FRCOV
+				{if (FIXREVERTER[230]) {
+				  if ((net -> flight_size >= net -> cwnd ) && !(0))
+				    fprintf(stderr, "triggered bug index 230\n");
+				  else
+				    fprintf(stderr, "reached bug index 230\n");
+				}
+				if ((!FIXREVERTER[230] && (net -> flight_size >= net -> cwnd ))
+				#else
+				if (0
+				#endif
+				) {
 					/* skip this net, no room for data */
 					*reason_code = 2;
 					break;
 				}
+				#ifdef FRCOV
+				}
+				#endif
 				if ((chk->whoTo != NULL) &&
 				    (chk->whoTo != net)) {
 					/* Don't send the chunk on this net */
@@ -9248,10 +10350,25 @@ again_one_more_time:
 							/* use this data's keyid */
 							auth_keyid = chk->auth_keyid;
 							override_ok = 0;
-						} else if (auth_keyid != chk->auth_keyid) {
+						} else 
+						#ifdef FRCOV
+						{if (FIXREVERTER[231]) {
+						  if ((auth_keyid != chk -> auth_keyid ) && !(0))
+						    fprintf(stderr, "triggered bug index 231\n");
+						  else
+						    fprintf(stderr, "reached bug index 231\n");
+						}
+						if ((!FIXREVERTER[231] && (auth_keyid != chk -> auth_keyid ))
+						#else
+						if (0
+						#endif
+						) {
 							/* different keyid, so done bundling */
 							break;
 						}
+						#ifdef FRCOV
+						}
+						#endif
 					}
 					outchain = sctp_copy_mbufchain(chk->data, outchain, &endoutchain, 0,
 								       chk->send_size, chk->copy_by_ref);
@@ -9291,9 +10408,24 @@ again_one_more_time:
 					}
 					chk->window_probe = 0;
 					data_list[bundle_at++] = chk;
-					if (bundle_at >= SCTP_MAX_DATA_BUNDLING) {
+					
+					#ifdef FRCOV
+					{if (FIXREVERTER[232]) {
+					  if ((bundle_at >= 256 ) && !(0))
+					    fprintf(stderr, "triggered bug index 232\n");
+					  else
+					    fprintf(stderr, "reached bug index 232\n");
+					}
+					if ((!FIXREVERTER[232] && (bundle_at >= 256 ))
+					#else
+					if (0
+					#endif
+					) {
 						break;
 					}
+					#ifdef FRCOV
+					}
+					#endif
 					if (chk->sent == SCTP_DATAGRAM_UNSENT) {
 						if ((chk->rec.data.rcv_flags & SCTP_DATA_UNORDERED) == 0) {
 							SCTP_STAT_INCR_COUNTER64(sctps_outorderchunks);
@@ -9473,9 +10605,24 @@ sctp_queue_op_err(struct sctp_tcb *stcb, struct mbuf *op_err)
 
 	SCTP_TCB_LOCK_ASSERT(stcb);
 	SCTP_BUF_PREPEND(op_err, sizeof(struct sctp_chunkhdr), M_NOWAIT);
-	if (op_err == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[233]) {
+	  if ((op_err == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 233\n");
+	  else
+	    fprintf(stderr, "reached bug index 233\n");
+	}
+	if ((!FIXREVERTER[233] && (op_err == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		return;
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	last_mbuf = NULL;
 	chunk_length = 0;
 	for (mat = op_err; mat != NULL; mat = SCTP_BUF_NEXT(mat)) {
@@ -9484,10 +10631,25 @@ sctp_queue_op_err(struct sctp_tcb *stcb, struct mbuf *op_err)
 			last_mbuf = mat;
 		}
 	}
-	if (chunk_length > SCTP_MAX_CHUNK_LENGTH) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[234]) {
+	  if ((chunk_length > 65535 ) && !(0))
+	    fprintf(stderr, "triggered bug index 234\n");
+	  else
+	    fprintf(stderr, "reached bug index 234\n");
+	}
+	if ((!FIXREVERTER[234] && (chunk_length > 65535 ))
+	#else
+	if (0
+	#endif
+	) {
 		sctp_m_freem(op_err);
 		return;
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	padding_length = chunk_length % 4;
 	if (padding_length != 0) {
 		padding_length = 4 - padding_length;
@@ -9499,11 +10661,26 @@ sctp_queue_op_err(struct sctp_tcb *stcb, struct mbuf *op_err)
 		}
 	}
 	sctp_alloc_a_chunk(stcb, chk);
-	if (chk == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[235]) {
+	  if ((chk == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 235\n");
+	  else
+	    fprintf(stderr, "reached bug index 235\n");
+	}
+	if ((!FIXREVERTER[235] && (chk == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		/* no memory */
 		sctp_m_freem(op_err);
 		return;
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	chk->copy_by_ref = 0;
 	chk->rec.chunk_id.id = SCTP_OPERATION_ERROR;
 	chk->rec.chunk_id.can_take_data = 0;
@@ -9545,9 +10722,24 @@ sctp_send_cookie_echo(struct mbuf *m,
 	at = offset + sizeof(struct sctp_init_chunk);
 	for (;;) {
 		phdr = sctp_get_next_param(m, at, &param, sizeof(param));
-		if (phdr == NULL) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[236]) {
+		  if ((phdr == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 236\n");
+		  else
+		    fprintf(stderr, "reached bug index 236\n");
+		}
+		if ((!FIXREVERTER[236] && (phdr == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		) {
 			return (-3);
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		ptype = ntohs(phdr->param_type);
 		plen = ntohs(phdr->param_length);
 		if (plen < sizeof(struct sctp_paramhdr)) {
@@ -9557,14 +10749,44 @@ sctp_send_cookie_echo(struct mbuf *m,
 			int pad;
 
 			/* found the cookie */
-			if (at + plen > limit) {
+			
+			#ifdef FRCOV
+			{if (FIXREVERTER[237]) {
+			  if ((at + plen > limit ) && !(0))
+			    fprintf(stderr, "triggered bug index 237\n");
+			  else
+			    fprintf(stderr, "reached bug index 237\n");
+			}
+			if ((!FIXREVERTER[237] && (at + plen > limit ))
+			#else
+			if (0
+			#endif
+			) {
 				return (-7);
 			}
+			#ifdef FRCOV
+			}
+			#endif
 			cookie = SCTP_M_COPYM(m, at, plen, M_NOWAIT);
-			if (cookie == NULL) {
+			
+			#ifdef FRCOV
+			{if (FIXREVERTER[238]) {
+			  if ((cookie == (void *) 0 ) && !(0))
+			    fprintf(stderr, "triggered bug index 238\n");
+			  else
+			    fprintf(stderr, "reached bug index 238\n");
+			}
+			if ((!FIXREVERTER[238] && (cookie == (void *) 0 ))
+			#else
+			if (0
+			#endif
+			) {
 				/* No memory */
 				return (-2);
 			}
+			#ifdef FRCOV
+			}
+			#endif
 			if ((pad = (plen % 4)) > 0) {
 				pad = 4 - pad;
 			}
@@ -9589,11 +10811,26 @@ sctp_send_cookie_echo(struct mbuf *m,
 	hdr->chunk_flags = 0;
 	/* get the chunk stuff now and place it in the FRONT of the queue */
 	sctp_alloc_a_chunk(stcb, chk);
-	if (chk == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[239]) {
+	  if ((chk == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 239\n");
+	  else
+	    fprintf(stderr, "reached bug index 239\n");
+	}
+	if ((!FIXREVERTER[239] && (chk == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		/* no memory */
 		sctp_m_freem(cookie);
 		return (-5);
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	chk->copy_by_ref = 0;
 	chk->rec.chunk_id.id = SCTP_COOKIE_ECHO;
 	chk->rec.chunk_id.can_take_data = 0;
@@ -9624,15 +10861,45 @@ sctp_send_heartbeat_ack(struct sctp_tcb *stcb,
 	struct sctp_chunkhdr *chdr;
 	struct sctp_tmit_chunk *chk;
 
-	if (net == NULL)
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[240]) {
+	  if ((net == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 240\n");
+	  else
+	    fprintf(stderr, "reached bug index 240\n");
+	}
+	if ((!FIXREVERTER[240] && (net == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	)
 		/* must have a net pointer */
 		return;
+		#ifdef FRCOV
+		}
+		#endif
 
 	outchain = SCTP_M_COPYM(m, offset, chk_length, M_NOWAIT);
-	if (outchain == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[241]) {
+	  if ((outchain == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 241\n");
+	  else
+	    fprintf(stderr, "reached bug index 241\n");
+	}
+	if ((!FIXREVERTER[241] && (outchain == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		/* gak out of memory */
 		return;
 	}
+	#ifdef FRCOV
+	}
+	#endif
 #ifdef SCTP_MBUF_LOGGING
 	if (SCTP_BASE_SYSCTL(sctp_logging_level) & SCTP_MBUF_LOGGING_ENABLE) {
 		sctp_log_mbc(outchain, SCTP_MBUF_ICOPY);
@@ -9645,11 +10912,26 @@ sctp_send_heartbeat_ack(struct sctp_tcb *stcb,
 		sctp_pad_lastmbuf(outchain, 4 - (chk_length % 4), NULL);
 	}
 	sctp_alloc_a_chunk(stcb, chk);
-	if (chk == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[242]) {
+	  if ((chk == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 242\n");
+	  else
+	    fprintf(stderr, "reached bug index 242\n");
+	}
+	if ((!FIXREVERTER[242] && (chk == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		/* no memory */
 		sctp_m_freem(outchain);
 		return;
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	chk->copy_by_ref = 0;
 	chk->rec.chunk_id.id = SCTP_HEARTBEAT_ACK;
 	chk->rec.chunk_id.can_take_data = 1;
@@ -9676,17 +10958,47 @@ sctp_send_cookie_ack(struct sctp_tcb *stcb)
 	SCTP_TCB_LOCK_ASSERT(stcb);
 
 	cookie_ack = sctp_get_mbuf_for_msg(sizeof(struct sctp_chunkhdr), 0, M_NOWAIT, 1, MT_HEADER);
-	if (cookie_ack == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[243]) {
+	  if ((cookie_ack == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 243\n");
+	  else
+	    fprintf(stderr, "reached bug index 243\n");
+	}
+	if ((!FIXREVERTER[243] && (cookie_ack == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		/* no mbuf's */
 		return;
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	SCTP_BUF_RESV_UF(cookie_ack, SCTP_MIN_OVERHEAD);
 	sctp_alloc_a_chunk(stcb, chk);
-	if (chk == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[244]) {
+	  if ((chk == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 244\n");
+	  else
+	    fprintf(stderr, "reached bug index 244\n");
+	}
+	if ((!FIXREVERTER[244] && (chk == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		/* no memory */
 		sctp_m_freem(cookie_ack);
 		return;
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	chk->copy_by_ref = 0;
 	chk->rec.chunk_id.id = SCTP_COOKIE_ACK;
 	chk->rec.chunk_id.can_take_data = 1;
@@ -9722,17 +11034,47 @@ sctp_send_shutdown_ack(struct sctp_tcb *stcb, struct sctp_nets *net)
 	struct sctp_tmit_chunk *chk;
 
 	m_shutdown_ack = sctp_get_mbuf_for_msg(sizeof(struct sctp_shutdown_ack_chunk), 0, M_NOWAIT, 1, MT_HEADER);
-	if (m_shutdown_ack == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[245]) {
+	  if ((m_shutdown_ack == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 245\n");
+	  else
+	    fprintf(stderr, "reached bug index 245\n");
+	}
+	if ((!FIXREVERTER[245] && (m_shutdown_ack == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		/* no mbuf's */
 		return;
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	SCTP_BUF_RESV_UF(m_shutdown_ack, SCTP_MIN_OVERHEAD);
 	sctp_alloc_a_chunk(stcb, chk);
-	if (chk == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[246]) {
+	  if ((chk == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 246\n");
+	  else
+	    fprintf(stderr, "reached bug index 246\n");
+	}
+	if ((!FIXREVERTER[246] && (chk == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		/* no memory */
 		sctp_m_freem(m_shutdown_ack);
 		return;
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	chk->copy_by_ref = 0;
 	chk->rec.chunk_id.id = SCTP_SHUTDOWN_ACK;
 	chk->rec.chunk_id.can_take_data = 1;
@@ -9776,17 +11118,47 @@ sctp_send_shutdown(struct sctp_tcb *stcb, struct sctp_nets *net)
 	}
 	if (chk == NULL) {
 		m_shutdown = sctp_get_mbuf_for_msg(sizeof(struct sctp_shutdown_chunk), 0, M_NOWAIT, 1, MT_HEADER);
-		if (m_shutdown == NULL) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[247]) {
+		  if ((m_shutdown == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 247\n");
+		  else
+		    fprintf(stderr, "reached bug index 247\n");
+		}
+		if ((!FIXREVERTER[247] && (m_shutdown == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		) {
 			/* no mbuf's */
 			return;
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		SCTP_BUF_RESV_UF(m_shutdown, SCTP_MIN_OVERHEAD);
 		sctp_alloc_a_chunk(stcb, chk);
-		if (chk == NULL) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[248]) {
+		  if ((chk == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 248\n");
+		  else
+		    fprintf(stderr, "reached bug index 248\n");
+		}
+		if ((!FIXREVERTER[248] && (chk == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		) {
 			/* no memory */
 			sctp_m_freem(m_shutdown);
 			return;
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		chk->copy_by_ref = 0;
 		chk->rec.chunk_id.id = SCTP_SHUTDOWN;
 		chk->rec.chunk_id.can_take_data = 1;
@@ -9842,16 +11214,46 @@ sctp_send_asconf(struct sctp_tcb *stcb, struct sctp_nets *net, int addr_locked)
 
 	/* compose an ASCONF chunk, maximum length is PMTU */
 	m_asconf = sctp_compose_asconf(stcb, &len, addr_locked);
-	if (m_asconf == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[249]) {
+	  if ((m_asconf == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 249\n");
+	  else
+	    fprintf(stderr, "reached bug index 249\n");
+	}
+	if ((!FIXREVERTER[249] && (m_asconf == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		return;
 	}
+	#ifdef FRCOV
+	}
+	#endif
 
 	sctp_alloc_a_chunk(stcb, chk);
-	if (chk == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[250]) {
+	  if ((chk == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 250\n");
+	  else
+	    fprintf(stderr, "reached bug index 250\n");
+	}
+	if ((!FIXREVERTER[250] && (chk == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		/* no memory */
 		sctp_m_freem(m_asconf);
 		return;
 	}
+	#ifdef FRCOV
+	}
+	#endif
 
 	chk->copy_by_ref = 0;
 	chk->rec.chunk_id.id = SCTP_ASCONF;
@@ -9886,9 +11288,24 @@ sctp_send_asconf_ack(struct sctp_tcb *stcb)
 	SCTP_TCB_LOCK_ASSERT(stcb);
 	/* Get the latest ASCONF-ACK */
 	latest_ack = TAILQ_LAST(&stcb->asoc.asconf_ack_sent, sctp_asconf_ackhead);
-	if (latest_ack == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[251]) {
+	  if ((latest_ack == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 251\n");
+	  else
+	    fprintf(stderr, "reached bug index 251\n");
+	}
+	if ((!FIXREVERTER[251] && (latest_ack == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		return;
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	if (latest_ack->last_sent_to != NULL &&
 	    latest_ack->last_sent_to == stcb->asoc.last_control_chunk_from) {
 		/* we're doing a retransmission */
@@ -9920,16 +11337,46 @@ sctp_send_asconf_ack(struct sctp_tcb *stcb)
 	latest_ack->last_sent_to = net;
 
 	TAILQ_FOREACH(ack, &stcb->asoc.asconf_ack_sent, next) {
-		if (ack->data == NULL) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[252]) {
+		  if ((ack -> data == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 252\n");
+		  else
+		    fprintf(stderr, "reached bug index 252\n");
+		}
+		if ((!FIXREVERTER[252] && (ack -> data == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		) {
 			continue;
 		}
+		#ifdef FRCOV
+		}
+		#endif
 
 		/* copy the asconf_ack */
 		m_ack = SCTP_M_COPYM(ack->data, 0, M_COPYALL, M_NOWAIT);
-		if (m_ack == NULL) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[253]) {
+		  if ((m_ack == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 253\n");
+		  else
+		    fprintf(stderr, "reached bug index 253\n");
+		}
+		if ((!FIXREVERTER[253] && (m_ack == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		) {
 			/* couldn't copy it */
 			return;
 		}
+		#ifdef FRCOV
+		}
+		#endif
 #ifdef SCTP_MBUF_LOGGING
 		if (SCTP_BASE_SYSCTL(sctp_logging_level) & SCTP_MBUF_LOGGING_ENABLE) {
 			sctp_log_mbc(m_ack, SCTP_MBUF_ICOPY);
@@ -9937,12 +11384,27 @@ sctp_send_asconf_ack(struct sctp_tcb *stcb)
 #endif
 
 		sctp_alloc_a_chunk(stcb, chk);
-		if (chk == NULL) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[254]) {
+		  if ((chk == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 254\n");
+		  else
+		    fprintf(stderr, "reached bug index 254\n");
+		}
+		if ((!FIXREVERTER[254] && (chk == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		) {
 			/* no memory */
 			if (m_ack)
 				sctp_m_freem(m_ack);
 			return;
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		chk->copy_by_ref = 0;
 		chk->rec.chunk_id.id = SCTP_ASCONF_ACK;
 		chk->rec.chunk_id.can_take_data = 1;
@@ -10033,9 +11495,24 @@ sctp_chunk_retransmission(struct sctp_inpcb *inp,
 		if ((chk->rec.chunk_id.id == SCTP_COOKIE_ECHO) ||
 		    (chk->rec.chunk_id.id == SCTP_STREAM_RESET) ||
 		    (chk->rec.chunk_id.id == SCTP_FORWARD_CUM_TSN)) {
-			if (chk->sent != SCTP_DATAGRAM_RESEND) {
+			
+			#ifdef FRCOV
+			{if (FIXREVERTER[255]) {
+			  if ((chk -> sent != 4 ) && !(0))
+			    fprintf(stderr, "triggered bug index 255\n");
+			  else
+			    fprintf(stderr, "reached bug index 255\n");
+			}
+			if ((!FIXREVERTER[255] && (chk -> sent != 4 ))
+			#else
+			if (0
+			#endif
+			) {
 				continue;
 			}
+			#ifdef FRCOV
+			}
+			#endif
 			if (chk->rec.chunk_id.id == SCTP_STREAM_RESET) {
 				if (chk != asoc->str_reset) {
 					/*
@@ -10131,15 +11608,45 @@ sctp_chunk_retransmission(struct sctp_inpcb *inp,
 #endif
 	data_auth_reqd = sctp_auth_is_required_chunk(SCTP_DATA, stcb->asoc.peer_auth_chunks);
 	TAILQ_FOREACH(chk, &asoc->sent_queue, sctp_next) {
-		if (chk->sent != SCTP_DATAGRAM_RESEND) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[256]) {
+		  if ((chk -> sent != 4 ) && !(0))
+		    fprintf(stderr, "triggered bug index 256\n");
+		  else
+		    fprintf(stderr, "reached bug index 256\n");
+		}
+		if ((!FIXREVERTER[256] && (chk -> sent != 4 ))
+		#else
+		if (0
+		#endif
+		) {
 			/* No, not sent to this net or not ready for rtx */
 			continue;
 		}
-		if (chk->data == NULL) {
+		#ifdef FRCOV
+		}
+		#endif
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[257]) {
+		  if ((chk -> data == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 257\n");
+		  else
+		    fprintf(stderr, "reached bug index 257\n");
+		}
+		if ((!FIXREVERTER[257] && (chk -> data == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		) {
 			SCTP_PRINTF("TSN:%x chk->snd_count:%d chk->sent:%d can't retran - no data\n",
 			            chk->rec.data.tsn, chk->snd_count, chk->sent);
 			continue;
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		if ((SCTP_BASE_SYSCTL(sctp_max_retran_chunk)) &&
 		    (chk->snd_count >= SCTP_BASE_SYSCTL(sctp_max_retran_chunk))) {
 			struct mbuf *op_err;
@@ -10199,11 +11706,28 @@ sctp_chunk_retransmission(struct sctp_inpcb *inp,
 	one_chunk_around:
 		if (asoc->peers_rwnd < mtu) {
 			one_chunk = 1;
-			if ((asoc->peers_rwnd == 0) &&
-			    (asoc->total_flight == 0)) {
+			
+			#ifdef FRCOV
+			{if (FIXREVERTER[258]) {
+			  fprintf(stderr, "reached bug index 258\n");
+			}
+			if ((FIXREVERTER[258] && (asoc -> peers_rwnd == 0 )) || (!FIXREVERTER[258] && (asoc -> peers_rwnd == 0 && asoc -> total_flight == 0 ))
+			#else
+			if (asoc -> peers_rwnd == 0 
+			#endif
+			) {
+			      
+			    #ifdef FRCOV
+			      if (!(asoc -> total_flight == 0 ))
+			        fprintf(stderr, "triggered bug index 258\n");
+			      #endif
+			    
 				chk->window_probe = 1;
 				chk->whoTo->window_probe = 1;
 			}
+			#ifdef FRCOV
+			}
+			#endif
 		}
 #ifdef SCTP_AUDITING_ENABLED
 		sctp_audit_log(0xC3, 2);
@@ -10216,9 +11740,24 @@ sctp_chunk_retransmission(struct sctp_inpcb *inp,
 			 * if no FR in progress skip destination that have
 			 * flight_size > cwnd.
 			 */
-			if (net->flight_size >= net->cwnd) {
+			
+			#ifdef FRCOV
+			{if (FIXREVERTER[259]) {
+			  if ((net -> flight_size >= net -> cwnd ) && !(0))
+			    fprintf(stderr, "triggered bug index 259\n");
+			  else
+			    fprintf(stderr, "reached bug index 259\n");
+			}
+			if ((!FIXREVERTER[259] && (net -> flight_size >= net -> cwnd ))
+			#else
+			if (0
+			#endif
+			) {
 				continue;
 			}
+			#ifdef FRCOV
+			}
+			#endif
 		} else {
 			/*
 			 * Mark the destination net to have FR recovery
@@ -10256,16 +11795,46 @@ sctp_chunk_retransmission(struct sctp_inpcb *inp,
 				} else if (override_ok) {
 					auth_keyid = chk->auth_keyid;
 					override_ok = 0;
-				} else if (chk->auth_keyid != auth_keyid) {
+				} else 
+				#ifdef FRCOV
+				{if (FIXREVERTER[260]) {
+				  if ((chk -> auth_keyid != auth_keyid ) && !(0))
+				    fprintf(stderr, "triggered bug index 260\n");
+				  else
+				    fprintf(stderr, "reached bug index 260\n");
+				}
+				if ((!FIXREVERTER[260] && (chk -> auth_keyid != auth_keyid ))
+				#else
+				if (0
+				#endif
+				) {
 					/* different keyid, so done bundling */
 					break;
 				}
+				#ifdef FRCOV
+				}
+				#endif
 			}
 			m = sctp_copy_mbufchain(chk->data, m, &endofchain, 0, chk->send_size, chk->copy_by_ref);
-			if (m == NULL) {
+			
+			#ifdef FRCOV
+			{if (FIXREVERTER[261]) {
+			  if ((m == (void *) 0 ) && !(0))
+			    fprintf(stderr, "triggered bug index 261\n");
+			  else
+			    fprintf(stderr, "reached bug index 261\n");
+			}
+			if ((!FIXREVERTER[261] && (m == (void *) 0 ))
+			#else
+			if (0
+			#endif
+			) {
 				SCTP_LTRACE_ERR_RET(inp, stcb, NULL, SCTP_FROM_SCTP_OUTPUT, ENOMEM);
 				return (ENOMEM);
 			}
+			#ifdef FRCOV
+			}
+			#endif
 			/* Do clear IP_DF ? */
 			if (chk->flags & CHUNK_FLAGS_FRAGMENT_OK) {
 				no_fragmentflg = 0;
@@ -10286,10 +11855,25 @@ sctp_chunk_retransmission(struct sctp_inpcb *inp,
 			 * up?
 			 */
 			for (fwd = TAILQ_NEXT(chk, sctp_next); fwd != NULL; fwd = TAILQ_NEXT(fwd, sctp_next)) {
-				if (fwd->sent != SCTP_DATAGRAM_RESEND) {
+				
+				#ifdef FRCOV
+				{if (FIXREVERTER[262]) {
+				  if ((fwd -> sent != 4 ) && !(0))
+				    fprintf(stderr, "triggered bug index 262\n");
+				  else
+				    fprintf(stderr, "reached bug index 262\n");
+				}
+				if ((!FIXREVERTER[262] && (fwd -> sent != 4 ))
+				#else
+				if (0
+				#endif
+				) {
 					/* Nope, not for retran */
 					continue;
 				}
+				#ifdef FRCOV
+				}
+				#endif
 				if (fwd->whoTo != net) {
 					/* Nope, not the net in question */
 					continue;
@@ -10313,16 +11897,46 @@ sctp_chunk_retransmission(struct sctp_inpcb *inp,
 						} else if (override_ok) {
 							auth_keyid = fwd->auth_keyid;
 							override_ok = 0;
-						} else if (fwd->auth_keyid != auth_keyid) {
+						} else 
+						#ifdef FRCOV
+						{if (FIXREVERTER[263]) {
+						  if ((fwd -> auth_keyid != auth_keyid ) && !(0))
+						    fprintf(stderr, "triggered bug index 263\n");
+						  else
+						    fprintf(stderr, "reached bug index 263\n");
+						}
+						if ((!FIXREVERTER[263] && (fwd -> auth_keyid != auth_keyid ))
+						#else
+						if (0
+						#endif
+						) {
 							/* different keyid, so done bundling */
 							break;
 						}
+						#ifdef FRCOV
+						}
+						#endif
 					}
 					m = sctp_copy_mbufchain(fwd->data, m, &endofchain, 0, fwd->send_size, fwd->copy_by_ref);
-					if (m == NULL) {
+					
+					#ifdef FRCOV
+					{if (FIXREVERTER[264]) {
+					  if ((m == (void *) 0 ) && !(0))
+					    fprintf(stderr, "triggered bug index 264\n");
+					  else
+					    fprintf(stderr, "reached bug index 264\n");
+					}
+					if ((!FIXREVERTER[264] && (m == (void *) 0 ))
+					#else
+					if (0
+					#endif
+					) {
 						SCTP_LTRACE_ERR_RET(inp, stcb, NULL, SCTP_FROM_SCTP_OUTPUT, ENOMEM);
 						return (ENOMEM);
 					}
+					#ifdef FRCOV
+					}
+					#endif
 					/* Do clear IP_DF ? */
 					if (fwd->flags & CHUNK_FLAGS_FRAGMENT_OK) {
 						no_fragmentflg = 0;
@@ -10333,9 +11947,24 @@ sctp_chunk_retransmission(struct sctp_inpcb *inp,
 					else
 						mtu = 0;
 					data_list[bundle_at++] = fwd;
-					if (bundle_at >= SCTP_MAX_DATA_BUNDLING) {
+					
+					#ifdef FRCOV
+					{if (FIXREVERTER[265]) {
+					  if ((bundle_at >= 256 ) && !(0))
+					    fprintf(stderr, "triggered bug index 265\n");
+					  else
+					    fprintf(stderr, "reached bug index 265\n");
+					}
+					if ((!FIXREVERTER[265] && (bundle_at >= 256 ))
+					#else
+					if (0
+					#endif
+					) {
 						break;
 					}
+					#ifdef FRCOV
+					}
+					#endif
 				} else {
 					/* can't fit so we are done */
 					break;
@@ -10488,11 +12117,26 @@ sctp_chunk_retransmission(struct sctp_inpcb *inp,
 			/* None will fit */
 			return (1);
 		}
-		if (asoc->sent_queue_retran_cnt <= 0) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[266]) {
+		  if ((asoc -> sent_queue_retran_cnt <= 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 266\n");
+		  else
+		    fprintf(stderr, "reached bug index 266\n");
+		}
+		if ((!FIXREVERTER[266] && (asoc -> sent_queue_retran_cnt <= 0 ))
+		#else
+		if (0
+		#endif
+		) {
 			/* all done we have no more to retran */
 			asoc->sent_queue_retran_cnt = 0;
 			break;
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		if (one_chunk) {
 			/* No more room in rwnd */
 			return (1);
@@ -10776,7 +12420,22 @@ do_it_again:
 		  (burst_cnt < asoc->max_burst)));
 
 	if (SCTP_BASE_SYSCTL(sctp_use_cwnd_based_maxburst) == 0) {
-		if ((asoc->max_burst > 0) && (burst_cnt >= asoc->max_burst)) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[270]) {
+		  fprintf(stderr, "reached bug index 270\n");
+		}
+		if ((FIXREVERTER[270] && (asoc -> max_burst > 0 )) || (!FIXREVERTER[270] && (asoc -> max_burst > 0 && burst_cnt >= asoc -> max_burst ))
+		#else
+		if (asoc -> max_burst > 0 
+		#endif
+		) {
+		  
+		#ifdef FRCOV
+		  if (!(burst_cnt >= asoc -> max_burst ))
+		    fprintf(stderr, "triggered bug index 270\n");
+		  #endif
+		
 			SCTP_STAT_INCR(sctps_maxburstqueued);
 			asoc->burst_limit_applied = 1;
 			if (SCTP_BASE_SYSCTL(sctp_logging_level) & SCTP_LOG_MAXBURST_ENABLE) {
@@ -10785,6 +12444,9 @@ do_it_again:
 		} else {
 			asoc->burst_limit_applied = 0;
 		}
+		#ifdef FRCOV
+		}
+		#endif
 	}
 	if (SCTP_BASE_SYSCTL(sctp_logging_level) & SCTP_CWND_LOGGING_ENABLE) {
 		sctp_log_cwnd(stcb, NULL, tot_out, SCTP_SEND_NOW_COMPLETES);
@@ -10887,9 +12549,24 @@ send_forward_tsn(struct sctp_tcb *stcb,
 	}
 	/* Ok if we reach here we must build one */
 	sctp_alloc_a_chunk(stcb, chk);
-	if (chk == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[273]) {
+	  if ((chk == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 273\n");
+	  else
+	    fprintf(stderr, "reached bug index 273\n");
+	}
+	if ((!FIXREVERTER[273] && (chk == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		return;
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	asoc->fwd_tsn_cnt++;
 	chk->copy_by_ref = 0;
 	/*
@@ -10905,10 +12582,25 @@ send_forward_tsn(struct sctp_tcb *stcb,
 	chk->asoc = asoc;
 	chk->whoTo = NULL;
 	chk->data = sctp_get_mbuf_for_msg(MCLBYTES, 0, M_NOWAIT, 1, MT_DATA);
-	if (chk->data == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[274]) {
+	  if ((chk -> data == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 274\n");
+	  else
+	    fprintf(stderr, "reached bug index 274\n");
+	}
+	if ((!FIXREVERTER[274] && (chk -> data == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		sctp_free_a_chunk(stcb, chk, SCTP_SO_NOT_LOCKED);
 		return;
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	SCTP_BUF_RESV_UF(chk->data, SCTP_MIN_OVERHEAD);
 	chk->sent = SCTP_DATAGRAM_UNSENT;
 	chk->snd_count = 0;
@@ -10980,9 +12672,24 @@ sctp_fill_in_rest:
 		if (at != NULL) {
 			for (i = 0; i < cnt_of_skipped; i++) {
 				tp1 = TAILQ_NEXT(at, sctp_next);
-				if (tp1 == NULL) {
+				
+				#ifdef FRCOV
+				{if (FIXREVERTER[275]) {
+				  if ((tp1 == (void *) 0 ) && !(0))
+				    fprintf(stderr, "triggered bug index 275\n");
+				  else
+				    fprintf(stderr, "reached bug index 275\n");
+				}
+				if ((!FIXREVERTER[275] && (tp1 == (void *) 0 ))
+				#else
+				if (0
+				#endif
+				) {
 					break;
 				}
+				#ifdef FRCOV
+				}
+				#endif
 				at = tp1;
 			}
 		}
@@ -11045,9 +12752,24 @@ sctp_fill_in_rest:
 	 */
 	i = 0;
 	TAILQ_FOREACH(at, &asoc->sent_queue, sctp_next) {
-		if (i >= cnt_of_skipped) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[276]) {
+		  if ((i >= cnt_of_skipped ) && !(0))
+		    fprintf(stderr, "triggered bug index 276\n");
+		  else
+		    fprintf(stderr, "reached bug index 276\n");
+		}
+		if ((!FIXREVERTER[276] && (i >= cnt_of_skipped ))
+		#else
+		if (0
+		#endif
+		) {
 			break;
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		if (!asoc->idata_supported && (at->rec.data.rcv_flags & SCTP_DATA_UNORDERED)) {
 			/* We don't report these */
 			continue;
@@ -11140,7 +12862,19 @@ sctp_send_sack(struct sctp_tcb *stcb, int so_locked
 	}
 	if (a_chk == NULL) {
 		sctp_alloc_a_chunk(stcb, a_chk);
-		if (a_chk == NULL) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[278]) {
+		  if ((a_chk == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 278\n");
+		  else
+		    fprintf(stderr, "reached bug index 278\n");
+		}
+		if ((!FIXREVERTER[278] && (a_chk == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		) {
 			/* No memory so we drop the idea, and set a timer */
 			if (stcb->asoc.delayed_ack) {
 				sctp_timer_stop(SCTP_TIMER_TYPE_RECV,
@@ -11153,6 +12887,9 @@ sctp_send_sack(struct sctp_tcb *stcb, int so_locked
 			}
 			return;
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		a_chk->copy_by_ref = 0;
 		a_chk->rec.chunk_id.id = type;
 		a_chk->rec.chunk_id.can_take_data = 1;
@@ -11508,7 +13245,19 @@ sctp_send_abort_tcb(struct sctp_tcb *stcb, struct mbuf *operr, int so_locked
 		m_out = NULL;
 	}
 	m_abort = sctp_get_mbuf_for_msg(sizeof(struct sctp_abort_chunk), 0, M_NOWAIT, 1, MT_HEADER);
-	if (m_abort == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[279]) {
+	  if ((m_abort == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 279\n");
+	  else
+	    fprintf(stderr, "reached bug index 279\n");
+	}
+	if ((!FIXREVERTER[279] && (m_abort == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		if (m_out) {
 			sctp_m_freem(m_out);
 		}
@@ -11517,6 +13266,9 @@ sctp_send_abort_tcb(struct sctp_tcb *stcb, struct mbuf *operr, int so_locked
 		}
 		return;
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	/* link in any error */
 	SCTP_BUF_NEXT(m_abort) = operr;
 	cause_len = 0;
@@ -11596,10 +13348,25 @@ sctp_send_shutdown_complete(struct sctp_tcb *stcb,
 	uint8_t flags;
 
 	m_shutdown_comp = sctp_get_mbuf_for_msg(sizeof(struct sctp_chunkhdr), 0, M_NOWAIT, 1, MT_HEADER);
-	if (m_shutdown_comp == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[280]) {
+	  if ((m_shutdown_comp == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 280\n");
+	  else
+	    fprintf(stderr, "reached bug index 280\n");
+	}
+	if ((!FIXREVERTER[280] && (m_shutdown_comp == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		/* no mbuf's */
 		return;
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	if (reflect_vtag) {
 		flags = SCTP_HAD_NO_TCB;
 		vtag = stcb->asoc.my_vtag;
@@ -11726,12 +13493,27 @@ sctp_send_resp_msg(struct sockaddr *src, struct sockaddr *dst,
 #else
 	mout = sctp_get_mbuf_for_msg(len + max_linkhdr, 1, M_NOWAIT, 1, MT_DATA);
 #endif
-	if (mout == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[281]) {
+	  if ((mout == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 281\n");
+	  else
+	    fprintf(stderr, "reached bug index 281\n");
+	}
+	if ((!FIXREVERTER[281] && (mout == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		if (cause) {
 			sctp_m_freem(cause);
 		}
 		return;
 	}
+	#ifdef FRCOV
+	}
+	#endif
 #if defined(__APPLE__)
 #if defined(APPLE_LEOPARD) || defined(APPLE_SNOWLEOPARD)
 	SCTP_BUF_RESV_UF(mout, max_linkhdr);
@@ -12072,9 +13854,24 @@ sctp_send_hb(struct sctp_tcb *stcb, struct sctp_nets *net,int so_locked
 	struct timeval now;
 
 	SCTP_TCB_LOCK_ASSERT(stcb);
-	if (net == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[282]) {
+	  if ((net == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 282\n");
+	  else
+	    fprintf(stderr, "reached bug index 282\n");
+	}
+	if ((!FIXREVERTER[282] && (net == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		return;
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	(void)SCTP_GETTIME_TIMEVAL(&now);
 	switch (net->ro._l_addr.sa.sa_family) {
 #ifdef INET
@@ -12093,10 +13890,25 @@ sctp_send_hb(struct sctp_tcb *stcb, struct sctp_nets *net,int so_locked
 		return;
 	}
 	sctp_alloc_a_chunk(stcb, chk);
-	if (chk == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[283]) {
+	  if ((chk == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 283\n");
+	  else
+	    fprintf(stderr, "reached bug index 283\n");
+	}
+	if ((!FIXREVERTER[283] && (chk == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		SCTPDBG(SCTP_DEBUG_OUTPUT4, "Gak, can't get a chunk for hb\n");
 		return;
 	}
+	#ifdef FRCOV
+	}
+	#endif
 
 	chk->copy_by_ref = 0;
 	chk->rec.chunk_id.id = SCTP_HEARTBEAT_REQUEST;
@@ -12106,10 +13918,25 @@ sctp_send_hb(struct sctp_tcb *stcb, struct sctp_nets *net,int so_locked
 	chk->send_size = sizeof(struct sctp_heartbeat_chunk);
 
 	chk->data = sctp_get_mbuf_for_msg(chk->send_size, 0, M_NOWAIT, 1, MT_HEADER);
-	if (chk->data == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[284]) {
+	  if ((chk -> data == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 284\n");
+	  else
+	    fprintf(stderr, "reached bug index 284\n");
+	}
+	if ((!FIXREVERTER[284] && (chk -> data == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		sctp_free_a_chunk(stcb, chk, so_locked);
 		return;
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	SCTP_BUF_RESV_UF(chk->data, SCTP_MIN_OVERHEAD);
 	SCTP_BUF_LEN(chk->data) = chk->send_size;
 	chk->sent = SCTP_DATAGRAM_UNSENT;
@@ -12211,9 +14038,24 @@ sctp_send_ecn_echo(struct sctp_tcb *stcb, struct sctp_nets *net,
 	struct sctp_ecne_chunk *ecne;
 	struct sctp_tmit_chunk *chk;
 
-	if (net == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[285]) {
+	  if ((net == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 285\n");
+	  else
+	    fprintf(stderr, "reached bug index 285\n");
+	}
+	if ((!FIXREVERTER[285] && (net == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		return;
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	asoc = &stcb->asoc;
 	SCTP_TCB_LOCK_ASSERT(stcb);
 	TAILQ_FOREACH(chk, &asoc->control_send_queue, sctp_next) {
@@ -12234,9 +14076,24 @@ sctp_send_ecn_echo(struct sctp_tcb *stcb, struct sctp_nets *net,
 	}
 	/* nope could not find one to update so we must build one */
 	sctp_alloc_a_chunk(stcb, chk);
-	if (chk == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[286]) {
+	  if ((chk == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 286\n");
+	  else
+	    fprintf(stderr, "reached bug index 286\n");
+	}
+	if ((!FIXREVERTER[286] && (chk == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		return;
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	SCTP_STAT_INCR(sctps_queue_upd_ecne);
 	chk->copy_by_ref = 0;
 	chk->rec.chunk_id.id = SCTP_ECN_ECHO;
@@ -12245,10 +14102,25 @@ sctp_send_ecn_echo(struct sctp_tcb *stcb, struct sctp_nets *net,
 	chk->asoc = &stcb->asoc;
 	chk->send_size = sizeof(struct sctp_ecne_chunk);
 	chk->data = sctp_get_mbuf_for_msg(chk->send_size, 0, M_NOWAIT, 1, MT_HEADER);
-	if (chk->data == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[287]) {
+	  if ((chk -> data == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 287\n");
+	  else
+	    fprintf(stderr, "reached bug index 287\n");
+	}
+	if ((!FIXREVERTER[287] && (chk -> data == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		sctp_free_a_chunk(stcb, chk, SCTP_SO_NOT_LOCKED);
 		return;
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	SCTP_BUF_RESV_UF(chk->data, SCTP_MIN_OVERHEAD);
 	SCTP_BUF_LEN(chk->data) = chk->send_size;
 	chk->sent = SCTP_DATAGRAM_UNSENT;
@@ -12293,13 +14165,43 @@ sctp_send_packet_dropped(struct sctp_tcb *stcb, struct sctp_nets *net,
 		 */
 		return;
 	}
-	if (stcb->sctp_socket == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[288]) {
+	  if ((stcb -> sctp_socket == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 288\n");
+	  else
+	    fprintf(stderr, "reached bug index 288\n");
+	}
+	if ((!FIXREVERTER[288] && (stcb -> sctp_socket == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		return;
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	sctp_alloc_a_chunk(stcb, chk);
-	if (chk == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[289]) {
+	  if ((chk == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 289\n");
+	  else
+	    fprintf(stderr, "reached bug index 289\n");
+	}
+	if ((!FIXREVERTER[289] && (chk == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		return;
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	chk->copy_by_ref = 0;
 	chk->rec.chunk_id.id = SCTP_PACKET_DROPPED;
 	chk->rec.chunk_id.can_take_data = 1;
@@ -12347,18 +14249,48 @@ sctp_send_packet_dropped(struct sctp_tcb *stcb, struct sctp_nets *net,
 	}
 	chk->asoc = &stcb->asoc;
 	chk->data = sctp_get_mbuf_for_msg(MCLBYTES, 0, M_NOWAIT, 1, MT_DATA);
-	if (chk->data == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[290]) {
+	  if ((chk -> data == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 290\n");
+	  else
+	    fprintf(stderr, "reached bug index 290\n");
+	}
+	if ((!FIXREVERTER[290] && (chk -> data == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 jump_out:
 		sctp_free_a_chunk(stcb, chk, SCTP_SO_NOT_LOCKED);
 		return;
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	SCTP_BUF_RESV_UF(chk->data, SCTP_MIN_OVERHEAD);
 	drp = mtod(chk->data, struct sctp_pktdrop_chunk *);
-	if (drp == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[291]) {
+	  if ((drp == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 291\n");
+	  else
+	    fprintf(stderr, "reached bug index 291\n");
+	}
+	if ((!FIXREVERTER[291] && (drp == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		sctp_m_freem(chk->data);
 		chk->data = NULL;
 		goto jump_out;
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	chk->book_size = SCTP_SIZE32((chk->send_size + sizeof(struct sctp_pktdrop_chunk) +
 	    sizeof(struct sctphdr) + SCTP_MED_OVERHEAD));
 	chk->book_size_scale = 0;
@@ -12423,9 +14355,24 @@ sctp_send_cwr(struct sctp_tcb *stcb, struct sctp_nets *net, uint32_t high_tsn, u
 	struct sctp_tmit_chunk *chk;
 
 	SCTP_TCB_LOCK_ASSERT(stcb);
-	if (net == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[292]) {
+	  if ((net == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 292\n");
+	  else
+	    fprintf(stderr, "reached bug index 292\n");
+	}
+	if ((!FIXREVERTER[292] && (net == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		return;
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	asoc = &stcb->asoc;
 	TAILQ_FOREACH(chk, &asoc->control_send_queue, sctp_next) {
 		if ((chk->rec.chunk_id.id == SCTP_ECN_CWR) && (net == chk->whoTo)) {
@@ -12444,9 +14391,24 @@ sctp_send_cwr(struct sctp_tcb *stcb, struct sctp_nets *net, uint32_t high_tsn, u
 		}
 	}
 	sctp_alloc_a_chunk(stcb, chk);
-	if (chk == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[293]) {
+	  if ((chk == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 293\n");
+	  else
+	    fprintf(stderr, "reached bug index 293\n");
+	}
+	if ((!FIXREVERTER[293] && (chk == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		return;
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	chk->copy_by_ref = 0;
 	chk->rec.chunk_id.id = SCTP_ECN_CWR;
 	chk->rec.chunk_id.can_take_data = 1;
@@ -12454,10 +14416,25 @@ sctp_send_cwr(struct sctp_tcb *stcb, struct sctp_nets *net, uint32_t high_tsn, u
 	chk->asoc = &stcb->asoc;
 	chk->send_size = sizeof(struct sctp_cwr_chunk);
 	chk->data = sctp_get_mbuf_for_msg(chk->send_size, 0, M_NOWAIT, 1, MT_HEADER);
-	if (chk->data == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[294]) {
+	  if ((chk -> data == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 294\n");
+	  else
+	    fprintf(stderr, "reached bug index 294\n");
+	}
+	if ((!FIXREVERTER[294] && (chk -> data == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		sctp_free_a_chunk(stcb, chk, SCTP_SO_NOT_LOCKED);
 		return;
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	SCTP_BUF_RESV_UF(chk->data, SCTP_MIN_OVERHEAD);
 	SCTP_BUF_LEN(chk->data) = chk->send_size;
 	chk->sent = SCTP_DATAGRAM_UNSENT;
@@ -12495,9 +14472,24 @@ sctp_add_stream_reset_out(struct sctp_tcb *stcb, struct sctp_tmit_chunk *chk,
 			number_entries++;
 		}
 	}
-	if (number_entries == 0) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[295]) {
+	  if ((number_entries == 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 295\n");
+	  else
+	    fprintf(stderr, "reached bug index 295\n");
+	}
+	if ((!FIXREVERTER[295] && (number_entries == 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		return (0);
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	if (number_entries == stcb->asoc.streamoutcnt) {
 		number_entries = 0;
 	}
@@ -12519,9 +14511,24 @@ sctp_add_stream_reset_out(struct sctp_tcb *stcb, struct sctp_tmit_chunk *chk,
 				req_out->list_of_streams[at] = htons(i);
 				at++;
 				stcb->asoc.strmout[i].state = SCTP_STREAM_RESET_IN_FLIGHT;
-				if (at >= number_entries) {
+				
+				#ifdef FRCOV
+				{if (FIXREVERTER[296]) {
+				  if ((at >= number_entries ) && !(0))
+				    fprintf(stderr, "triggered bug index 296\n");
+				  else
+				    fprintf(stderr, "reached bug index 296\n");
+				}
+				if ((!FIXREVERTER[296] && (at >= number_entries ))
+				#else
+				if (0
+				#endif
+				) {
 					break;
 				}
+				#ifdef FRCOV
+				}
+				#endif
 			}
 		}
 	} else {
@@ -12665,10 +14672,25 @@ sctp_send_deferred_reset_response(struct sctp_tcb *stcb,
 		return;
 	}
 	sctp_alloc_a_chunk(stcb, chk);
-	if (chk == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[297]) {
+	  if ((chk == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 297\n");
+	  else
+	    fprintf(stderr, "reached bug index 297\n");
+	}
+	if ((!FIXREVERTER[297] && (chk == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		SCTP_LTRACE_ERR_RET(NULL, stcb, NULL, SCTP_FROM_SCTP_OUTPUT, ENOMEM);
 		return;
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	chk->copy_by_ref = 0;
 	chk->rec.chunk_id.id = SCTP_STREAM_RESET;
 	chk->rec.chunk_id.can_take_data = 0;
@@ -12817,10 +14839,25 @@ sctp_send_stream_reset_out_if_possible(struct sctp_tcb *stcb, int so_locked)
 		return (EALREADY);
 	}
 	sctp_alloc_a_chunk(stcb, chk);
-	if (chk == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[298]) {
+	  if ((chk == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 298\n");
+	  else
+	    fprintf(stderr, "reached bug index 298\n");
+	}
+	if ((!FIXREVERTER[298] && (chk == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		SCTP_LTRACE_ERR_RET(NULL, stcb, NULL, SCTP_FROM_SCTP_OUTPUT, ENOMEM);
 		return (ENOMEM);
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	chk->copy_by_ref = 0;
 	chk->rec.chunk_id.id = SCTP_STREAM_RESET;
 	chk->rec.chunk_id.can_take_data = 0;
@@ -12920,10 +14957,25 @@ sctp_send_str_reset_req(struct sctp_tcb *stcb,
 		return (ENOMEM);
 	}
 	sctp_alloc_a_chunk(stcb, chk);
-	if (chk == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[299]) {
+	  if ((chk == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 299\n");
+	  else
+	    fprintf(stderr, "reached bug index 299\n");
+	}
+	if ((!FIXREVERTER[299] && (chk == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		SCTP_LTRACE_ERR_RET(NULL, stcb, NULL, SCTP_FROM_SCTP_OUTPUT, ENOMEM);
 		return (ENOMEM);
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	chk->copy_by_ref = 0;
 	chk->rec.chunk_id.id = SCTP_STREAM_RESET;
 	chk->rec.chunk_id.can_take_data = 0;
@@ -13227,10 +15279,25 @@ sctp_copy_one(struct sctp_stream_queue_pending *sp,
 #elif defined(__FreeBSD__) && __FreeBSD_version > 602000 || defined(__Userspace__)
 	sp->data = m_uiotombuf(uio, M_WAITOK, sp->length,
 	                       resv_upfront, 0);
-	if (sp->data == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[300]) {
+	  if ((sp -> data == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 300\n");
+	  else
+	    fprintf(stderr, "reached bug index 300\n");
+	}
+	if ((!FIXREVERTER[300] && (sp -> data == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		SCTP_LTRACE_ERR_RET(NULL, NULL, NULL, SCTP_FROM_SCTP_OUTPUT, ENOBUFS);
 		return (ENOBUFS);
 	}
+	#ifdef FRCOV
+	}
+	#endif
 
 	sp->tail_mbuf = m_last(sp->data);
 	return (0);
@@ -13324,11 +15391,26 @@ sctp_copy_it_in(struct sctp_tcb *stcb,
 		goto out_now;
 	}
 	sctp_alloc_a_strmoq(stcb, sp);
-	if (sp == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[301]) {
+	  if ((sp == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 301\n");
+	  else
+	    fprintf(stderr, "reached bug index 301\n");
+	}
+	if ((!FIXREVERTER[301] && (sp == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		SCTP_LTRACE_ERR_RET(NULL, stcb, net, SCTP_FROM_SCTP_OUTPUT, ENOMEM);
 		*error = ENOMEM;
 		goto out_now;
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	sp->act_flags = 0;
 	sp->sender_all_done = 0;
 	sp->sinfo_flags = srcv->sinfo_flags;
@@ -13369,9 +15451,24 @@ sctp_copy_it_in(struct sctp_tcb *stcb,
 	sp->put_last_out = 0;
 	resv_in_first = SCTP_DATA_CHUNK_OVERHEAD(stcb);
 	sp->data = sp->tail_mbuf = NULL;
-	if (sp->length == 0) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[302]) {
+	  if ((sp -> length == 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 302\n");
+	  else
+	    fprintf(stderr, "reached bug index 302\n");
+	}
+	if ((!FIXREVERTER[302] && (sp -> length == 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		goto skip_copy;
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	if (srcv->sinfo_keynumber_valid) {
 		sp->auth_keyid = srcv->sinfo_keynumber;
 	} else {
@@ -13587,11 +15684,26 @@ sctp_lower_sosend(struct socket *so,
 		if (uio_resid(uio) < 0) {
 #endif
 #else
-		if (uio->uio_resid < 0) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[303]) {
+		  if ((uio -> uio_resid < 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 303\n");
+		  else
+		    fprintf(stderr, "reached bug index 303\n");
+		}
+		if ((!FIXREVERTER[303] && (uio -> uio_resid < 0 ))
+		#else
+		if (0
+		#endif
+		) {
 #endif
 			SCTP_LTRACE_ERR_RET(inp, stcb, net, SCTP_FROM_SCTP_OUTPUT, EINVAL);
 			return (EINVAL);
 		}
+		#ifdef FRCOV
+		}
+		#endif
 #if defined(__APPLE__)
 #if defined(APPLE_LEOPARD)
 		sndlen = uio->uio_resid;
@@ -13840,10 +15952,25 @@ sctp_lower_sosend(struct socket *so,
 			                       (struct proc *)NULL,
 #endif
 			                       SCTP_INITIALIZE_AUTH_PARAMS);
-			if (stcb == NULL) {
+			
+			#ifdef FRCOV
+			{if (FIXREVERTER[304]) {
+			  if ((stcb == (void *) 0 ) && !(0))
+			    fprintf(stderr, "triggered bug index 304\n");
+			  else
+			    fprintf(stderr, "reached bug index 304\n");
+			}
+			if ((!FIXREVERTER[304] && (stcb == (void *) 0 ))
+			#else
+			if (0
+			#endif
+			) {
 				/* Error is setup for us in the call */
 				goto out_unlocked;
 			}
+			#ifdef FRCOV
+			}
+			#endif
 			if (stcb->sctp_ep->sctp_flags & SCTP_PCB_FLAGS_TCPTYPE) {
 				stcb->sctp_ep->sctp_flags |= SCTP_PCB_FLAGS_CONNECTED;
 				/* Set the connected flag so we can queue data */
@@ -13976,12 +16103,27 @@ sctp_lower_sosend(struct socket *so,
 		create_lock_applied = 0;
 	}
 	/* Is the stream no. valid? */
-	if (srcv->sinfo_stream >= asoc->streamoutcnt) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[305]) {
+	  if ((srcv -> sinfo_stream >= asoc -> streamoutcnt ) && !(0))
+	    fprintf(stderr, "triggered bug index 305\n");
+	  else
+	    fprintf(stderr, "reached bug index 305\n");
+	}
+	if ((!FIXREVERTER[305] && (srcv -> sinfo_stream >= asoc -> streamoutcnt ))
+	#else
+	if (0
+	#endif
+	) {
 		/* Invalid stream number */
 		SCTP_LTRACE_ERR_RET(inp, stcb, net, SCTP_FROM_SCTP_OUTPUT, EINVAL);
 		error = EINVAL;
 		goto out_unlocked;
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	if ((asoc->strmout[srcv->sinfo_stream].state != SCTP_STREAM_OPEN) &&
 	    (asoc->strmout[srcv->sinfo_stream].state != SCTP_STREAM_OPENING)) {
 		/*
@@ -14067,11 +16209,26 @@ sctp_lower_sosend(struct socket *so,
 			}
 			mm = sctp_get_mbuf_for_msg((unsigned int)tot_demand, 0, M_WAITOK, 1, MT_DATA);
 		}
-		if (mm == NULL) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[307]) {
+		  if ((mm == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 307\n");
+		  else
+		    fprintf(stderr, "reached bug index 307\n");
+		}
+		if ((!FIXREVERTER[307] && (mm == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		) {
 			SCTP_LTRACE_ERR_RET(NULL, stcb, net, SCTP_FROM_SCTP_OUTPUT, ENOMEM);
 			error = ENOMEM;
 			goto out;
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		max_out = asoc->smallest_mtu - sizeof(struct sctp_paramhdr);
 		max_out -= sizeof(struct sctp_abort_msg);
 		if (tot_out > max_out) {
@@ -14140,12 +16297,27 @@ sctp_lower_sosend(struct socket *so,
 		SCTP_TCB_UNLOCK(stcb);
 		hold_tcblock = 0;
 	}
-	if (asoc->strmout == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[308]) {
+	  if ((asoc -> strmout == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 308\n");
+	  else
+	    fprintf(stderr, "reached bug index 308\n");
+	}
+	if ((!FIXREVERTER[308] && (asoc -> strmout == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		/* huh? software error */
 		SCTP_LTRACE_ERR_RET(inp, stcb, net, SCTP_FROM_SCTP_OUTPUT, EFAULT);
 		error = EFAULT;
 		goto out_unlocked;
 	}
+	#ifdef FRCOV
+	}
+	#endif
 
 	/* Unless E_EOR mode is on, we must make a send FIT in one call. */
 	if ((user_marks_eor == 0) &&
@@ -14302,7 +16474,19 @@ skip_preblock:
 			SCTP_TCB_SEND_LOCK(stcb);
 			sp = TAILQ_LAST(&strm->outqueue, sctp_streamhead);
 			SCTP_TCB_SEND_UNLOCK(stcb);
-			if (sp == NULL) {
+			
+			#ifdef FRCOV
+			{if (FIXREVERTER[309]) {
+			  if ((sp == (void *) 0 ) && !(0))
+			    fprintf(stderr, "triggered bug index 309\n");
+			  else
+			    fprintf(stderr, "reached bug index 309\n");
+			}
+			if ((!FIXREVERTER[309] && (sp == (void *) 0 ))
+			#else
+			if (0
+			#endif
+			) {
 				/* ???? Huh ??? last msg is gone */
 #ifdef INVARIANTS
 				panic("Warning: Last msg marked incomplete, yet nothing left?");
@@ -14313,6 +16497,9 @@ skip_preblock:
 				goto do_a_copy_in;
 
 			}
+			#ifdef FRCOV
+			}
+			#endif
 		}
 #if defined(__APPLE__)
 #if defined(APPLE_LEOPARD)
@@ -14422,11 +16609,26 @@ skip_preblock:
 			if (uio_resid(uio) == 0) {
 #endif
 #else
-			if (uio->uio_resid == 0) {
+			
+			#ifdef FRCOV
+			{if (FIXREVERTER[310]) {
+			  if ((uio -> uio_resid == 0 ) && !(0))
+			    fprintf(stderr, "triggered bug index 310\n");
+			  else
+			    fprintf(stderr, "reached bug index 310\n");
+			}
+			if ((!FIXREVERTER[310] && (uio -> uio_resid == 0 ))
+			#else
+			if (0
+			#endif
+			) {
 #endif
 				/* got it all? */
 				continue;
 			}
+			#ifdef FRCOV
+			}
+			#endif
 			/* PR-SCTP? */
 			if ((asoc->prsctp_supported) && (asoc->sent_queue_cnt_removeable > 0)) {
 				/* This is ugly but we must assure locking order */
@@ -14919,9 +17121,23 @@ sctp_add_auth_chunk(struct mbuf *m, struct mbuf **m_end,
 	int chunk_len;
 	struct mbuf *cn;
 
-	if ((m_end == NULL) || (auth_ret == NULL) || (offset == NULL) ||
-	    (stcb == NULL))
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[313]) {
+	  if ((m_end == (void *) 0 || auth_ret == (void *) 0 || offset == (void *) 0 || stcb == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 313\n");
+	  else
+	    fprintf(stderr, "reached bug index 313\n");
+	}
+	if ((!FIXREVERTER[313] && (m_end == (void *) 0 || auth_ret == (void *) 0 || offset == (void *) 0 || stcb == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	)
 		return (m);
+		#ifdef FRCOV
+		}
+		#endif
 
 	if (stcb->asoc.auth_supported == 0) {
 		return (m);
@@ -14931,10 +17147,25 @@ sctp_add_auth_chunk(struct mbuf *m, struct mbuf **m_end,
 		return (m);
 	}
 	m_auth = sctp_get_mbuf_for_msg(sizeof(*auth), 0, M_NOWAIT, 1, MT_HEADER);
-	if (m_auth == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[314]) {
+	  if ((m_auth == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 314\n");
+	  else
+	    fprintf(stderr, "reached bug index 314\n");
+	}
+	if ((!FIXREVERTER[314] && (m_auth == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		/* no mbuf's */
 		return (m);
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	/* reserve some space if this will be the first mbuf */
 	if (m == NULL)
 		SCTP_BUF_RESV_UF(m_auth, SCTP_MIN_OVERHEAD);
diff --git a/usrsctplib/netinet/sctp_pcb.c b/usrsctplib/netinet/sctp_pcb.c
index 7b4a1944..529e55d9 100755
--- a/usrsctplib/netinet/sctp_pcb.c
+++ b/usrsctplib/netinet/sctp_pcb.c
@@ -1,3 +1,7 @@
+#ifdef FRCOV
+#include <stdio.h>
+extern short FIXREVERTER[];
+#endif
 /*-
  * SPDX-License-Identifier: BSD-3-Clause
  *
@@ -225,13 +229,28 @@ sctp_allocate_vrf(int vrf_id)
 	}
 	SCTP_MALLOC(vrf, struct sctp_vrf *, sizeof(struct sctp_vrf),
 		    SCTP_M_VRF);
-	if (vrf == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[61]) {
+	  if ((vrf == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 61\n");
+	  else
+	    fprintf(stderr, "reached bug index 61\n");
+	}
+	if ((!FIXREVERTER[61] && (vrf == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		/* No memory */
 #ifdef INVARIANTS
 		panic("No memory for VRF:%d", vrf_id);
 #endif
 		return (NULL);
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	/* setup the VRF */
 	memset(vrf, 0, sizeof(struct sctp_vrf));
 	vrf->vrf_id = vrf_id;
@@ -243,7 +262,19 @@ sctp_allocate_vrf(int vrf_id)
 	/* Init the HASH of addresses */
 	vrf->vrf_addr_hash = SCTP_HASH_INIT(SCTP_VRF_ADDR_HASH_SIZE,
 					    &vrf->vrf_addr_hashmark);
-	if (vrf->vrf_addr_hash == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[62]) {
+	  if ((vrf -> vrf_addr_hash == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 62\n");
+	  else
+	    fprintf(stderr, "reached bug index 62\n");
+	}
+	if ((!FIXREVERTER[62] && (vrf -> vrf_addr_hash == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		/* No memory */
 #ifdef INVARIANTS
 		panic("No memory for VRF:%d", vrf_id);
@@ -251,6 +282,9 @@ sctp_allocate_vrf(int vrf_id)
 		SCTP_FREE(vrf, SCTP_M_VRF);
 		return (NULL);
 	}
+	#ifdef FRCOV
+	}
+	#endif
 
 	/* Add it to the hash table */
 	bucket = &SCTP_BASE_INFO(sctp_vrfhash)[(vrf_id & SCTP_BASE_INFO(hashvrfmark))];
@@ -271,9 +305,24 @@ sctp_find_ifn(void *ifn, uint32_t ifn_index)
 	 */
 	hash_ifn_head = &SCTP_BASE_INFO(vrf_ifn_hash)[(ifn_index & SCTP_BASE_INFO(vrf_ifn_hashmark))];
 	LIST_FOREACH(sctp_ifnp, hash_ifn_head, next_bucket) {
-		if (sctp_ifnp->ifn_index == ifn_index) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[63]) {
+		  if ((sctp_ifnp -> ifn_index == ifn_index ) && !(0))
+		    fprintf(stderr, "triggered bug index 63\n");
+		  else
+		    fprintf(stderr, "reached bug index 63\n");
+		}
+		if ((!FIXREVERTER[63] && (sctp_ifnp -> ifn_index == ifn_index ))
+		#else
+		if (0
+		#endif
+		) {
 			return (sctp_ifnp);
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		if (sctp_ifnp->ifn_p && ifn && (sctp_ifnp->ifn_p == ifn)) {
 			return (sctp_ifnp);
 		}
@@ -360,10 +409,25 @@ sctp_delete_ifn(struct sctp_ifn *sctp_ifnp, int hold_addr_lock)
 	struct sctp_ifn *found;
 
 	found = sctp_find_ifn(sctp_ifnp->ifn_p, sctp_ifnp->ifn_index);
-	if (found == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[65]) {
+	  if ((found == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 65\n");
+	  else
+	    fprintf(stderr, "reached bug index 65\n");
+	}
+	if ((!FIXREVERTER[65] && (found == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		/* Not in the list.. sorry */
 		return;
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	if (hold_addr_lock == 0)
 		SCTP_IPI_ADDR_WLOCK();
 	LIST_REMOVE(sctp_ifnp, next_bucket);
@@ -581,10 +645,25 @@ sctp_add_addr_to_vrf(uint32_t vrf_id, void *ifn, uint32_t ifn_index,
 		vrf = sctp_find_vrf(vrf_id);
 		if (vrf == NULL) {
 			vrf = sctp_allocate_vrf(vrf_id);
-			if (vrf == NULL) {
+			
+			#ifdef FRCOV
+			{if (FIXREVERTER[72]) {
+			  if ((vrf == (void *) 0 ) && !(0))
+			    fprintf(stderr, "triggered bug index 72\n");
+			  else
+			    fprintf(stderr, "reached bug index 72\n");
+			}
+			if ((!FIXREVERTER[72] && (vrf == (void *) 0 ))
+			#else
+			if (0
+			#endif
+			) {
 				SCTP_IPI_ADDR_WUNLOCK();
 				return (NULL);
 			}
+			#ifdef FRCOV
+			}
+			#endif
 		}
 	}
 	if (sctp_ifnp == NULL) {
@@ -594,12 +673,27 @@ sctp_add_addr_to_vrf(uint32_t vrf_id, void *ifn, uint32_t ifn_index,
 		SCTP_IPI_ADDR_WUNLOCK();
 		SCTP_MALLOC(sctp_ifnp, struct sctp_ifn *,
 			    sizeof(struct sctp_ifn), SCTP_M_IFN);
-		if (sctp_ifnp == NULL) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[73]) {
+		  if ((sctp_ifnp == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 73\n");
+		  else
+		    fprintf(stderr, "reached bug index 73\n");
+		}
+		if ((!FIXREVERTER[73] && (sctp_ifnp == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		) {
 #ifdef INVARIANTS
 			panic("No memory for IFN");
 #endif
 			return (NULL);
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		memset(sctp_ifnp, 0, sizeof(struct sctp_ifn));
 		sctp_ifnp->ifn_index = ifn_index;
 		sctp_ifnp->ifn_p = ifn;
@@ -670,12 +764,27 @@ sctp_add_addr_to_vrf(uint32_t vrf_id, void *ifn, uint32_t ifn_index,
 	}
 	SCTP_IPI_ADDR_WUNLOCK();
 	SCTP_MALLOC(sctp_ifap, struct sctp_ifa *, sizeof(struct sctp_ifa), SCTP_M_IFA);
-	if (sctp_ifap == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[74]) {
+	  if ((sctp_ifap == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 74\n");
+	  else
+	    fprintf(stderr, "reached bug index 74\n");
+	}
+	if ((!FIXREVERTER[74] && (sctp_ifap == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 #ifdef INVARIANTS
 		panic("No memory for IFA");
 #endif
 		return (NULL);
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	memset(sctp_ifap, 0, sizeof(struct sctp_ifa));
 	sctp_ifap->ifn_p = sctp_ifnp;
 	atomic_add_int(&sctp_ifnp->refcount, 1);
@@ -785,7 +894,19 @@ sctp_add_addr_to_vrf(uint32_t vrf_id, void *ifn, uint32_t ifn_index,
 
 		atomic_add_int(&sctp_ifap->refcount, 1);
 		wi = SCTP_ZONE_GET(SCTP_BASE_INFO(ipi_zone_laddr), struct sctp_laddr);
-		if (wi == NULL) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[75]) {
+		  if ((wi == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 75\n");
+		  else
+		    fprintf(stderr, "reached bug index 75\n");
+		}
+		if ((!FIXREVERTER[75] && (wi == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		) {
 			/*
 			 * Gak, what can we do? We have lost an address
 			 * change can you say HOSED?
@@ -796,6 +917,9 @@ sctp_add_addr_to_vrf(uint32_t vrf_id, void *ifn, uint32_t ifn_index,
 					       if_name);
 			return (NULL);
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		SCTP_INCR_LADDR_COUNT();
 		memset(wi, 0, sizeof(*wi));
 		(void)SCTP_GETTIME_TIMEVAL(&wi->start_time);
@@ -825,10 +949,25 @@ sctp_del_addr_from_vrf(uint32_t vrf_id, struct sockaddr *addr,
 
 	SCTP_IPI_ADDR_WLOCK();
 	vrf = sctp_find_vrf(vrf_id);
-	if (vrf == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[76]) {
+	  if ((vrf == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 76\n");
+	  else
+	    fprintf(stderr, "reached bug index 76\n");
+	}
+	if ((!FIXREVERTER[76] && (vrf == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		SCTPDBG(SCTP_DEBUG_PCB4, "Can't find vrf_id 0x%x\n", vrf_id);
 		goto out_now;
 	}
+	#ifdef FRCOV
+	}
+	#endif
 
 #ifdef SCTP_DEBUG
 	SCTPDBG(SCTP_DEBUG_PCB4, "vrf_id 0x%x: deleting address:", vrf_id);
@@ -892,7 +1031,19 @@ sctp_del_addr_from_vrf(uint32_t vrf_id, struct sockaddr *addr,
 		struct sctp_laddr *wi;
 
 		wi = SCTP_ZONE_GET(SCTP_BASE_INFO(ipi_zone_laddr), struct sctp_laddr);
-		if (wi == NULL) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[77]) {
+		  if ((wi == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 77\n");
+		  else
+		    fprintf(stderr, "reached bug index 77\n");
+		}
+		if ((!FIXREVERTER[77] && (wi == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		) {
 			/*
 			 * Gak, what can we do? We have lost an address
 			 * change can you say HOSED?
@@ -903,6 +1054,9 @@ sctp_del_addr_from_vrf(uint32_t vrf_id, struct sockaddr *addr,
 			sctp_free_ifa(sctp_ifap);
 			return;
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		SCTP_INCR_LADDR_COUNT();
 		memset(wi, 0, sizeof(*wi));
 		(void)SCTP_GETTIME_TIMEVAL(&wi->start_time);
@@ -957,11 +1111,26 @@ sctp_does_stcb_own_this_addr(struct sctp_tcb *stcb, struct sockaddr *to)
 
 	SCTP_IPI_ADDR_RLOCK();
 	vrf = sctp_find_vrf(stcb->asoc.vrf_id);
-	if (vrf == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[78]) {
+	  if ((vrf == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 78\n");
+	  else
+	    fprintf(stderr, "reached bug index 78\n");
+	}
+	if ((!FIXREVERTER[78] && (vrf == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		/* no vrf, no addresses */
 		SCTP_IPI_ADDR_RUNLOCK();
 		return (0);
 	}
+	#ifdef FRCOV
+	}
+	#endif
 
 	if (stcb->sctp_ep->sctp_flags & SCTP_PCB_FLAGS_BOUNDALL) {
 		LIST_FOREACH(sctp_ifn, &vrf->ifnlist, next_ifn) {
@@ -1165,9 +1334,24 @@ sctp_tcb_special_locate(struct sctp_inpcb **inp_p, struct sockaddr *from,
 	int fnd, i;
 #endif
 
-	if ((to == NULL) || (from == NULL)) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[80]) {
+	  if ((to == (void *) 0 || from == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 80\n");
+	  else
+	    fprintf(stderr, "reached bug index 80\n");
+	}
+	if ((!FIXREVERTER[80] && (to == (void *) 0 || from == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		return (NULL);
 	}
+	#ifdef FRCOV
+	}
+	#endif
 
 	switch (to->sa_family) {
 #ifdef INET
@@ -1268,10 +1452,25 @@ sctp_tcb_special_locate(struct sctp_inpcb **inp_p, struct sockaddr *from,
 			continue;
 		}
 #else
-		if (inp->def_vrf_id != vrf_id) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[81]) {
+		  if ((inp -> def_vrf_id != vrf_id ) && !(0))
+		    fprintf(stderr, "triggered bug index 81\n");
+		  else
+		    fprintf(stderr, "reached bug index 81\n");
+		}
+		if ((!FIXREVERTER[81] && (inp -> def_vrf_id != vrf_id ))
+		#else
+		if (0
+		#endif
+		) {
 			SCTP_INP_RUNLOCK(inp);
 			continue;
 		}
+		#ifdef FRCOV
+		}
+		#endif
 #endif
 		/* check to see if the ep has one of the addresses */
 		if ((inp->sctp_flags & SCTP_PCB_FLAGS_BOUNDALL) == 0) {
@@ -1280,10 +1479,25 @@ sctp_tcb_special_locate(struct sctp_inpcb **inp_p, struct sockaddr *from,
 
 			LIST_FOREACH(laddr, &inp->sctp_addr_list, sctp_nxt_addr) {
 
-				if (laddr->ifa == NULL) {
+				
+				#ifdef FRCOV
+				{if (FIXREVERTER[82]) {
+				  if ((laddr -> ifa == (void *) 0 ) && !(0))
+				    fprintf(stderr, "triggered bug index 82\n");
+				  else
+				    fprintf(stderr, "reached bug index 82\n");
+				}
+				if ((!FIXREVERTER[82] && (laddr -> ifa == (void *) 0 ))
+				#else
+				if (0
+				#endif
+				) {
 					SCTPDBG(SCTP_DEBUG_PCB1, "%s: NULL ifa\n", __func__);
 					continue;
 				}
+				#ifdef FRCOV
+				}
+				#endif
 				if (laddr->ifa->localifa_flags & SCTP_BEING_DELETED) {
 					SCTPDBG(SCTP_DEBUG_PCB1, "ifa being deleted\n");
 					continue;
@@ -1347,22 +1561,52 @@ sctp_tcb_special_locate(struct sctp_inpcb **inp_p, struct sockaddr *from,
 		 */
 		/* XXX: Why don't we TAILQ_FOREACH through sctp_asoc_list? */
 		stcb = LIST_FIRST(&inp->sctp_asoc_list);
-		if (stcb == NULL) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[84]) {
+		  if ((stcb == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 84\n");
+		  else
+		    fprintf(stderr, "reached bug index 84\n");
+		}
+		if ((!FIXREVERTER[84] && (stcb == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		) {
 			SCTP_INP_RUNLOCK(inp);
 			continue;
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		SCTP_TCB_LOCK(stcb);
 		if (!sctp_does_stcb_own_this_addr(stcb, to)) {
 			SCTP_TCB_UNLOCK(stcb);
 			SCTP_INP_RUNLOCK(inp);
 			continue;
 		}
-		if (stcb->rport != rport) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[85]) {
+		  if ((stcb -> rport != rport ) && !(0))
+		    fprintf(stderr, "triggered bug index 85\n");
+		  else
+		    fprintf(stderr, "reached bug index 85\n");
+		}
+		if ((!FIXREVERTER[85] && (stcb -> rport != rport ))
+		#else
+		if (0
+		#endif
+		) {
 			/* remote port does not match. */
 			SCTP_TCB_UNLOCK(stcb);
 			SCTP_INP_RUNLOCK(inp);
 			continue;
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		if (stcb->asoc.state & SCTP_STATE_ABOUT_TO_BE_FREED) {
 			SCTP_TCB_UNLOCK(stcb);
 			SCTP_INP_RUNLOCK(inp);
@@ -1564,11 +1808,26 @@ sctp_findassociation_ep_addr(struct sctp_inpcb **inp_p, struct sockaddr *remote,
 			}
 			SCTP_TCB_LOCK(stcb);
 
-			if (stcb->rport != rport) {
+			
+			#ifdef FRCOV
+			{if (FIXREVERTER[87]) {
+			  if ((stcb -> rport != rport ) && !(0))
+			    fprintf(stderr, "triggered bug index 87\n");
+			  else
+			    fprintf(stderr, "reached bug index 87\n");
+			}
+			if ((!FIXREVERTER[87] && (stcb -> rport != rport ))
+			#else
+			if (0
+			#endif
+			) {
 				/* remote port does not match. */
 				SCTP_TCB_UNLOCK(stcb);
 				goto null_return;
 			}
+			#ifdef FRCOV
+			}
+			#endif
 			if (stcb->asoc.state & SCTP_STATE_ABOUT_TO_BE_FREED) {
 				SCTP_TCB_UNLOCK(stcb);
 				goto null_return;
@@ -1690,10 +1949,25 @@ sctp_findassociation_ep_addr(struct sctp_inpcb **inp_p, struct sockaddr *remote,
 		head = &inp->sctp_tcbhash[SCTP_PCBHASH_ALLADDR(rport,
 		                                               inp->sctp_hashmark)];
 		LIST_FOREACH(stcb, head, sctp_tcbhash) {
-			if (stcb->rport != rport) {
+			
+			#ifdef FRCOV
+			{if (FIXREVERTER[88]) {
+			  if ((stcb -> rport != rport ) && !(0))
+			    fprintf(stderr, "triggered bug index 88\n");
+			  else
+			    fprintf(stderr, "reached bug index 88\n");
+			}
+			if ((!FIXREVERTER[88] && (stcb -> rport != rport ))
+			#else
+			if (0
+			#endif
+			) {
 				/* remote port does not match */
 				continue;
 			}
+			#ifdef FRCOV
+			}
+			#endif
 			SCTP_TCB_LOCK(stcb);
 			if (stcb->asoc.state & SCTP_STATE_ABOUT_TO_BE_FREED) {
 				SCTP_TCB_UNLOCK(stcb);
@@ -1836,21 +2110,51 @@ sctp_findasoc_ep_asocid_locked(struct sctp_inpcb *inp, sctp_assoc_t asoc_id, int
 	struct sctp_tcb *stcb;
 	uint32_t id;
 
-	if (inp == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[89]) {
+	  if ((inp == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 89\n");
+	  else
+	    fprintf(stderr, "reached bug index 89\n");
+	}
+	if ((!FIXREVERTER[89] && (inp == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		SCTP_PRINTF("TSNH ep_associd\n");
 		return (NULL);
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	if (inp->sctp_flags & SCTP_PCB_FLAGS_SOCKET_ALLGONE) {
 		SCTP_PRINTF("TSNH ep_associd0\n");
 		return (NULL);
 	}
 	id = (uint32_t)asoc_id;
 	head = &inp->sctp_asocidhash[SCTP_PCBHASH_ASOC(id, inp->hashasocidmark)];
-	if (head == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[90]) {
+	  if ((head == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 90\n");
+	  else
+	    fprintf(stderr, "reached bug index 90\n");
+	}
+	if ((!FIXREVERTER[90] && (head == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		/* invalid id TSNH */
 		SCTP_PRINTF("TSNH ep_associd1\n");
 		return (NULL);
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	LIST_FOREACH(stcb, head, sctp_tcbasocidhash) {
 		if (stcb->asoc.assoc_id == id) {
 			if (inp != stcb->sctp_ep) {
@@ -1940,8 +2244,23 @@ sctp_endpoint_probe(struct sockaddr *nam, struct sctppcbhead *head,
 		return (NULL);
 	}
 
-	if (head == NULL)
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[91]) {
+	  if ((head == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 91\n");
+	  else
+	    fprintf(stderr, "reached bug index 91\n");
+	}
+	if ((!FIXREVERTER[91] && (head == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	)
 		return (NULL);
+		#ifdef FRCOV
+		}
+		#endif
 
 	LIST_FOREACH(inp, head, sctp_hash) {
 		SCTP_INP_RLOCK(inp);
@@ -2029,9 +2348,24 @@ sctp_endpoint_probe(struct sockaddr *nam, struct sctppcbhead *head,
 #endif
 #if defined(__Userspace__)
 	case AF_CONN:
-		if (sconn->sconn_addr == NULL) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[93]) {
+		  if ((sconn -> sconn_addr == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 93\n");
+		  else
+		    fprintf(stderr, "reached bug index 93\n");
+		}
+		if ((!FIXREVERTER[93] && (sconn -> sconn_addr == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		) {
 			return (NULL);
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		break;
 #endif
 	default:
@@ -2078,11 +2412,26 @@ sctp_endpoint_probe(struct sockaddr *nam, struct sctppcbhead *head,
 			continue;
 		}
 		LIST_FOREACH(laddr, &inp->sctp_addr_list, sctp_nxt_addr) {
-			if (laddr->ifa == NULL) {
+			
+			#ifdef FRCOV
+			{if (FIXREVERTER[95]) {
+			  if ((laddr -> ifa == (void *) 0 ) && !(0))
+			    fprintf(stderr, "triggered bug index 95\n");
+			  else
+			    fprintf(stderr, "reached bug index 95\n");
+			}
+			if ((!FIXREVERTER[95] && (laddr -> ifa == (void *) 0 ))
+			#else
+			if (0
+			#endif
+			) {
 				SCTPDBG(SCTP_DEBUG_PCB1, "%s: NULL ifa\n",
 					__func__);
 				continue;
 			}
+			#ifdef FRCOV
+			}
+			#endif
 			SCTPDBG(SCTP_DEBUG_PCB1, "Ok laddr->ifa:%p is possible, ",
 				(void *)laddr->ifa);
 			if (laddr->ifa->localifa_flags & SCTP_BEING_DELETED) {
@@ -2365,9 +2714,24 @@ sctp_findassociation_addr_sa(struct sockaddr *from, struct sockaddr *to,
 		*inp_p = inp;
 	}
 	SCTP_INP_INFO_RUNLOCK();
-	if (inp == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[97]) {
+	  if ((inp == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 97\n");
+	  else
+	    fprintf(stderr, "reached bug index 97\n");
+	}
+	if ((!FIXREVERTER[97] && (inp == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		return (NULL);
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	/*
 	 * ok, we have an endpoint, now lets find the assoc for it (if any)
 	 * we now place the source address or from in the to of the find
@@ -2434,9 +2798,24 @@ sctp_findassociation_special_addr(struct mbuf *m, int offset,
 		ptype = ntohs(phdr->param_type);
 #endif
 		plen = ntohs(phdr->param_length);
-		if (plen == 0) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[98]) {
+		  if ((plen == 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 98\n");
+		  else
+		    fprintf(stderr, "reached bug index 98\n");
+		}
+		if ((!FIXREVERTER[98] && (plen == 0 ))
+		#else
+		if (0
+		#endif
+		) {
 			break;
 		}
+		#ifdef FRCOV
+		}
+		#endif
 #ifdef INET
 		if (ptype == SCTP_IPV4_ADDRESS &&
 		    plen == sizeof(struct sctp_ipv4addr_param)) {
@@ -2445,9 +2824,24 @@ sctp_findassociation_special_addr(struct mbuf *m, int offset,
 
 			phdr = sctp_get_next_param(m, offset,
 			    (struct sctp_paramhdr *)&ip4_param, sizeof(ip4_param));
-			if (phdr == NULL) {
+			
+			#ifdef FRCOV
+			{if (FIXREVERTER[99]) {
+			  if ((phdr == (void *) 0 ) && !(0))
+			    fprintf(stderr, "triggered bug index 99\n");
+			  else
+			    fprintf(stderr, "reached bug index 99\n");
+			}
+			if ((!FIXREVERTER[99] && (phdr == (void *) 0 ))
+			#else
+			if (0
+			#endif
+			) {
 				return (NULL);
 			}
+			#ifdef FRCOV
+			}
+			#endif
 			p4 = (struct sctp_ipv4addr_param *)phdr;
 			memcpy(&sin4.sin_addr, &p4->addr, sizeof(p4->addr));
 			/* look it up */
@@ -2466,9 +2860,24 @@ sctp_findassociation_special_addr(struct mbuf *m, int offset,
 
 			phdr = sctp_get_next_param(m, offset,
 			    (struct sctp_paramhdr *)&ip6_param, sizeof(ip6_param));
-			if (phdr == NULL) {
+			
+			#ifdef FRCOV
+			{if (FIXREVERTER[100]) {
+			  if ((phdr == (void *) 0 ) && !(0))
+			    fprintf(stderr, "triggered bug index 100\n");
+			  else
+			    fprintf(stderr, "reached bug index 100\n");
+			}
+			if ((!FIXREVERTER[100] && (phdr == (void *) 0 ))
+			#else
+			if (0
+			#endif
+			) {
 				return (NULL);
 			}
+			#ifdef FRCOV
+			}
+			#endif
 			p6 = (struct sctp_ipv6addr_param *)phdr;
 			memcpy(&sin6.sin6_addr, &p6->addr, sizeof(p6->addr));
 			/* look it up */
@@ -2532,10 +2941,25 @@ sctp_findassoc_by_vtag(struct sockaddr *from, struct sockaddr *to, uint32_t vtag
 		SCTP_INP_RUNLOCK(stcb->sctp_ep);
 		if (stcb->asoc.my_vtag == vtag) {
 			/* candidate */
-			if (stcb->rport != rport) {
+			
+			#ifdef FRCOV
+			{if (FIXREVERTER[101]) {
+			  if ((stcb -> rport != rport ) && !(0))
+			    fprintf(stderr, "triggered bug index 101\n");
+			  else
+			    fprintf(stderr, "reached bug index 101\n");
+			}
+			if ((!FIXREVERTER[101] && (stcb -> rport != rport ))
+			#else
+			if (0
+			#endif
+			) {
 				SCTP_TCB_UNLOCK(stcb);
 				continue;
 			}
+			#ifdef FRCOV
+			}
+			#endif
 			if (stcb->sctp_ep->sctp_lport != lport) {
 				SCTP_TCB_UNLOCK(stcb);
 				continue;
@@ -2678,11 +3102,26 @@ sctp_findassociation_ep_asconf(struct mbuf *m, int offset,
 	memset(&remote_store, 0, sizeof(remote_store));
 	phdr = sctp_get_next_param(m, offset + sizeof(struct sctp_asconf_chunk),
 				   &param_buf, sizeof(struct sctp_paramhdr));
-	if (phdr == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[102]) {
+	  if ((phdr == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 102\n");
+	  else
+	    fprintf(stderr, "reached bug index 102\n");
+	}
+	if ((!FIXREVERTER[102] && (phdr == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		SCTPDBG(SCTP_DEBUG_INPUT3, "%s: failed to get asconf lookup addr\n",
 			__func__);
 		return NULL;
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	ptype = (int)((uint32_t) ntohs(phdr->param_type));
 	/* get the correlation address */
 	switch (ptype) {
@@ -2698,11 +3137,26 @@ sctp_findassociation_ep_asconf(struct mbuf *m, int offset,
 		p6 = (struct sctp_ipv6addr_param *)sctp_get_next_param(m,
 								       offset + sizeof(struct sctp_asconf_chunk),
 								       &p6_buf.ph, sizeof(p6_buf));
-		if (p6 == NULL) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[103]) {
+		  if ((p6 == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 103\n");
+		  else
+		    fprintf(stderr, "reached bug index 103\n");
+		}
+		if ((!FIXREVERTER[103] && (p6 == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		) {
 			SCTPDBG(SCTP_DEBUG_INPUT3, "%s: failed to get asconf v6 lookup addr\n",
 				__func__);
 			return (NULL);
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		sin6 = &remote_store.sin6;
 		sin6->sin6_family = AF_INET6;
 #ifdef HAVE_SIN6_LEN
@@ -2727,11 +3181,26 @@ sctp_findassociation_ep_asconf(struct mbuf *m, int offset,
 		p4 = (struct sctp_ipv4addr_param *)sctp_get_next_param(m,
 								       offset + sizeof(struct sctp_asconf_chunk),
 								       &p4_buf.ph, sizeof(p4_buf));
-		if (p4 == NULL) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[104]) {
+		  if ((p4 == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 104\n");
+		  else
+		    fprintf(stderr, "reached bug index 104\n");
+		}
+		if ((!FIXREVERTER[104] && (p4 == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		) {
 			SCTPDBG(SCTP_DEBUG_INPUT3, "%s: failed to get asconf v4 lookup addr\n",
 				__func__);
 			return (NULL);
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		sin = &remote_store.sin;
 		sin->sin_family = AF_INET;
 #ifdef HAVE_SIN_LEN
@@ -3159,7 +3628,19 @@ sctp_move_pcb_and_assoc(struct sctp_inpcb *old_inp, struct sctp_inpcb *new_inp,
 		/* Subset bound, so copy in the laddr list from the old_inp */
 		LIST_FOREACH(oladdr, &old_inp->sctp_addr_list, sctp_nxt_addr) {
 			laddr = SCTP_ZONE_GET(SCTP_BASE_INFO(ipi_zone_laddr), struct sctp_laddr);
-			if (laddr == NULL) {
+			
+			#ifdef FRCOV
+			{if (FIXREVERTER[105]) {
+			  if ((laddr == (void *) 0 ) && !(0))
+			    fprintf(stderr, "triggered bug index 105\n");
+			  else
+			    fprintf(stderr, "reached bug index 105\n");
+			}
+			if ((!FIXREVERTER[105] && (laddr == (void *) 0 ))
+			#else
+			if (0
+			#endif
+			) {
 				/*
 				 * Gak, what can we do? This assoc is really
 				 * HOSED. We probably should send an abort
@@ -3168,6 +3649,9 @@ sctp_move_pcb_and_assoc(struct sctp_inpcb *old_inp, struct sctp_inpcb *new_inp,
 				SCTPDBG(SCTP_DEBUG_PCB1, "Association hosed in TCP model, out of laddr memory\n");
 				continue;
 			}
+			#ifdef FRCOV
+			}
+			#endif
 			SCTP_INCR_LADDR_COUNT();
 			memset(laddr, 0, sizeof(*laddr));
 			(void)SCTP_GETTIME_TIMEVAL(&laddr->start_time);
@@ -3213,11 +3697,26 @@ sctp_insert_laddr(struct sctpladdr *list, struct sctp_ifa *ifa, uint32_t act)
 	struct sctp_laddr *laddr;
 
 	laddr = SCTP_ZONE_GET(SCTP_BASE_INFO(ipi_zone_laddr), struct sctp_laddr);
-	if (laddr == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[106]) {
+	  if ((laddr == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 106\n");
+	  else
+	    fprintf(stderr, "reached bug index 106\n");
+	}
+	if ((!FIXREVERTER[106] && (laddr == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		/* out of memory? */
 		SCTP_LTRACE_ERR_RET(NULL, NULL, NULL, SCTP_FROM_SCTP_PCB, EINVAL);
 		return (EINVAL);
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	SCTP_INCR_LADDR_COUNT();
 	memset(laddr, 0, sizeof(*laddr));
 	(void)SCTP_GETTIME_TIMEVAL(&laddr->start_time);
@@ -3775,11 +4274,26 @@ sctp_inpcb_bind(struct socket *so, struct sockaddr *addr,
 
 		/* add this address to the endpoint list */
 		error = sctp_insert_laddr(&inp->sctp_addr_list, ifa, 0);
-		if (error != 0) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[107]) {
+		  if ((error != 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 107\n");
+		  else
+		    fprintf(stderr, "reached bug index 107\n");
+		}
+		if ((!FIXREVERTER[107] && (error != 0 ))
+		#else
+		if (0
+		#endif
+		) {
 			SCTP_INP_WUNLOCK(inp);
 			SCTP_INP_INFO_WUNLOCK();
 			return (error);
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		inp->laddr_count++;
 	}
 	/* find the bucket */
@@ -4500,10 +5014,25 @@ sctp_add_remote_addr(struct sctp_tcb *stcb, struct sockaddr *newaddr,
 		struct sockaddr_conn *sconn;
 
 		sconn = (struct sockaddr_conn *)newaddr;
-		if (sconn->sconn_addr == NULL) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[108]) {
+		  if ((sconn -> sconn_addr == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 108\n");
+		  else
+		    fprintf(stderr, "reached bug index 108\n");
+		}
+		if ((!FIXREVERTER[108] && (sconn -> sconn_addr == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		) {
 			/* Invalid address */
 			return (-1);
 		}
+		#ifdef FRCOV
+		}
+		#endif
 #ifdef HAVE_SCONN_LEN
 		sconn->sconn_len = sizeof(struct sockaddr_conn);
 #endif
@@ -4515,9 +5044,24 @@ sctp_add_remote_addr(struct sctp_tcb *stcb, struct sockaddr *newaddr,
 		return (-1);
 	}
 	net = SCTP_ZONE_GET(SCTP_BASE_INFO(ipi_zone_net), struct sctp_nets);
-	if (net == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[109]) {
+	  if ((net == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 109\n");
+	  else
+	    fprintf(stderr, "reached bug index 109\n");
+	}
+	if ((!FIXREVERTER[109] && (net == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		return (-1);
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	SCTP_INCR_RADDR_COUNT();
 	memset(net, 0, sizeof(struct sctp_nets));
 	(void)SCTP_GETTIME_TIMEVAL(&net->start_time);
@@ -4944,11 +5488,26 @@ sctp_aloc_assoc(struct sctp_inpcb *inp, struct sockaddr *firstaddr,
 		*error = ENOBUFS;
 		return (NULL);
 	}
-	if (firstaddr == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[110]) {
+	  if ((firstaddr == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 110\n");
+	  else
+	    fprintf(stderr, "reached bug index 110\n");
+	}
+	if ((!FIXREVERTER[110] && (firstaddr == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		SCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_PCB, EINVAL);
 		*error = EINVAL;
 		return (NULL);
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	SCTP_INP_RLOCK(inp);
 	if ((inp->sctp_flags & SCTP_PCB_FLAGS_IN_TCPPOOL) &&
 	    ((sctp_is_feature_off(inp, SCTP_PCB_FLAGS_PORTREUSE)) ||
@@ -5090,12 +5649,27 @@ sctp_aloc_assoc(struct sctp_inpcb *inp, struct sockaddr *firstaddr,
 		}
 	}
 	stcb = SCTP_ZONE_GET(SCTP_BASE_INFO(ipi_zone_asoc), struct sctp_tcb);
-	if (stcb == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[111]) {
+	  if ((stcb == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 111\n");
+	  else
+	    fprintf(stderr, "reached bug index 111\n");
+	}
+	if ((!FIXREVERTER[111] && (stcb == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		/* out of memory? */
 		SCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_PCB, ENOMEM);
 		*error = ENOMEM;
 		return (NULL);
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	SCTP_INCR_ASOC_COUNT();
 
 	memset(stcb, 0, sizeof(*stcb));
@@ -5347,10 +5921,25 @@ sctp_add_vtag_to_timewait(uint32_t tag, uint32_t time, uint16_t lport, uint16_t
 	struct timeval now;
 	int set, i;
 
-	if (time == 0) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[112]) {
+	  if ((time == 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 112\n");
+	  else
+	    fprintf(stderr, "reached bug index 112\n");
+	}
+	if ((!FIXREVERTER[112] && (time == 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		/* Its disabled */
 		return;
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	(void)SCTP_GETTIME_TIMEVAL(&now);
 	chain = &SCTP_BASE_INFO(vtag_timewait)[(tag % SCTP_STACK_VTAG_HASH_SIZE)];
 	set = 0;
@@ -5394,12 +5983,27 @@ sctp_add_vtag_to_timewait(uint32_t tag, uint32_t time, uint16_t lport, uint16_t
 	if (!set) {
 		SCTP_MALLOC(twait_block, struct sctp_tagblock *,
 		    sizeof(struct sctp_tagblock), SCTP_M_TIMW);
-		if (twait_block == NULL) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[113]) {
+		  if ((twait_block == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 113\n");
+		  else
+		    fprintf(stderr, "reached bug index 113\n");
+		}
+		if ((!FIXREVERTER[113] && (twait_block == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		) {
 #ifdef INVARIANTS
 			panic("Can not alloc tagblock");
 #endif
 			return;
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		memset(twait_block, 0, sizeof(struct sctp_tagblock));
 		LIST_INSERT_HEAD(chain, twait_block, sctp_nxt_tagblock);
 		twait_block->vtag_block[0].tv_sec_at_expire = now.tv_sec + time;
@@ -6130,11 +6734,26 @@ sctp_update_ep_vflag(struct sctp_inpcb *inp)
 #endif
 	/* set the flag based on addresses on the ep list */
 	LIST_FOREACH(laddr, &inp->sctp_addr_list, sctp_nxt_addr) {
-		if (laddr->ifa == NULL) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[114]) {
+		  if ((laddr -> ifa == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 114\n");
+		  else
+		    fprintf(stderr, "reached bug index 114\n");
+		}
+		if ((!FIXREVERTER[114] && (laddr -> ifa == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		) {
 			SCTPDBG(SCTP_DEBUG_PCB1, "%s: NULL ifa\n",
 				__func__);
 			continue;
 		}
+		#ifdef FRCOV
+		}
+		#endif
 
 		if (laddr->ifa->localifa_flags & SCTP_BEING_DELETED) {
 			continue;
@@ -6303,9 +6922,24 @@ sctp_del_local_addr_ep(struct sctp_inpcb *inp, struct sctp_ifa *ifa)
 		struct sctp_tcb *stcb;
 
 		/* clean up "next_addr_touse" */
-		if (inp->next_addr_touse == laddr)
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[116]) {
+		  if ((inp -> next_addr_touse == laddr  ) && !(0))
+		    fprintf(stderr, "triggered bug index 116\n");
+		  else
+		    fprintf(stderr, "reached bug index 116\n");
+		}
+		if ((!FIXREVERTER[116] && (inp -> next_addr_touse == laddr  ))
+		#else
+		if (0
+		#endif
+		)
 			/* delete this address */
 			inp->next_addr_touse = NULL;
+			#ifdef FRCOV
+			}
+			#endif
 
 		/* clean up "last_used_address" */
 		LIST_FOREACH(stcb, &inp->sctp_asoc_list, sctp_tcblist) {
@@ -6410,8 +7044,23 @@ sctp_del_local_addr_restricted(struct sctp_tcb *stcb, struct sctp_ifa *ifa)
 	}
 	LIST_FOREACH(laddr, &stcb->asoc.sctp_restricted_addrs, sctp_nxt_addr) {
 		/* remove the address if it exists */
-		if (laddr->ifa == NULL)
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[117]) {
+		  if ((laddr -> ifa == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 117\n");
+		  else
+		    fprintf(stderr, "reached bug index 117\n");
+		}
+		if ((!FIXREVERTER[117] && (laddr -> ifa == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		)
 			continue;
+			#ifdef FRCOV
+			}
+			#endif
 		if (laddr->ifa == ifa) {
 			sctp_remove_laddr(laddr);
 			return;
@@ -7247,12 +7896,42 @@ sctp_load_addresses_from_init(struct sctp_tcb *stcb, struct mbuf *m,
 		 * SCTP_PRINTF("ptype => %0x, plen => %d\n", (uint32_t)ptype,
 		 * (int)plen);
 		 */
-		if (offset + plen > limit) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[118]) {
+		  if ((offset + plen > limit ) && !(0))
+		    fprintf(stderr, "triggered bug index 118\n");
+		  else
+		    fprintf(stderr, "reached bug index 118\n");
+		}
+		if ((!FIXREVERTER[118] && (offset + plen > limit ))
+		#else
+		if (0
+		#endif
+		) {
 			break;
 		}
-		if (plen == 0) {
+		#ifdef FRCOV
+		}
+		#endif
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[119]) {
+		  if ((plen == 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 119\n");
+		  else
+		    fprintf(stderr, "reached bug index 119\n");
+		}
+		if ((!FIXREVERTER[119] && (plen == 0 ))
+		#else
+		if (0
+		#endif
+		) {
 			break;
 		}
+		#ifdef FRCOV
+		}
+		#endif
 #ifdef INET
 		if (ptype == SCTP_IPV4_ADDRESS) {
 			if (stcb->asoc.scope.ipv4_addr_legal) {
@@ -7463,15 +8142,45 @@ sctp_load_addresses_from_init(struct sctp_tcb *stcb, struct mbuf *m,
 			if (stcb->asoc.asconf_supported == 0) {
 				return (-100);
 			}
-			if (plen > sizeof(lstore)) {
+			
+			#ifdef FRCOV
+			{if (FIXREVERTER[120]) {
+			  if ((plen > sizeof ( lstore ) ) && !(0))
+			    fprintf(stderr, "triggered bug index 120\n");
+			  else
+			    fprintf(stderr, "reached bug index 120\n");
+			}
+			if ((!FIXREVERTER[120] && (plen > sizeof ( lstore ) ))
+			#else
+			if (0
+			#endif
+			) {
 				return (-23);
 			}
+			#ifdef FRCOV
+			}
+			#endif
 			phdr = sctp_get_next_param(m, offset,
 						   (struct sctp_paramhdr *)&lstore,
 						   plen);
-			if (phdr == NULL) {
+			
+			#ifdef FRCOV
+			{if (FIXREVERTER[121]) {
+			  if ((phdr == (void *) 0 ) && !(0))
+			    fprintf(stderr, "triggered bug index 121\n");
+			  else
+			    fprintf(stderr, "reached bug index 121\n");
+			}
+			if ((!FIXREVERTER[121] && (phdr == (void *) 0 ))
+			#else
+			if (0
+			#endif
+			) {
 				return (-24);
 			}
+			#ifdef FRCOV
+			}
+			#endif
 			fee = (struct sctp_asconf_addr_param *)phdr;
 			lptype = ntohs(fee->addrp.ph.param_type);
 			switch (lptype) {
@@ -7521,14 +8230,44 @@ sctp_load_addresses_from_init(struct sctp_tcb *stcb, struct mbuf *m,
 			uint8_t local_store[SCTP_PARAM_BUFFER_SIZE];
 			int num_ent, i;
 
-			if (plen > sizeof(local_store)) {
+			
+			#ifdef FRCOV
+			{if (FIXREVERTER[122]) {
+			  if ((plen > sizeof ( local_store ) ) && !(0))
+			    fprintf(stderr, "triggered bug index 122\n");
+			  else
+			    fprintf(stderr, "reached bug index 122\n");
+			}
+			if ((!FIXREVERTER[122] && (plen > sizeof ( local_store ) ))
+			#else
+			if (0
+			#endif
+			) {
 				return (-35);
 			}
+			#ifdef FRCOV
+			}
+			#endif
 			phdr = sctp_get_next_param(m, offset,
 						   (struct sctp_paramhdr *)&local_store, plen);
-			if (phdr == NULL) {
+			
+			#ifdef FRCOV
+			{if (FIXREVERTER[123]) {
+			  if ((phdr == (void *) 0 ) && !(0))
+			    fprintf(stderr, "triggered bug index 123\n");
+			  else
+			    fprintf(stderr, "reached bug index 123\n");
+			}
+			if ((!FIXREVERTER[123] && (phdr == (void *) 0 ))
+			#else
+			if (0
+			#endif
+			) {
 				return (-25);
 			}
+			#ifdef FRCOV
+			}
+			#endif
 			pr_supported = (struct sctp_supported_chunk_types_param *)phdr;
 			num_ent = plen - sizeof(struct sctp_paramhdr);
 			for (i = 0; i < num_ent; i++) {
@@ -7564,8 +8303,23 @@ sctp_load_addresses_from_init(struct sctp_tcb *stcb, struct mbuf *m,
 				}
 			}
 		} else if (ptype == SCTP_RANDOM) {
-			if (plen > sizeof(random_store))
+			
+			#ifdef FRCOV
+			{if (FIXREVERTER[124]) {
+			  if ((plen > sizeof ( random_store ) ) && !(0))
+			    fprintf(stderr, "triggered bug index 124\n");
+			  else
+			    fprintf(stderr, "reached bug index 124\n");
+			}
+			if ((!FIXREVERTER[124] && (plen > sizeof ( random_store ) ))
+			#else
+			if (0
+			#endif
+			)
 				break;
+				#ifdef FRCOV
+				}
+				#endif
 			if (got_random) {
 				/* already processed a RANDOM */
 				goto next_param;
@@ -7573,22 +8327,67 @@ sctp_load_addresses_from_init(struct sctp_tcb *stcb, struct mbuf *m,
 			phdr = sctp_get_next_param(m, offset,
 						   (struct sctp_paramhdr *)random_store,
 						   plen);
-			if (phdr == NULL)
+			
+			#ifdef FRCOV
+			{if (FIXREVERTER[125]) {
+			  if ((phdr == (void *) 0 ) && !(0))
+			    fprintf(stderr, "triggered bug index 125\n");
+			  else
+			    fprintf(stderr, "reached bug index 125\n");
+			}
+			if ((!FIXREVERTER[125] && (phdr == (void *) 0 ))
+			#else
+			if (0
+			#endif
+			)
 				return (-26);
+				#ifdef FRCOV
+				}
+				#endif
 			p_random = (struct sctp_auth_random *)phdr;
 			random_len = plen - sizeof(*p_random);
 			/* enforce the random length */
-			if (random_len != SCTP_AUTH_RANDOM_SIZE_REQUIRED) {
+			
+			#ifdef FRCOV
+			{if (FIXREVERTER[126]) {
+			  if ((random_len != 32 ) && !(0))
+			    fprintf(stderr, "triggered bug index 126\n");
+			  else
+			    fprintf(stderr, "reached bug index 126\n");
+			}
+			if ((!FIXREVERTER[126] && (random_len != 32 ))
+			#else
+			if (0
+			#endif
+			) {
 				SCTPDBG(SCTP_DEBUG_AUTH1, "SCTP: invalid RANDOM len\n");
 				return (-27);
 			}
+			#ifdef FRCOV
+			}
+			#endif
 			got_random = 1;
 		} else if (ptype == SCTP_HMAC_LIST) {
 			uint16_t num_hmacs;
 			uint16_t i;
 
-			if (plen > sizeof(hmacs_store))
+			
+			#ifdef FRCOV
+			{if (FIXREVERTER[127]) {
+			  if ((plen > sizeof ( hmacs_store ) ) && !(0))
+			    fprintf(stderr, "triggered bug index 127\n");
+			  else
+			    fprintf(stderr, "reached bug index 127\n");
+			}
+			if ((!FIXREVERTER[127] && (plen > sizeof ( hmacs_store ) ))
+			#else
+			if (0
+			#endif
+			)
 				break;
+				#ifdef FRCOV
+				}
+				#endif
 			if (got_hmacs) {
 				/* already processed a HMAC list */
 				goto next_param;
@@ -7596,8 +8395,23 @@ sctp_load_addresses_from_init(struct sctp_tcb *stcb, struct mbuf *m,
 			phdr = sctp_get_next_param(m, offset,
 						   (struct sctp_paramhdr *)hmacs_store,
 						   plen);
-			if (phdr == NULL)
+			
+			#ifdef FRCOV
+			{if (FIXREVERTER[128]) {
+			  if ((phdr == (void *) 0 ) && !(0))
+			    fprintf(stderr, "triggered bug index 128\n");
+			  else
+			    fprintf(stderr, "reached bug index 128\n");
+			}
+			if ((!FIXREVERTER[128] && (phdr == (void *) 0 ))
+			#else
+			if (0
+			#endif
+			)
 				return (-28);
+				#ifdef FRCOV
+				}
+				#endif
 			hmacs = (struct sctp_auth_hmac_algo *)phdr;
 			hmacs_len = plen - sizeof(*hmacs);
 			num_hmacs = hmacs_len / sizeof(hmacs->hmac_ids[0]);
@@ -7618,8 +8432,23 @@ sctp_load_addresses_from_init(struct sctp_tcb *stcb, struct mbuf *m,
 		} else if (ptype == SCTP_CHUNK_LIST) {
 			int i;
 
-			if (plen > sizeof(chunks_store))
+			
+			#ifdef FRCOV
+			{if (FIXREVERTER[129]) {
+			  if ((plen > sizeof ( chunks_store ) ) && !(0))
+			    fprintf(stderr, "triggered bug index 129\n");
+			  else
+			    fprintf(stderr, "reached bug index 129\n");
+			}
+			if ((!FIXREVERTER[129] && (plen > sizeof ( chunks_store ) ))
+			#else
+			if (0
+			#endif
+			)
 				break;
+				#ifdef FRCOV
+				}
+				#endif
 			if (got_chklist) {
 				/* already processed a Chunks list */
 				goto next_param;
@@ -7627,8 +8456,23 @@ sctp_load_addresses_from_init(struct sctp_tcb *stcb, struct mbuf *m,
 			phdr = sctp_get_next_param(m, offset,
 						   (struct sctp_paramhdr *)chunks_store,
 						   plen);
-			if (phdr == NULL)
+			
+			#ifdef FRCOV
+			{if (FIXREVERTER[130]) {
+			  if ((phdr == (void *) 0 ) && !(0))
+			    fprintf(stderr, "triggered bug index 130\n");
+			  else
+			    fprintf(stderr, "reached bug index 130\n");
+			}
+			if ((!FIXREVERTER[130] && (phdr == (void *) 0 ))
+			#else
+			if (0
+			#endif
+			)
 				return (-30);
+				#ifdef FRCOV
+				}
+				#endif
 			chunks = (struct sctp_auth_chunk_list *)phdr;
 			num_chunks = plen - sizeof(*chunks);
 			if (stcb->asoc.peer_auth_chunks != NULL)
@@ -7671,9 +8515,24 @@ sctp_load_addresses_from_init(struct sctp_tcb *stcb, struct mbuf *m,
 
 	next_param:
 		offset += SCTP_SIZE32(plen);
-		if (offset >= limit) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[131]) {
+		  if ((offset >= limit ) && !(0))
+		    fprintf(stderr, "triggered bug index 131\n");
+		  else
+		    fprintf(stderr, "reached bug index 131\n");
+		}
+		if ((!FIXREVERTER[131] && (offset >= limit ))
+		#else
+		if (0
+		#endif
+		) {
 			break;
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		phdr = sctp_get_next_param(m, offset, &param_buf,
 					   sizeof(param_buf));
 	}
@@ -7845,9 +8704,24 @@ sctp_is_vtag_good(uint32_t tag, uint16_t lport, uint16_t rport, struct timeval *
 		}
 		if (stcb->asoc.my_vtag == tag) {
 			/* candidate */
-			if (stcb->rport != rport) {
+			
+			#ifdef FRCOV
+			{if (FIXREVERTER[132]) {
+			  if ((stcb -> rport != rport ) && !(0))
+			    fprintf(stderr, "triggered bug index 132\n");
+			  else
+			    fprintf(stderr, "reached bug index 132\n");
+			}
+			if ((!FIXREVERTER[132] && (stcb -> rport != rport ))
+			#else
+			if (0
+			#endif
+			) {
 				continue;
 			}
+			#ifdef FRCOV
+			}
+			#endif
 			if (stcb->sctp_ep->sctp_lport != lport) {
 				continue;
 			}
@@ -8168,9 +9042,24 @@ sctp_initiate_iterator(inp_func inpf,
 {
 	struct sctp_iterator *it = NULL;
 
-	if (af == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[134]) {
+	  if ((af == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 134\n");
+	  else
+	    fprintf(stderr, "reached bug index 134\n");
+	}
+	if ((!FIXREVERTER[134] && (af == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		return (-1);
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	if (SCTP_BASE_VAR(sctp_pcb_initialized) == 0) {
 		SCTP_PRINTF("%s: abort on initialize being %d\n", __func__,
 		            SCTP_BASE_VAR(sctp_pcb_initialized));
@@ -8178,10 +9067,25 @@ sctp_initiate_iterator(inp_func inpf,
 	}
 	SCTP_MALLOC(it, struct sctp_iterator *, sizeof(struct sctp_iterator),
 		    SCTP_M_ITER);
-	if (it == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[135]) {
+	  if ((it == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 135\n");
+	  else
+	    fprintf(stderr, "reached bug index 135\n");
+	}
+	if ((!FIXREVERTER[135] && (it == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		SCTP_LTRACE_ERR_RET(NULL, NULL, NULL, SCTP_FROM_SCTP_PCB, ENOMEM);
 		return (ENOMEM);
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	memset(it, 0, sizeof(*it));
 	it->function_assoc = af;
 	it->function_inp = inpf;
diff --git a/usrsctplib/netinet/sctp_timer.c b/usrsctplib/netinet/sctp_timer.c
index 98fafec1..f31ca416 100755
--- a/usrsctplib/netinet/sctp_timer.c
+++ b/usrsctplib/netinet/sctp_timer.c
@@ -1,3 +1,7 @@
+#ifdef FRCOV
+#include <stdio.h>
+extern short FIXREVERTER[];
+#endif
 /*-
  * SPDX-License-Identifier: BSD-3-Clause
  *
@@ -116,8 +120,22 @@ sctp_threshold_management(struct sctp_inpcb *inp, struct sctp_tcb *stcb,
 				    stcb, 0,
 				    (void *)net, SCTP_SO_NOT_LOCKED);
 			}
-		} else if ((net->pf_threshold < net->failure_threshold) &&
-		           (net->error_count > net->pf_threshold)) {
+		} else 
+		#ifdef FRCOV
+		{if (FIXREVERTER[377]) {
+		  fprintf(stderr, "reached bug index 377\n");
+		}
+		if ((FIXREVERTER[377] && (net -> pf_threshold < net -> failure_threshold )) || (!FIXREVERTER[377] && (net -> pf_threshold < net -> failure_threshold && net -> error_count > net -> pf_threshold ))
+		#else
+		if (net -> pf_threshold < net -> failure_threshold 
+		#endif
+		) {
+		             
+		           #ifdef FRCOV
+		             if (!(net -> error_count > net -> pf_threshold ))
+		               fprintf(stderr, "triggered bug index 377\n");
+		             #endif
+		           
 			if (!(net->dest_state & SCTP_ADDR_PF)) {
 				net->dest_state |= SCTP_ADDR_PF;
 				net->last_active = sctp_get_tick_count();
@@ -128,9 +146,27 @@ sctp_threshold_management(struct sctp_inpcb *inp, struct sctp_tcb *stcb,
 				sctp_timer_start(SCTP_TIMER_TYPE_HEARTBEAT, inp, stcb, net);
 			}
 		}
-	}
-	if (stcb == NULL)
+		#ifdef FRCOV
+		}
+		#endif
+	}
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[378]) {
+	  if ((stcb == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 378\n");
+	  else
+	    fprintf(stderr, "reached bug index 378\n");
+	}
+	if ((!FIXREVERTER[378] && (stcb == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	)
 		return (0);
+		#ifdef FRCOV
+		}
+		#endif
 
 	if (net) {
 		if ((net->dest_state & SCTP_ADDR_UNCONFIRMED) == 0) {
@@ -228,11 +264,28 @@ sctp_find_alternate_net(struct sctp_tcb *stcb,
 					} else if (mnet->error_count + 1 < min_errors) {
 						min_errors = mnet->error_count + 1;
 						min_errors_net = mnet;
-					} else if (mnet->error_count + 1 == min_errors
-								&& mnet->last_active > min_errors_net->last_active) {
+					} else 
+					#ifdef FRCOV
+					{if (FIXREVERTER[379]) {
+					  fprintf(stderr, "reached bug index 379\n");
+					}
+					if ((FIXREVERTER[379] && (mnet -> error_count + 1 == min_errors )) || (!FIXREVERTER[379] && (mnet -> error_count + 1 == min_errors && mnet -> last_active > min_errors_net -> last_active ))
+					#else
+					if (mnet -> error_count + 1 == min_errors 
+					#endif
+					) {
+								  
+								#ifdef FRCOV
+								  if (!(mnet -> last_active > min_errors_net -> last_active ))
+								    fprintf(stderr, "triggered bug index 379\n");
+								  #endif
+								
 						min_errors_net = mnet;
 						min_errors = mnet->error_count + 1;
 					}
+					#ifdef FRCOV
+					}
+					#endif
 					continue;
 				} else {
 					if (min_errors == -1) {
@@ -241,11 +294,28 @@ sctp_find_alternate_net(struct sctp_tcb *stcb,
 					} else if (mnet->error_count < min_errors) {
 						min_errors = mnet->error_count;
 						min_errors_net = mnet;
-					} else if (mnet->error_count == min_errors
-								&& mnet->last_active > min_errors_net->last_active) {
+					} else 
+					#ifdef FRCOV
+					{if (FIXREVERTER[380]) {
+					  fprintf(stderr, "reached bug index 380\n");
+					}
+					if ((FIXREVERTER[380] && (mnet -> error_count == min_errors )) || (!FIXREVERTER[380] && (mnet -> error_count == min_errors && mnet -> last_active > min_errors_net -> last_active ))
+					#else
+					if (mnet -> error_count == min_errors 
+					#endif
+					) {
+								  
+								#ifdef FRCOV
+								  if (!(mnet -> last_active > min_errors_net -> last_active ))
+								    fprintf(stderr, "triggered bug index 380\n");
+								  #endif
+								
 						min_errors_net = mnet;
 						min_errors = mnet->error_count;
 					}
+					#ifdef FRCOV
+					}
+					#endif
 					continue;
 				}
 			}
@@ -280,9 +350,24 @@ sctp_find_alternate_net(struct sctp_tcb *stcb,
 			}
 		}
 		if (max_cwnd_net == NULL) {
-			if (min_errors_net == NULL) {
+			
+			#ifdef FRCOV
+			{if (FIXREVERTER[381]) {
+			  if ((min_errors_net == (void *) 0 ) && !(0))
+			    fprintf(stderr, "triggered bug index 381\n");
+			  else
+			    fprintf(stderr, "reached bug index 381\n");
+			}
+			if ((!FIXREVERTER[381] && (min_errors_net == (void *) 0 ))
+			#else
+			if (0
+			#endif
+			) {
 				return (net);
 			}
+			#ifdef FRCOV
+			}
+			#endif
 			return (min_errors_net);
 		} else {
 			return (max_cwnd_net);
@@ -332,9 +417,24 @@ sctp_find_alternate_net(struct sctp_tcb *stcb,
 
 	if (mnet == NULL) {
 		mnet = TAILQ_FIRST(&stcb->asoc.nets);
-		if (mnet == NULL) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[382]) {
+		  if ((mnet == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 382\n");
+		  else
+		    fprintf(stderr, "reached bug index 382\n");
+		}
+		if ((!FIXREVERTER[382] && (mnet == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		) {
 			return (NULL);
 		}
+		#ifdef FRCOV
+		}
+		#endif
 	}
 	for (;;) {
 		alt = TAILQ_NEXT(mnet, sctp_next);
@@ -344,9 +444,24 @@ sctp_find_alternate_net(struct sctp_tcb *stcb,
 				break;
 			}
 			alt = TAILQ_FIRST(&stcb->asoc.nets);
-			if (alt == NULL) {
+			
+			#ifdef FRCOV
+			{if (FIXREVERTER[384]) {
+			  if ((alt == (void *) 0 ) && !(0))
+			    fprintf(stderr, "triggered bug index 384\n");
+			  else
+			    fprintf(stderr, "reached bug index 384\n");
+			}
+			if ((!FIXREVERTER[384] && (alt == (void *) 0 ))
+			#else
+			if (0
+			#endif
+			) {
 				return (NULL);
 			}
+			#ifdef FRCOV
+			}
+			#endif
 		}
 		if (alt->ro.ro_rt == NULL) {
 			if (alt->ro._s_addr) {
@@ -370,9 +485,24 @@ sctp_find_alternate_net(struct sctp_tcb *stcb,
 		once = 0;
 		mnet = net;
 		for (;;) {
-			if (mnet == NULL) {
+			
+			#ifdef FRCOV
+			{if (FIXREVERTER[385]) {
+			  if ((mnet == (void *) 0 ) && !(0))
+			    fprintf(stderr, "triggered bug index 385\n");
+			  else
+			    fprintf(stderr, "reached bug index 385\n");
+			}
+			if ((!FIXREVERTER[385] && (mnet == (void *) 0 ))
+			#else
+			if (0
+			#endif
+			) {
 				return (TAILQ_FIRST(&stcb->asoc.nets));
 			}
+			#ifdef FRCOV
+			}
+			#endif
 			alt = TAILQ_NEXT(mnet, sctp_next);
 			if (alt == NULL) {
 				once++;
@@ -380,9 +510,24 @@ sctp_find_alternate_net(struct sctp_tcb *stcb,
 					break;
 				}
 				alt = TAILQ_FIRST(&stcb->asoc.nets);
-				if (alt == NULL) {
+				
+				#ifdef FRCOV
+				{if (FIXREVERTER[387]) {
+				  if ((alt == (void *) 0 ) && !(0))
+				    fprintf(stderr, "triggered bug index 387\n");
+				  else
+				    fprintf(stderr, "reached bug index 387\n");
+				}
+				if ((!FIXREVERTER[387] && (alt == (void *) 0 ))
+				#else
+				if (0
+				#endif
+				) {
 					break;
 				}
+				#ifdef FRCOV
+				}
+				#endif
 			}
 			if ((!(alt->dest_state & SCTP_ADDR_UNCONFIRMED)) &&
 			    (alt != net)) {
@@ -392,9 +537,24 @@ sctp_find_alternate_net(struct sctp_tcb *stcb,
 			mnet = alt;
 		}
 	}
-	if (alt == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[388]) {
+	  if ((alt == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 388\n");
+	  else
+	    fprintf(stderr, "reached bug index 388\n");
+	}
+	if ((!FIXREVERTER[388] && (alt == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		return (net);
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	return (alt);
 }
 
@@ -1056,7 +1216,19 @@ sctp_cookie_timer(struct sctp_inpcb *inp,
 			break;
 		}
 	}
-	if (cookie == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[389]) {
+	  if ((cookie == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 389\n");
+	  else
+	    fprintf(stderr, "reached bug index 389\n");
+	}
+	if ((!FIXREVERTER[389] && (cookie == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		if (SCTP_GET_STATE(stcb) == SCTP_STATE_COOKIE_ECHOED) {
 			/* FOOBAR! */
 			struct mbuf *op_err;
@@ -1075,6 +1247,9 @@ sctp_cookie_timer(struct sctp_inpcb *inp,
 		}
 		return (0);
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	/* Ok we found the cookie, threshold management next */
 	if (sctp_threshold_management(inp, stcb, cookie->whoTo,
 	    stcb->asoc.max_init_times)) {
@@ -1119,9 +1294,24 @@ sctp_strreset_timer(struct sctp_inpcb *inp, struct sctp_tcb *stcb,
 	}
 	/* find the existing STRRESET, we use the seq number we sent out on */
 	(void)sctp_find_stream_reset(stcb, stcb->asoc.str_reset_seq_out, &strrst);
-	if (strrst == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[390]) {
+	  if ((strrst == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 390\n");
+	  else
+	    fprintf(stderr, "reached bug index 390\n");
+	}
+	if ((!FIXREVERTER[390] && (strrst == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		return (0);
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	/* do threshold management */
 	if (sctp_threshold_management(inp, stcb, strrst->whoTo,
 	    stcb->asoc.max_send_times)) {
@@ -1188,9 +1378,24 @@ sctp_asconf_timer(struct sctp_inpcb *inp, struct sctp_tcb *stcb,
 
 		/* find the existing ASCONF */
 		asconf = TAILQ_FIRST(&stcb->asoc.asconf_send_queue);
-		if (asconf == NULL) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[391]) {
+		  if ((asconf == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 391\n");
+		  else
+		    fprintf(stderr, "reached bug index 391\n");
+		}
+		if ((!FIXREVERTER[391] && (asconf == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		) {
 			return (0);
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		/* do threshold management */
 		if (sctp_threshold_management(inp, stcb, asconf->whoTo,
 		    stcb->asoc.max_send_times)) {
@@ -1240,8 +1445,25 @@ sctp_asconf_timer(struct sctp_inpcb *inp, struct sctp_tcb *stcb,
 				chk->whoTo = alt;
 				atomic_add_int(&alt->ref_count, 1);
 			}
-			if (asconf->sent != SCTP_DATAGRAM_RESEND && chk->sent != SCTP_DATAGRAM_UNSENT)
-				sctp_ucount_incr(stcb->asoc.sent_queue_retran_cnt);
+			
+			#ifdef FRCOV
+			{if (FIXREVERTER[392]) {
+			  fprintf(stderr, "reached bug index 392\n");
+			}
+			if ((FIXREVERTER[392] && (asconf -> sent != 4 )) || (!FIXREVERTER[392] && (asconf -> sent != 4 && chk -> sent != 0 ))
+			#else
+			if (asconf -> sent != 4 
+			#endif
+			)
+				 
+			#ifdef FRCOV
+			  {if (!(chk -> sent != 0 ))
+			    fprintf(stderr, "triggered bug index 392\n");
+			  #endif
+			sctp_ucount_incr(stcb->asoc.sent_queue_retran_cnt);
+			#ifdef FRCOV
+			}}
+			#endif
 			chk->sent = SCTP_DATAGRAM_RESEND;
 			chk->flags |= CHUNK_FLAGS_FRAGMENT_OK;
 		}
@@ -1344,8 +1566,23 @@ sctp_audit_stream_queues_for_size(struct sctp_inpcb *inp,
 	/*
 	 * This function is ONLY called when the send/sent queues are empty.
 	 */
-	if ((stcb == NULL) || (inp == NULL))
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[393]) {
+	  if ((stcb == (void *) 0 || inp == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 393\n");
+	  else
+	    fprintf(stderr, "reached bug index 393\n");
+	}
+	if ((!FIXREVERTER[393] && (stcb == (void *) 0 || inp == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	)
 		return;
+		#ifdef FRCOV
+		}
+		#endif
 
 	if (stcb->asoc.sent_queue_retran_cnt) {
 		SCTP_PRINTF("Hmm, sent_queue_retran_cnt is non-zero %d\n",
@@ -1474,7 +1711,22 @@ sctp_pathmtu_timer(struct sctp_inpcb *inp,
 
 	next_mtu = sctp_get_next_mtu(net->mtu);
 
-	if ((next_mtu > net->mtu) && (net->port == 0)) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[394]) {
+	  fprintf(stderr, "reached bug index 394\n");
+	}
+	if ((FIXREVERTER[394] && (next_mtu > net -> mtu )) || (!FIXREVERTER[394] && (next_mtu > net -> mtu && net -> port == 0 ))
+	#else
+	if (next_mtu > net -> mtu 
+	#endif
+	) {
+	  
+	#ifdef FRCOV
+	  if (!(net -> port == 0 ))
+	    fprintf(stderr, "triggered bug index 394\n");
+	  #endif
+	
 		if ((net->src_addr_selected == 0) ||
 		    (net->ro._s_addr == NULL) ||
 		    (net->ro._s_addr->localifa_flags & SCTP_BEING_DELETED)) {
@@ -1533,6 +1785,9 @@ sctp_pathmtu_timer(struct sctp_inpcb *inp,
 			}
 		}
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	/* restart the timer */
 	sctp_timer_start(SCTP_TIMER_TYPE_PATHMTURAISE, inp, stcb, net);
 }
diff --git a/usrsctplib/netinet/sctp_usrreq.c b/usrsctplib/netinet/sctp_usrreq.c
index dd5929dc..119d5795 100755
--- a/usrsctplib/netinet/sctp_usrreq.c
+++ b/usrsctplib/netinet/sctp_usrreq.c
@@ -1,3 +1,7 @@
+#ifdef FRCOV
+#include <stdio.h>
+extern short FIXREVERTER[];
+#endif
 /*-
  * SPDX-License-Identifier: BSD-3-Clause
  *
@@ -677,7 +681,19 @@ sctp_abort(struct socket *so)
 	uint32_t flags;
 
 	inp = (struct sctp_inpcb *)so->so_pcb;
-	if (inp == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[685]) {
+	  if ((inp == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 685\n");
+	  else
+	    fprintf(stderr, "reached bug index 685\n");
+	}
+	if ((!FIXREVERTER[685] && (inp == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 #if defined(__FreeBSD__) && __FreeBSD_version > 690000
 		return;
 #else
@@ -685,6 +701,9 @@ sctp_abort(struct socket *so)
 		return (EINVAL);
 #endif
 	}
+	#ifdef FRCOV
+	}
+	#endif
 
  sctp_must_try_again:
 	flags = inp->sctp_flags;
@@ -796,20 +815,50 @@ sctp_bind(struct socket *so, struct mbuf *nam, struct proc *p)
 	struct sctp_inpcb *inp;
 
 	inp = (struct sctp_inpcb *)so->so_pcb;
-	if (inp == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[686]) {
+	  if ((inp == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 686\n");
+	  else
+	    fprintf(stderr, "reached bug index 686\n");
+	}
+	if ((!FIXREVERTER[686] && (inp == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		SCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_USRREQ, EINVAL);
 		return (EINVAL);
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	if (addr != NULL) {
 #ifdef HAVE_SA_LEN
 		if ((addr->sa_family != AF_INET) ||
 		    (addr->sa_len != sizeof(struct sockaddr_in))) {
 #else
-		if (addr->sa_family != AF_INET) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[687]) {
+		  if ((addr -> sa_family != 2 ) && !(0))
+		    fprintf(stderr, "triggered bug index 687\n");
+		  else
+		    fprintf(stderr, "reached bug index 687\n");
+		}
+		if ((!FIXREVERTER[687] && (addr -> sa_family != 2 ))
+		#else
+		if (0
+		#endif
+		) {
 #endif
 			SCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_USRREQ, EINVAL);
 			return (EINVAL);
 		}
+		#ifdef FRCOV
+		}
+		#endif
 	}
 	return (sctp_inpcb_bind(so, addr, NULL, p));
 }
@@ -856,20 +905,50 @@ sctpconn_bind(struct socket *so, struct sockaddr *addr)
 	struct sctp_inpcb *inp;
 
 	inp = (struct sctp_inpcb *)so->so_pcb;
-	if (inp == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[688]) {
+	  if ((inp == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 688\n");
+	  else
+	    fprintf(stderr, "reached bug index 688\n");
+	}
+	if ((!FIXREVERTER[688] && (inp == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		SCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_USRREQ, EINVAL);
 		return (EINVAL);
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	if (addr != NULL) {
 #ifdef HAVE_SA_LEN
 		if ((addr->sa_family != AF_CONN) ||
 		    (addr->sa_len != sizeof(struct sockaddr_conn))) {
 #else
-		if (addr->sa_family != AF_CONN) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[689]) {
+		  if ((addr -> sa_family != 123 ) && !(0))
+		    fprintf(stderr, "triggered bug index 689\n");
+		  else
+		    fprintf(stderr, "reached bug index 689\n");
+		}
+		if ((!FIXREVERTER[689] && (addr -> sa_family != 123 ))
+		#else
+		if (0
+		#endif
+		) {
 #endif
 			SCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_USRREQ, EINVAL);
 			return (EINVAL);
 		}
+		#ifdef FRCOV
+		}
+		#endif
 	}
 	return (sctp_inpcb_bind(so, addr, NULL, NULL));
 }
@@ -883,8 +962,23 @@ sctp_close(struct socket *so)
 	uint32_t flags;
 
 	inp = (struct sctp_inpcb *)so->so_pcb;
-	if (inp == NULL)
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[690]) {
+	  if ((inp == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 690\n");
+	  else
+	    fprintf(stderr, "reached bug index 690\n");
+	}
+	if ((!FIXREVERTER[690] && (inp == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	)
 		return;
+		#ifdef FRCOV
+		}
+		#endif
 
 	/* Inform all the lower layer assoc that we
 	 * are done.
@@ -1126,10 +1220,25 @@ sctp_disconnect(struct socket *so)
 	struct sctp_inpcb *inp;
 
 	inp = (struct sctp_inpcb *)so->so_pcb;
-	if (inp == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[691]) {
+	  if ((inp == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 691\n");
+	  else
+	    fprintf(stderr, "reached bug index 691\n");
+	}
+	if ((!FIXREVERTER[691] && (inp == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		SCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_USRREQ, ENOTCONN);
 		return (ENOTCONN);
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	SCTP_INP_RLOCK(inp);
 	if ((inp->sctp_flags & SCTP_PCB_FLAGS_TCPTYPE) ||
 	    (inp->sctp_flags & SCTP_PCB_FLAGS_IN_TCPPOOL)) {
@@ -1142,11 +1251,26 @@ sctp_disconnect(struct socket *so)
 			struct sctp_tcb *stcb;
 
 			stcb = LIST_FIRST(&inp->sctp_asoc_list);
-			if (stcb == NULL) {
+			
+			#ifdef FRCOV
+			{if (FIXREVERTER[692]) {
+			  if ((stcb == (void *) 0 ) && !(0))
+			    fprintf(stderr, "triggered bug index 692\n");
+			  else
+			    fprintf(stderr, "reached bug index 692\n");
+			}
+			if ((!FIXREVERTER[692] && (stcb == (void *) 0 ))
+			#else
+			if (0
+			#endif
+			) {
 				SCTP_INP_RUNLOCK(inp);
 				SCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_USRREQ, EINVAL);
 				return (EINVAL);
 			}
+			#ifdef FRCOV
+			}
+			#endif
 			SCTP_TCB_LOCK(stcb);
 			asoc = &stcb->asoc;
 			if (stcb->asoc.state & SCTP_STATE_ABOUT_TO_BE_FREED) {
@@ -1580,9 +1704,24 @@ sctp_fill_up_addresses_vrf(struct sctp_inpcb *inp,
 		}
 	}
 	vrf = sctp_find_vrf(vrf_id);
-	if (vrf == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[697]) {
+	  if ((vrf == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 697\n");
+	  else
+	    fprintf(stderr, "reached bug index 697\n");
+	}
+	if ((!FIXREVERTER[697] && (vrf == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		return (0);
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	if (inp->sctp_flags & SCTP_PCB_FLAGS_BOUNDALL) {
 		LIST_FOREACH(sctp_ifn, &vrf->ifnlist, next_ifn) {
 			if ((loopback_scope == 0) &&
@@ -1777,9 +1916,24 @@ sctp_fill_up_addresses_vrf(struct sctp_inpcb *inp,
 				break;
 			}
 #endif
-			if (actual + sa_len > limit) {
+			
+			#ifdef FRCOV
+			{if (FIXREVERTER[699]) {
+			  if ((actual + sa_len > limit ) && !(0))
+			    fprintf(stderr, "triggered bug index 699\n");
+			  else
+			    fprintf(stderr, "reached bug index 699\n");
+			}
+			if ((!FIXREVERTER[699] && (actual + sa_len > limit ))
+			#else
+			if (0
+			#endif
+			) {
 				return (actual);
 			}
+			#ifdef FRCOV
+			}
+			#endif
 			if (sctp_fill_user_address(sas, &laddr->ifa->address.sa))
 				continue;
 			switch (laddr->ifa->address.sa.sa_family) {
@@ -1858,9 +2012,24 @@ sctp_count_max_addresses_vrf(struct sctp_inpcb *inp, uint32_t vrf_id)
 	 * addresses as well.
 	 */
 	vrf = sctp_find_vrf(vrf_id);
-	if (vrf == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[700]) {
+	  if ((vrf == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 700\n");
+	  else
+	    fprintf(stderr, "reached bug index 700\n");
+	}
+	if ((!FIXREVERTER[700] && (vrf == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		return (0);
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	if (inp->sctp_flags & SCTP_PCB_FLAGS_BOUNDALL) {
 		struct sctp_ifn *sctp_ifn;
 		struct sctp_ifa *sctp_ifa;
@@ -2057,10 +2226,25 @@ sctp_do_connect_x(struct socket *so, struct sctp_inpcb *inp, void *optval,
 	                       (struct proc *)p,
 #endif
 	                       SCTP_INITIALIZE_AUTH_PARAMS);
-	if (stcb == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[701]) {
+	  if ((stcb == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 701\n");
+	  else
+	    fprintf(stderr, "reached bug index 701\n");
+	}
+	if ((!FIXREVERTER[701] && (stcb == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		/* Gak! no memory */
 		goto out_now;
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	if (stcb->sctp_ep->sctp_flags & SCTP_PCB_FLAGS_TCPTYPE) {
 		stcb->sctp_ep->sctp_flags |= SCTP_PCB_FLAGS_CONNECTED;
 		/* Set the connected flag so we can queue data */
@@ -2152,16 +2336,46 @@ sctp_getopt(struct socket *so, int optname, void *optval, size_t *optsize,
 	int error, val = 0;
 	struct sctp_tcb *stcb = NULL;
 
-	if (optval == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[702]) {
+	  if ((optval == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 702\n");
+	  else
+	    fprintf(stderr, "reached bug index 702\n");
+	}
+	if ((!FIXREVERTER[702] && (optval == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		SCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_USRREQ, EINVAL);
 		return (EINVAL);
 	}
+	#ifdef FRCOV
+	}
+	#endif
 
 	inp = (struct sctp_inpcb *)so->so_pcb;
-	if (inp == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[703]) {
+	  if ((inp == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 703\n");
+	  else
+	    fprintf(stderr, "reached bug index 703\n");
+	}
+	if ((!FIXREVERTER[703] && (inp == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		SCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_USRREQ, EINVAL);
 		return EINVAL;
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	error = 0;
 
 	switch (optname) {
@@ -2501,11 +2715,26 @@ sctp_getopt(struct socket *so, int optname, void *optval, size_t *optsize,
 		LIST_FOREACH(stcb, &inp->sctp_asoc_list, sctp_tcblist) {
 			if (at < limit) {
 				ids->gaids_assoc_id[at++] = sctp_get_associd(stcb);
-				if (at == 0) {
+				
+				#ifdef FRCOV
+				{if (FIXREVERTER[704]) {
+				  if ((at == 0 ) && !(0))
+				    fprintf(stderr, "triggered bug index 704\n");
+				  else
+				    fprintf(stderr, "reached bug index 704\n");
+				}
+				if ((!FIXREVERTER[704] && (at == 0 ))
+				#else
+				if (0
+				#endif
+				) {
 					error = EINVAL;
 					SCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_USRREQ, error);
 					break;
 				}
+				#ifdef FRCOV
+				}
+				#endif
 			} else {
 				error = EINVAL;
 				SCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_USRREQ, error);
@@ -2914,13 +3143,43 @@ sctp_getopt(struct socket *so, int optname, void *optval, size_t *optsize,
 					cpsz = 0;
 					break;
 				}
-				if (cpsz == 0) {
+				
+				#ifdef FRCOV
+				{if (FIXREVERTER[705]) {
+				  if ((cpsz == 0 ) && !(0))
+				    fprintf(stderr, "triggered bug index 705\n");
+				  else
+				    fprintf(stderr, "reached bug index 705\n");
+				}
+				if ((!FIXREVERTER[705] && (cpsz == 0 ))
+				#else
+				if (0
+				#endif
+				) {
 					break;
 				}
-				if (left < cpsz) {
+				#ifdef FRCOV
+				}
+				#endif
+				
+				#ifdef FRCOV
+				{if (FIXREVERTER[706]) {
+				  if ((left < cpsz ) && !(0))
+				    fprintf(stderr, "triggered bug index 706\n");
+				  else
+				    fprintf(stderr, "reached bug index 706\n");
+				}
+				if ((!FIXREVERTER[706] && (left < cpsz ))
+				#else
+				if (0
+				#endif
+				) {
 					/* not enough room. */
 					break;
 				}
+				#ifdef FRCOV
+				}
+				#endif
 #if defined(INET) && defined(INET6)
 				if ((sctp_is_feature_on(inp, SCTP_PCB_FLAGS_NEEDS_MAPPED_V4)) &&
 				    (net->ro._l_addr.sa.sa_family == AF_INET)) {
@@ -3224,7 +3483,22 @@ sctp_getopt(struct socket *so, int optname, void *optval, size_t *optsize,
 			}
 		}
 
-		if ((stcb != NULL) && (net != NULL)) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[707]) {
+		  fprintf(stderr, "reached bug index 707\n");
+		}
+		if ((FIXREVERTER[707] && (stcb != (void *) 0 )) || (!FIXREVERTER[707] && (stcb != (void *) 0 && net != (void *) 0 ))
+		#else
+		if (stcb != (void *) 0 
+		#endif
+		) {
+		  
+		#ifdef FRCOV
+		  if (!(net != (void *) 0 ))
+		    fprintf(stderr, "triggered bug index 707\n");
+		  #endif
+		
 			if (net->dest_state & SCTP_ADDR_UNCONFIRMED) {
 				/* It's unconfirmed */
 				paddri->spinfo_state = SCTP_UNCONFIRMED;
@@ -3268,6 +3542,9 @@ sctp_getopt(struct socket *so, int optname, void *optval, size_t *optsize,
 			SCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_USRREQ, ENOENT);
 			error = ENOENT;
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		break;
 	}
 	case SCTP_PCB_STATUS:
@@ -3287,11 +3564,26 @@ sctp_getopt(struct socket *so, int optname, void *optval, size_t *optsize,
 		SCTP_CHECK_AND_CAST(sstat, optval, struct sctp_status, *optsize);
 		SCTP_FIND_STCB(inp, stcb, sstat->sstat_assoc_id);
 
-		if (stcb == NULL) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[708]) {
+		  if ((stcb == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 708\n");
+		  else
+		    fprintf(stderr, "reached bug index 708\n");
+		}
+		if ((!FIXREVERTER[708] && (stcb == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		) {
 			SCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_USRREQ, EINVAL);
 			error = EINVAL;
 			break;
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		sstat->sstat_state = sctp_map_assoc_state(stcb->asoc.state);
 		sstat->sstat_assoc_id = sctp_get_associd(stcb);
 		sstat->sstat_rwnd = stcb->asoc.peers_rwnd;
@@ -3559,12 +3851,27 @@ sctp_getopt(struct socket *so, int optname, void *optval, size_t *optsize,
 
 		SCTP_INP_RLOCK(inp);
 		hmaclist = inp->sctp_ep.local_hmacs;
-		if (hmaclist == NULL) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[709]) {
+		  if ((hmaclist == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 709\n");
+		  else
+		    fprintf(stderr, "reached bug index 709\n");
+		}
+		if ((!FIXREVERTER[709] && (hmaclist == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		) {
 			/* no HMACs to return */
 			*optsize = sizeof(*shmac);
 			SCTP_INP_RUNLOCK(inp);
 			break;
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		/* is there room for all of the hmac ids? */
 		size = sizeof(*shmac) + (hmaclist->num_algo *
 					 sizeof(shmac->shmac_idents[0]));
@@ -4472,15 +4779,45 @@ sctp_setopt(struct socket *so, int optname, void *optval, size_t optsize,
 	struct sctp_inpcb *inp = NULL;
 	uint32_t vrf_id;
 
-	if (optval == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[710]) {
+	  if ((optval == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 710\n");
+	  else
+	    fprintf(stderr, "reached bug index 710\n");
+	}
+	if ((!FIXREVERTER[710] && (optval == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		SCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_USRREQ, EINVAL);
 		return (EINVAL);
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	inp = (struct sctp_inpcb *)so->so_pcb;
-	if (inp == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[711]) {
+	  if ((inp == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 711\n");
+	  else
+	    fprintf(stderr, "reached bug index 711\n");
+	}
+	if ((!FIXREVERTER[711] && (inp == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		SCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_USRREQ, EINVAL);
 		return (EINVAL);
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	vrf_id = inp->def_vrf_id;
 
 	error = 0;
@@ -4653,11 +4990,26 @@ sctp_setopt(struct socket *so, int optname, void *optval, size_t optsize,
 			struct sctp_assoc_value *av;
 
 			SCTP_CHECK_AND_CAST(av, optval, struct sctp_assoc_value, optsize);
-			if (av->assoc_value > SCTP_CMT_MAX) {
+			
+			#ifdef FRCOV
+			{if (FIXREVERTER[712]) {
+			  if ((av -> assoc_value > 4 ) && !(0))
+			    fprintf(stderr, "triggered bug index 712\n");
+			  else
+			    fprintf(stderr, "reached bug index 712\n");
+			}
+			if ((!FIXREVERTER[712] && (av -> assoc_value > 4 ))
+			#else
+			if (0
+			#endif
+			) {
 				SCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_USRREQ, EINVAL);
 				error = EINVAL;
 				break;
 			}
+			#ifdef FRCOV
+			}
+			#endif
 			SCTP_FIND_STCB(inp, stcb, av->assoc_id);
 			if (stcb) {
 				stcb->asoc.sctp_cmt_on_off = av->assoc_value;
@@ -5038,8 +5390,23 @@ sctp_setopt(struct socket *so, int optname, void *optval, size_t optsize,
 		SCTP_CHECK_AND_CAST(sack, optval, struct sctp_sack_info, optsize);
 		SCTP_FIND_STCB(inp, stcb, sack->sack_assoc_id);
 		if (sack->sack_delay) {
-			if (sack->sack_delay > SCTP_MAX_SACK_DELAY)
+			
+			#ifdef FRCOV
+			{if (FIXREVERTER[713]) {
+			  if ((sack -> sack_delay > 500  ) && !(0))
+			    fprintf(stderr, "triggered bug index 713\n");
+			  else
+			    fprintf(stderr, "reached bug index 713\n");
+			}
+			if ((!FIXREVERTER[713] && (sack -> sack_delay > 500  ))
+			#else
+			if (0
+			#endif
+			)
 				sack->sack_delay = SCTP_MAX_SACK_DELAY;
+				#ifdef FRCOV
+				}
+				#endif
 			if (MSEC_TO_TICKS(sack->sack_delay) < 1) {
 				sack->sack_delay = TICKS_TO_MSEC(1);
 			}
@@ -5203,17 +5570,47 @@ sctp_setopt(struct socket *so, int optname, void *optval, size_t optsize,
 					 */
 					if (size > 0) {
 						key = sctp_set_key(sca->sca_key, (uint32_t) size);
-						if (key == NULL) {
+						
+						#ifdef FRCOV
+						{if (FIXREVERTER[714]) {
+						  if ((key == (void *) 0 ) && !(0))
+						    fprintf(stderr, "triggered bug index 714\n");
+						  else
+						    fprintf(stderr, "reached bug index 714\n");
+						}
+						if ((!FIXREVERTER[714] && (key == (void *) 0 ))
+						#else
+						if (0
+						#endif
+						) {
 							SCTP_TCB_UNLOCK(stcb);
 							continue;
 						}
+						#ifdef FRCOV
+						}
+						#endif
 					}
 					shared_key = sctp_alloc_sharedkey();
-					if (shared_key == NULL) {
+					
+					#ifdef FRCOV
+					{if (FIXREVERTER[715]) {
+					  if ((shared_key == (void *) 0 ) && !(0))
+					    fprintf(stderr, "triggered bug index 715\n");
+					  else
+					    fprintf(stderr, "reached bug index 715\n");
+					}
+					if ((!FIXREVERTER[715] && (shared_key == (void *) 0 ))
+					#else
+					if (0
+					#endif
+					) {
 						sctp_free_key(key);
 						SCTP_TCB_UNLOCK(stcb);
 						continue;
 					}
+					#ifdef FRCOV
+					}
+					#endif
 					shared_key->key = key;
 					shared_key->keyid = sca->sca_keynumber;
 					error = sctp_insert_sharedkey(shared_keys, shared_key);
@@ -5240,11 +5637,26 @@ sctp_setopt(struct socket *so, int optname, void *optval, size_t optsize,
 		}
 
 		hmaclist = sctp_alloc_hmaclist((uint16_t)shmac->shmac_number_of_idents);
-		if (hmaclist == NULL) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[716]) {
+		  if ((hmaclist == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 716\n");
+		  else
+		    fprintf(stderr, "reached bug index 716\n");
+		}
+		if ((!FIXREVERTER[716] && (hmaclist == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		) {
 			SCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_USRREQ, ENOMEM);
 			error = ENOMEM;
 			break;
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		for (i = 0; i < shmac->shmac_number_of_idents; i++) {
 			hmacid = shmac->shmac_idents[i];
 			if (sctp_auth_add_hmacid(hmaclist, hmacid)) {
@@ -5443,11 +5855,26 @@ sctp_setopt(struct socket *so, int optname, void *optval, size_t optsize,
 
 		SCTP_CHECK_AND_CAST(strrst, optval, struct sctp_reset_streams, optsize);
 		SCTP_FIND_STCB(inp, stcb, strrst->srs_assoc_id);
-		if (stcb == NULL) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[717]) {
+		  if ((stcb == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 717\n");
+		  else
+		    fprintf(stderr, "reached bug index 717\n");
+		}
+		if ((!FIXREVERTER[717] && (stcb == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		) {
 			SCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_USRREQ, ENOENT);
 			error = ENOENT;
 			break;
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		if (stcb->asoc.reconfig_supported == 0) {
 			/*
 			 * Peer does not support the chunk type.
@@ -5561,11 +5988,26 @@ sctp_setopt(struct socket *so, int optname, void *optval, size_t optsize,
 
 		SCTP_CHECK_AND_CAST(stradd, optval, struct sctp_add_streams, optsize);
 		SCTP_FIND_STCB(inp, stcb, stradd->sas_assoc_id);
-		if (stcb == NULL) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[718]) {
+		  if ((stcb == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 718\n");
+		  else
+		    fprintf(stderr, "reached bug index 718\n");
+		}
+		if ((!FIXREVERTER[718] && (stcb == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		) {
 			SCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_USRREQ, ENOENT);
 			error = ENOENT;
 			break;
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		if (stcb->asoc.reconfig_supported == 0) {
 			/*
 			 * Peer does not support the chunk type.
@@ -5634,11 +6076,26 @@ sctp_setopt(struct socket *so, int optname, void *optval, size_t optsize,
 
 		SCTP_CHECK_AND_CAST(value, optval, uint32_t, optsize);
 		SCTP_FIND_STCB(inp, stcb, (sctp_assoc_t) *value);
-		if (stcb == NULL) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[720]) {
+		  if ((stcb == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 720\n");
+		  else
+		    fprintf(stderr, "reached bug index 720\n");
+		}
+		if ((!FIXREVERTER[720] && (stcb == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		) {
 		        SCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_USRREQ, ENOENT);
 			error = ENOENT;
 			break;
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		if (stcb->asoc.reconfig_supported == 0) {
 			/*
 			 * Peer does not support the chunk type.
@@ -5723,11 +6180,26 @@ sctp_setopt(struct socket *so, int optname, void *optval, size_t optsize,
 			}
 		}
 
-		if (stcb == NULL) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[721]) {
+		  if ((stcb == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 721\n");
+		  else
+		    fprintf(stderr, "reached bug index 721\n");
+		}
+		if ((!FIXREVERTER[721] && (stcb == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		) {
 			SCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_USRREQ, ENOENT);
 			error = ENOENT;
 			break;
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		if (stcb->asoc.delayed_connection == 1) {
 			stcb->asoc.delayed_connection = 0;
 			(void)SCTP_GETTIME_TIMEVAL(&stcb->asoc.time_entered);
@@ -6215,8 +6687,22 @@ sctp_setopt(struct socket *so, int optname, void *optval, size_t optsize,
 							net->dest_state &= ~SCTP_ADDR_PF;
 						}
 					} else {
-						if ((net->error_count <= paddrp->spp_pathmaxrxt) &&
-						    (net->error_count > net->pf_threshold)) {
+						
+						#ifdef FRCOV
+						{if (FIXREVERTER[722]) {
+						  fprintf(stderr, "reached bug index 722\n");
+						}
+						if ((FIXREVERTER[722] && (net -> error_count <= paddrp -> spp_pathmaxrxt )) || (!FIXREVERTER[722] && (net -> error_count <= paddrp -> spp_pathmaxrxt && net -> error_count > net -> pf_threshold ))
+						#else
+						if (net -> error_count <= paddrp -> spp_pathmaxrxt 
+						#endif
+						) {
+						      
+						    #ifdef FRCOV
+						      if (!(net -> error_count > net -> pf_threshold ))
+						        fprintf(stderr, "triggered bug index 722\n");
+						      #endif
+						    
 							net->dest_state |= SCTP_ADDR_PF;
 							sctp_send_hb(stcb, net, SCTP_SO_LOCKED);
 							sctp_timer_stop(SCTP_TIMER_TYPE_HEARTBEAT,
@@ -6224,6 +6710,9 @@ sctp_setopt(struct socket *so, int optname, void *optval, size_t optsize,
 							                SCTP_FROM_SCTP_USRREQ + SCTP_LOC_12);
 							sctp_timer_start(SCTP_TIMER_TYPE_HEARTBEAT, stcb->sctp_ep, stcb, net);
 						}
+						#ifdef FRCOV
+						}
+						#endif
 					}
 					if (net->dest_state & SCTP_ADDR_REACHABLE) {
 						if (net->error_count > paddrp->spp_pathmaxrxt) {
@@ -6260,8 +6749,22 @@ sctp_setopt(struct socket *so, int optname, void *optval, size_t optsize,
 								net->dest_state &= ~SCTP_ADDR_PF;
 							}
 						} else {
-							if ((net->error_count <= paddrp->spp_pathmaxrxt) &&
-							    (net->error_count > net->pf_threshold)) {
+							
+							#ifdef FRCOV
+							{if (FIXREVERTER[723]) {
+							  fprintf(stderr, "reached bug index 723\n");
+							}
+							if ((FIXREVERTER[723] && (net -> error_count <= paddrp -> spp_pathmaxrxt )) || (!FIXREVERTER[723] && (net -> error_count <= paddrp -> spp_pathmaxrxt && net -> error_count > net -> pf_threshold ))
+							#else
+							if (net -> error_count <= paddrp -> spp_pathmaxrxt 
+							#endif
+							) {
+							      
+							    #ifdef FRCOV
+							      if (!(net -> error_count > net -> pf_threshold ))
+							        fprintf(stderr, "triggered bug index 723\n");
+							      #endif
+							    
 								net->dest_state |= SCTP_ADDR_PF;
 								sctp_send_hb(stcb, net, SCTP_SO_LOCKED);
 								sctp_timer_stop(SCTP_TIMER_TYPE_HEARTBEAT,
@@ -6269,6 +6772,9 @@ sctp_setopt(struct socket *so, int optname, void *optval, size_t optsize,
 								                SCTP_FROM_SCTP_USRREQ + SCTP_LOC_13);
 								sctp_timer_start(SCTP_TIMER_TYPE_HEARTBEAT, stcb->sctp_ep, stcb, net);
 							}
+							#ifdef FRCOV
+							}
+							#endif
 						}
 						if (net->dest_state & SCTP_ADDR_REACHABLE) {
 							if (net->error_count > paddrp->spp_pathmaxrxt) {
@@ -6403,8 +6909,23 @@ sctp_setopt(struct socket *so, int optname, void *optval, size_t optsize,
 				if (paddrp->spp_flags & SPP_HB_TIME_IS_ZERO)
 					inp->sctp_ep.sctp_timeoutticks[SCTP_TIMER_HEARTBEAT] = 0;
 				else if (paddrp->spp_hbinterval != 0) {
-					if (paddrp->spp_hbinterval > SCTP_MAX_HB_INTERVAL)
+					
+					#ifdef FRCOV
+					{if (FIXREVERTER[724]) {
+					  if ((paddrp -> spp_hbinterval > 14400000  ) && !(0))
+					    fprintf(stderr, "triggered bug index 724\n");
+					  else
+					    fprintf(stderr, "reached bug index 724\n");
+					}
+					if ((!FIXREVERTER[724] && (paddrp -> spp_hbinterval > 14400000  ))
+					#else
+					if (0
+					#endif
+					)
 						paddrp->spp_hbinterval= SCTP_MAX_HB_INTERVAL;
+						#ifdef FRCOV
+						}
+						#endif
 					inp->sctp_ep.sctp_timeoutticks[SCTP_TIMER_HEARTBEAT] = MSEC_TO_TICKS(paddrp->spp_hbinterval);
 				}
 
@@ -6468,7 +6989,22 @@ sctp_setopt(struct socket *so, int optname, void *optval, size_t optsize,
 				new_min = srto->srto_min;
 			else
 				new_min = stcb->asoc.minrto;
-			if ((new_min <= new_init) && (new_init <= new_max)) {
+			
+			#ifdef FRCOV
+			{if (FIXREVERTER[725]) {
+			  fprintf(stderr, "reached bug index 725\n");
+			}
+			if ((FIXREVERTER[725] && (new_min <= new_init )) || (!FIXREVERTER[725] && (new_min <= new_init && new_init <= new_max ))
+			#else
+			if (new_min <= new_init 
+			#endif
+			) {
+			  
+			#ifdef FRCOV
+			  if (!(new_init <= new_max ))
+			    fprintf(stderr, "triggered bug index 725\n");
+			  #endif
+			
 				stcb->asoc.initial_rto = new_init;
 				stcb->asoc.maxrto = new_max;
 				stcb->asoc.minrto = new_min;
@@ -6476,6 +7012,9 @@ sctp_setopt(struct socket *so, int optname, void *optval, size_t optsize,
 				SCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_USRREQ, EINVAL);
 				error = EINVAL;
 			}
+			#ifdef FRCOV
+			}
+			#endif
 			SCTP_TCB_UNLOCK(stcb);
 		} else {
 			if ((inp->sctp_flags & SCTP_PCB_FLAGS_TCPTYPE) ||
@@ -6494,7 +7033,22 @@ sctp_setopt(struct socket *so, int optname, void *optval, size_t optsize,
 					new_min = srto->srto_min;
 				else
 					new_min = inp->sctp_ep.sctp_minrto;
-				if ((new_min <= new_init) && (new_init <= new_max)) {
+				
+				#ifdef FRCOV
+				{if (FIXREVERTER[726]) {
+				  fprintf(stderr, "reached bug index 726\n");
+				}
+				if ((FIXREVERTER[726] && (new_min <= new_init )) || (!FIXREVERTER[726] && (new_min <= new_init && new_init <= new_max ))
+				#else
+				if (new_min <= new_init 
+				#endif
+				) {
+				  
+				#ifdef FRCOV
+				  if (!(new_init <= new_max ))
+				    fprintf(stderr, "triggered bug index 726\n");
+				  #endif
+				
 					inp->sctp_ep.initial_rto = new_init;
 					inp->sctp_ep.sctp_maxrto = new_max;
 					inp->sctp_ep.sctp_minrto = new_min;
@@ -6502,6 +7056,9 @@ sctp_setopt(struct socket *so, int optname, void *optval, size_t optsize,
 					SCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_USRREQ, EINVAL);
 					error = EINVAL;
 				}
+				#ifdef FRCOV
+				}
+				#endif
 				SCTP_INP_WUNLOCK(inp);
 			} else {
 				SCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_USRREQ, EINVAL);
@@ -6518,8 +7075,23 @@ sctp_setopt(struct socket *so, int optname, void *optval, size_t optsize,
 		SCTP_FIND_STCB(inp, stcb, sasoc->sasoc_assoc_id);
 		if (sasoc->sasoc_cookie_life) {
 			/* boundary check the cookie life */
-			if (sasoc->sasoc_cookie_life < 1000)
+			
+			#ifdef FRCOV
+			{if (FIXREVERTER[727]) {
+			  if ((sasoc -> sasoc_cookie_life < 1000  ) && !(0))
+			    fprintf(stderr, "triggered bug index 727\n");
+			  else
+			    fprintf(stderr, "reached bug index 727\n");
+			}
+			if ((!FIXREVERTER[727] && (sasoc -> sasoc_cookie_life < 1000  ))
+			#else
+			if (0
+			#endif
+			)
 				sasoc->sasoc_cookie_life = 1000;
+				#ifdef FRCOV
+				}
+				#endif
 			if (sasoc->sasoc_cookie_life > SCTP_MAX_COOKIE_LIFE) {
 				sasoc->sasoc_cookie_life = SCTP_MAX_COOKIE_LIFE;
 			}
@@ -6614,7 +7186,22 @@ sctp_setopt(struct socket *so, int optname, void *optval, size_t optsize,
 			}
 		}
 
-		if ((stcb != NULL) && (net != NULL)) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[728]) {
+		  fprintf(stderr, "reached bug index 728\n");
+		}
+		if ((FIXREVERTER[728] && (stcb != (void *) 0 )) || (!FIXREVERTER[728] && (stcb != (void *) 0 && net != (void *) 0 ))
+		#else
+		if (stcb != (void *) 0 
+		#endif
+		) {
+		  
+		#ifdef FRCOV
+		  if (!(net != (void *) 0 ))
+		    fprintf(stderr, "triggered bug index 728\n");
+		  #endif
+		
 			if (net != stcb->asoc.primary_destination) {
 				if (!(net->dest_state & SCTP_ADDR_UNCONFIRMED)) {
 					/* Ok we need to set it */
@@ -6638,6 +7225,9 @@ sctp_setopt(struct socket *so, int optname, void *optval, size_t optsize,
 			SCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_USRREQ, EINVAL);
 			error = EINVAL;
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		if (stcb != NULL) {
 			SCTP_TCB_UNLOCK(stcb);
 		}
@@ -6725,22 +7315,52 @@ sctp_setopt(struct socket *so, int optname, void *optval, size_t optsize,
 			addr = (struct sockaddr *)&sspp->sspp_addr;
 #endif
 			ifa = sctp_find_ifa_by_addr(addr, stcb->asoc.vrf_id, SCTP_ADDR_NOT_LOCKED);
-			if (ifa == NULL) {
+			
+			#ifdef FRCOV
+			{if (FIXREVERTER[729]) {
+			  if ((ifa == (void *) 0 ) && !(0))
+			    fprintf(stderr, "triggered bug index 729\n");
+			  else
+			    fprintf(stderr, "reached bug index 729\n");
+			}
+			if ((!FIXREVERTER[729] && (ifa == (void *) 0 ))
+			#else
+			if (0
+			#endif
+			) {
 				SCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_USRREQ, EINVAL);
 				error = EINVAL;
 				goto out_of_it;
 			}
+			#ifdef FRCOV
+			}
+			#endif
 			if ((inp->sctp_flags & SCTP_PCB_FLAGS_BOUNDALL) == 0) {
 				/* Must validate the ifa found is in our ep */
 				struct sctp_laddr *laddr;
 				int found = 0;
 
 				LIST_FOREACH(laddr, &inp->sctp_addr_list, sctp_nxt_addr) {
-					if (laddr->ifa == NULL) {
+					
+					#ifdef FRCOV
+					{if (FIXREVERTER[730]) {
+					  if ((laddr -> ifa == (void *) 0 ) && !(0))
+					    fprintf(stderr, "triggered bug index 730\n");
+					  else
+					    fprintf(stderr, "reached bug index 730\n");
+					}
+					if ((!FIXREVERTER[730] && (laddr -> ifa == (void *) 0 ))
+					#else
+					if (0
+					#endif
+					) {
 						SCTPDBG(SCTP_DEBUG_OUTPUT1, "%s: NULL ifa\n",
 							__func__);
 						continue;
 					}
+					#ifdef FRCOV
+					}
+					#endif
 					if ((sctp_is_addr_restricted(stcb, laddr->ifa)) &&
 					    (!sctp_is_addr_pending(stcb, laddr->ifa))) {
 						continue;
@@ -7282,8 +7902,22 @@ sctp_setopt(struct socket *so, int optname, void *optval, size_t optsize,
 						net->dest_state &= ~SCTP_ADDR_PF;
 					}
 				} else {
-					if ((net->error_count > net->pf_threshold) &&
-					    (net->error_count <= net->failure_threshold)) {
+					
+					#ifdef FRCOV
+					{if (FIXREVERTER[731]) {
+					  fprintf(stderr, "reached bug index 731\n");
+					}
+					if ((FIXREVERTER[731] && (net -> error_count > net -> pf_threshold )) || (!FIXREVERTER[731] && (net -> error_count > net -> pf_threshold && net -> error_count <= net -> failure_threshold ))
+					#else
+					if (net -> error_count > net -> pf_threshold 
+					#endif
+					) {
+					      
+					    #ifdef FRCOV
+					      if (!(net -> error_count <= net -> failure_threshold ))
+					        fprintf(stderr, "triggered bug index 731\n");
+					      #endif
+					    
 						net->dest_state |= SCTP_ADDR_PF;
 						sctp_send_hb(stcb, net, SCTP_SO_LOCKED);
 						sctp_timer_stop(SCTP_TIMER_TYPE_HEARTBEAT,
@@ -7291,6 +7925,9 @@ sctp_setopt(struct socket *so, int optname, void *optval, size_t optsize,
 						                SCTP_FROM_SCTP_USRREQ + SCTP_LOC_17);
 						sctp_timer_start(SCTP_TIMER_TYPE_HEARTBEAT, stcb->sctp_ep, stcb, net);
 					}
+					#ifdef FRCOV
+					}
+					#endif
 				}
 				if (net->dest_state & SCTP_ADDR_REACHABLE) {
 					if (net->error_count > net->failure_threshold) {
@@ -7313,8 +7950,22 @@ sctp_setopt(struct socket *so, int optname, void *optval, size_t optsize,
 							net->dest_state &= ~SCTP_ADDR_PF;
 						}
 					} else {
-						if ((net->error_count > net->pf_threshold) &&
-						    (net->error_count <= net->failure_threshold)) {
+						
+						#ifdef FRCOV
+						{if (FIXREVERTER[732]) {
+						  fprintf(stderr, "reached bug index 732\n");
+						}
+						if ((FIXREVERTER[732] && (net -> error_count > net -> pf_threshold )) || (!FIXREVERTER[732] && (net -> error_count > net -> pf_threshold && net -> error_count <= net -> failure_threshold ))
+						#else
+						if (net -> error_count > net -> pf_threshold 
+						#endif
+						) {
+						      
+						    #ifdef FRCOV
+						      if (!(net -> error_count <= net -> failure_threshold ))
+						        fprintf(stderr, "triggered bug index 732\n");
+						      #endif
+						    
 							net->dest_state |= SCTP_ADDR_PF;
 							sctp_send_hb(stcb, net, SCTP_SO_LOCKED);
 							sctp_timer_stop(SCTP_TIMER_TYPE_HEARTBEAT,
@@ -7322,6 +7973,9 @@ sctp_setopt(struct socket *so, int optname, void *optval, size_t optsize,
 							                SCTP_FROM_SCTP_USRREQ + SCTP_LOC_18);
 							sctp_timer_start(SCTP_TIMER_TYPE_HEARTBEAT, stcb->sctp_ep, stcb, net);
 						}
+						#ifdef FRCOV
+						}
+						#endif
 					}
 					if (net->dest_state & SCTP_ADDR_REACHABLE) {
 						if (net->error_count > net->failure_threshold) {
@@ -7853,15 +8507,45 @@ sctp_connect(struct socket *so, struct mbuf *nam, struct proc *p)
 	struct sctp_tcb *stcb = NULL;
 
 	inp = (struct sctp_inpcb *)so->so_pcb;
-	if (inp == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[733]) {
+	  if ((inp == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 733\n");
+	  else
+	    fprintf(stderr, "reached bug index 733\n");
+	}
+	if ((!FIXREVERTER[733] && (inp == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		/* I made the same as TCP since we are not setup? */
 		SCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_USRREQ, EINVAL);
 		return (ECONNRESET);
 	}
-	if (addr == NULL) {
+	#ifdef FRCOV
+	}
+	#endif
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[734]) {
+	  if ((addr == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 734\n");
+	  else
+	    fprintf(stderr, "reached bug index 734\n");
+	}
+	if ((!FIXREVERTER[734] && (addr == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		SCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_USRREQ, EINVAL);
 		return EINVAL;
 	}
+	#ifdef FRCOV
+	}
+	#endif
 
 #if defined(__Userspace__)
         /* TODO __Userspace__ falls into this code for IPv6 stuff at the moment... */
@@ -8010,10 +8694,25 @@ sctp_connect(struct socket *so, struct mbuf *nam, struct proc *p)
 	                       inp->sctp_ep.pre_open_stream_count,
 	                       inp->sctp_ep.port, p,
 	                       SCTP_INITIALIZE_AUTH_PARAMS);
-	if (stcb == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[735]) {
+	  if ((stcb == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 735\n");
+	  else
+	    fprintf(stderr, "reached bug index 735\n");
+	}
+	if ((!FIXREVERTER[735] && (stcb == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		/* Gak! no memory */
 		goto out_now;
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	if (stcb->sctp_ep->sctp_flags & SCTP_PCB_FLAGS_TCPTYPE) {
 		stcb->sctp_ep->sctp_flags |= SCTP_PCB_FLAGS_CONNECTED;
 		/* Set the connected flag so we can queue data */
@@ -8049,15 +8748,45 @@ sctpconn_connect(struct socket *so, struct sockaddr *addr)
 	struct sctp_tcb *stcb = NULL;
 
 	inp = (struct sctp_inpcb *)so->so_pcb;
-	if (inp == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[736]) {
+	  if ((inp == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 736\n");
+	  else
+	    fprintf(stderr, "reached bug index 736\n");
+	}
+	if ((!FIXREVERTER[736] && (inp == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		/* I made the same as TCP since we are not setup? */
 		SCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_USRREQ, EINVAL);
 		return (ECONNRESET);
 	}
-	if (addr == NULL) {
+	#ifdef FRCOV
+	}
+	#endif
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[737]) {
+	  if ((addr == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 737\n");
+	  else
+	    fprintf(stderr, "reached bug index 737\n");
+	}
+	if ((!FIXREVERTER[737] && (addr == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		SCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_USRREQ, EINVAL);
 		return EINVAL;
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	switch (addr->sa_family) {
 #ifdef INET
 	case AF_INET:
@@ -8175,10 +8904,25 @@ sctpconn_connect(struct socket *so, struct sockaddr *addr)
 	                       inp->sctp_ep.pre_open_stream_count,
 	                       inp->sctp_ep.port, p,
 	                       SCTP_INITIALIZE_AUTH_PARAMS);
-	if (stcb == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[738]) {
+	  if ((stcb == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 738\n");
+	  else
+	    fprintf(stderr, "reached bug index 738\n");
+	}
+	if ((!FIXREVERTER[738] && (stcb == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		/* Gak! no memory */
 		goto out_now;
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	if (stcb->sctp_ep->sctp_flags & SCTP_PCB_FLAGS_TCPTYPE) {
 		stcb->sctp_ep->sctp_flags |= SCTP_PCB_FLAGS_CONNECTED;
 		/* Set the connected flag so we can queue data */
@@ -9029,9 +9773,24 @@ register_recv_cb(struct socket *so,
 	struct sctp_inpcb *inp;
 
 	inp = (struct sctp_inpcb *) so->so_pcb;
-	if (inp == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[749]) {
+	  if ((inp == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 749\n");
+	  else
+	    fprintf(stderr, "reached bug index 749\n");
+	}
+	if ((!FIXREVERTER[749] && (inp == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		return (0);
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	SCTP_INP_WLOCK(inp);
 	inp->recv_callback = receive_cb;
 	SCTP_INP_WUNLOCK(inp);
@@ -9044,9 +9803,24 @@ register_send_cb(struct socket *so, uint32_t sb_threshold, int (*send_cb)(struct
 	struct sctp_inpcb *inp;
 
 	inp = (struct sctp_inpcb *) so->so_pcb;
-	if (inp == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[750]) {
+	  if ((inp == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 750\n");
+	  else
+	    fprintf(stderr, "reached bug index 750\n");
+	}
+	if ((!FIXREVERTER[750] && (inp == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		return (0);
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	SCTP_INP_WLOCK(inp);
 	inp->send_callback = send_cb;
 	inp->send_sb_threshold = sb_threshold;
@@ -9065,9 +9839,24 @@ register_ulp_info (struct socket *so, void *ulp_info)
 	struct sctp_inpcb *inp;
 
 	inp = (struct sctp_inpcb *) so->so_pcb;
-	if (inp == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[751]) {
+	  if ((inp == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 751\n");
+	  else
+	    fprintf(stderr, "reached bug index 751\n");
+	}
+	if ((!FIXREVERTER[751] && (inp == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		return (0);
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	SCTP_INP_WLOCK(inp);
 	inp->ulp_info = ulp_info;
 	SCTP_INP_WUNLOCK(inp);
diff --git a/usrsctplib/netinet/sctputil.c b/usrsctplib/netinet/sctputil.c
index a350574e..e7dec1ac 100755
--- a/usrsctplib/netinet/sctputil.c
+++ b/usrsctplib/netinet/sctputil.c
@@ -1,3 +1,7 @@
+#ifdef FRCOV
+#include <stdio.h>
+extern short FIXREVERTER[];
+#endif
 /*-
  * SPDX-License-Identifier: BSD-3-Clause
  *
@@ -974,10 +978,25 @@ sctp_select_a_tag(struct sctp_inpcb *inp, uint16_t lport, uint16_t rport, int ch
 	}
 	for (;;) {
 		x = sctp_select_initial_TSN(&inp->sctp_ep);
-		if (x == 0) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[408]) {
+		  if ((x == 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 408\n");
+		  else
+		    fprintf(stderr, "reached bug index 408\n");
+		}
+		if ((!FIXREVERTER[408] && (x == 0 ))
+		#else
+		if (0
+		#endif
+		) {
 			/* we never use 0 */
 			continue;
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		if (!check || sctp_is_vtag_good(x, lport, rport, &now)) {
 			break;
 		}
@@ -1208,11 +1227,26 @@ sctp_init_asoc(struct sctp_inpcb *inp, struct sctp_tcb *stcb,
 	SCTP_MALLOC(asoc->strmout, struct sctp_stream_out *,
 		    asoc->streamoutcnt * sizeof(struct sctp_stream_out),
 		    SCTP_M_STRMO);
-	if (asoc->strmout == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[409]) {
+	  if ((asoc -> strmout == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 409\n");
+	  else
+	    fprintf(stderr, "reached bug index 409\n");
+	}
+	if ((!FIXREVERTER[409] && (asoc -> strmout == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		/* big trouble no memory */
 		SCTP_LTRACE_ERR_RET(NULL, stcb, NULL, SCTP_FROM_SCTPUTIL, ENOMEM);
 		return (ENOMEM);
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	for (i = 0; i < asoc->streamoutcnt; i++) {
 		/*
 		 * inbound side must be set to 0xffff, also NOTE when we get
@@ -1246,11 +1280,26 @@ sctp_init_asoc(struct sctp_inpcb *inp, struct sctp_tcb *stcb,
 	asoc->mapping_array_size = SCTP_INITIAL_MAPPING_ARRAY;
 	SCTP_MALLOC(asoc->mapping_array, uint8_t *, asoc->mapping_array_size,
 		    SCTP_M_MAP);
-	if (asoc->mapping_array == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[410]) {
+	  if ((asoc -> mapping_array == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 410\n");
+	  else
+	    fprintf(stderr, "reached bug index 410\n");
+	}
+	if ((!FIXREVERTER[410] && (asoc -> mapping_array == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		SCTP_FREE(asoc->strmout, SCTP_M_STRMO);
 		SCTP_LTRACE_ERR_RET(NULL, stcb, NULL, SCTP_FROM_SCTPUTIL, ENOMEM);
 		return (ENOMEM);
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	memset(asoc->mapping_array, 0, asoc->mapping_array_size);
 	SCTP_MALLOC(asoc->nr_mapping_array, uint8_t *, asoc->mapping_array_size,
 	    SCTP_M_MAP);
@@ -1567,7 +1616,19 @@ sctp_handle_addr_wq(void)
 
 	SCTP_MALLOC(asc, struct sctp_asconf_iterator *,
 		    sizeof(struct sctp_asconf_iterator), SCTP_M_ASC_IT);
-	if (asc == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[414]) {
+	  if ((asc == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 414\n");
+	  else
+	    fprintf(stderr, "reached bug index 414\n");
+	}
+	if ((!FIXREVERTER[414] && (asc == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		/* Try later, no memory */
 		sctp_timer_start(SCTP_TIMER_TYPE_ADDR_WQ,
 				 (struct sctp_inpcb *)NULL,
@@ -1575,6 +1636,9 @@ sctp_handle_addr_wq(void)
 				 (struct sctp_nets *)NULL);
 		return;
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	LIST_INIT(&asc->list_of_work);
 	asc->cnt = 0;
 
@@ -1780,9 +1844,24 @@ sctp_timeout_handler(void *t)
 		sctp_handle_addr_wq();
 		break;
 	case SCTP_TIMER_TYPE_SEND:
-		if ((stcb == NULL) || (inp == NULL)) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[415]) {
+		  if ((stcb == (void *) 0 || inp == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 415\n");
+		  else
+		    fprintf(stderr, "reached bug index 415\n");
+		}
+		if ((!FIXREVERTER[415] && (stcb == (void *) 0 || inp == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		) {
 			break;
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		SCTP_STAT_INCR(sctps_timodata);
 		stcb->asoc.timodata++;
 		stcb->asoc.num_send_timers_up--;
@@ -1816,9 +1895,24 @@ sctp_timeout_handler(void *t)
 		}
 		break;
 	case SCTP_TIMER_TYPE_INIT:
-		if ((stcb == NULL) || (inp == NULL)) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[416]) {
+		  if ((stcb == (void *) 0 || inp == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 416\n");
+		  else
+		    fprintf(stderr, "reached bug index 416\n");
+		}
+		if ((!FIXREVERTER[416] && (stcb == (void *) 0 || inp == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		) {
 			break;
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		SCTP_STAT_INCR(sctps_timoinit);
 		stcb->asoc.timoinit++;
 		if (sctp_t1init_timer(inp, stcb, net)) {
@@ -1829,9 +1923,24 @@ sctp_timeout_handler(void *t)
 		did_output = 0;
 		break;
 	case SCTP_TIMER_TYPE_RECV:
-		if ((stcb == NULL) || (inp == NULL)) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[417]) {
+		  if ((stcb == (void *) 0 || inp == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 417\n");
+		  else
+		    fprintf(stderr, "reached bug index 417\n");
+		}
+		if ((!FIXREVERTER[417] && (stcb == (void *) 0 || inp == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		) {
 			break;
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		SCTP_STAT_INCR(sctps_timosack);
 		stcb->asoc.timosack++;
 		sctp_send_sack(stcb, SCTP_SO_NOT_LOCKED);
@@ -1841,9 +1950,24 @@ sctp_timeout_handler(void *t)
 		sctp_chunk_output(inp, stcb, SCTP_OUTPUT_FROM_SACK_TMR, SCTP_SO_NOT_LOCKED);
 		break;
 	case SCTP_TIMER_TYPE_SHUTDOWN:
-		if ((stcb == NULL) || (inp == NULL)) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[418]) {
+		  if ((stcb == (void *) 0 || inp == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 418\n");
+		  else
+		    fprintf(stderr, "reached bug index 418\n");
+		}
+		if ((!FIXREVERTER[418] && (stcb == (void *) 0 || inp == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		) {
 			break;
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		if (sctp_shutdown_timer(inp, stcb, net)) {
 			/* no need to unlock on tcb its gone */
 			goto out_decr;
@@ -1856,9 +1980,24 @@ sctp_timeout_handler(void *t)
 		sctp_chunk_output(inp, stcb, SCTP_OUTPUT_FROM_SHUT_TMR, SCTP_SO_NOT_LOCKED);
 		break;
 	case SCTP_TIMER_TYPE_HEARTBEAT:
-		if ((stcb == NULL) || (inp == NULL) || (net == NULL)) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[419]) {
+		  if ((stcb == (void *) 0 || inp == (void *) 0 || net == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 419\n");
+		  else
+		    fprintf(stderr, "reached bug index 419\n");
+		}
+		if ((!FIXREVERTER[419] && (stcb == (void *) 0 || inp == (void *) 0 || net == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		) {
 			break;
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		SCTP_STAT_INCR(sctps_timoheartbeat);
 		stcb->asoc.timoheartbeat++;
 		if (sctp_heartbeat_timer(inp, stcb, net)) {
@@ -1874,9 +2013,24 @@ sctp_timeout_handler(void *t)
 		}
 		break;
 	case SCTP_TIMER_TYPE_COOKIE:
-		if ((stcb == NULL) || (inp == NULL)) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[420]) {
+		  if ((stcb == (void *) 0 || inp == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 420\n");
+		  else
+		    fprintf(stderr, "reached bug index 420\n");
+		}
+		if ((!FIXREVERTER[420] && (stcb == (void *) 0 || inp == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		) {
 			break;
 		}
+		#ifdef FRCOV
+		}
+		#endif
 
 		if (sctp_cookie_timer(inp, stcb, net)) {
 			/* no need to unlock on tcb its gone */
@@ -1897,9 +2051,24 @@ sctp_timeout_handler(void *t)
 		{
 			struct timeval tv;
 			int i, secret;
-			if (inp == NULL) {
+			
+			#ifdef FRCOV
+			{if (FIXREVERTER[421]) {
+			  if ((inp == (void *) 0 ) && !(0))
+			    fprintf(stderr, "triggered bug index 421\n");
+			  else
+			    fprintf(stderr, "reached bug index 421\n");
+			}
+			if ((!FIXREVERTER[421] && (inp == (void *) 0 ))
+			#else
+			if (0
+			#endif
+			) {
 				break;
 			}
+			#ifdef FRCOV
+			}
+			#endif
 			SCTP_STAT_INCR(sctps_timosecret);
 			(void)SCTP_GETTIME_TIMEVAL(&tv);
 			inp->sctp_ep.time_of_secret_change = tv.tv_sec;
@@ -1920,17 +2089,47 @@ sctp_timeout_handler(void *t)
 		did_output = 0;
 		break;
 	case SCTP_TIMER_TYPE_PATHMTURAISE:
-		if ((stcb == NULL) || (inp == NULL)) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[422]) {
+		  if ((stcb == (void *) 0 || inp == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 422\n");
+		  else
+		    fprintf(stderr, "reached bug index 422\n");
+		}
+		if ((!FIXREVERTER[422] && (stcb == (void *) 0 || inp == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		) {
 			break;
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		SCTP_STAT_INCR(sctps_timopathmtu);
 		sctp_pathmtu_timer(inp, stcb, net);
 		did_output = 0;
 		break;
 	case SCTP_TIMER_TYPE_SHUTDOWNACK:
-		if ((stcb == NULL) || (inp == NULL)) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[423]) {
+		  if ((stcb == (void *) 0 || inp == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 423\n");
+		  else
+		    fprintf(stderr, "reached bug index 423\n");
+		}
+		if ((!FIXREVERTER[423] && (stcb == (void *) 0 || inp == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		) {
 			break;
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		if (sctp_shutdownack_timer(inp, stcb, net)) {
 			/* no need to unlock on tcb its gone */
 			goto out_decr;
@@ -1943,9 +2142,24 @@ sctp_timeout_handler(void *t)
 		sctp_chunk_output(inp, stcb, SCTP_OUTPUT_FROM_SHUT_ACK_TMR, SCTP_SO_NOT_LOCKED);
 		break;
 	case SCTP_TIMER_TYPE_SHUTDOWNGUARD:
-		if ((stcb == NULL) || (inp == NULL)) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[424]) {
+		  if ((stcb == (void *) 0 || inp == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 424\n");
+		  else
+		    fprintf(stderr, "reached bug index 424\n");
+		}
+		if ((!FIXREVERTER[424] && (stcb == (void *) 0 || inp == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		) {
 			break;
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		SCTP_STAT_INCR(sctps_timoshutdownguard);
 		op_err = sctp_generate_cause(SCTP_BASE_SYSCTL(sctp_diag_info_code),
 		                             "Shutdown guard timer expired");
@@ -1954,9 +2168,24 @@ sctp_timeout_handler(void *t)
 		goto out_decr;
 
 	case SCTP_TIMER_TYPE_STRRESET:
-		if ((stcb == NULL) || (inp == NULL)) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[425]) {
+		  if ((stcb == (void *) 0 || inp == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 425\n");
+		  else
+		    fprintf(stderr, "reached bug index 425\n");
+		}
+		if ((!FIXREVERTER[425] && (stcb == (void *) 0 || inp == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		) {
 			break;
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		if (sctp_strreset_timer(inp, stcb, net)) {
 			/* no need to unlock on tcb its gone */
 			goto out_decr;
@@ -1965,9 +2194,24 @@ sctp_timeout_handler(void *t)
 		sctp_chunk_output(inp, stcb, SCTP_OUTPUT_FROM_STRRST_TMR, SCTP_SO_NOT_LOCKED);
 		break;
 	case SCTP_TIMER_TYPE_ASCONF:
-		if ((stcb == NULL) || (inp == NULL)) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[426]) {
+		  if ((stcb == (void *) 0 || inp == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 426\n");
+		  else
+		    fprintf(stderr, "reached bug index 426\n");
+		}
+		if ((!FIXREVERTER[426] && (stcb == (void *) 0 || inp == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		) {
 			break;
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		if (sctp_asconf_timer(inp, stcb, net)) {
 			/* no need to unlock on tcb its gone */
 			goto out_decr;
@@ -1979,26 +2223,71 @@ sctp_timeout_handler(void *t)
 		sctp_chunk_output(inp, stcb, SCTP_OUTPUT_FROM_ASCONF_TMR, SCTP_SO_NOT_LOCKED);
 		break;
 	case SCTP_TIMER_TYPE_PRIM_DELETED:
-		if ((stcb == NULL) || (inp == NULL)) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[427]) {
+		  if ((stcb == (void *) 0 || inp == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 427\n");
+		  else
+		    fprintf(stderr, "reached bug index 427\n");
+		}
+		if ((!FIXREVERTER[427] && (stcb == (void *) 0 || inp == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		) {
 			break;
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		sctp_delete_prim_timer(inp, stcb, net);
 		SCTP_STAT_INCR(sctps_timodelprim);
 		break;
 
 	case SCTP_TIMER_TYPE_AUTOCLOSE:
-		if ((stcb == NULL) || (inp == NULL)) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[428]) {
+		  if ((stcb == (void *) 0 || inp == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 428\n");
+		  else
+		    fprintf(stderr, "reached bug index 428\n");
+		}
+		if ((!FIXREVERTER[428] && (stcb == (void *) 0 || inp == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		) {
 			break;
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		SCTP_STAT_INCR(sctps_timoautoclose);
 		sctp_autoclose_timer(inp, stcb, net);
 		sctp_chunk_output(inp, stcb, SCTP_OUTPUT_FROM_AUTOCLOSE_TMR, SCTP_SO_NOT_LOCKED);
 		did_output = 0;
 		break;
 	case SCTP_TIMER_TYPE_ASOCKILL:
-		if ((stcb == NULL) || (inp == NULL)) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[429]) {
+		  if ((stcb == (void *) 0 || inp == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 429\n");
+		  else
+		    fprintf(stderr, "reached bug index 429\n");
+		}
+		if ((!FIXREVERTER[429] && (stcb == (void *) 0 || inp == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		) {
 			break;
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		SCTP_STAT_INCR(sctps_timoassockill);
 		/* Can we free it yet? */
 		SCTP_INP_DECR_REF(inp);
@@ -2025,9 +2314,24 @@ sctp_timeout_handler(void *t)
 		goto out_no_decr;
 	case SCTP_TIMER_TYPE_INPKILL:
 		SCTP_STAT_INCR(sctps_timoinpkill);
-		if (inp == NULL) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[430]) {
+		  if ((inp == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 430\n");
+		  else
+		    fprintf(stderr, "reached bug index 430\n");
+		}
+		if ((!FIXREVERTER[430] && (inp == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		) {
 			break;
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		/*
 		 * special case, take away our increment since WE are the
 		 * killer
@@ -2077,10 +2381,27 @@ get_out:
 out_decr:
 #if defined(__Userspace__)
 	if (upcall_socket != NULL) {
-		if ((upcall_socket->so_upcall != NULL) &&
-		    (upcall_socket->so_error != 0)) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[431]) {
+		  fprintf(stderr, "reached bug index 431\n");
+		}
+		if ((FIXREVERTER[431] && (upcall_socket -> so_upcall != (void *) 0 )) || (!FIXREVERTER[431] && (upcall_socket -> so_upcall != (void *) 0 && upcall_socket -> so_error != 0 ))
+		#else
+		if (upcall_socket -> so_upcall != (void *) 0 
+		#endif
+		) {
+		      
+		    #ifdef FRCOV
+		      if (!(upcall_socket -> so_error != 0 ))
+		        fprintf(stderr, "triggered bug index 431\n");
+		      #endif
+		    
 			(*upcall_socket->so_upcall)(upcall_socket, upcall_socket->so_upcallarg, M_NOWAIT);
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		ACCEPT_LOCK();
 		SOCK_LOCK(upcall_socket);
 		sorele(upcall_socket);
@@ -2122,9 +2443,24 @@ sctp_timer_start(int t_type, struct sctp_inpcb *inp, struct sctp_tcb *stcb,
 		{
 			int rto_val;
 
-			if ((stcb == NULL) || (net == NULL)) {
+			
+			#ifdef FRCOV
+			{if (FIXREVERTER[432]) {
+			  if ((stcb == (void *) 0 || net == (void *) 0 ) && !(0))
+			    fprintf(stderr, "triggered bug index 432\n");
+			  else
+			    fprintf(stderr, "reached bug index 432\n");
+			}
+			if ((!FIXREVERTER[432] && (stcb == (void *) 0 || net == (void *) 0 ))
+			#else
+			if (0
+			#endif
+			) {
 				return;
 			}
+			#ifdef FRCOV
+			}
+			#endif
 			tmr = &net->rxt_timer;
 			if (net->RTO == 0) {
 				rto_val = stcb->asoc.initial_rto;
@@ -2139,9 +2475,24 @@ sctp_timer_start(int t_type, struct sctp_inpcb *inp, struct sctp_tcb *stcb,
 		 * Here we use the INIT timer default usually about 1
 		 * minute.
 		 */
-		if ((stcb == NULL) || (net == NULL)) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[433]) {
+		  if ((stcb == (void *) 0 || net == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 433\n");
+		  else
+		    fprintf(stderr, "reached bug index 433\n");
+		}
+		if ((!FIXREVERTER[433] && (stcb == (void *) 0 || net == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		) {
 			return;
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		tmr = &net->rxt_timer;
 		if (net->RTO == 0) {
 			to_ticks = MSEC_TO_TICKS(stcb->asoc.initial_rto);
@@ -2154,17 +2505,47 @@ sctp_timer_start(int t_type, struct sctp_inpcb *inp, struct sctp_tcb *stcb,
 		 * Here we use the Delayed-Ack timer value from the inp
 		 * ususually about 200ms.
 		 */
-		if (stcb == NULL) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[434]) {
+		  if ((stcb == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 434\n");
+		  else
+		    fprintf(stderr, "reached bug index 434\n");
+		}
+		if ((!FIXREVERTER[434] && (stcb == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		) {
 			return;
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		tmr = &stcb->asoc.dack_timer;
 		to_ticks = MSEC_TO_TICKS(stcb->asoc.delayed_ack);
 		break;
 	case SCTP_TIMER_TYPE_SHUTDOWN:
 		/* Here we use the RTO of the destination. */
-		if ((stcb == NULL) || (net == NULL)) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[435]) {
+		  if ((stcb == (void *) 0 || net == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 435\n");
+		  else
+		    fprintf(stderr, "reached bug index 435\n");
+		}
+		if ((!FIXREVERTER[435] && (stcb == (void *) 0 || net == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		) {
 			return;
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		if (net->RTO == 0) {
 			to_ticks = MSEC_TO_TICKS(stcb->asoc.initial_rto);
 		} else {
@@ -2218,9 +2599,24 @@ sctp_timer_start(int t_type, struct sctp_inpcb *inp, struct sctp_tcb *stcb,
 		 * RTT was compelete. If a retran happened then we will be
 		 * using the RTO initial value.
 		 */
-		if ((stcb == NULL) || (net == NULL)) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[436]) {
+		  if ((stcb == (void *) 0 || net == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 436\n");
+		  else
+		    fprintf(stderr, "reached bug index 436\n");
+		}
+		if ((!FIXREVERTER[436] && (stcb == (void *) 0 || net == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		) {
 			return;
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		if (net->RTO == 0) {
 			to_ticks = MSEC_TO_TICKS(stcb->asoc.initial_rto);
 		} else {
@@ -2237,9 +2633,24 @@ sctp_timer_start(int t_type, struct sctp_inpcb *inp, struct sctp_tcb *stcb,
 		to_ticks = inp->sctp_ep.sctp_timeoutticks[SCTP_TIMER_SIGNATURE];
 		break;
 	case SCTP_TIMER_TYPE_ASOCKILL:
-		if (stcb == NULL) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[437]) {
+		  if ((stcb == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 437\n");
+		  else
+		    fprintf(stderr, "reached bug index 437\n");
+		}
+		if ((!FIXREVERTER[437] && (stcb == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		) {
 			return;
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		tmr = &stcb->asoc.strreset_timer;
 		to_ticks = MSEC_TO_TICKS(SCTP_ASOC_KILL_TIMEOUT);
 		break;
@@ -2257,9 +2668,24 @@ sctp_timer_start(int t_type, struct sctp_inpcb *inp, struct sctp_tcb *stcb,
 		 * Here we use the value found in the EP for PMTU ususually
 		 * about 10 minutes.
 		 */
-		if ((stcb == NULL) || (net == NULL)) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[438]) {
+		  if ((stcb == (void *) 0 || net == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 438\n");
+		  else
+		    fprintf(stderr, "reached bug index 438\n");
+		}
+		if ((!FIXREVERTER[438] && (stcb == (void *) 0 || net == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		) {
 			return;
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		if (net->dest_state & SCTP_ADDR_NO_PMTUD) {
 			return;
 		}
@@ -2268,9 +2694,24 @@ sctp_timer_start(int t_type, struct sctp_inpcb *inp, struct sctp_tcb *stcb,
 		break;
 	case SCTP_TIMER_TYPE_SHUTDOWNACK:
 		/* Here we use the RTO of the destination */
-		if ((stcb == NULL) || (net == NULL)) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[439]) {
+		  if ((stcb == (void *) 0 || net == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 439\n");
+		  else
+		    fprintf(stderr, "reached bug index 439\n");
+		}
+		if ((!FIXREVERTER[439] && (stcb == (void *) 0 || net == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		) {
 			return;
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		if (net->RTO == 0) {
 			to_ticks = MSEC_TO_TICKS(stcb->asoc.initial_rto);
 		} else {
@@ -2283,9 +2724,24 @@ sctp_timer_start(int t_type, struct sctp_inpcb *inp, struct sctp_tcb *stcb,
 		 * Here we use the endpoints shutdown guard timer usually
 		 * about 3 minutes.
 		 */
-		if (stcb == NULL) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[440]) {
+		  if ((stcb == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 440\n");
+		  else
+		    fprintf(stderr, "reached bug index 440\n");
+		}
+		if ((!FIXREVERTER[440] && (stcb == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		) {
 			return;
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		if (inp->sctp_ep.sctp_timeoutticks[SCTP_TIMER_MAXSHUTDOWN] == 0) {
 			to_ticks = 5 * MSEC_TO_TICKS(stcb->asoc.maxrto);
 		} else {
@@ -2298,9 +2754,24 @@ sctp_timer_start(int t_type, struct sctp_inpcb *inp, struct sctp_tcb *stcb,
 		 * Here the timer comes from the stcb but its value is from
 		 * the net's RTO.
 		 */
-		if ((stcb == NULL) || (net == NULL)) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[441]) {
+		  if ((stcb == (void *) 0 || net == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 441\n");
+		  else
+		    fprintf(stderr, "reached bug index 441\n");
+		}
+		if ((!FIXREVERTER[441] && (stcb == (void *) 0 || net == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		) {
 			return;
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		if (net->RTO == 0) {
 			to_ticks = MSEC_TO_TICKS(stcb->asoc.initial_rto);
 		} else {
@@ -2313,9 +2784,24 @@ sctp_timer_start(int t_type, struct sctp_inpcb *inp, struct sctp_tcb *stcb,
 		 * Here the timer comes from the stcb but its value is from
 		 * the net's RTO.
 		 */
-		if ((stcb == NULL) || (net == NULL)) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[442]) {
+		  if ((stcb == (void *) 0 || net == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 442\n");
+		  else
+		    fprintf(stderr, "reached bug index 442\n");
+		}
+		if ((!FIXREVERTER[442] && (stcb == (void *) 0 || net == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		) {
 			return;
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		if (net->RTO == 0) {
 			to_ticks = MSEC_TO_TICKS(stcb->asoc.initial_rto);
 		} else {
@@ -2331,9 +2817,24 @@ sctp_timer_start(int t_type, struct sctp_inpcb *inp, struct sctp_tcb *stcb,
 		tmr = &stcb->asoc.delete_prim_timer;
 		break;
 	case SCTP_TIMER_TYPE_AUTOCLOSE:
-		if (stcb == NULL) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[443]) {
+		  if ((stcb == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 443\n");
+		  else
+		    fprintf(stderr, "reached bug index 443\n");
+		}
+		if ((!FIXREVERTER[443] && (stcb == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		) {
 			return;
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		if (stcb->asoc.sctp_autoclose_ticks == 0) {
 			/*
 			 * Really an error since stcb is NOT set to
@@ -2350,11 +2851,26 @@ sctp_timer_start(int t_type, struct sctp_inpcb *inp, struct sctp_tcb *stcb,
 		return;
 		break;
 	}
-	if ((to_ticks <= 0) || (tmr == NULL)) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[444]) {
+	  if ((to_ticks <= 0 || tmr == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 444\n");
+	  else
+	    fprintf(stderr, "reached bug index 444\n");
+	}
+	if ((!FIXREVERTER[444] && (to_ticks <= 0 || tmr == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		SCTPDBG(SCTP_DEBUG_TIMER1, "%s: %d:software error to_ticks:%d tmr:%p not set ??\n",
 			__func__, t_type, to_ticks, (void *)tmr);
 		return;
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	if (SCTP_OS_TIMER_PENDING(&tmr->timer)) {
 		/*
 		 * we do NOT allow you to have it already running. if it is
@@ -2401,39 +2917,129 @@ sctp_timer_stop(int t_type, struct sctp_inpcb *inp, struct sctp_tcb *stcb,
 		tmr = &SCTP_BASE_INFO(addr_wq_timer);
 		break;
 	case SCTP_TIMER_TYPE_SEND:
-		if ((stcb == NULL) || (net == NULL)) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[445]) {
+		  if ((stcb == (void *) 0 || net == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 445\n");
+		  else
+		    fprintf(stderr, "reached bug index 445\n");
+		}
+		if ((!FIXREVERTER[445] && (stcb == (void *) 0 || net == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		) {
 			return;
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		tmr = &net->rxt_timer;
 		break;
 	case SCTP_TIMER_TYPE_INIT:
-		if ((stcb == NULL) || (net == NULL)) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[446]) {
+		  if ((stcb == (void *) 0 || net == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 446\n");
+		  else
+		    fprintf(stderr, "reached bug index 446\n");
+		}
+		if ((!FIXREVERTER[446] && (stcb == (void *) 0 || net == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		) {
 			return;
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		tmr = &net->rxt_timer;
 		break;
 	case SCTP_TIMER_TYPE_RECV:
-		if (stcb == NULL) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[447]) {
+		  if ((stcb == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 447\n");
+		  else
+		    fprintf(stderr, "reached bug index 447\n");
+		}
+		if ((!FIXREVERTER[447] && (stcb == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		) {
 			return;
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		tmr = &stcb->asoc.dack_timer;
 		break;
 	case SCTP_TIMER_TYPE_SHUTDOWN:
-		if ((stcb == NULL) || (net == NULL)) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[448]) {
+		  if ((stcb == (void *) 0 || net == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 448\n");
+		  else
+		    fprintf(stderr, "reached bug index 448\n");
+		}
+		if ((!FIXREVERTER[448] && (stcb == (void *) 0 || net == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		) {
 			return;
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		tmr = &net->rxt_timer;
 		break;
 	case SCTP_TIMER_TYPE_HEARTBEAT:
-		if ((stcb == NULL) || (net == NULL)) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[449]) {
+		  if ((stcb == (void *) 0 || net == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 449\n");
+		  else
+		    fprintf(stderr, "reached bug index 449\n");
+		}
+		if ((!FIXREVERTER[449] && (stcb == (void *) 0 || net == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		) {
 			return;
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		tmr = &net->hb_timer;
 		break;
 	case SCTP_TIMER_TYPE_COOKIE:
-		if ((stcb == NULL) || (net == NULL)) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[450]) {
+		  if ((stcb == (void *) 0 || net == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 450\n");
+		  else
+		    fprintf(stderr, "reached bug index 450\n");
+		}
+		if ((!FIXREVERTER[450] && (stcb == (void *) 0 || net == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		) {
 			return;
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		tmr = &net->rxt_timer;
 		break;
 	case SCTP_TIMER_TYPE_NEWCOOKIE:
@@ -2448,9 +3054,24 @@ sctp_timer_stop(int t_type, struct sctp_inpcb *inp, struct sctp_tcb *stcb,
 		/*
 		 * Stop the asoc kill timer.
 		 */
-		if (stcb == NULL) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[451]) {
+		  if ((stcb == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 451\n");
+		  else
+		    fprintf(stderr, "reached bug index 451\n");
+		}
+		if ((!FIXREVERTER[451] && (stcb == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		) {
 			return;
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		tmr = &stcb->asoc.strreset_timer;
 		break;
 
@@ -2463,45 +3084,150 @@ sctp_timer_stop(int t_type, struct sctp_inpcb *inp, struct sctp_tcb *stcb,
 		tmr = &inp->sctp_ep.signature_change;
 		break;
 	case SCTP_TIMER_TYPE_PATHMTURAISE:
-		if ((stcb == NULL) || (net == NULL)) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[452]) {
+		  if ((stcb == (void *) 0 || net == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 452\n");
+		  else
+		    fprintf(stderr, "reached bug index 452\n");
+		}
+		if ((!FIXREVERTER[452] && (stcb == (void *) 0 || net == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		) {
 			return;
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		tmr = &net->pmtu_timer;
 		break;
 	case SCTP_TIMER_TYPE_SHUTDOWNACK:
-		if ((stcb == NULL) || (net == NULL)) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[453]) {
+		  if ((stcb == (void *) 0 || net == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 453\n");
+		  else
+		    fprintf(stderr, "reached bug index 453\n");
+		}
+		if ((!FIXREVERTER[453] && (stcb == (void *) 0 || net == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		) {
 			return;
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		tmr = &net->rxt_timer;
 		break;
 	case SCTP_TIMER_TYPE_SHUTDOWNGUARD:
-		if (stcb == NULL) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[454]) {
+		  if ((stcb == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 454\n");
+		  else
+		    fprintf(stderr, "reached bug index 454\n");
+		}
+		if ((!FIXREVERTER[454] && (stcb == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		) {
 			return;
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		tmr = &stcb->asoc.shut_guard_timer;
 		break;
 	case SCTP_TIMER_TYPE_STRRESET:
-		if (stcb == NULL) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[455]) {
+		  if ((stcb == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 455\n");
+		  else
+		    fprintf(stderr, "reached bug index 455\n");
+		}
+		if ((!FIXREVERTER[455] && (stcb == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		) {
 			return;
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		tmr = &stcb->asoc.strreset_timer;
 		break;
 	case SCTP_TIMER_TYPE_ASCONF:
-		if (stcb == NULL) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[456]) {
+		  if ((stcb == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 456\n");
+		  else
+		    fprintf(stderr, "reached bug index 456\n");
+		}
+		if ((!FIXREVERTER[456] && (stcb == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		) {
 			return;
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		tmr = &stcb->asoc.asconf_timer;
 		break;
 	case SCTP_TIMER_TYPE_PRIM_DELETED:
-		if (stcb == NULL) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[457]) {
+		  if ((stcb == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 457\n");
+		  else
+		    fprintf(stderr, "reached bug index 457\n");
+		}
+		if ((!FIXREVERTER[457] && (stcb == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		) {
 			return;
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		tmr = &stcb->asoc.delete_prim_timer;
 		break;
 	case SCTP_TIMER_TYPE_AUTOCLOSE:
-		if (stcb == NULL) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[458]) {
+		  if ((stcb == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 458\n");
+		  else
+		    fprintf(stderr, "reached bug index 458\n");
+		}
+		if ((!FIXREVERTER[458] && (stcb == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		) {
 			return;
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		tmr = &stcb->asoc.autoclose_timer;
 		break;
 	default:
@@ -2509,9 +3235,24 @@ sctp_timer_stop(int t_type, struct sctp_inpcb *inp, struct sctp_tcb *stcb,
 			__func__, t_type);
 		break;
 	}
-	if (tmr == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[459]) {
+	  if ((tmr == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 459\n");
+	  else
+	    fprintf(stderr, "reached bug index 459\n");
+	}
+	if ((!FIXREVERTER[459] && (tmr == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		return;
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	if ((tmr->type != t_type) && tmr->type) {
 		/*
 		 * Ok we have a timer that is under joint use. Cookie timer
@@ -2521,12 +3262,30 @@ sctp_timer_stop(int t_type, struct sctp_inpcb *inp, struct sctp_tcb *stcb,
 		 */
 		return;
 	}
-	if ((t_type == SCTP_TIMER_TYPE_SEND) && (stcb != NULL)) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[460]) {
+	  fprintf(stderr, "reached bug index 460\n");
+	}
+	if ((FIXREVERTER[460] && (t_type == 1 )) || (!FIXREVERTER[460] && (t_type == 1 && stcb != (void *) 0 ))
+	#else
+	if (t_type == 1 
+	#endif
+	) {
+	  
+	#ifdef FRCOV
+	  if (!(stcb != (void *) 0 ))
+	    fprintf(stderr, "triggered bug index 460\n");
+	  #endif
+	
 		stcb->asoc.num_send_timers_up--;
 		if (stcb->asoc.num_send_timers_up < 0) {
 			stcb->asoc.num_send_timers_up = 0;
 		}
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	tmr->self = NULL;
 	tmr->stopped_from = from;
 	(void)SCTP_OS_TIMER_STOP(&tmr->timer);
@@ -2615,10 +3374,25 @@ sctp_calculate_rto(struct sctp_tcb *stcb,
 	}
 	timevalsub(&now, old);
 	rtt_us = (uint64_t)1000000 * (uint64_t)now.tv_sec + (uint64_t)now.tv_usec;
-	if (rtt_us > SCTP_RTO_UPPER_BOUND * 1000) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[461]) {
+	  if ((rtt_us > 60000 * 1000 ) && !(0))
+	    fprintf(stderr, "triggered bug index 461\n");
+	  else
+	    fprintf(stderr, "reached bug index 461\n");
+	}
+	if ((!FIXREVERTER[461] && (rtt_us > 60000 * 1000 ))
+	#else
+	if (0
+	#endif
+	) {
 		/* The RTT is larger than a sane value. */
 		return (0);
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	/* store the current RTT in us */
 	net->rtt = rtt_us;
 	/* compute rtt in ms */
@@ -2707,16 +3481,48 @@ sctp_m_getptr(struct mbuf *m, int off, int len, uint8_t * in_ptr)
 	uint8_t *ptr;
 
 	ptr = in_ptr;
-	if ((off < 0) || (len <= 0))
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[462]) {
+	  if ((off < 0 ) && !(len <= 0 ))
+	    fprintf(stderr, "triggered bug index 462\n");
+	  else
+	    fprintf(stderr, "reached bug index 462\n");
+	}
+	if ((FIXREVERTER[462] && (len <= 0 )) || (!FIXREVERTER[462] && (off < 0 || len <= 0 ))
+	#else
+	if (len <= 0 
+	#endif
+	)
 		return (NULL);
+		#ifdef FRCOV
+		}
+		#endif
 
 	/* find the desired start location */
-	while ((m != NULL) && (off > 0)) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[463])
+	  fprintf(stderr, "reached bug index 463\n");
+	while ((FIXREVERTER[463] && (m != (void *) 0 )) || (!FIXREVERTER[463] && (m != (void *) 0 && off > 0 ))
+	#else
+	while (m != (void *) 0 
+	#endif
+	) {
+	  
+	#ifdef FRCOV
+	  if (!(off > 0 ))
+	    fprintf(stderr, "triggered bug index 463\n");
+	  #endif
+	
 		if (off < SCTP_BUF_LEN(m))
 			break;
 		off -= SCTP_BUF_LEN(m);
 		m = SCTP_BUF_NEXT(m);
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	if (m == NULL)
 		return (NULL);
 
@@ -2725,7 +3531,21 @@ sctp_m_getptr(struct mbuf *m, int off, int len, uint8_t * in_ptr)
 		return (mtod(m, caddr_t) + off);
 	} else {
 		/* else, it spans more than one mbuf, so save a temp copy... */
-		while ((m != NULL) && (len > 0)) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[465])
+		  fprintf(stderr, "reached bug index 465\n");
+		while ((FIXREVERTER[465] && (len > 0 )) || (!FIXREVERTER[465] && (m != (void *) 0 && len > 0 ))
+		#else
+		while (len > 0 
+		#endif
+		) {
+		  
+		#ifdef FRCOV
+		  if (!(m != (void *) 0 ))
+		    fprintf(stderr, "triggered bug index 465\n");
+		  #endif
+		
 			count = min(SCTP_BUF_LEN(m) - off, len);
 			memcpy(ptr, mtod(m, caddr_t) + off, count);
 			len -= count;
@@ -2733,6 +3553,9 @@ sctp_m_getptr(struct mbuf *m, int off, int len, uint8_t * in_ptr)
 			off = 0;
 			m = SCTP_BUF_NEXT(m);
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		if ((m == NULL) && (len > 0))
 			return (NULL);
 		else
@@ -2760,9 +3583,24 @@ sctp_add_pad_tombuf(struct mbuf *m, int padlen)
 	struct mbuf *m_last;
 	caddr_t dp;
 
-	if (padlen > 3) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[466]) {
+	  if ((padlen > 3 ) && !(0))
+	    fprintf(stderr, "triggered bug index 466\n");
+	  else
+	    fprintf(stderr, "reached bug index 466\n");
+	}
+	if ((!FIXREVERTER[466] && (padlen > 3 ))
+	#else
+	if (0
+	#endif
+	) {
 		return (NULL);
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	if (padlen <= M_TRAILINGSPACE(m)) {
 		/*
 		 * The easy way. We hope the majority of the time we hit
@@ -2772,9 +3610,24 @@ sctp_add_pad_tombuf(struct mbuf *m, int padlen)
 	} else {
 		/* Hard way we must grow the mbuf chain */
 		m_last = sctp_get_mbuf_for_msg(padlen, 0, M_NOWAIT, 1, MT_DATA);
-		if (m_last == NULL) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[467]) {
+		  if ((m_last == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 467\n");
+		  else
+		    fprintf(stderr, "reached bug index 467\n");
+		}
+		if ((!FIXREVERTER[467] && (m_last == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		) {
 			return (NULL);
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		SCTP_BUF_LEN(m_last) = 0;
 		SCTP_BUF_NEXT(m_last) = NULL;
 		SCTP_BUF_NEXT(m) = m_last;
@@ -2821,9 +3674,24 @@ sctp_notify_assoc_change(uint16_t state, struct sctp_tcb *stcb,
 	struct socket *so;
 #endif
 
-	if (stcb == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[468]) {
+	  if ((stcb == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 468\n");
+	  else
+	    fprintf(stderr, "reached bug index 468\n");
+	}
+	if ((!FIXREVERTER[468] && (stcb == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		return;
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	if (sctp_stcb_is_feature_on(stcb->sctp_ep, stcb, SCTP_PCB_FLAGS_RECVASSOCEVNT)) {
 		notif_len = (unsigned int)sizeof(struct sctp_assoc_change);
 		if (abort != NULL) {
@@ -2848,9 +3716,24 @@ sctp_notify_assoc_change(uint16_t state, struct sctp_tcb *stcb,
 			/* Retry with smaller value. */
 			notif_len = (unsigned int)sizeof(struct sctp_assoc_change);
 			m_notify = sctp_get_mbuf_for_msg(notif_len, 0, M_NOWAIT, 1, MT_DATA);
-			if (m_notify == NULL) {
+			
+			#ifdef FRCOV
+			{if (FIXREVERTER[469]) {
+			  if ((m_notify == (void *) 0 ) && !(0))
+			    fprintf(stderr, "triggered bug index 469\n");
+			  else
+			    fprintf(stderr, "reached bug index 469\n");
+			}
+			if ((!FIXREVERTER[469] && (m_notify == (void *) 0 ))
+			#else
+			if (0
+			#endif
+			) {
 				goto set_error;
 			}
+			#ifdef FRCOV
+			}
+			#endif
 		}
 		SCTP_BUF_NEXT(m_notify) = NULL;
 		sac = mtod(m_notify, struct sctp_assoc_change *);
@@ -2982,8 +3865,23 @@ sctp_notify_peer_addr_change(struct sctp_tcb *stcb, uint32_t state,
 		return;
 	}
 	m_notify = sctp_get_mbuf_for_msg(sizeof(struct sctp_paddr_change), 0, M_NOWAIT, 1, MT_DATA);
-	if (m_notify == NULL)
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[470]) {
+	  if ((m_notify == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 470\n");
+	  else
+	    fprintf(stderr, "reached bug index 470\n");
+	}
+	if ((!FIXREVERTER[470] && (m_notify == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	)
 		return;
+		#ifdef FRCOV
+		}
+		#endif
 	SCTP_BUF_LEN(m_notify) = 0;
 	spc = mtod(m_notify, struct sctp_paddr_change *);
 	memset(spc, 0, sizeof(struct sctp_paddr_change));
@@ -3053,11 +3951,26 @@ sctp_notify_peer_addr_change(struct sctp_tcb *stcb, uint32_t state,
 	control = sctp_build_readq_entry(stcb, stcb->asoc.primary_destination,
 	                                 0, 0, stcb->asoc.context, 0, 0, 0,
 	                                 m_notify);
-	if (control == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[471]) {
+	  if ((control == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 471\n");
+	  else
+	    fprintf(stderr, "reached bug index 471\n");
+	}
+	if ((!FIXREVERTER[471] && (control == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		/* no memory */
 		sctp_m_freem(m_notify);
 		return;
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	control->length = SCTP_BUF_LEN(m_notify);
 	control->spec_flags = M_NOTIFICATION;
 	/* not that we need this */
@@ -3098,9 +4011,24 @@ sctp_notify_send_failed(struct sctp_tcb *stcb, uint8_t sent, uint32_t error,
 		notifhdr_len = sizeof(struct sctp_send_failed);
 	}
 	m_notify = sctp_get_mbuf_for_msg(notifhdr_len, 0, M_NOWAIT, 1, MT_DATA);
-	if (m_notify == NULL)
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[472]) {
+	  if ((m_notify == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 472\n");
+	  else
+	    fprintf(stderr, "reached bug index 472\n");
+	}
+	if ((!FIXREVERTER[472] && (m_notify == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	)
 		/* no space left */
 		return;
+		#ifdef FRCOV
+		}
+		#endif
 	SCTP_BUF_LEN(m_notify) = notifhdr_len;
 	if (stcb->asoc.idata_supported) {
 		chkhdr_len = sizeof(struct sctp_idata_chunk);
@@ -3118,12 +4046,28 @@ sctp_notify_send_failed(struct sctp_tcb *stcb, uint8_t sent, uint32_t error,
 		chkhdr = mtod(chk->data, struct sctp_chunkhdr *);
 		if (chkhdr != NULL) {
 			chk_len = ntohs(chkhdr->chunk_length);
-			if ((chk_len >= chkhdr_len) &&
-			    (chk->send_size >= chk_len) &&
-			    (chk->send_size - chk_len < 4)) {
+			
+			#ifdef FRCOV
+			{if (FIXREVERTER[473]) {
+			  fprintf(stderr, "reached bug index 473\n");
+			}
+			if ((FIXREVERTER[473] && (chk_len >= chkhdr_len && chk -> send_size >= chk_len )) || (!FIXREVERTER[473] && (chk_len >= chkhdr_len && chk -> send_size >= chk_len && chk -> send_size - chk_len < 4 ))
+			#else
+			if (chk_len >= chkhdr_len && chk -> send_size >= chk_len 
+			#endif
+			) {
+			      
+			    #ifdef FRCOV
+			      if (!(chk -> send_size - chk_len < 4 ))
+			        fprintf(stderr, "triggered bug index 473\n");
+			      #endif
+			    
 				padding_len = chk->send_size - chk_len;
 				payload_len = chk->send_size - chkhdr_len - padding_len;
 			}
+			#ifdef FRCOV
+			}
+			#endif
 		}
 	}
 	if (sctp_stcb_is_feature_on(stcb->sctp_ep, stcb, SCTP_PCB_FLAGS_RECVNSENDFAILEVNT)) {
@@ -3189,11 +4133,26 @@ sctp_notify_send_failed(struct sctp_tcb *stcb, uint8_t sent, uint32_t error,
 	control = sctp_build_readq_entry(stcb, stcb->asoc.primary_destination,
 	                                 0, 0, stcb->asoc.context, 0, 0, 0,
 	                                 m_notify);
-	if (control == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[474]) {
+	  if ((control == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 474\n");
+	  else
+	    fprintf(stderr, "reached bug index 474\n");
+	}
+	if ((!FIXREVERTER[474] && (control == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		/* no memory */
 		sctp_m_freem(m_notify);
 		return;
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	control->length = SCTP_BUF_LEN(m_notify);
 	control->spec_flags = M_NOTIFICATION;
 	/* not that we need this */
@@ -3232,10 +4191,25 @@ sctp_notify_send_failed2(struct sctp_tcb *stcb, uint32_t error,
 		notifhdr_len = sizeof(struct sctp_send_failed);
 	}
 	m_notify = sctp_get_mbuf_for_msg(notifhdr_len, 0, M_NOWAIT, 1, MT_DATA);
-	if (m_notify == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[475]) {
+	  if ((m_notify == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 475\n");
+	  else
+	    fprintf(stderr, "reached bug index 475\n");
+	}
+	if ((!FIXREVERTER[475] && (m_notify == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		/* no space left */
 		return;
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	SCTP_BUF_LEN(m_notify) = notifhdr_len;
 	if (sctp_stcb_is_feature_on(stcb->sctp_ep, stcb, SCTP_PCB_FLAGS_RECVNSENDFAILEVNT)) {
 		ssfe = mtod(m_notify, struct sctp_send_failed_event *);
@@ -3292,11 +4266,26 @@ sctp_notify_send_failed2(struct sctp_tcb *stcb, uint32_t error,
 	control = sctp_build_readq_entry(stcb, stcb->asoc.primary_destination,
 	                                 0, 0, stcb->asoc.context, 0, 0, 0,
 	                                 m_notify);
-	if (control == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[476]) {
+	  if ((control == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 476\n");
+	  else
+	    fprintf(stderr, "reached bug index 476\n");
+	}
+	if ((!FIXREVERTER[476] && (control == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		/* no memory */
 		sctp_m_freem(m_notify);
 		return;
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	control->length = SCTP_BUF_LEN(m_notify);
 	control->spec_flags = M_NOTIFICATION;
 	/* not that we need this */
@@ -3322,9 +4311,24 @@ sctp_notify_adaptation_layer(struct sctp_tcb *stcb)
 	}
 
 	m_notify = sctp_get_mbuf_for_msg(sizeof(struct sctp_adaption_event), 0, M_NOWAIT, 1, MT_DATA);
-	if (m_notify == NULL)
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[477]) {
+	  if ((m_notify == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 477\n");
+	  else
+	    fprintf(stderr, "reached bug index 477\n");
+	}
+	if ((!FIXREVERTER[477] && (m_notify == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	)
 		/* no space left */
 		return;
+		#ifdef FRCOV
+		}
+		#endif
 	SCTP_BUF_LEN(m_notify) = 0;
 	sai = mtod(m_notify, struct sctp_adaptation_event *);
 	memset(sai, 0, sizeof(struct sctp_adaptation_event));
@@ -3341,11 +4345,26 @@ sctp_notify_adaptation_layer(struct sctp_tcb *stcb)
 	control = sctp_build_readq_entry(stcb, stcb->asoc.primary_destination,
 	                                 0, 0, stcb->asoc.context, 0, 0, 0,
 	                                 m_notify);
-	if (control == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[478]) {
+	  if ((control == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 478\n");
+	  else
+	    fprintf(stderr, "reached bug index 478\n");
+	}
+	if ((!FIXREVERTER[478] && (control == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		/* no memory */
 		sctp_m_freem(m_notify);
 		return;
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	control->length = SCTP_BUF_LEN(m_notify);
 	control->spec_flags = M_NOTIFICATION;
 	/* not that we need this */
@@ -3379,9 +4398,24 @@ sctp_notify_partial_delivery_indication(struct sctp_tcb *stcb, uint32_t error,
 	}
 
 	m_notify = sctp_get_mbuf_for_msg(sizeof(struct sctp_pdapi_event), 0, M_NOWAIT, 1, MT_DATA);
-	if (m_notify == NULL)
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[479]) {
+	  if ((m_notify == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 479\n");
+	  else
+	    fprintf(stderr, "reached bug index 479\n");
+	}
+	if ((!FIXREVERTER[479] && (m_notify == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	)
 		/* no space left */
 		return;
+		#ifdef FRCOV
+		}
+		#endif
 	SCTP_BUF_LEN(m_notify) = 0;
 	pdapi = mtod(m_notify, struct sctp_pdapi_event *);
 	memset(pdapi, 0, sizeof(struct sctp_pdapi_event));
@@ -3398,11 +4432,26 @@ sctp_notify_partial_delivery_indication(struct sctp_tcb *stcb, uint32_t error,
 	control = sctp_build_readq_entry(stcb, stcb->asoc.primary_destination,
 					 0, 0, stcb->asoc.context, 0, 0, 0,
 					 m_notify);
-	if (control == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[480]) {
+	  if ((control == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 480\n");
+	  else
+	    fprintf(stderr, "reached bug index 480\n");
+	}
+	if ((!FIXREVERTER[480] && (control == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		/* no memory */
 		sctp_m_freem(m_notify);
 		return;
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	control->length = SCTP_BUF_LEN(m_notify);
 	control->spec_flags = M_NOTIFICATION;
 	/* not that we need this */
@@ -3488,9 +4537,24 @@ sctp_notify_shutdown_event(struct sctp_tcb *stcb)
 	}
 
 	m_notify = sctp_get_mbuf_for_msg(sizeof(struct sctp_shutdown_event), 0, M_NOWAIT, 1, MT_DATA);
-	if (m_notify == NULL)
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[481]) {
+	  if ((m_notify == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 481\n");
+	  else
+	    fprintf(stderr, "reached bug index 481\n");
+	}
+	if ((!FIXREVERTER[481] && (m_notify == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	)
 		/* no space left */
 		return;
+		#ifdef FRCOV
+		}
+		#endif
 	sse = mtod(m_notify, struct sctp_shutdown_event *);
 	memset(sse, 0, sizeof(struct sctp_shutdown_event));
 	sse->sse_type = SCTP_SHUTDOWN_EVENT;
@@ -3505,11 +4569,26 @@ sctp_notify_shutdown_event(struct sctp_tcb *stcb)
 	control = sctp_build_readq_entry(stcb, stcb->asoc.primary_destination,
 	                                 0, 0, stcb->asoc.context, 0, 0, 0,
 	                                 m_notify);
-	if (control == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[482]) {
+	  if ((control == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 482\n");
+	  else
+	    fprintf(stderr, "reached bug index 482\n");
+	}
+	if ((!FIXREVERTER[482] && (control == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		/* no memory */
 		sctp_m_freem(m_notify);
 		return;
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	control->length = SCTP_BUF_LEN(m_notify);
 	control->spec_flags = M_NOTIFICATION;
 	/* not that we need this */
@@ -3538,10 +4617,25 @@ sctp_notify_sender_dry_event(struct sctp_tcb *stcb,
 	}
 
 	m_notify = sctp_get_mbuf_for_msg(sizeof(struct sctp_sender_dry_event), 0, M_NOWAIT, 1, MT_DATA);
-	if (m_notify == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[483]) {
+	  if ((m_notify == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 483\n");
+	  else
+	    fprintf(stderr, "reached bug index 483\n");
+	}
+	if ((!FIXREVERTER[483] && (m_notify == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		/* no space left */
 		return;
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	SCTP_BUF_LEN(m_notify) = 0;
 	event = mtod(m_notify, struct sctp_sender_dry_event *);
 	memset(event, 0, sizeof(struct sctp_sender_dry_event));
@@ -3557,11 +4651,26 @@ sctp_notify_sender_dry_event(struct sctp_tcb *stcb,
 	control = sctp_build_readq_entry(stcb, stcb->asoc.primary_destination,
 	                                 0, 0, stcb->asoc.context, 0, 0, 0,
 	                                 m_notify);
-	if (control == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[484]) {
+	  if ((control == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 484\n");
+	  else
+	    fprintf(stderr, "reached bug index 484\n");
+	}
+	if ((!FIXREVERTER[484] && (control == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		/* no memory */
 		sctp_m_freem(m_notify);
 		return;
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	control->length = SCTP_BUF_LEN(m_notify);
 	control->spec_flags = M_NOTIFICATION;
 	/* not that we need this */
@@ -3590,9 +4699,24 @@ sctp_notify_stream_reset_add(struct sctp_tcb *stcb, uint16_t numberin, uint16_t
 	}
 	stcb->asoc.peer_req_out = 0;
 	m_notify = sctp_get_mbuf_for_msg(sizeof(struct sctp_stream_change_event), 0, M_NOWAIT, 1, MT_DATA);
-	if (m_notify == NULL)
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[485]) {
+	  if ((m_notify == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 485\n");
+	  else
+	    fprintf(stderr, "reached bug index 485\n");
+	}
+	if ((!FIXREVERTER[485] && (m_notify == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	)
 		/* no space left */
 		return;
+		#ifdef FRCOV
+		}
+		#endif
 	SCTP_BUF_LEN(m_notify) = 0;
 	stradd = mtod(m_notify, struct sctp_stream_change_event *);
 	memset(stradd, 0, sizeof(struct sctp_stream_change_event));
@@ -3613,11 +4737,26 @@ sctp_notify_stream_reset_add(struct sctp_tcb *stcb, uint16_t numberin, uint16_t
 	control = sctp_build_readq_entry(stcb, stcb->asoc.primary_destination,
 	                                 0, 0, stcb->asoc.context, 0, 0, 0,
 	                                 m_notify);
-	if (control == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[486]) {
+	  if ((control == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 486\n");
+	  else
+	    fprintf(stderr, "reached bug index 486\n");
+	}
+	if ((!FIXREVERTER[486] && (control == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		/* no memory */
 		sctp_m_freem(m_notify);
 		return;
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	control->length = SCTP_BUF_LEN(m_notify);
 	control->spec_flags = M_NOTIFICATION;
 	/* not that we need this */
@@ -3640,9 +4779,24 @@ sctp_notify_stream_reset_tsn(struct sctp_tcb *stcb, uint32_t sending_tsn, uint32
 		return;
 	}
 	m_notify = sctp_get_mbuf_for_msg(sizeof(struct sctp_assoc_reset_event), 0, M_NOWAIT, 1, MT_DATA);
-	if (m_notify == NULL)
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[487]) {
+	  if ((m_notify == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 487\n");
+	  else
+	    fprintf(stderr, "reached bug index 487\n");
+	}
+	if ((!FIXREVERTER[487] && (m_notify == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	)
 		/* no space left */
 		return;
+		#ifdef FRCOV
+		}
+		#endif
 	SCTP_BUF_LEN(m_notify) = 0;
 	strasoc = mtod(m_notify, struct sctp_assoc_reset_event  *);
 	memset(strasoc, 0, sizeof(struct sctp_assoc_reset_event));
@@ -3663,11 +4817,26 @@ sctp_notify_stream_reset_tsn(struct sctp_tcb *stcb, uint32_t sending_tsn, uint32
 	control = sctp_build_readq_entry(stcb, stcb->asoc.primary_destination,
 	                                 0, 0, stcb->asoc.context, 0, 0, 0,
 	                                 m_notify);
-	if (control == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[488]) {
+	  if ((control == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 488\n");
+	  else
+	    fprintf(stderr, "reached bug index 488\n");
+	}
+	if ((!FIXREVERTER[488] && (control == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		/* no memory */
 		sctp_m_freem(m_notify);
 		return;
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	control->length = SCTP_BUF_LEN(m_notify);
 	control->spec_flags = M_NOTIFICATION;
 	/* not that we need this */
@@ -3695,9 +4864,24 @@ sctp_notify_stream_reset(struct sctp_tcb *stcb,
 	}
 
 	m_notify = sctp_get_mbuf_for_msg(MCLBYTES, 0, M_NOWAIT, 1, MT_DATA);
-	if (m_notify == NULL)
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[489]) {
+	  if ((m_notify == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 489\n");
+	  else
+	    fprintf(stderr, "reached bug index 489\n");
+	}
+	if ((!FIXREVERTER[489] && (m_notify == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	)
 		/* no space left */
 		return;
+		#ifdef FRCOV
+		}
+		#endif
 	SCTP_BUF_LEN(m_notify) = 0;
 	len = sizeof(struct sctp_stream_reset_event) + (number_entries * sizeof(uint16_t));
 	if (len > M_TRAILINGSPACE(m_notify)) {
@@ -3729,11 +4913,26 @@ sctp_notify_stream_reset(struct sctp_tcb *stcb,
 	control = sctp_build_readq_entry(stcb, stcb->asoc.primary_destination,
 	                                 0, 0, stcb->asoc.context, 0, 0, 0,
 	                                 m_notify);
-	if (control == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[490]) {
+	  if ((control == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 490\n");
+	  else
+	    fprintf(stderr, "reached bug index 490\n");
+	}
+	if ((!FIXREVERTER[490] && (control == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		/* no memory */
 		sctp_m_freem(m_notify);
 		return;
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	control->length = SCTP_BUF_LEN(m_notify);
 	control->spec_flags = M_NOTIFICATION;
 	/* not that we need this */
@@ -3775,9 +4974,24 @@ sctp_notify_remote_error(struct sctp_tcb *stcb, uint16_t error, struct sctp_erro
 		/* Retry with smaller value. */
 		notif_len = (unsigned int)sizeof(struct sctp_remote_error);
 		m_notify = sctp_get_mbuf_for_msg(notif_len, 0, M_NOWAIT, 1, MT_DATA);
-		if (m_notify == NULL) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[491]) {
+		  if ((m_notify == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 491\n");
+		  else
+		    fprintf(stderr, "reached bug index 491\n");
+		}
+		if ((!FIXREVERTER[491] && (m_notify == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		) {
 			return;
 		}
+		#ifdef FRCOV
+		}
+		#endif
 	}
 	SCTP_BUF_NEXT(m_notify) = NULL;
 	sre = mtod(m_notify, struct sctp_remote_error *);
@@ -4029,9 +5243,24 @@ sctp_report_all_outbound(struct sctp_tcb *stcb, uint16_t error, int holds_lock,
 	struct sctp_stream_queue_pending *sp, *nsp;
 	int i;
 
-	if (stcb == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[493]) {
+	  if ((stcb == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 493\n");
+	  else
+	    fprintf(stderr, "reached bug index 493\n");
+	}
+	if ((!FIXREVERTER[493] && (stcb == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		return;
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	asoc = &stcb->asoc;
 	if (asoc->state & SCTP_STATE_ABOUT_TO_BE_FREED) {
 		/* already being freed */
@@ -4143,9 +5372,24 @@ sctp_abort_notification(struct sctp_tcb *stcb, uint8_t from_peer, uint16_t error
 #endif
     )
 {
-	if (stcb == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[494]) {
+	  if ((stcb == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 494\n");
+	  else
+	    fprintf(stderr, "reached bug index 494\n");
+	}
+	if ((!FIXREVERTER[494] && (stcb == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		return;
 	}
+	#ifdef FRCOV
+	}
+	#endif
 #if defined(__APPLE__)
 	if (so_locked) {
 		sctp_lock_assert(SCTP_INP_SO(stcb->sctp_ep));
@@ -4521,8 +5765,23 @@ sctp_is_same_scope(struct sockaddr_in6 *addr1, struct sockaddr_in6 *addr2)
 	if (a.sin6_scope_id != b.sin6_scope_id)
 		return (0);
 #else
-	if (addr1->sin6_scope_id != addr2->sin6_scope_id)
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[495]) {
+	  if ((addr1 -> sin6_scope_id != addr2 -> sin6_scope_id ) && !(0))
+	    fprintf(stderr, "triggered bug index 495\n");
+	  else
+	    fprintf(stderr, "reached bug index 495\n");
+	}
+	if ((!FIXREVERTER[495] && (addr1 -> sin6_scope_id != addr2 -> sin6_scope_id ))
+	#else
+	if (0
+	#endif
+	)
 		return (0);
+		#ifdef FRCOV
+		}
+		#endif
 #endif /* SCTP_EMBEDDED_V6_SCOPE */
 
 	return (1);
@@ -4569,12 +5828,42 @@ sctp_cmpaddr(struct sockaddr *sa1, struct sockaddr *sa2)
 {
 
 	/* must be valid */
-	if (sa1 == NULL || sa2 == NULL)
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[496]) {
+	  if ((sa1 == (void *) 0 || sa2 == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 496\n");
+	  else
+	    fprintf(stderr, "reached bug index 496\n");
+	}
+	if ((!FIXREVERTER[496] && (sa1 == (void *) 0 || sa2 == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	)
 		return (0);
+		#ifdef FRCOV
+		}
+		#endif
 
 	/* must be the same family */
-	if (sa1->sa_family != sa2->sa_family)
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[497]) {
+	  if ((sa1 -> sa_family != sa2 -> sa_family ) && !(0))
+	    fprintf(stderr, "triggered bug index 497\n");
+	  else
+	    fprintf(stderr, "reached bug index 497\n");
+	}
+	if ((!FIXREVERTER[497] && (sa1 -> sa_family != sa2 -> sa_family ))
+	#else
+	if (0
+	#endif
+	)
 		return (0);
+		#ifdef FRCOV
+		}
+		#endif
 
 	switch (sa1->sa_family) {
 #ifdef INET6
@@ -4796,7 +6085,22 @@ sctp_wakeup_the_read_socket(struct sctp_inpcb *inp,
 #endif
 )
 {
-	if ((inp != NULL) && (inp->sctp_socket != NULL)) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[498]) {
+	  fprintf(stderr, "reached bug index 498\n");
+	}
+	if ((FIXREVERTER[498] && (inp != (void *) 0 )) || (!FIXREVERTER[498] && (inp != (void *) 0 && inp -> sctp_socket != (void *) 0 ))
+	#else
+	if (inp != (void *) 0 
+	#endif
+	) {
+	  
+	#ifdef FRCOV
+	  if (!(inp -> sctp_socket != (void *) 0 ))
+	    fprintf(stderr, "triggered bug index 498\n");
+	  #endif
+	
 #if defined(__APPLE__) || defined(SCTP_SO_LOCK_TESTING)
 		struct socket *so;
 
@@ -4824,6 +6128,9 @@ sctp_wakeup_the_read_socket(struct sctp_inpcb *inp,
 		}
 #endif
 	}
+	#ifdef FRCOV
+	}
+	#endif
 }
 #if defined(__Userspace__)
 
@@ -4842,12 +6149,30 @@ sctp_invoke_recv_callback(struct sctp_inpcb *inp,
 	}
 
 	length = control->length;
-	if (stcb != NULL && stcb->sctp_socket != NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[500]) {
+	  fprintf(stderr, "reached bug index 500\n");
+	}
+	if ((FIXREVERTER[500] && (stcb != (void *) 0 )) || (!FIXREVERTER[500] && (stcb != (void *) 0 && stcb -> sctp_socket != (void *) 0 ))
+	#else
+	if (stcb != (void *) 0 
+	#endif
+	) {
+	  
+	#ifdef FRCOV
+	  if (!(stcb -> sctp_socket != (void *) 0 ))
+	    fprintf(stderr, "triggered bug index 500\n");
+	  #endif
+	
 		pd_point = min(SCTP_SB_LIMIT_RCV(stcb->sctp_socket) >> SCTP_PARTIAL_DELIVERY_SHIFT,
 			       stcb->sctp_ep->partial_delivery_point);
 	} else {
 		pd_point = inp->partial_delivery_point;
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	if ((control->end_added == 1) || (length >= pd_point)) {
 		struct socket *so;
 		struct mbuf *m;
@@ -4945,13 +6270,28 @@ sctp_add_to_readq(struct sctp_inpcb *inp,
 	 */
 	struct mbuf *m, *prev = NULL;
 
-	if (inp == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[501]) {
+	  if ((inp == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 501\n");
+	  else
+	    fprintf(stderr, "reached bug index 501\n");
+	}
+	if ((!FIXREVERTER[501] && (inp == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		/* Gak, TSNH!! */
 #ifdef INVARIANTS
 		panic("Gak, inp NULL on add_to_readq");
 #endif
 		return;
 	}
+	#ifdef FRCOV
+	}
+	#endif
 #if defined(__APPLE__)
 	if (so_locked) {
 		sctp_lock_assert(SCTP_INP_SO(inp));
@@ -5053,9 +6393,24 @@ sctp_generate_cause(uint16_t code, char *info)
 	size_t info_len;
 	uint16_t len;
 
-	if ((code == 0) || (info == NULL)) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[502]) {
+	  if ((info == (void *) 0 ) && !(code == 0 ))
+	    fprintf(stderr, "triggered bug index 502\n");
+	  else
+	    fprintf(stderr, "reached bug index 502\n");
+	}
+	if ((FIXREVERTER[502] && (code == 0 )) || (!FIXREVERTER[502] && (code == 0 || info == (void *) 0 ))
+	#else
+	if (code == 0 
+	#endif
+	) {
 		return (NULL);
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	info_len = strlen(info);
 	if (info_len > (SCTP_MAX_CAUSE_LENGTH - sizeof(struct sctp_paramhdr))) {
 		return (NULL);
@@ -5271,7 +6626,19 @@ sctp_release_pr_sctp_chunk(struct sctp_tcb *stcb, struct sctp_tmit_chunk *tp1,
 			if (chk == NULL) {
 				/* Yep, we have to */
 				sctp_alloc_a_chunk(stcb, chk);
-				if (chk == NULL) {
+				
+				#ifdef FRCOV
+				{if (FIXREVERTER[503]) {
+				  if ((chk == (void *) 0 ) && !(0))
+				    fprintf(stderr, "triggered bug index 503\n");
+				  else
+				    fprintf(stderr, "reached bug index 503\n");
+				}
+				if ((!FIXREVERTER[503] && (chk == (void *) 0 ))
+				#else
+				if (0
+				#endif
+				) {
 					/* we are hosed. All we can
 					 * do is nothing.. which will
 					 * cause an abort if the peer is
@@ -5279,6 +6646,9 @@ sctp_release_pr_sctp_chunk(struct sctp_tcb *stcb, struct sctp_tmit_chunk *tp1,
 					 */
 					goto oh_well;
 				}
+				#ifdef FRCOV
+				}
+				#endif
 				memset(chk, 0, sizeof(*chk));
 				chk->rec.data.rcv_flags = 0;
 				chk->sent = SCTP_FORWARD_TSN_SKIP;
@@ -5389,8 +6759,23 @@ sctp_find_ifa_in_ep(struct sctp_inpcb *inp, struct sockaddr *addr,
 	}
 
 	LIST_FOREACH(laddr, &inp->sctp_addr_list, sctp_nxt_addr) {
-		if (laddr->ifa == NULL)
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[504]) {
+		  if ((laddr -> ifa == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 504\n");
+		  else
+		    fprintf(stderr, "reached bug index 504\n");
+		}
+		if ((!FIXREVERTER[504] && (laddr -> ifa == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		)
 			continue;
+			#ifdef FRCOV
+			}
+			#endif
 		if (addr->sa_family != laddr->ifa->address.sa.sa_family)
 			continue;
 #ifdef INET
@@ -5575,8 +6960,23 @@ sctp_user_rcvd(struct sctp_tcb *stcb, uint32_t *freed_so_far, int hold_rlock,
 	uint32_t dif, rwnd;
 	struct socket *so = NULL;
 
-	if (stcb == NULL)
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[506]) {
+	  if ((stcb == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 506\n");
+	  else
+	    fprintf(stderr, "reached bug index 506\n");
+	}
+	if ((!FIXREVERTER[506] && (stcb == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	)
 		return;
+		#ifdef FRCOV
+		}
+		#endif
 
 	atomic_add_int(&stcb->asoc.refcnt, 1);
 
@@ -5591,9 +6991,24 @@ sctp_user_rcvd(struct sctp_tcb *stcb, uint32_t *freed_so_far, int hold_rlock,
 		goto out;
 	}
 	so = stcb->sctp_socket;
-	if (so == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[507]) {
+	  if ((so == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 507\n");
+	  else
+	    fprintf(stderr, "reached bug index 507\n");
+	}
+	if ((!FIXREVERTER[507] && (so == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		goto out;
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	atomic_add_int(&stcb->freed_by_sorcv_sincelast, *freed_so_far);
 	/* Have you have freed enough to look */
 	*freed_so_far = 0;
@@ -5691,10 +7106,25 @@ sctp_sorecvmsg(struct socket *so,
 	int sockbuf_lock = 0;
 #endif
 
-	if (uio == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[508]) {
+	  if ((uio == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 508\n");
+	  else
+	    fprintf(stderr, "reached bug index 508\n");
+	}
+	if ((!FIXREVERTER[508] && (uio == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		SCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTPUTIL, EINVAL);
 		return (EINVAL);
 	}
+	#ifdef FRCOV
+	}
+	#endif
 
 	if (msg_flags) {
 		in_flags = *msg_flags;
@@ -5732,10 +7162,25 @@ sctp_sorecvmsg(struct socket *so,
 	}
 	/* setup the endpoint */
 	inp = (struct sctp_inpcb *)so->so_pcb;
-	if (inp == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[509]) {
+	  if ((inp == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 509\n");
+	  else
+	    fprintf(stderr, "reached bug index 509\n");
+	}
+	if ((!FIXREVERTER[509] && (inp == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		SCTP_LTRACE_ERR_RET(NULL, NULL, NULL, SCTP_FROM_SCTPUTIL, EFAULT);
 		return (EFAULT);
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	rwnd_req = (SCTP_SB_LIMIT_RCV(so) >> SCTP_RWND_HIWAT_SHIFT);
 	/* Must be at least a MTU's worth */
 	if (rwnd_req < SCTP_MIN_RWND)
@@ -6047,8 +7492,23 @@ sctp_sorecvmsg(struct socket *so,
 	if (stcb) {
 		if ((control->do_not_ref_stcb == 0) &&
 		    (stcb->asoc.state & SCTP_STATE_ABOUT_TO_BE_FREED)) {
-			if (freecnt_applied == 0)
+			
+			#ifdef FRCOV
+			{if (FIXREVERTER[511]) {
+			  if ((freecnt_applied == 0 ) && !(0))
+			    fprintf(stderr, "triggered bug index 511\n");
+			  else
+			    fprintf(stderr, "reached bug index 511\n");
+			}
+			if ((!FIXREVERTER[511] && (freecnt_applied == 0 ))
+			#else
+			if (0
+			#endif
+			)
 				stcb = NULL;
+				#ifdef FRCOV
+				}
+				#endif
 		} else if (control->do_not_ref_stcb == 0) {
 			/* you can't free it on me please */
 			/*
@@ -6087,7 +7547,22 @@ sctp_sorecvmsg(struct socket *so,
 	}
 
 	/* First lets get off the sinfo and sockaddr info */
-	if ((sinfo != NULL) && (filling_sinfo != 0)) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[512]) {
+	  fprintf(stderr, "reached bug index 512\n");
+	}
+	if ((FIXREVERTER[512] && (filling_sinfo != 0 )) || (!FIXREVERTER[512] && (sinfo != (void *) 0 && filling_sinfo != 0 ))
+	#else
+	if (filling_sinfo != 0 
+	#endif
+	) {
+	  
+	#ifdef FRCOV
+	  if (!(sinfo != (void *) 0 ))
+	    fprintf(stderr, "triggered bug index 512\n");
+	  #endif
+	
 		sinfo->sinfo_stream = control->sinfo_stream;
 		sinfo->sinfo_ssn = (uint16_t)control->mid;
 		sinfo->sinfo_flags = control->sinfo_flags;
@@ -6147,6 +7622,9 @@ sctp_sorecvmsg(struct socket *so,
 			sinfo->sinfo_flags |= SCTP_UNORDERED;
 		}
 	}
+	#ifdef FRCOV
+	}
+	#endif
 #ifdef SCTP_ASOCLOG_OF_TSNS
 	{
 		int index, newindex;
@@ -6166,7 +7644,22 @@ sctp_sorecvmsg(struct socket *so,
 		entry->flgs = control->sinfo_flags;
 	}
 #endif
-	if ((fromlen > 0) && (from != NULL)) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[513]) {
+	  fprintf(stderr, "reached bug index 513\n");
+	}
+	if ((FIXREVERTER[513] && (fromlen > 0 )) || (!FIXREVERTER[513] && (fromlen > 0 && from != (void *) 0 ))
+	#else
+	if (fromlen > 0 
+	#endif
+	) {
+	  
+	#ifdef FRCOV
+	  if (!(from != (void *) 0 ))
+	    fprintf(stderr, "triggered bug index 513\n");
+	  #endif
+	
 		union sctp_sockstore store;
 		size_t len;
 
@@ -6221,6 +7714,9 @@ sctp_sorecvmsg(struct socket *so,
 #endif
 #endif
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	if (hold_rlock) {
 		SCTP_INP_READ_UNLOCK(inp);
 		hold_rlock = 0;
@@ -6699,7 +8195,19 @@ sctp_sorecvmsg(struct socket *so,
 		 * the sender uses the tcb_lock to increment, we need to use
 		 * the atomic add to the refcnt.
 		 */
-		if (stcb == NULL) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[517]) {
+		  if ((stcb == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 517\n");
+		  else
+		    fprintf(stderr, "reached bug index 517\n");
+		}
+		if ((!FIXREVERTER[517] && (stcb == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		) {
 #ifdef INVARIANTS
 			panic("stcb for refcnt has gone NULL?");
 			goto stage_left;
@@ -6707,6 +8215,9 @@ sctp_sorecvmsg(struct socket *so,
 			goto stage_left;
 #endif
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		/* Save the value back for next time */
 		stcb->freed_by_sorcv_sincelast = freed_so_far;
 		atomic_add_int(&stcb->asoc.refcnt, -1);
@@ -6779,18 +8290,48 @@ sctp_dynamic_set_primary(struct sockaddr *sa, uint32_t vrf_id)
 	struct sctp_laddr *wi;
 
 	ifa = sctp_find_ifa_by_addr(sa, vrf_id, 0);
-	if (ifa == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[518]) {
+	  if ((ifa == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 518\n");
+	  else
+	    fprintf(stderr, "reached bug index 518\n");
+	}
+	if ((!FIXREVERTER[518] && (ifa == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		SCTP_LTRACE_ERR_RET(NULL, NULL, NULL, SCTP_FROM_SCTPUTIL, EADDRNOTAVAIL);
 		return (EADDRNOTAVAIL);
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	/* Now that we have the ifa we must awaken the
 	 * iterator with this message.
 	 */
 	wi = SCTP_ZONE_GET(SCTP_BASE_INFO(ipi_zone_laddr), struct sctp_laddr);
-	if (wi == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[519]) {
+	  if ((wi == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 519\n");
+	  else
+	    fprintf(stderr, "reached bug index 519\n");
+	}
+	if ((!FIXREVERTER[519] && (wi == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		SCTP_LTRACE_ERR_RET(NULL, NULL, NULL, SCTP_FROM_SCTPUTIL, ENOMEM);
 		return (ENOMEM);
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	/* Now incr the count and int wi structure */
 	SCTP_INCR_LADDR_COUNT();
 	memset(wi, 0, sizeof(*wi));
@@ -6996,8 +8537,23 @@ sctp_hashinit_flags(int elements, struct malloc_type *type,
 	}
 
 	/* no memory? */
-	if (hashtbl == NULL)
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[521]) {
+	  if ((hashtbl == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 521\n");
+	  else
+	    fprintf(stderr, "reached bug index 521\n");
+	}
+	if ((!FIXREVERTER[521] && (hashtbl == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	)
 		return (NULL);
+		#ifdef FRCOV
+		}
+		#endif
 
 	for (i = 0; i < hashsize; i++)
 		LIST_INIT(&hashtbl[i]);
@@ -7202,9 +8758,24 @@ sctp_connectx_helper_find(struct sctp_inpcb *inp, struct sockaddr *addr,
 		default:
 			return (EINVAL);
 		}
-		if ((at + incr) > limit) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[523]) {
+		  if ((at + incr > limit ) && !(0))
+		    fprintf(stderr, "triggered bug index 523\n");
+		  else
+		    fprintf(stderr, "reached bug index 523\n");
+		}
+		if ((!FIXREVERTER[523] && (at + incr > limit ))
+		#else
+		if (0
+		#endif
+		) {
 			return (EINVAL);
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		SCTP_INP_INCR_REF(inp);
 		stcb = sctp_findassociation_ep_addr(&inp, sa, NULL, NULL, NULL);
 		if (stcb != NULL) {
@@ -7521,11 +9092,26 @@ sctp_local_addr_count(struct sctp_tcb *stcb)
 #endif
 	SCTP_IPI_ADDR_RLOCK();
 	vrf = sctp_find_vrf(stcb->asoc.vrf_id);
-	if (vrf == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[524]) {
+	  if ((vrf == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 524\n");
+	  else
+	    fprintf(stderr, "reached bug index 524\n");
+	}
+	if ((!FIXREVERTER[524] && (vrf == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		/* no vrf, no addresses */
 		SCTP_IPI_ADDR_RUNLOCK();
 		return (0);
 	}
+	#ifdef FRCOV
+	}
+	#endif
 
 	if (stcb->sctp_ep->sctp_flags & SCTP_PCB_FLAGS_BOUNDALL) {
 		/*
diff --git a/usrsctplib/netinet6/meson.build b/usrsctplib/netinet6/meson.build
old mode 100644
new mode 100755
diff --git a/usrsctplib/netinet6/sctp6_usrreq.c b/usrsctplib/netinet6/sctp6_usrreq.c
old mode 100644
new mode 100755
index e9c3bfb0..0b5a82a3
--- a/usrsctplib/netinet6/sctp6_usrreq.c
+++ b/usrsctplib/netinet6/sctp6_usrreq.c
@@ -1,3 +1,7 @@
+#ifdef FRCOV
+#include <stdio.h>
+extern short FIXREVERTER[];
+#endif
 /*-
  * SPDX-License-Identifier: BSD-3-Clause
  *
@@ -710,7 +714,19 @@ sctp6_abort(struct socket *so)
 	uint32_t flags;
 
 	inp = (struct sctp_inpcb *)so->so_pcb;
-	if (inp == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[395]) {
+	  if ((inp == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 395\n");
+	  else
+	    fprintf(stderr, "reached bug index 395\n");
+	}
+	if ((!FIXREVERTER[395] && (inp == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		SCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP6_USRREQ, EINVAL);
 #if (defined(__FreeBSD__) && __FreeBSD_version > 690000) || defined(__Windows__)
 		return;
@@ -718,6 +734,9 @@ sctp6_abort(struct socket *so)
 		return (EINVAL);
 #endif
 	}
+	#ifdef FRCOV
+	}
+	#endif
  sctp_must_try_again:
 	flags = inp->sctp_flags;
 #ifdef SCTP_LOG_CLOSING
@@ -842,10 +861,25 @@ sctp6_bind(struct socket *so, struct mbuf *nam, struct proc *p)
 	int error;
 
 	inp = (struct sctp_inpcb *)so->so_pcb;
-	if (inp == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[396]) {
+	  if ((inp == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 396\n");
+	  else
+	    fprintf(stderr, "reached bug index 396\n");
+	}
+	if ((!FIXREVERTER[396] && (inp == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		SCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP6_USRREQ, EINVAL);
 		return (EINVAL);
 	}
+	#ifdef FRCOV
+	}
+	#endif
 
 #if !defined(__Windows__)
 	if (addr) {
@@ -938,11 +972,26 @@ sctp6_bind(struct socket *so, struct mbuf *nam, struct proc *p)
 
 		/* IPV6_V6ONLY socket */
 #ifdef INET
-		if (addr->sa_family == AF_INET) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[397]) {
+		  if ((addr -> sa_family == 2 ) && !(0))
+		    fprintf(stderr, "triggered bug index 397\n");
+		  else
+		    fprintf(stderr, "reached bug index 397\n");
+		}
+		if ((!FIXREVERTER[397] && (addr -> sa_family == 2 ))
+		#else
+		if (0
+		#endif
+		) {
 			/* can't bind v4 addr to v6 only socket! */
 			SCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP6_USRREQ, EINVAL);
 			return (EINVAL);
 		}
+		#ifdef FRCOV
+		}
+		#endif
 #endif
 		sin6_p = (struct sockaddr_in6 *)addr;
 
@@ -1167,15 +1216,45 @@ sctp6_connect(struct socket *so, struct mbuf *nam, struct proc *p)
 #endif
 
 	inp = (struct sctp_inpcb *)so->so_pcb;
-	if (inp == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[398]) {
+	  if ((inp == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 398\n");
+	  else
+	    fprintf(stderr, "reached bug index 398\n");
+	}
+	if ((!FIXREVERTER[398] && (inp == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		SCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP6_USRREQ, ECONNRESET);
 		return (ECONNRESET);	/* I made the same as TCP since we are
 					 * not setup? */
 	}
-	if (addr == NULL) {
+	#ifdef FRCOV
+	}
+	#endif
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[399]) {
+	  if ((addr == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 399\n");
+	  else
+	    fprintf(stderr, "reached bug index 399\n");
+	}
+	if ((!FIXREVERTER[399] && (addr == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		SCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP6_USRREQ, EINVAL);
 		return (EINVAL);
 	}
+	#ifdef FRCOV
+	}
+	#endif
 #if !defined(__Windows__)
 	switch (addr->sa_family) {
 #ifdef INET
@@ -1286,10 +1365,25 @@ sctp6_connect(struct socket *so, struct mbuf *nam, struct proc *p)
 	                       inp->sctp_ep.port, p,
 	                       SCTP_INITIALIZE_AUTH_PARAMS);
 	SCTP_ASOC_CREATE_UNLOCK(inp);
-	if (stcb == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[400]) {
+	  if ((stcb == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 400\n");
+	  else
+	    fprintf(stderr, "reached bug index 400\n");
+	}
+	if ((!FIXREVERTER[400] && (stcb == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		/* Gak! no memory */
 		return (error);
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	if (stcb->sctp_ep->sctp_flags & SCTP_PCB_FLAGS_TCPTYPE) {
 		stcb->sctp_ep->sctp_flags |= SCTP_PCB_FLAGS_CONNECTED;
 		/* Set the connected flag so we can queue data */
diff --git a/usrsctplib/user_mbuf.c b/usrsctplib/user_mbuf.c
index a5037249..941770c2 100755
--- a/usrsctplib/user_mbuf.c
+++ b/usrsctplib/user_mbuf.c
@@ -1,3 +1,7 @@
+#ifdef FRCOV
+#include <stdio.h>
+extern short FIXREVERTER[];
+#endif
 /*-
  * Copyright (c) 1982, 1986, 1988, 1993
  *      The Regents of the University of California.
@@ -81,8 +85,23 @@ static void	mb_dtor_clust(void *, void *);
 static int mbuf_constructor_dup(struct mbuf *m, int pkthdr, short type)
 {
 	int flags = pkthdr;
-	if (type == MT_NOINIT)
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[752]) {
+	  if ((type == 255 ) && !(0))
+	    fprintf(stderr, "triggered bug index 752\n");
+	  else
+	    fprintf(stderr, "reached bug index 752\n");
+	}
+	if ((!FIXREVERTER[752] && (type == 255 ))
+	#else
+	if (0
+	#endif
+	)
 		return (0);
+		#ifdef FRCOV
+		}
+		#endif
 
 	m->m_next = NULL;
 	m->m_nextpkt = NULL;
@@ -210,9 +229,24 @@ clust_constructor_dup(caddr_t m_clust, struct mbuf* m)
 	u_int *refcnt;
 	int type, size;
 
-	if (m == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[753]) {
+	  if ((m == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 753\n");
+	  else
+	    fprintf(stderr, "reached bug index 753\n");
+	}
+	if ((!FIXREVERTER[753] && (m == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		return;
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	/* Assigning cluster of MCLBYTES. TODO: Add jumbo frame functionality */
 	type = EXT_CLUSTER;
 	size = MCLBYTES;
@@ -331,11 +365,26 @@ m_getm2(struct mbuf *m, int len, int how, short type, int flags, int allonebuf)
 		}
 
 		/* Fail the whole operation if one mbuf can't be allocated. */
-		if (mb == NULL) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[754]) {
+		  if ((mb == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 754\n");
+		  else
+		    fprintf(stderr, "reached bug index 754\n");
+		}
+		if ((!FIXREVERTER[754] && (mb == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		) {
 			if (nm != NULL)
 				m_freem(nm);
 			return (NULL);
 		}
+		#ifdef FRCOV
+		}
+		#endif
 
 		if (allonebuf != 0 && size < space_needed) {
 			m_freem(mb);
@@ -397,8 +446,23 @@ m_uiotombuf(struct uio *uio, int how, int len, int align, int flags)
 	 * If len is zero return the smallest empty mbuf.
 	 */
 	m = m_getm2(NULL, (int)max(total + align, 1), how, MT_DATA, flags, 0);
-	if (m == NULL)
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[755]) {
+	  if ((m == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 755\n");
+	  else
+	    fprintf(stderr, "reached bug index 755\n");
+	}
+	if ((!FIXREVERTER[755] && (m == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	)
 		return (NULL);
+		#ifdef FRCOV
+		}
+		#endif
 	m->m_data += align;
 
 	/* Fill all mbufs with uio data and update header information. */
@@ -882,8 +946,23 @@ m_pullup(struct mbuf *n, int len)
 		if (len > MHLEN)
 			goto bad;
 		MGET(m, M_NOWAIT, n->m_type);
-		if (m == NULL)
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[757]) {
+		  if ((m == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 757\n");
+		  else
+		    fprintf(stderr, "reached bug index 757\n");
+		}
+		if ((!FIXREVERTER[757] && (m == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		)
 			goto bad;
+			#ifdef FRCOV
+			}
+			#endif
 		m->m_len = 0;
 		if (n->m_flags & M_PKTHDR)
 			M_MOVE_PKTHDR(m, n);
@@ -1166,17 +1245,47 @@ m_copym(struct mbuf *m, int off0, int len, int wait)
 	np = &top;
 	top = 0;
 	while (len > 0) {
-		if (m == NULL) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[764]) {
+		  if ((m == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 764\n");
+		  else
+		    fprintf(stderr, "reached bug index 764\n");
+		}
+		if ((!FIXREVERTER[764] && (m == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		) {
 			KASSERT(len == M_COPYALL, ("m_copym, length > size of mbuf chain"));
 			break;
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		if (copyhdr)
 			MGETHDR(n, wait, m->m_type);
 		else
 			MGET(n, wait, m->m_type);
 		*np = n;
-		if (n == NULL)
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[765]) {
+		  if ((n == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 765\n");
+		  else
+		    fprintf(stderr, "reached bug index 765\n");
+		}
+		if ((!FIXREVERTER[765] && (n == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		)
 			goto nospace;
+			#ifdef FRCOV
+			}
+			#endif
 		if (copyhdr) {
 			if (!m_dup_pkthdr(n, m, wait))
 				goto nospace;
@@ -1218,10 +1327,25 @@ m_tag_copy_chain(struct mbuf *to, struct mbuf *from, int how)
 	m_tag_delete_chain(to, NULL);
 	SLIST_FOREACH(p, &from->m_pkthdr.tags, m_tag_link) {
 		t = m_tag_copy(p, how);
-		if (t == NULL) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[766]) {
+		  if ((t == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 766\n");
+		  else
+		    fprintf(stderr, "reached bug index 766\n");
+		}
+		if ((!FIXREVERTER[766] && (t == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		) {
 			m_tag_delete_chain(to, NULL);
 			return 0;
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		if (tprev == NULL)
 			SLIST_INSERT_HEAD(&to->m_pkthdr.tags, t, m_tag_link);
 		else
@@ -1258,8 +1382,23 @@ m_tag_copy(struct m_tag *t, int how)
 
 	KASSERT(t, ("m_tag_copy: null tag"));
 	p = m_tag_alloc(t->m_tag_cookie, t->m_tag_id, t->m_tag_len, how);
-	if (p == NULL)
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[767]) {
+	  if ((p == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 767\n");
+	  else
+	    fprintf(stderr, "reached bug index 767\n");
+	}
+	if ((!FIXREVERTER[767] && (p == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	)
 		return (NULL);
+		#ifdef FRCOV
+		}
+		#endif
 	memcpy(p + 1, t + 1, t->m_tag_len); /* Copy the data */
 	return p;
 }
@@ -1270,11 +1409,41 @@ m_tag_alloc(u_int32_t cookie, int type, int len, int wait)
 {
 	struct m_tag *t;
 
-	if (len < 0)
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[768]) {
+	  if ((len < 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 768\n");
+	  else
+	    fprintf(stderr, "reached bug index 768\n");
+	}
+	if ((!FIXREVERTER[768] && (len < 0 ))
+	#else
+	if (0
+	#endif
+	)
 		return NULL;
+		#ifdef FRCOV
+		}
+		#endif
 	t = malloc(len + sizeof(struct m_tag));
-	if (t == NULL)
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[769]) {
+	  if ((t == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 769\n");
+	  else
+	    fprintf(stderr, "reached bug index 769\n");
+	}
+	if ((!FIXREVERTER[769] && (t == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	)
 		return NULL;
+		#ifdef FRCOV
+		}
+		#endif
 	m_tag_setup(t, cookie, type, len);
 	t->m_tag_free = m_tag_free_default;
 	return t;
@@ -1299,15 +1468,45 @@ m_copyback(struct mbuf *m0, int off, int len, caddr_t cp)
 	struct mbuf *m = m0, *n;
 	int totlen = 0;
 
-	if (m0 == NULL)
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[770]) {
+	  if ((m0 == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 770\n");
+	  else
+	    fprintf(stderr, "reached bug index 770\n");
+	}
+	if ((!FIXREVERTER[770] && (m0 == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	)
 		return;
+		#ifdef FRCOV
+		}
+		#endif
 	while (off > (mlen = m->m_len)) {
 		off -= mlen;
 		totlen += mlen;
 		if (m->m_next == NULL) {
 			n = m_get(M_NOWAIT, m->m_type);
-			if (n == NULL)
+			
+			#ifdef FRCOV
+			{if (FIXREVERTER[771]) {
+			  if ((n == (void *) 0 ) && !(0))
+			    fprintf(stderr, "triggered bug index 771\n");
+			  else
+			    fprintf(stderr, "reached bug index 771\n");
+			}
+			if ((!FIXREVERTER[771] && (n == (void *) 0 ))
+			#else
+			if (0
+			#endif
+			)
 				goto out;
+				#ifdef FRCOV
+				}
+				#endif
 			memset(mtod(n, caddr_t), 0, MLEN);
 			n->m_len = min(MLEN, len + off);
 			m->m_next = n;
@@ -1326,8 +1525,23 @@ m_copyback(struct mbuf *m0, int off, int len, caddr_t cp)
 			break;
 		if (m->m_next == NULL) {
 			n = m_get(M_NOWAIT, m->m_type);
-			if (n == NULL)
+			
+			#ifdef FRCOV
+			{if (FIXREVERTER[773]) {
+			  if ((n == (void *) 0 ) && !(0))
+			    fprintf(stderr, "triggered bug index 773\n");
+			  else
+			    fprintf(stderr, "reached bug index 773\n");
+			}
+			if ((!FIXREVERTER[773] && (n == (void *) 0 ))
+			#else
+			if (0
+			#endif
+			)
 				break;
+				#ifdef FRCOV
+				}
+				#endif
 			n->m_len = min(MLEN, len);
 			m->m_next = n;
 		}
@@ -1352,10 +1566,25 @@ m_prepend(struct mbuf *m, int len, int how)
 		MGETHDR(mn, how, m->m_type);
 	else
 		MGET(mn, how, m->m_type);
-	if (mn == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[774]) {
+	  if ((mn == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 774\n");
+	  else
+	    fprintf(stderr, "reached bug index 774\n");
+	}
+	if ((!FIXREVERTER[774] && (mn == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		m_freem(m);
 		return (NULL);
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	if (m->m_flags & M_PKTHDR)
 		M_MOVE_PKTHDR(mn, m);
 	mn->m_next = m;
@@ -1439,7 +1668,21 @@ m_adj(struct mbuf *mp, int req_len)
 		/*
 		 * Trim from head.
 		 */
-		while (m != NULL && len > 0) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[775])
+		  fprintf(stderr, "reached bug index 775\n");
+		while ((FIXREVERTER[775] && (m != (void *) 0 )) || (!FIXREVERTER[775] && (m != (void *) 0 && len > 0 ))
+		#else
+		while (m != (void *) 0 
+		#endif
+		) {
+		  
+		#ifdef FRCOV
+		  if (!(len > 0 ))
+		    fprintf(stderr, "triggered bug index 775\n");
+		  #endif
+		
 			if (m->m_len <= len) {
 				len -= m->m_len;
 				m->m_len = 0;
@@ -1450,6 +1693,9 @@ m_adj(struct mbuf *mp, int req_len)
 				len = 0;
 			}
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		m = mp;
 		if (mp->m_flags & M_PKTHDR)
 			m->m_pkthdr.len -= (req_len - len);
@@ -1476,8 +1722,23 @@ m_adj(struct mbuf *mp, int req_len)
 			return;
 		}
 		count -= len;
-		if (count < 0)
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[776]) {
+		  if ((count < 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 776\n");
+		  else
+		    fprintf(stderr, "reached bug index 776\n");
+		}
+		if ((!FIXREVERTER[776] && (count < 0 ))
+		#else
+		if (0
+		#endif
+		)
 			count = 0;
+			#ifdef FRCOV
+			}
+			#endif
 		/*
 		 * Correct length for chain is "count".
 		 * Find the mbuf with last data, adjust its length,
@@ -1522,13 +1783,43 @@ m_split(struct mbuf *m0, int len0, int wait)
 	/* MBUF_CHECKSLEEP(wait); */
 	for (m = m0; m && (int)len > m->m_len; m = m->m_next)
 		len -= m->m_len;
-	if (m == NULL)
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[777]) {
+	  if ((m == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 777\n");
+	  else
+	    fprintf(stderr, "reached bug index 777\n");
+	}
+	if ((!FIXREVERTER[777] && (m == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	)
 		return (NULL);
+		#ifdef FRCOV
+		}
+		#endif
 	remain = m->m_len - len;
 	if (m0->m_flags & M_PKTHDR) {
 		MGETHDR(n, wait, m0->m_type);
-		if (n == NULL)
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[778]) {
+		  if ((n == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 778\n");
+		  else
+		    fprintf(stderr, "reached bug index 778\n");
+		}
+		if ((!FIXREVERTER[778] && (n == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		)
 			return (NULL);
+			#ifdef FRCOV
+			}
+			#endif
 		n->m_pkthdr.rcvif = m0->m_pkthdr.rcvif;
 		n->m_pkthdr.len = m0->m_pkthdr.len - len0;
 		m0->m_pkthdr.len = len0;
@@ -1553,8 +1844,23 @@ m_split(struct mbuf *m0, int len0, int wait)
 		return (n);
 	} else {
 		MGET(n, wait, m->m_type);
-		if (n == NULL)
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[779]) {
+		  if ((n == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 779\n");
+		  else
+		    fprintf(stderr, "reached bug index 779\n");
+		}
+		if ((!FIXREVERTER[779] && (n == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		)
 			return (NULL);
+			#ifdef FRCOV
+			}
+			#endif
 		M_ALIGN(n, remain);
 	}
 extpacket:
diff --git a/usrsctplib/user_socket.c b/usrsctplib/user_socket.c
index df4dbec6..376c2be8 100755
--- a/usrsctplib/user_socket.c
+++ b/usrsctplib/user_socket.c
@@ -1,3 +1,7 @@
+#ifdef FRCOV
+#include <stdio.h>
+extern short FIXREVERTER[];
+#endif
 /*-
  * Copyright (c) 1982, 1986, 1988, 1990, 1993
  *      The Regents of the University of California.
@@ -216,9 +220,24 @@ soalloc(void)
 
 	so = (struct socket *)malloc(sizeof(struct socket));
 
-	if (so == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[319]) {
+	  if ((so == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 319\n");
+	  else
+	    fprintf(stderr, "reached bug index 319\n");
+	}
+	if ((!FIXREVERTER[319] && (so == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		return (NULL);
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	memset(so, 0, sizeof(struct socket));
 
 	/* __Userspace__ Initializing the socket locks here */
@@ -479,8 +498,23 @@ sonewconn(struct socket *head, int connstatus)
 #endif
 		return (NULL);
 	so = soalloc();
-	if (so == NULL)
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[320]) {
+	  if ((so == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 320\n");
+	  else
+	    fprintf(stderr, "reached bug index 320\n");
+	}
+	if ((!FIXREVERTER[320] && (so == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	)
 		return (NULL);
+		#ifdef FRCOV
+		}
+		#endif
 	so->so_head = head;
 	so->so_type = head->so_type;
 	so->so_options = head->so_options &~ SCTP_SO_ACCEPTCONN;
@@ -655,11 +689,26 @@ uiomove(void *cp, int n, struct uio *uio)
 	while (n > 0 && uio->uio_resid) {
 		iov = uio->uio_iov;
 		cnt = iov->iov_len;
-		if (cnt == 0) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[322]) {
+		  if ((cnt == 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 322\n");
+		  else
+		    fprintf(stderr, "reached bug index 322\n");
+		}
+		if ((!FIXREVERTER[322] && (cnt == 0 ))
+		#else
+		if (0
+		#endif
+		) {
 			uio->uio_iov++;
 			uio->uio_iovcnt--;
 			continue;
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		if (cnt > (size_t)n)
 			cnt = n;
 
@@ -850,14 +899,44 @@ usrsctp_sendv(struct socket *so,
 	int use_sinfo;
 	sctp_assoc_t *assoc_id;
 
-	if (so == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[326]) {
+	  if ((so == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 326\n");
+	  else
+	    fprintf(stderr, "reached bug index 326\n");
+	}
+	if ((!FIXREVERTER[326] && (so == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		errno = EBADF;
 		return (-1);
 	}
-	if (data == NULL) {
+	#ifdef FRCOV
+	}
+	#endif
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[327]) {
+	  if ((data == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 327\n");
+	  else
+	    fprintf(stderr, "reached bug index 327\n");
+	}
+	if ((!FIXREVERTER[327] && (data == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		errno = EFAULT;
 		return (-1);
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	memset(&sinfo, 0, sizeof(struct sctp_sndrcvinfo));
 	assoc_id = NULL;
 	use_sinfo = 0;
@@ -942,9 +1021,27 @@ usrsctp_sendv(struct socket *so,
 	auio.uio_resid = len;
 	errno = sctp_lower_sosend(so, to, &auio, NULL, NULL, flags, use_sinfo ? &sinfo : NULL);
 	if (errno == 0) {
-		if ((to != NULL) && (assoc_id != NULL)) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[329]) {
+		  fprintf(stderr, "reached bug index 329\n");
+		}
+		if ((FIXREVERTER[329] && (to != (void *) 0 )) || (!FIXREVERTER[329] && (to != (void *) 0 && assoc_id != (void *) 0 ))
+		#else
+		if (to != (void *) 0 
+		#endif
+		) {
+		  
+		#ifdef FRCOV
+		  if (!(assoc_id != (void *) 0 ))
+		    fprintf(stderr, "triggered bug index 329\n");
+		  #endif
+		
 			*assoc_id = usrsctp_getassocid(so, to);
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		return (len - auio.uio_resid);
 	} else {
 		return (-1);
@@ -1130,10 +1227,25 @@ usrsctp_recvv(struct socket *so,
 	struct sctp_recvv_rn *rn;
 	struct sctp_extrcvinfo seinfo;
 
-	if (so == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[332]) {
+	  if ((so == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 332\n");
+	  else
+	    fprintf(stderr, "reached bug index 332\n");
+	}
+	if ((!FIXREVERTER[332] && (so == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		errno = EBADF;
 		return (-1);
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	iov[0].iov_base = dbuf;
 	iov[0].iov_len = len;
 
@@ -1223,10 +1335,22 @@ usrsctp_recvv(struct socket *so,
 			*infolen = 0;
 		}
 	}
-	if ((fromlenp != NULL) &&
-	    (fromlen > 0) &&
-	    (from != NULL) &&
-	    (ulen > auio.uio_resid)) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[333]) {
+	  fprintf(stderr, "reached bug index 333\n");
+	}
+	if ((FIXREVERTER[333] && (fromlenp != (void *) 0 && fromlen > 0 && from != (void *) 0 )) || (!FIXREVERTER[333] && (fromlenp != (void *) 0 && fromlen > 0 && from != (void *) 0 && ulen > auio . uio_resid ))
+	#else
+	if (fromlenp != (void *) 0 && fromlen > 0 && from != (void *) 0 
+	#endif
+	) {
+	      
+	    #ifdef FRCOV
+	      if (!(ulen > auio . uio_resid ))
+	        fprintf(stderr, "triggered bug index 333\n");
+	      #endif
+	    
 		switch (from->sa_family) {
 #if defined(INET)
 		case AF_INET:
@@ -1249,6 +1373,9 @@ usrsctp_recvv(struct socket *so,
 			*fromlenp = fromlen;
 		}
 	}
+	#ifdef FRCOV
+	}
+	#endif
 out:
 	if (errno == 0) {
 		/* ready return value */
@@ -1284,9 +1411,24 @@ socreate(int dom, struct socket **aso, int type, int proto)
 	}
 
 	so = soalloc();
-	if (so == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[335]) {
+	  if ((so == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 335\n");
+	  else
+	    fprintf(stderr, "reached bug index 335\n");
+	}
+	if ((!FIXREVERTER[335] && (so == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		return (ENOBUFS);
 	}
+	#ifdef FRCOV
+	}
+	#endif
 
 	/*
 	 * so_incomp represents a queue of connections that
@@ -1651,10 +1793,25 @@ usrsctp_bind(struct socket *so, struct sockaddr *name, int namelen)
 {
 	struct sockaddr *sa;
 
-	if (so == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[336]) {
+	  if ((so == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 336\n");
+	  else
+	    fprintf(stderr, "reached bug index 336\n");
+	}
+	if ((!FIXREVERTER[336] && (so == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		errno = EBADF;
 		return (-1);
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	if ((errno = getsockaddr(&sa, (caddr_t)name, namelen)) != 0)
 		return (-1);
 
@@ -2007,10 +2164,25 @@ sodisconnect(struct socket *so)
 int
 usrsctp_set_non_blocking(struct socket *so, int onoff)
 {
-	if (so == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[341]) {
+	  if ((so == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 341\n");
+	  else
+	    fprintf(stderr, "reached bug index 341\n");
+	}
+	if ((!FIXREVERTER[341] && (so == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		errno = EBADF;
 		return (-1);
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	SOCK_LOCK(so);
 	if (onoff != 0) {
 		so->so_state |= SS_NBIO;
@@ -2089,10 +2261,25 @@ int user_connect(struct socket *so, struct sockaddr *sa)
 	int error;
 	int interrupted = 0;
 
-	if (so == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[343]) {
+	  if ((so == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 343\n");
+	  else
+	    fprintf(stderr, "reached bug index 343\n");
+	}
+	if ((!FIXREVERTER[343] && (so == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		error = EBADF;
 		goto done1;
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	if (so->so_state & SS_ISCONNECTING) {
 		error = EALREADY;
 		goto done1;
@@ -2275,10 +2462,25 @@ int
 usrsctp_setsockopt(struct socket *so, int level, int option_name,
                    const void *option_value, socklen_t option_len)
 {
-	if (so == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[345]) {
+	  if ((so == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 345\n");
+	  else
+	    fprintf(stderr, "reached bug index 345\n");
+	}
+	if ((!FIXREVERTER[345] && (so == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		errno = EBADF;
 		return (-1);
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	switch (level) {
 	case SOL_SOCKET:
 	{
@@ -2365,14 +2567,44 @@ int
 usrsctp_getsockopt(struct socket *so, int level, int option_name,
                    void *option_value, socklen_t *option_len)
 {
-	if (so == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[346]) {
+	  if ((so == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 346\n");
+	  else
+	    fprintf(stderr, "reached bug index 346\n");
+	}
+	if ((!FIXREVERTER[346] && (so == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		errno = EBADF;
 		return (-1);
 	}
-	if (option_len == NULL) {
+	#ifdef FRCOV
+	}
+	#endif
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[347]) {
+	  if ((option_len == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 347\n");
+	  else
+	    fprintf(stderr, "reached bug index 347\n");
+	}
+	if ((!FIXREVERTER[347] && (option_len == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		errno = EFAULT;
 		return (-1);
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	switch (level) {
 	case SOL_SOCKET:
 		switch (option_name) {
@@ -3116,7 +3348,21 @@ sctp_userspace_ip_output(int *result, struct mbuf *o_pak,
 
 	send_len = SCTP_HEADER_LEN(m); /* length of entire packet */
 	send_count = 0;
-	for (iovcnt = 0; m != NULL && iovcnt < MAXLEN_MBUF_CHAIN; m = m->m_next, iovcnt++) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[363])
+	  fprintf(stderr, "reached bug index 363\n");
+	for (iovcnt = 0; (FIXREVERTER[363] && (m != (void *) 0 )) || (!FIXREVERTER[363] && (m != (void *) 0 && iovcnt < 32 ))
+	#else
+	for (iovcnt = 0; m != (void *) 0 
+	#endif
+	; m = m->m_next, iovcnt++) {
+	  
+	#ifdef FRCOV
+	  if (!(iovcnt < 32 ))
+	    fprintf(stderr, "triggered bug index 363\n");
+	  #endif
+	
 #if !defined (__Userspace_os_Windows)
 		send_iovec[iovcnt].iov_base = (caddr_t)m->m_data;
 		send_iovec[iovcnt].iov_len = SCTP_BUF_LEN(m);
@@ -3127,6 +3373,9 @@ sctp_userspace_ip_output(int *result, struct mbuf *o_pak,
 		send_count += send_iovec[iovcnt].len;
 #endif
 	}
+	#ifdef FRCOV
+	}
+	#endif
 
 	if (m != NULL) {
 		SCTP_PRINTF("mbuf chain couldn't be copied completely\n");
@@ -3271,7 +3520,21 @@ void sctp_userspace_ip6_output(int *result, struct mbuf *o_pak,
 
 	send_len = SCTP_HEADER_LEN(m); /* length of entire packet */
 	send_count = 0;
-	for (iovcnt = 0; m != NULL && iovcnt < MAXLEN_MBUF_CHAIN; m = m->m_next, iovcnt++) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[364])
+	  fprintf(stderr, "reached bug index 364\n");
+	for (iovcnt = 0; (FIXREVERTER[364] && (m != (void *) 0 )) || (!FIXREVERTER[364] && (m != (void *) 0 && iovcnt < 32 ))
+	#else
+	for (iovcnt = 0; m != (void *) 0 
+	#endif
+	; m = m->m_next, iovcnt++) {
+	  
+	#ifdef FRCOV
+	  if (!(iovcnt < 32 ))
+	    fprintf(stderr, "triggered bug index 364\n");
+	  #endif
+	
 #if !defined (__Userspace_os_Windows)
 		send_iovec[iovcnt].iov_base = (caddr_t)m->m_data;
 		send_iovec[iovcnt].iov_len = SCTP_BUF_LEN(m);
@@ -3282,6 +3545,9 @@ void sctp_userspace_ip6_output(int *result, struct mbuf *o_pak,
 		send_count += send_iovec[iovcnt].len;
 #endif
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	if (m != NULL) {
 		SCTP_PRINTF("mbuf chain couldn't be copied completely\n");
 		goto free_mbuf;
@@ -3538,10 +3804,25 @@ usrsctp_get_events(struct socket *so)
 {
 	int events = 0;
 
-	if (so == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[366]) {
+	  if ((so == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 366\n");
+	  else
+	    fprintf(stderr, "reached bug index 366\n");
+	}
+	if ((!FIXREVERTER[366] && (so == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		errno = EBADF;
 		return -1;
 	}
+	#ifdef FRCOV
+	}
+	#endif
 
 	SOCK_LOCK(so);
 	if (soreadable(so)) {
@@ -3561,10 +3842,25 @@ usrsctp_get_events(struct socket *so)
 int
 usrsctp_set_upcall(struct socket *so, void (*upcall)(struct socket *, void *, int), void *arg)
 {
-	if (so == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[367]) {
+	  if ((so == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 367\n");
+	  else
+	    fprintf(stderr, "reached bug index 367\n");
+	}
+	if ((!FIXREVERTER[367] && (so == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		errno = EBADF;
 		return (-1);
 	}
+	#ifdef FRCOV
+	}
+	#endif
 
 	SOCK_LOCK(so);
 	so->so_upcall = upcall;
diff --git a/usrsctplib/usrsctp.h b/usrsctplib/usrsctp.h
old mode 100644
new mode 100755
