#!/usr/bin/env python3
"""
This script automates multiple afl-fuzz experiments on Docker using the corpus paths
generated by the previous script. Instead of running the commands directly, the script
writes each constructed shell command to an output text file (run_commands.sh) so you can
execute them manually.

Each generated command will:
  - Remove only PDF files from the local corpus folder (./corpus).
  - Copy the corpus from the specified source location into ./corpus.
  - Execute a docker-compose command (with a unique project name) to launch the experiment.
  
IMPORTANT:
  â€¢ Ensure your docker-compose.yaml mounts the local ./corpus folder to the container path.
    For example, in docker-compose.yaml:
      volumes:
        - ./corpus:/corpus
      and it uses /corpus as the input directory.
      
Usage example:
  python3 automate.py --input-file corpus_paths.txt --target /usr/local/bin/mutool --project-prefix fuzz --docker-image fuzz-testing

After running this script, open "run_commands.sh" and copy/paste its contents to execute the commands.
"""

import os
import sys
import argparse

def parse_arguments():
    parser = argparse.ArgumentParser(
        description="Generate shell commands for multiple afl-fuzz experiments with corpus copying."
    )
    parser.add_argument("--input-file", "-i", required=True,
                        help="Path to the file containing corpus directories (one per line).")
    parser.add_argument("--target", "-t", required=True,
                        help="The target binary to fuzz (to be passed to the container).")
    parser.add_argument("--project-prefix", "-p", default="fuzz",
                        help="Prefix for Docker Compose project names (default: 'fuzz').")
    parser.add_argument("--docker-image", default="fuzz-testing",
                        help="Name of the Docker image to use (default: 'fuzz-testing').")
    parser.add_argument("--output-script", "-o", default="run_commands.sh",
                        help="Name of the output file to write the commands (default: run_commands.sh).")
    return parser.parse_args()

def read_corpus_paths(input_file):
    corpus_paths = []
    try:
        with open(input_file, "r") as f:
            for line in f:
                path = line.strip()
                if path:  # skip empty lines
                    corpus_paths.append(path)
        if not corpus_paths:
            print(f"Error: No corpus paths found in '{input_file}'.")
            sys.exit(1)
    except Exception as e:
        print(f"Error reading input file '{input_file}': {e}")
        sys.exit(1)
    return corpus_paths

def construct_command(corpus_path, target, project_name, docker_image):
    # Ensure the corpus path is absolute.
    abs_corpus_path = os.path.abspath(corpus_path)
    # The command will:
    # 1. Remove any PDF files from the local ./corpus folder.
    # 2. Copy all contents from the given corpus location into ./corpus.
    # 3. Launch docker-compose in detached mode with a unique project name.
    cmd = (
        f'rm -f ./corpus/*.pdf && '
        f'cp -r "{abs_corpus_path}/." ./corpus/ && '
        f'docker-compose -p {project_name} up -d'
    )
    # If your docker-compose and container make use of TARGET and DOCKER_IMAGE,
    # you can inline those as environment variables:
    #
    # cmd = (
    #     f'TARGET="{target}" DOCKER_IMAGE="{docker_image}" ' + cmd
    # )
    #
    # For this example, we assume docker-compose/entrypoint is set up to work with the
    # local corpus folder.
    return cmd

def main():
    args = parse_arguments()

    # Read corpus directories from the input file.
    corpus_paths = read_corpus_paths(args.input_file)
    print(f"Found {len(corpus_paths)} corpus(s) in '{args.input_file}'.")

    # Open the output file where commands will be written.
    try:
        with open(args.output_script, "w") as output_file:
            # Write the shebang and an initial comment.
            output_file.write("#!/bin/bash\n")
            output_file.write("# Auto-generated commands to run afl-fuzz experiments via docker-compose with corpus copying.\n\n")

            # For each corpus, construct a unique project name and command, then write it.
            for idx, corpus in enumerate(corpus_paths, start=1):
                project_name = f"{args.project_prefix}_{idx}"
                cmd = construct_command(corpus, args.target, project_name, args.docker_image)
                output_file.write(cmd + "\n")
                print(f"Generated command for project '{project_name}':\n{cmd}\n")
    except Exception as e:
        print(f"Error opening output file '{args.output_script}': {e}")
        sys.exit(1)

    print(f"All commands written to '{args.output_script}'.\n"
          f"Make the file executable (chmod +x {args.output_script}) and run it to start experiments.")

if __name__ == "__main__":
    main()